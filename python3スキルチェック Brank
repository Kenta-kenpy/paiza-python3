※欠番が存在する理由につきましては、出題自体を公開終了した問題が欠番となっております。

--------------------------------------------- B001　※欠番 ◆
# B001 ◆
# B002 ◆
# B003 ◆
# B004 ログファイルの抽出
# utf-8
def isValidIp(m, c):
    ret = False
    if m == "*" or m == c:
        ret = True
    elif m[0] == "[":
        a = m.split("-")
        ss = int(a[0].replace("[", ""))
        ee = int(a[1].replace("]", ""))
        if ss <= int(c) <= ee:
            ret = True
    return ret


def main():
    # IPアドレスを読み込む
    mip = input().strip().split(".")
    
    # ログの数を読み込む
    n = int(input())
    
    # ログを1行ずつ読み込み、IPアドレスをチェックする
    for i in range(n):
        s = input().strip().split(" ")
        tip = s[0].split(".")
        if mip[0] == tip[0] and \
           mip[1] == tip[1] and \
           isValidIp(mip[2], tip[2]) and \
           isValidIp(mip[3], tip[3]):
            print(s[0] + " " + s[3][1:] + " " + s[6])


if __name__ == '__main__':
    main()
'''
1 標準入力からIPアドレスとログの数を取得し、IPアドレスを「.」で分割してリストに格納する
2 ログの数だけ繰り返し、1行ずつログを取得する
3 取得したログのIPアドレスを「.」で分割してリストに格納する
4 IPアドレスの1〜3オクテットが一致し、4オクテットが以下の条件を満たす場合に、ログの情報を出力する
　・IPアドレスの4オクテットが、IPアドレスの4オクテットと完全一致する場合
　・IPアドレスの4オクテットが、ワイルドカード「*」の場合
　・IPアドレスの4オクテットが、範囲指定の場合（「[」と「]」で囲まれた範囲内の数値のみ許可される）
具体的には、以下のような関数を定義して使用しています。
isValidIp(m, c)
　・引数mが「*」またはcと完全一致する場合はTrueを返す
　・引数mが範囲指定の場合は、引数cが範囲内にある場合はTrueを返す
このコードは、ログのIPアドレスが与えられたIPアドレスにマッチするかどうかを判定する処理を行っており、与えられたIPアドレスがワイルドカードや範囲指定を含んでいる場合にも対応しています。
'''

# B005 ◆　
# B006 ダーツゲーム
# utf-8
# 標準入力からの値の取得
import sys
input_line = sys.stdin.read()
input_list = input_line.split()

# 初期値の設定
o_y = float(input_list[0])
s = float(input_list[1])
theta = float(input_list[2])
x = float(input_list[3])
y = float(input_list[4])
a = float(input_list[5])

# 矢が当たるかどうかの判定
import math
g = 9.8
rad = math.radians(theta)
t = x / (s * math.cos(rad))
y2 = o_y + s * math.sin(rad) * t - (g * t ** 2) / 2
if y - a / 2 <= y2 <= y + a / 2:
    # 当たった場合、的の中心からの距離を出力
    dist = abs(y2 - y)
    print("Hit {:.1f}".format(round(dist, 1)))
else:
    # 当たらなかった場合、Missを出力
    print("Miss")
'''
以下の手順で矢が的に当たるかどうかを判定し、当たった場合には的の中心からの距離を出力します。
まず、sys.stdin.read()で標準入力から値を読み込み、split()でスペース区切りの文字列をリストに変換します。
次に、リストから必要な値を取り出し、float()で数値に変換します。
これで、矢の初期値点の高さ o_y、初速 s、角度 theta、的までの距離 x、的の高さ y、的の大きさ a がそれぞれ変数に格納されました。

矢が当たるかどうかの判定には、以下の計算式を使用します。
y2 = o_y + s * sin(rad) * t - (g * t^2) / 2
ここで、radはthetaをラジアンに変換したもの、tは矢が的に当たるまでの時間です。この式は、矢の初期値点から投げた瞬間の高さ o_y に、矢が的に当たるまでに到達する高さを足し合わせたものを計算し、的の高さ y ± 的の大きさ a の範囲内にあるかどうかを判定します。

具体的には、以下のように計算します。
import math

# 重力加速度
g = 9.8

# 角度をラジアンに変換
rad = math.radians(theta)

# 矢が的に当たるまでの時間
t = x / (s * math.cos(rad))

# 矢が的に当たるときの高さ
y2 = o_y + s * math.sin(rad) * t - (g * t ** 2) / 2

矢が当たるかどうかを判定する部分では、まず重力加速度を9.8[m/s^2]として、投射角度θに対しての水平方向と鉛直方向の初速度を求めます。そして、投射角度θと初速度sを用いて、到達時間tを求めます。tを用いて、矢の到達位置y2を計算します。その後、的の位置yから、的の半径a/2の範囲内に矢の到達位置y2があるかどうかを判定しています。
当たった場合は、的の中心からの距離を求めています。このとき、求めた距離を絶対値をとっているのは、矢が的の上側に当たった場合でも、的の中心からの距離を正しく求めるためです。また、四捨五入して小数点第1位までの数値を出力するには、Pythonの組み込み関数であるround()関数を使います。
当たらなかった場合は、"Miss"を出力しています。
'''

# B007 ◆
# B008 ◆
# B009 カンファレンスのタイムテーブル作成
# utf-8
# coding: utf-8

# 分を時刻表記に変換する関数　m分をhh:mm形式の文字列に変換する関数
def m2h(m):
    hour = m // 60 % 24  # 24時間制での時間を算出
    minute = m % 60  # 分を算出
    return f'{hour:02}:{minute:02}'  # hh:mm形式の文字列に変換して返す

# 時刻表記を分に変換する関数　hh:mm形式の文字列をm分に変換する関数
def h2m(h):
    hour, minute = map(int, h.split(':'))  # : を区切り文字として文字列を分割して、時と分に分ける
    return hour * 60 + minute  # 時を分に変換して分と合算し、分単位で返す

# 各プレゼンテーションの開始・終了時刻を計算する関数　スケジュールの時間計算を行う関数
def presentation_time(start_time, duration):
    global rest   # お昼休憩のフラグ　# グローバル変数 rest を参照するため、global宣言
    noon = h2m('12:00')  # 12:00を分単位に変換して、お昼の時間として取得
    end_time = start_time + duration  # 終了時刻を算出
    if not rest and noon < end_time:  # お昼休憩が必要かどうかを判定　# 休憩をとっておらず、終了時刻がお昼を過ぎている場合
        start_time += 60 - 10  # お昼休憩をとるために開始時刻をずらす　# お昼休憩を含む1時間の空きを作るために10分引いた時間に移動
        end_time = start_time + duration  # 新しい終了時刻を再度算出
        rest = True  # 休憩を取ったことをフラグに設定
    return start_time, end_time  # スケジュールの開始時間と終了時間を返す

n = int(input())  # # プレゼンテーションスケジュールの個数を入力

start_time = h2m('10:00')  # 最初のプレゼンテーションの開始時刻を10:00として、分単位に変換して取得

rest = False  # お昼休憩をとっていないことをフラグに設定　お昼休憩のフラグを初期化
for _ in range(n):  # スケジュールの個数だけ繰り返し処理を実行
    name, duration = input().split()  # スケジュール名と時間を入力として受け取る
    start_time, end_time = presentation_time(start_time, int(duration))  # スケジュールの開始時間と終了時間を計算
    print(f'{m2h(start_time)} - {m2h(end_time)} {name}')  # スケジュールの時間と名前を出力
    start_time = end_time + 10 # 休憩時間10分を加算して次のプレゼンテーションの開始時刻を計算する
'''
m2h() 関数
この関数は、分単位の時間を時:分の形式の文字列に変換するためのものです。
入力された分を60で割った余りが分の値、60で割った商を24で割った余りが時の値として取得します。
最後に、f-string を使って、"時:分" の形式で文字列を生成し、それを返します。

h2m() 関数
この関数は、時:分の形式の文字列を分単位の時間に変換するためのものです。
split() 関数を使って、文字列を ":" で分割し、時と分の値を取得します。
時を60で掛けたものに分を足し合わせて、分単位の時間を計算し、それを返します。

presentation_time() 関数
この関数は、スピーカーのプレゼンテーションの開始時間と終了時間を計算するためのものです。
引数として、スピーカーのプレゼンテーションの開始時間と時間の長さを受け取ります。
global キーワードを使って、rest 変数をグローバル変数として宣言します。
noon 変数には、12:00の分単位の時間を代入します。
end_time 変数には、プレゼンテーションの終了時間を代入します。
rest 変数が False かつ noon より end_time が後の場合、つまり、プレゼンテーションがお昼休憩をまたいでいる場合、開始時間にお昼休憩の10分を足した時間から再スタートし、終了時間を再計算します。
最後に、開始時間と終了時間を返します。

それ以降のメイン部分
まず、n = int(input())で発表する人数nを受け取ります。
次に、発表が始まる開始時間を表す変数start_timeに、10:00の時間をh2m('10:00')を使って分単位で代入します。
そして、restフラグをFalseで初期化します。これは、お昼休憩のチェックのために使用されます。
forループを使って、各発表の時間を処理します。forループの中で、name, duration = input().split()で発表者の名前nameと発表時間durationを受け取ります。このdurationは単位が分であり、整数型であることに注意してください。
次に、presentation_time(start_time, int(duration))を呼び出して、発表の終了時刻を計算し、その時間を人間が読みやすい形式で出力します。presentation_time関数は、start_timeと発表時間durationを引数として受け取り、終了時間のタイムスタンプ（分単位）を返します。
また、restフラグがFalseである場合は、終了時間が12:00を超える場合に、お昼休憩の時間（10分）を追加します。noon = h2m('12:00')で、12:00の時間を分単位で取得します。そして、noonよりも終了時間が後である場合に、start_time += 60 - 10で、お昼休憩を考慮した新しい開始時間を計算します。最後に、restフラグをTrueに設定します。
各発表が終わった後、start_timeにend_time + 10を代入して、次の発表の開始時間を計算します。この+ 10は、前の発表の終了時間と次の発表の開始時間の間に10分の休憩時間が必要であることを示しています。
'''

# B010 サッカーのオフサイド判定
# utf-8
def team_lineup(players, reverse=False):
    if reverse:
        players = list(map(lambda x:-x, players))
    return zip(range(1, 12), players)

def is_offside(x_player, x_passer, x_offside_line):
    return x_passer < x_offside_line < x_player

def get_offside_players(offence_team, diffence_team, x_passer, x_offside_line):
    offside_players = []
    for idx, x_p in enumerate(offence_team):
        if is_offside(x_p, x_passer, x_offside_line):
            offside_players.append(idx+1)
    return offside_players

def get_offside_line(diffence_team):
    return sorted(diffence_team, reverse=True)[1]

def get_opponent(name):
    return 'A' if name == 'B' else 'B'

# main
offence_name, passer = input().split()
team = {}
team['A'] = list(map(int, input().split()))
team['B'] = list(map(int, input().split()))

if offence_name == 'B':
    for t in team:
        team[t] = list(map(lambda x:-x, team[t]))

diffence_name = get_opponent(offence_name)
offence_team = team[offence_name]
diffence_team = team[diffence_name]

x_offside_line = get_offside_line(diffence_team)
x_passer = int(offence_team[int(passer)-1])

offside_players = get_offside_players(offence_team, diffence_team, x_passer, x_offside_line)

if offside_players:
    for p in offside_players:
        print(p)
else:
    print('None')
'''
与えられたサッカーの試合状況に対して、次のパスを受け取るとオフサイドと判定される選手の背番号を小さいものから順に1行ずつ出力するものです。
まず、input()関数を使って標準入力から入力を受け取ります。1行目では攻撃するチームの名前(offence_name)と、パスを受け取る選手の背番号(passer)をスペース区切りで受け取り、
2行目と3行目ではそれぞれ攻撃するチームの選手の背番号(team_a_numbers, team_b_numbers)をスペース区切りで受け取ります。
次に、攻撃するチームと守備するチームの背番号をリストで保持します。if文で、offence_nameが'B'の場合、攻撃するチームと守備するチームの背番号を反転させます。
この処理によって、攻撃するチームが必ずAチームになるようにしています。
次に、守備するチームの最後尾から2番目の背番号を取得します。この背番号より前に攻撃するチームの選手がいる場合、オフサイドの判定が行われます。
最後に、攻撃するチームの選手の中でオフサイドとなる選手の背番号を出力します。オフサイドとなる選手がいない場合には、"None"を出力します。
このコードのポイントは、オフサイド判定を行うis_offside関数にあります。この関数は、与えられた選手の背番号(x_player)、パスを出した選手の背番号(x_passer)、
そして守備するチームのオフサイドラインの背番号(x_offside_line)を受け取り、オフサイド判定を行います。
オフサイド判定は、パスを出した選手より前方に守備するチームのオフサイドラインと、パスを受けた選手が存在する場合に成立します。
'''

--------------------------------------------- B011　※欠番 ◆
# B011 名刺バインダー管理
# utf-8
n, m = map(int, input().split())

# m番目の名刺が含まれるページを計算する
page = (m - 1) // (n * 2) + 1

# そのページの最後の名刺番号と最初の名刺番号を計算する
last_card_num = page * n * 2
first_card_num = last_card_num - (n * 2 - 1)

# m番目の名刺が表面か裏面かによって、裏側の名刺の番号を計算する
if m <= (first_card_num + n - 1):
    back_card_num = last_card_num - (m - first_card_num)
else:
    back_card_num = first_card_num + (last_card_num - m)

print(back_card_num)
'''
1行目では、入力された文字列をスペースで分割し、それぞれ整数型に変換して、nとmに代入しています。
2行目では、m番目の名刺が属するページ数を求めています。m-1をn*2で割り、+1をしているのは、pythonで整数を割った場合、小数点以下が切り捨てられるためです。
また、m-1をする理由は、1番目の名刺が0ページ目にあるとみなすためです。3行目では、pageページに含まれる最後の名刺の番号を計算しています。pageページには、n2枚の名刺があるため、pmaxにn2をかけ、その後page-1をかけます。
それに1を足すのは、1ページ目が0番目のページであるとしているためです。4行目では、pageページに含まれる最初の名刺の番号を計算しています。pminには、pmaxからn*2-1を引いた数が入ります。
この式は、pageページの最初の名刺の番号がpage-1ページの最後の名刺の番号に1を足したものであることから導かれます。
5行目では、m番目の名刺の裏面にある名刺の番号を計算しています。mは、pageページの中で何番目の名刺なのかを計算します。pageページの最初の名刺の番号から、m番目の名刺の番号を引いたものが、m番目の名刺の裏面にある名刺の番号になります。
'''

# B012 ◆
# B013 ◆
# B014 3Dプリンタ
# utf-8
X,Y,Z=list(map(int,input().split()))
m=[['.' for j in range(Y)] for i in range(Z)]
for k in range(Z):
    for i in range(X):
        n=input()
        for j in range(Y):
            if n[j]=='#':
                m[k][j]='#'
    l=input()
for i in reversed(range(Z)):
    l=map(str,m[i])
    s=''.join(l)
    print(s)
'''
入力されたX,Y,Zに対して、Z枚のX行Y列のマス目を作成しています。マス目は、二次元リストで表現されています。
そして、入力されたマス目の状態を、マス目に反映させます。
最後に、マス目を反転させ、反転したマス目を出力します。
ここで、マス目の反転は、reversed(range(Z))を使用して、Zから0までの範囲を逆順に取得していることで実現されています。
また、map(str, m[i])を使用して、マス目を文字列に変換し、join()関数でつなげて、横一列の文字列として出力しています。
'''

# B015 7セグメントディスプレイ（デジタル表示の数字）　※テストケース通過せず
# utf-8
def check_display(a, b):
    # 各数字に対応する7セグメントディスプレイの状態
    digits = {
        0: [1, 1, 1, 1, 1, 1, 0],
        1: [0, 1, 1, 0, 0, 0, 0],
        2: [1, 1, 0, 1, 1, 0, 1],
        3: [1, 1, 1, 1, 0, 0, 1],
        4: [0, 1, 1, 0, 0, 1, 1],
        5: [1, 0, 1, 1, 0, 1, 1],
        6: [1, 0, 1, 1, 1, 1, 1],
        7: [1, 1, 1, 0, 0, 0, 0],
        8: [1, 1, 1, 1, 1, 1, 1],
        9: [1, 1, 1, 1, 0, 1, 1]
    }

    def is_valid_display(display):
        # ディスプレイの状態が各数字のいずれかと一致するかを判定
        for digit in digits.values():
            if display == digit:
                return True
        return False

    def symmetric_move(display):
        # 対称移動を行った後のディスプレイの状態を返す
        return display[::-1]

    def rotate_move(display):
        # 回転移動を行った後のディスプレイの状態を返す
        return display[-1:] + display[:-1]

    # 入力をリストに変換
    a_list = list(map(int, a.split()))
    b_list = list(map(int, b.split()))

    # 1. 装置が正しく2桁の数字を表すかを判定
    condition1 = is_valid_display(a_list) and is_valid_display(b_list)

    # 2. 装置を対称移動すると正しく2桁の数字を表すかを判定
    a_symmetric = symmetric_move(a_list)
    b_symmetric = symmetric_move(b_list)
    condition2 = is_valid_display(a_symmetric) and is_valid_display(b_symmetric)

    # 3. 装置を回転移動すると正しく2桁の数字を表すかを判定
    a_rotated = rotate_move(a_list)
    b_rotated = rotate_move(b_list)
    condition3 = is_valid_display(a_rotated) and is_valid_display(b_rotated)

    # 結果を出力
    result = ["Yes" if condition else "No" for condition in [condition1, condition2, condition3]]
    return "\n".join(result)

# 入力の受け取り
a = input()
b = input()

# 出力結果の表示
print(check_display(a, b))

# 別解　同様にテストケース通過せず
def check_display():
    # 各数字に対応する7セグメントディスプレイの状態
    digits = {
        0: [1, 1, 1, 1, 1, 1, 0],
        1: [0, 1, 1, 0, 0, 0, 0],
        2: [1, 1, 0, 1, 1, 0, 1],
        3: [1, 1, 1, 1, 0, 0, 1],
        4: [0, 1, 1, 0, 0, 1, 1],
        5: [1, 0, 1, 1, 0, 1, 1],
        6: [1, 0, 1, 1, 1, 1, 1],
        7: [1, 1, 1, 0, 0, 0, 0],
        8: [1, 1, 1, 1, 1, 1, 1],
        9: [1, 1, 1, 1, 0, 1, 1]
    }

    def is_valid_display(display):
        # ディスプレイの状態が各数字のいずれかと一致するかを判定
        for digit in digits.values():
            if display == digit:
                return True
        return False

    def symmetric_move(display):
        # 対称移動を行った後のディスプレイの状態を返す
        return display[::-1]

    def rotate_move(display):
        # 回転移動を行った後のディスプレイの状態を返す
        return display[-1:] + display[:-1]

    # 入力を受け取る
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    # 1. 装置が正しく2桁の数字を表すかを判定
    condition1 = is_valid_display(a) and is_valid_display(b)

    # 2. 装置を対称移動すると正しく2桁の数字を表すかを判定
    a_symmetric = symmetric_move(a)
    b_symmetric = symmetric_move(b)
    condition2 = is_valid_display(a_symmetric) and is_valid_display(b_symmetric)

    # 3. 装置を回転移動すると正しく2桁の数字を表すかを判定
    a_rotated = rotate_move(a)
    b_rotated = rotate_move(b)
    condition3 = is_valid_display(a_rotated) and is_valid_display(b_rotated)

    # 結果を出力
    result = ["Yes" if condition1 else "No",
              "Yes" if condition2 else "No",
              "Yes" if condition3 else "No"]
    return "\n".join(result)

# テストケース
print(check_display())

# B016 ここはどこ？
# utf-8
class B016:
    def __init__(self):
        info = input().split()
        self.board = {"W": int(info[0]), "H": int(info[1])}
        self.move_times = int(info[2])
        self.player = {}

    def set_player_position(self):
        position = input().split()
        self.player["X"] = int(position[0])
        self.player["Y"] = int(position[1])

    def set_move_info(self):
        self.move_info = []
        for i in range(self.move_times):
            move = input().split()
            self.move_info.append({"dir": move[0], "step": int(move[1])})

    def get_final_position(self):
        for move in self.move_info:
            self.move(move["dir"], move["step"])

    def move(self, direction, step):
        if direction == "U":
            step = step % self.board["H"]
            if self.player["Y"] + step > self.board["H"] - 1:
                self.player["Y"] = step - (self.board["H"] - self.player["Y"])
            else:
                self.player["Y"] += step
        elif direction == "D":
            step = step % self.board["H"]
            if self.player["Y"] - step < 0:
                self.player["Y"] = self.board["H"] - (step - self.player["Y"])
            else:
                self.player["Y"] -= step
        elif direction == "L":
            step = step % self.board["W"]
            if self.player["X"] - step < 0:
                self.player["X"] = self.board["W"] - (step - self.player["X"])
            else:
                self.player["X"] -= step
        elif direction == "R":
            step = step % self.board["W"]
            if self.player["X"] + step > self.board["W"] - 1:
                self.player["X"] = step - (self.board["W"] - self.player["X"])
            else:
                self.player["X"] += step

    def display(self):
        print("{} {}".format(self.player["X"], self.player["Y"]))

b016 = B016()
b016.set_player_position()
b016.set_move_info()
b016.get_final_position()
b016.display()
'''
このコードは、与えられた初期位置と移動ログに基づいて、移動後の位置を計算して出力するプログラムです。
まず、1行目でマップの横幅 w、縦幅 h、移動ログの個数 nを読み取ります。2行目では初期位置 x, yを読み取り、3行目からn+2行目までの各行で移動ログを読み取ります。
移動ログには、「dir_i」と「m_i」があり、「dir_i」は移動する方向（"U"、"D"、"R"、"L"）を、「m_i」は移動する距離を表しています。各ログに基づいて、プログラムは現在の位置から移動後の位置を計算し、最後に移動後の位置を出力します。
「move」メソッドは、与えられた方向と距離に応じて、与えられた座標を更新する関数です。プログラムは、与えられた移動ログに基づいて、「move」メソッドを呼び出し、プレイヤーの位置を更新します。
最後に、「display」メソッドは、プレイヤーの最終位置を出力します。
'''

# B017 手役の強さ(花札)
# utf-8
class StrongestMeans:
    def __init__(self, cards):
        self.cards = cards
        self.countOfCard = {}

    def getMeans(self):
        self.countCard()

        means = ""
        max_count = max(self.countOfCard.values())
        if max_count == 1:
            means = "NoPair"
        elif max_count == 2:
            means = "TwoPair" if len(self.countOfCard) == 2 else "OnePair"
        elif max_count == 3:
            means = "ThreeCard"
        elif max_count == 4:
            means = "FourCard"

        return means

    def countCard(self):
        for card in self.cards:
            if card == "*":
                self.plusAllKindCardOne()
            else:
                self.plusSpecifiedCardOne(card)

    def plusAllKindCardOne(self):
        cards = set(self.cards)
        for card in cards:
            if card != "*":
                self.plusSpecifiedCardOne(card)

    def plusSpecifiedCardOne(self, card):
        self.countOfCard[card] = self.countOfCard.get(card, 0) + 1

cards = input().strip()
strongMeans = StrongestMeans(list(cards))
print(strongMeans.getMeans())
'''
このコードは、入力のフォーマットに合わせてカードの入力を受け取り、StrongestMeansクラスのインスタンスを作成して、getMeansメソッドを呼び出し、結果を表示しています。
注意点：
カードの入力は、スペースで区切られた4つの文字列として受け取ります。
input().strip()を使って末尾の改行文字を除去します。
入力の最後には余分な文字や空行が含まれていないことを確認してください。
このコードを使用して、与えられた入力に基づいて最高の手役を判定し、出力することができます。

まず、StrongestMeansという名前のクラスが定義されています。このクラスは、カードの集合から手役の強さを判定するためのメソッドを提供します。
__init__メソッドは、cardsという引数を受け取り、インスタンスの初期化を行います。cardsは入力されたカードのリストです。countOfCardはカードの出現回数を格納するための辞書です。
getMeansメソッドは手役の強さを返します。まず、countCardメソッドを呼び出してカードの出現回数を数えます。
次に、countOfCard辞書の値の中で最大の数を取得します。その最大数に応じて手役を判定し、meansに結果を格納します。

countCardメソッドは、カードの出現回数を数えるためのメソッドです。self.cardsの各カードについて、cardとして処理します。
もしcardがワイルドカード "*" ならば、plusAllKindCardOneメソッドを呼び出します。
そうでない場合は、plusSpecifiedCardOneメソッドを呼び出して指定されたカードの出現回数を増やします。

plusAllKindCardOneメソッドは、ワイルドカード "*" の場合に他のすべてのカードの出現回数を増やすためのメソッドです。
self.cardsのユニークな要素を取得し、それぞれのカードについて処理します。
'''

# B018 ◆
# B019 グレースケールの画像の縮小
# utf-8
def shrink_image(N, K, pixels):
    # N/K × N/Kの画像を作成
    new_N = N // K
    new_pixels = [[0] * new_N for _ in range(new_N)]

    # 各ブロックの平均値を計算
    for r in range(new_N):
        for c in range(new_N):
            block_sum = 0
            for i in range(r * K, (r + 1) * K):
                for j in range(c * K, (c + 1) * K):
                    block_sum += pixels[i][j]
            average = block_sum // (K * K)
            new_pixels[r][c] = average

    return new_pixels

# 入力を受け取る
N, K = map(int, input().split())
pixels = []
for _ in range(N):
    row = list(map(int, input().split()))
    pixels.append(row)

# 画像を縮小
result = shrink_image(N, K, pixels)

# 結果を出力
for row in result:
    print(*row)
'''
shrink_image(N, K, pixels) 関数は、元の画像を指定されたブロックサイズで縮小するための関数です。関数は以下の手順で動作します。

元の画像のサイズ N とブロックサイズ K を受け取ります。
新しい画像のサイズ new_N を計算します。new_N は N を K で割った商です。
新しい画像を表現するための二次元リスト new_pixels を作成します。サイズは new_N × new_N です。
各ブロックの平均値を計算し、新しい画像のピクセル値として new_pixels に格納します。
最終的に new_pixels を返します。
メインのプログラムでは、以下の手順で処理が行われます。

元の画像のサイズ N とブロックサイズ K を入力します。
N 行のピクセル値を受け取り、二次元リスト pixels に格納します。
shrink_image(N, K, pixels) 関数を呼び出して、画像を縮小します。結果は result に格納されます。
result を出力します。
'''

# B020 ネットサーフィン
# utf-8
n = int(input())  # クエリの数を取得
queries = []  # クエリを保持するリスト
history = ["blank page"]  # ページの履歴を保持するリスト

# クエリを入力してリストに追加
for _ in range(n):
    queries.append(input())

# 各クエリを処理
for query in queries:
    if query == "use the back button":
        if len(history) > 1:
            history.pop()  # 直前のページを履歴から削除
        print(history[-1])  # 現在のページを出力
    else:
        page_name = query[6:]  # ページ名を取得
        history.append(page_name)  # ページを履歴に追加
        print(page_name)  # ページ名を出力

print()  # 最後の改行を出力
'''
このコードでは、まずクエリの数を取得し、その後のクエリをリストに追加します。それぞれのクエリに対して以下の処理を行います。

"use the back button" の場合:

履歴が1つ以上存在する場合は、直前のページを履歴から削除します。
現在のページを出力します。
"go to [page_name]" の場合:

ページ名を取得し、履歴に追加します。
ページ名を出力します。
最後に改行を出力します。

この修正により、最初のページが "blank page" であること、"use the back button" の場合でも "blank page" 以外の指定されたページを開くこと、各テストケースでの出力例が要件を満たすようになります。

修正後のコードでは、入力例に対する出力例も要件を満たすようになります。それぞれのクエリに対して適切なページを開き、履歴を保持しながら出力しています。
'''
--------------------------------------------- B021　※欠番 ◆
# B021 ◆
# B022 ◆
# B023 マッチ棒パズル
# utf-8
def get_another(a, b):
    for i in range(len(a)):
        a[i] = b[i]
    return a


def set_number(number):
    number[0][0] = "69"
    number[0][1] = "8"
    number[0][2] = ""

    number[1][0] = ""
    number[1][1] = "7"
    number[1][2] = ""

    number[2][0] = "3"
    number[2][1] = ""
    number[2][2] = ""

    number[3][0] = "25"
    number[3][1] = "9"
    number[3][2] = ""

    number[4][0] = ""
    number[4][1] = ""
    number[4][2] = ""

    number[5][0] = "3"
    number[5][1] = "69"
    number[5][2] = ""

    number[6][0] = "09"
    number[6][1] = "8"
    number[6][2] = "5"

    number[7][0] = ""
    number[7][1] = ""
    number[7][2] = "1"

    number[8][0] = ""
    number[8][1] = ""
    number[8][2] = "069"

    number[9][0] = "06"
    number[9][1] = "8"
    number[9][2] = "35"

    return number


def main():
    charS = input().strip()
    result = []

    number = [["" for _ in range(3)] for _ in range(10)]
    number = set_number(number)

    temp = list(charS)
    temp = get_another(temp, list(charS))
    for i in range(len(charS)):
        for j in range(3):
            point = int(charS[i])

            for k in range(len(number[point][j])):
                if j == 0:
                    temp[i] = number[point][0][k]
                    output = "".join(temp)
                    result.append(output)
                    temp = get_another(temp, list(charS))
                elif j == 1:
                    for l in range(i + 1, len(charS)):
                        point2 = int(charS[l])
                        for m in range(len(number[point2][2])):
                            temp[i] = number[point][1][k]
                            temp[l] = number[point2][2][m]
                            output = "".join(temp)
                            result.append(output)
                            temp = get_another(temp, list(charS))
                else:
                    for l in range(i + 1, len(charS)):
                        point2 = int(charS[l])
                        for m in range(len(number[point2][1])):
                            temp[i] = number[point][2][k]
                            temp[l] = number[point2][1][m]
                            output = "".join(temp)
                            result.append(output)
                            temp = get_another(temp, list(charS))

    result.sort()

    if len(result) == 0:
        print("none")
    else:
        for i in range(len(result)):
            print(result[i])
main()
'''
get_another(a, b) 関数:
リスト a をリスト b の要素で上書きする関数です。
a と b の要素数は同じである必要があります。
set_number(number) 関数:
number という2次元リストを引数として受け取り、特定のパターンで要素を初期化します。
この関数は number リストを返します。
main() 関数:
・プログラムのエントリーポイントとなる関数です。
・入力文字列 charS を受け取り、結果のリスト result を初期化します。
・2次元リスト number を set_number() 関数で初期化します。
・charS の各文字を処理するループを開始します。
・charS の各文字について、3つのパターン (j の値) に対してループを開始します。
・パターンごとに、数字の置換を行い、結果を result リストに追加します。
・最後に result をソートし、結果を出力します。

このコードのアルゴリズムは、与えられた文字列 charS の各文字に対して、異なるパターンで数字の置換を行い、結果を生成しています。
これにより、全ての可能な置換パターンを網羅的に生成することができます。最終的な結果は辞書順にソートされています。
ただし、このコードでは一部の箇所で冗長な処理が行われており、効率的ではないと言えます。特に、リストのコピー (temp = get_another(temp, list(charS))) や結果のリストに要素を追加する際のループ処理が、改善の余地があります。
'''

# B024 格子を円で切り取る　※数学的アプローチが必要
# utf-8
import math # mathモジュールをインポートして円周率の計算や平方根の計算を行います。

while True: # 無限ループを開始
    try: # 入力を試みます。もし例外が発生した場合、exceptブロックに移動します。
        r = float(input()) # 半径 r の値を浮動小数点数として入力します。
        if r <= 0: # もし r が0以下の場合、無効な入力値として扱い、エラーメッセージを表示して次のループに移ります。
            print("Invalid input: r must be a positive number.")
            continue
        total = 0 # 格子点の合計数を初期化します。
        n = math.ceil(r) # r の値を切り上げて最も近い整数 n にします。これは最小の正方形の一辺の長さとなります。
        for i in range(n + 1): # 0から n までの範囲でループ
            if r * r - i * i < 0: # もし r * r - i * i が0より小さい場合、円の内部にないのでスキップします。
                continue
            total += math.ceil(math.sqrt(r * r - i * i)) # 円の内部にある格子点の数を計算し、それを total に加算します。
        print(total * 4) # 計算された格子点の合計数に4を乗算して出力します。
    except (ValueError, EOFError): # 入力時に ValueError や EOFError の例外が発生した場合、ループを終了します。
        break
'''
このコードでは、入力された半径 r をもとに最小の正方形内の格子点の数を求め、さらに円の内部にある格子点の数を計算しています。
最終的に、格子点の数に4を乗算して出力します。なお、無効な入力や入力の終了（EOF）に対しても適切に処理しているため、例外が発生しても安全に終了できます。
'''

# B025 うさぎジャンプ
# utf-8
# N, M, Kの入力を受け取る
N, M, K = map(int, input().split())

# 各うさぎの現在の位置をリストに格納する
s = [int(input()) for _ in range(M)]

# しげみの状態を管理するリストを作成する（初期値は0）
grass = [0] * N

# 各うさぎの初期位置をしげみのリストに反映する
for i in s:
    grass[i - 1] = i

# Kセットのジャンプを行う
for _ in range(K):
    for j in range(M):
        # うさぎがジャンプ先として選ぶしげみの番号（% nを行うことで範囲内に収める）
        grass_num = s[j] % N
        # ジャンプ先が他のうさぎに占拠されている場合、空いているしげみを探す
        while grass[grass_num] != 0:
            grass_num = (grass_num + 1) % N
        # ジャンプ元のしげみからうさぎを移動させる
        grass[grass_num] = grass[s[j] - 1]
        grass[s[j] - 1] = 0
        # うさぎの位置情報を更新する
        s[j] = grass_num + 1

# 各うさぎの最終位置を出力する
for i in s:
    print(i)
'''
標準入力からN、M、Kの値を受け取ります。それぞれ、しげみの数N、うさぎの数M、ジャンプ回数Kを表します。
うさぎの現在位置をリストsに格納しています。range(m)でうさぎの数M回ループし、int(input())によって各うさぎの位置を受け取ります。
しげみの状態を管理するためのリストgrassを作成、初期値は全て0です。次のループでは、リストsに格納されている各うさぎの位置情報を、リストgrassに反映させています。
各うさぎの位置-1のインデックスに対応する要素にうさぎの番号を代入しています。Kセットのジャンプを行っています。
外側のループはK回ループします。内側のループでは、各うさぎに対してジャンプ処理を行います。
grass_numはうさぎがジャンプ先として選ぶしげみの番号です。s[j] % nによって範囲内に収められます。
grass[grass_num] != 0は、ジャンプ先のしげみが他のうさぎに占拠されているかどうかを判定しています。もし占拠されている場合、次の空いているしげみを探すためにgrass_numを1ずつ増やしていきます。whileループを抜けた時点で、grass_numには空いているしげみの番号が格納されます。
ジャンプ元のしげみからうさぎを移動させるために、grass[grass_num]にジャンプ元のうさぎの番号を代入し、ジャンプ元のしげみを空にします。
最後に、うさぎの位置情報を更新するためにs[j]にgrass_num + 1を代入します。+ 1はインデックスと番号の差を調整するためです。
'''

# B026 自動販売機
# utf-8
class VendingMachine:
    def __init__(self, coin_in_machine):
        self.coin_in_machine = coin_in_machine

    def sell_result(self, customers):
        for customer in customers:
            arr_customer = customer.split(" ")

            # お客様が購入した商品の価格及び入れた各コインの枚数
            product_price = int(arr_customer[0])
            use_coin = {
                500: int(arr_customer[1]),
                100: int(arr_customer[2]),
                50: int(arr_customer[3]),
                10: int(arr_customer[4])
            }

            change_coin = {
                500: 0,
                100: 0,
                50: 0,
                10: 0
            }

            # お釣り
            change = [500 * use_coin[500] + 100 * use_coin[100] + 50 * use_coin[50] + 10 * use_coin[10] - product_price]
            tmp_change = change[0]

            for coin, coin_number in self.coin_in_machine.items():
                self.change(coin, coin_number, change, change_coin)

            message = ""
            if self.check_if_pass(change_coin, tmp_change):

                # 自動販売機内部コインの変化
                for coin, coin_number in self.coin_in_machine.items():
                    self.coin_in_machine[coin] = coin_number + use_coin[coin] - change_coin[coin]

                # 出力
                k = 0
                for coin, count in change_coin.items():
                    message += str(count)
                    if k == len(change_coin) - 1:
                        break
                    message += " "
                    k += 1

            else:
                message += "impossible"
            print(message)

    def change(self, coin, coin_number, change, change_coin):
        # お釣りの残りがcoin以下の場合は計算不要なので処理を終了する
        if change[0] < coin:
            return
        for num in range(coin_number, -1, -1):
            price = change[0] - num * coin
            # 残りのお釣りがcoinを使ってprice円支払える場合
            if price >= 0:
                change[0] -= num * coin
                change_coin[coin] = num
                return

    def check_if_pass(self, change_coin, tmp_change):
        # 50円玉と10円玉の合計が100円以上の場合は条件を満たさない
        if change_coin[50] * 50 + change_coin[10] * 10 >= 100:
            return False
        for coin, coin_number in self.coin_in_machine.items():
            # 自動販売機内のコインの枚数を超える場合は条件を満たさない
            if change_coin[coin] > coin_number:
                return False
        # お釣りの合計金額がtmp_change円と一致しない場合は条件を満たさない
        if change_coin[500] * 500 + change_coin[100] * 100 + change_coin[50] * 50 + change_coin[10] * 10 != tmp_change:
            return False
        return True


# 入力値の読み込み
info = input().strip()
arr_info = info.split(" ")

coin_in_machine = {
    500: int(arr_info[0]),
    100: int(arr_info[1]),
    50: int(arr_info[2]),
    10: int(arr_info[3])
}

count_of_customer = int(input().strip())
customers = []
for _ in range(count_of_customer):
    customers.append(input().strip())

# 自動販売機オブジェクトの作成と売り上げ結果の表示
vending_machine = VendingMachine(coin_in_machine)
vending_machine.sell_result(customers)
'''
VendingMachine クラス:
coin_in_machine インスタンス変数: 自動販売機内の各コインの枚数を格納する辞書です。
__init__ メソッド: coin_in_machine 辞書を受け取り、インスタンス変数に設定します。
sell_result メソッド: 複数の顧客の購入情報を受け取り、結果を表示します。
change メソッド: お釣りの計算を行います。指定されたコインで支払い可能な最大枚数を計算し、お釣りと使用したコインの枚数を更新します。
check_if_pass メソッド: お釣りの条件をチェックし、条件を満たすかどうかを判定します。

入力の読み込み:
最初の入力は自動販売機内のコインの枚数を表す文字列です。空白で区切られた各要素は、500円、100円、50円、10円のコインの枚数を表します。
2番目の入力は顧客の数を表す整数です。
続く入力は各顧客の購入情報を表す文字列です。空白で区切られた各要素は、商品の価格、500円、100円、50円、10円のコインの枚数を表します。

自動販売機オブジェクトの作成と売り上げ結果の出力:
入力から得られた情報をもとに、VendingMachine オブジェクトを作成します。
sell_result メソッドを呼び出し、顧客ごとの売り上げ結果を出力します。
'''

# B027 ◆
# B028 チャット記録
# utf-8
# 入力を取得
n, g, m = list(map(int, input().split()))
# グループの情報を取得
k = [list(map(int, input().split())) for i in range(g)]
# 各社員の画面に表示されるメッセージを格納するリストを初期化
N = [[] for i in range(n)]
# メッセージの数だけループ
for i in range(m):
    # メッセージの情報を入力し、送信者、受信者の種類、ターゲット、内容を取得
    s = input().split()
    sender = int(s[0])
    recipient_type = int(s[1])
    target = int(s[2])
    content = s[3:]
    
    # 受信者の種類が0の場合、送信者と受信者の両方の画面にメッセージを追加
    if recipient_type == 0 and sender != target:
        N[sender-1] += content
        N[target-1] += content
    
    # 受信者の種類が1の場合、対象のグループに所属するすべての社員の画面にメッセージを追加
    if recipient_type == 1:
        group_members = k[target-1][1:]  # グループのメンバーを取得
        for member in group_members:
            N[member-1] += content
    
# 各社員の画面に表示されるメッセージを出力
for i in range(n-1):
    print('\n'.join(N[i]))
    print('--')
print('\n'.join(N[-1]))
'''
このコードは、与えられた入力に基づいてメッセージのやり取りをシミュレーションし、各社員の画面に表示されるメッセージを出力します。
まず、社員数 n、グループ数 g、メッセージ数 m を入力します。次に、各グループの情報を入力し、グループに所属する社員のリストを作成します。
その後、メッセージの数だけループを回し、各メッセージに対して以下の処理を行います。
メッセージの情報を入力し、送信者と受信者の種類、ターゲット、内容を取得します。
受信者の種類が 0 の場合、送信者と受信者の両方の画面にメッセージを追加します。
受信者の種類が 1 の場合、対象のグループに所属するすべての社員の画面にメッセージを追加します。
最後に、各社員の画面に表示されるメッセージを出力します。各社員の画面ごとに、メッセージを改行区切りで表示し、最後にハイフンで区切ります。
'''

# B029 地価の予想　※テストケース90点　条件内の境界値で不一致
# utf-8
import math

def predict_land_price(x, y, k, known_points):
    # 地点A（x, y）から既知の地点までの距離と価格を計算して保持する
    distances = [(math.sqrt((x - xi) ** 2 + (y - yi) ** 2), pi) for xi, yi, pi in known_points]
    distances.sort(key=lambda d: (d[0], d[1]))  # 距離を昇順にソート

    # k個の最も近い地点の価格の合計を計算し、平均を求めて予測価格とする
    total_price = sum(p for _, p in distances[:k])
    predicted_price = round(total_price / k)

    return predicted_price

def main():
    # 入力値の読み込み
    x, y = map(int, input().split())
    k = int(input())
    N = int(input())

    # 入力条件の検証
    if not (2 <= N <= 100):
        raise ValueError("Nは2から100の範囲内である必要があります")
    if not (1 <= k <= N):
        raise ValueError("kは1からNの範囲内である必要があります")
    if not (0 <= x <= 1000) or not (0 <= y <= 1000):
        raise ValueError("xとyは0から1000の範囲内である必要があります")

    known_points = []
    for _ in range(N):
        # 既知の地点の座標と価格を読み込む
        xi, yi, pi = map(int, input().split())

        # 既知の地点の条件の検証
        if not (0 <= xi <= 1000) or not (0 <= yi <= 1000):
            raise ValueError("xiとyiは0から1000の範囲内である必要があります")
        if not (1 <= pi <= 100):
            raise ValueError("piは1から100の範囲内である必要があります")

        known_points.append((xi, yi, pi))

    # k-近傍法を使用して地点A（x, y）における地価を予測する
    predicted_price = predict_land_price(x, y, k, known_points)

    # 予測した地価を出力する
    print(predicted_price)

if __name__ == "__main__":
    try:
        main()
    except ValueError as e:
        print("入力が無効です:", str(e))

# utf-8　Java
import java.util.Scanner;
import java.util.TreeMap;

public class Main {

	public static void main(String[] args) {

		Scanner in = new Scanner(System.in);

		// 基準点のX座標,Y座標の設定

		int coordinateX = in.nextInt();// 基準点X座標入力
		int coordinateY = in.nextInt();// 基準点Y座標入力

		// 近い点の個数・既知の個数の設定

		int nearPointCount = in.nextInt();// 基準値からいくつ既知の点を使うか入力
		int knownPointCount = in.nextInt();// 既知の点はいくつあるか入力

		// 既知の点の座標・地価設定

		int[] knownPointCoordinateX = new int[knownPointCount];// 既知の点のX座標格納
		int[] knownPointCoordinateY = new int[knownPointCount];// 既知の点のY座標格納
		int[] landPrice = new int[knownPointCount];// 既知の点の地価格納

		for (int i = 0; i < knownPointCount; i++) {
			knownPointCoordinateX[i] = in.nextInt();// X座標入力
			knownPointCoordinateY[i] = in.nextInt();// Ｙ座標入力
			landPrice[i] = in.nextInt();// 地価入力
		}

		// 基準値と既知との距離計算設定

		TreeMap<Double, Integer> distanceLandPrice = new TreeMap<>(); // 基準値との距離ををkeyに地価をvalueのTreeMap
		double tmp = 0;// 基準値との距離の一時変数

		for (int i = 0; i < knownPointCount; i++) {

			// 距離計算
			tmp = Math.sqrt(Math.pow(coordinateX - knownPointCoordinateX[i], 2)
					+ Math.pow(coordinateY - knownPointCoordinateY[i], 2));

			distanceLandPrice.put(tmp, landPrice[i]);
		}

		// 基準点の地価計算設定

		double sumLandPrice = 0;// 地価合計 四捨五入するためdouble型で扱う
		int cnt = 0;// 既知の点をいくつ使ったかカウント

		for (double key : distanceLandPrice.keySet()) {// 昇順にソートされたkeyから取り出す = 基準値との距離が短いものから

			if (cnt == nearPointCount) {
				break;
			}
			sumLandPrice += distanceLandPrice.get(key);// 地価の合計更新
			cnt++;
		}

		// 結果出力

		System.out.println(Math.round(sumLandPrice / nearPointCount));

	}
}

# B030 氷のダンジョン　※入力例1のみOK
# utf-8
def explore_dungeon(H, W, dungeon, s_x, s_y, N, directions):
    # 方向ごとの座標の変化量
    dx = {'U': 0, 'R': 1, 'D': 0, 'L': -1}
    dy = {'U': -1, 'R': 0, 'D': 1, 'L': 0}

    # 初期座標
    x = s_x
    y = s_y

    # 移動を実行
    for direction in directions:
        while True:
            # 移動先の座標を計算
            nx = x + dx[direction]
            ny = y + dy[direction]

            # 移動先がダンジョン内かどうかをチェック
            if nx < 1 or nx > W or ny < 1 or ny > H:
                break  # 移動先がダンジョン外なら終了

            # 移動先が壁なら終了
            if dungeon[ny][nx] == '#':
                break

            # 移動先が土の床なら移動
            x = nx
            y = ny

    return x, y


# 入力の読み込み
H, W = map(int, input().split())
dungeon = []
for _ in range(H):
    dungeon.append(input().strip())
s_x, s_y = map(int, input().split())
N = int(input())
directions = []
for _ in range(N):
    directions.append(input().strip())

# ダンジョンの探索
final_x, final_y = explore_dungeon(H, W, dungeon, s_x, s_y, N, directions)

# 結果の出力
print(final_x, final_y)

--------------------------------------------- B031　※欠番 ◆
# B031 コインのウラとオモテ
# utf-8
def count_black_coins(N, s):
    board = list(s)  # 入力文字列をリストに変換してボードとして扱う
    black_count = board.count('b')  # 最初の黒コインの数を数える

    flipped = True  # 反転が行われたかどうかを表すフラグ
    while flipped:
        flipped = False  # 初期値は反転が行われなかったとする
        i = 0
        while i < N:
            if board[i] == 'b':  # 黒コインの場合
                j = i
                while j < N and board[j] == 'b':
                    j += 1
                if i > 0 and j < N and 'w' not in board[i:j]:
                    # 黒コインが白コインを挟めない場合、反転させる
                    for k in range(i, j):
                        board[k] = 'w'
                    flipped = True  # 反転が行われたのでフラグを立てる
            elif board[i] == 'w':  # 白コインの場合
                j = i
                while j < N and board[j] == 'w':
                    j += 1
                if i > 0 and j < N and 'b' not in board[i:j]:
                    # 白コインが黒コインを挟めない場合、反転させる
                    for k in range(i, j):
                        board[k] = 'b'
                    flipped = True  # 反転が行われたのでフラグを立てる
            i = j

    black_count = board.count('b')  # 最終的な黒コインの数を数える
    return black_count

# 入力の読み込み
N = int(input())
s = input().rstrip()

# 黒コインの個数の計算
result = count_black_coins(N, s)

# 結果の出力
print(result)
'''
まず、count_black_coinsという関数が定義されています。この関数は、引数としてボードの横の長さを表すNとゲーム開始時のコインの並びを表す文字列sを受け取り、最終的な黒コインの数を返します。
関数内では、boardというリストを作成し、sを文字ごとに分割して格納します。また、最初の黒コインの数を数えるための変数black_countを用意します。
flippedというフラグ変数をTrueで初期化します。この変数は、反転が行われたかどうかを示す役割を果たします。
次に、whileループが開始されます。ループ内では、まずflippedをFalseに設定します。これは、反転が行われなかった場合のデフォルトの状態です。
次に、インデックスiを初期化し、iがNより小さい間ループを繰り返します。ループ内では、以下の処理が行われます。

board[i]が黒コインの場合：
jをiとし、jがN以下かつboard[j]が黒コインである間ループを繰り返します。つまり、連続する黒コインの範囲を見つけます。
もしiより前に白コインがなく、jより後に白コインがない場合、つまり黒コインが白コインを挟めない状態であれば、その範囲のコインを反転させます。具体的には、board[i:j]の要素をすべて白コインに置き換えます。
反転が行われた場合、flippedをTrueに設定します。

board[i]が白コインの場合：
jをiとし、jがN以下かつboard[j]が白コインである間ループを繰り返します。つまり、連続する白コインの範囲を見つけます。
もしiより前に黒コインがなく、jより後に黒コインがない場合、つまり白コインが黒コインを挟めない状態であれば、その範囲のコインを反転させます。具体的には、board[i:j]の要素をすべて黒コインに置き換えます。
反転が行われた場合、flippedをTrueに設定します。
iをjの値に更新します。

ループの最後で、もしflippedがTrueのままであれば、まだ反転が行われる可能性があるため、再度の反転処理を行います。これは、連続するコインの範囲に対しての反転を繰り返し行うためです。
最後に、最終的なボードの状態で黒コインの数を数え、その結果をblack_countとして返します。
メインの処理では、入力を受け取り、count_black_coins関数を呼び出して最終的な黒コインの数を計算し、結果を出力します。
'''

# B032 デジタル計算機
# utf-8
class Abacus:
    def __init__(self, width):
        self.width = width

    def get_number(self):
        numbers = []
        # そろばんの状態を入力
        for _ in range(8):
            pearls = input().strip()
            numbers.append(list(pearls))
        
        result = ''
        # 列ごとに珠の移動をシミュレーション
        for pearls in zip(*numbers):
            tmp = 0
            for position, pearl in enumerate(pearls):
                if position < 2:
                    if position == 1 and pearl == '*':
                        tmp += 5  # 上の桁で2つ目の珠が存在し、'*' の場合は5を加算
                    continue
                if position == 2:
                    continue # 3つ目の位置は無視して次の位置へ進む
                if position > 2:
                    if pearl == '|':
                        break   # '|' が現れた場合は珠の移動が終了し、ループから抜ける
                    tmp += 1    # '|' が出現するまで、珠の移動回数をカウント
            result += str(tmp)  # 珠の移動回数を結果に追加

        return int(result.rjust(self.width, '0')) # 結果を指定の桁数に合わせてゼロで左詰めし、整数として返す

    def get_result(self, number):
        result = [['*' if i != 2 else '=' for _ in range(self.width)] for i in range(8)]
        # そろばんの初期状態を生成
        number = str(number).rjust(self.width, '0')
 
        # 数字をそろばんの状態に変換
        for i, digit in enumerate(number):
            digit = int(digit)
            if digit < 5:
                result[0][i] = '*'  # 上の桁の珠
                result[1][i] = '|'  # 下の桁の珠
            else:
                result[0][i] = '|'  # 上の桁の珠

            number = str(digit - 5) if digit >= 5 else str(digit)
            # 数字が5以上の場合は珠を1つ上に移動させた後の数字
            # 数字が5未満の場合は珠を移動させずそのままの数字
            # 条件が真の場合、珠を1つ上に移動させた後の数字を表す文字列に変換しています。
            # 条件が偽の場合、珠を移動させず、元の数字のままとなります。
            # 下の桁の珠を配置
            for j in range(3, 8):
                if j - 3 == int(number):
                    result[j][i] = '|'  # 下の桁の珠

        # 結果を表示
        for row in result:
            print(''.join(row))


W = int(input())  # そろばんの長さを入力
abacus = Abacus(W)
A = abacus.get_number()  # 数字 A のそろばんを取得
B = abacus.get_number()  # 数字 B のそろばんを取得
abacus.get_result(A + B)  # A + B のそろばんを表示
'''
Abacus クラスのコンストラクタで、そろばんの幅（桁数）を受け取り、インスタンス変数 width に設定します。
get_number メソッドは、そろばんの状態を入力として受け取り、その状態に対応する数値を返します。
入力されたそろばんの状態は、8行分の文字列として受け取ります。各行は桁ごとの珠の状態を表しています。それぞれの珠は '*' または '|' のいずれかです。
列ごとに珠の移動をシミュレーションし、数値に変換しています。具体的な処理は以下の通りです。

position と pearl には珠の位置と状態が順番に渡されます。
position が 0 または 1 の場合、2つ目の珠の位置であることを判定しています。
もし pearl が '*' の場合、上の桁で2つ目の珠が存在することを意味し、結果に 5 を加算します。
position が 2 の場合、3つ目の位置であることを判定して無視します。
position が 2 より大きい場合、下の桁の位置であることを意味します。
もし pearl が '|' の場合、珠の移動が終了し、ループから抜けます。
それ以外の場合、珠の移動回数を 1 加算します。
最終的に、結果を文字列 result に追加し、指定の桁数に合わせて左詰めし、整数として返します。

get_result メソッドは、数値をそろばんの状態に変換して表示します。
まず、数値 number を文字列に変換し、指定の桁数に合わせて左詰めします。
それぞれの桁の数字をそろばんの状態に変換して result に格納します。具体的な処理は以下の通りです。

i と digit には桁のインデックスと数字が順番に渡されます。
digit を整数に変換し、その値に応じて上の桁と下の桁の珠の状態を設定します。
もし digit が 5 未満の場合、上の桁の珠に '*' を、下の桁の珠に '|' を設定します。
もし digit が 5 以上の場合、上の桁の珠に '|' を設定します。
digit を 5 を引いた値に変換し、その結果を number に再代入します。これにより、次の桁の珠の配置に移ります。
下の桁の珠の位置 j が、j - 3 と number の値が一致する場合、下の桁の珠に '|' を設定します。
最終的に、結果のそろばんの状態を表示します。
'''

# B033 テーブルジェネレーター
# utf-8
def generate_table(headers, data):
    # 各列の最大幅を計算
    column_widths = [max(len(header), max(len(str(row[i])) for row in data)) for i, header in enumerate(headers)]

    # ヘッダー行を生成
    header_row = "| " + " | ".join(header.ljust(width) for header, width in zip(headers, column_widths)) + " |"

    # 区切り行を生成
    separator_row = "|-" + "-|-".join("-" * width for width in column_widths) + "-|"

    # データ行を生成
    data_rows = ""
    for row in data:
        data_row = "| " + " | ".join(str(cell).ljust(width) for cell, width in zip(row, column_widths)) + " |\n"
        data_rows += data_row

    # テーブルを結合して返す
    table = header_row + "\n" + separator_row + "\n" + data_rows
    return table

def generate_output(headers, data):
    # テーブルを生成
    table = generate_table(headers, data)
    # 改行と余分な空白を削除して出力用文字列を作成
    output = ""
    output += table.strip() + "\n"

    return output

# 入力の取得
W = int(input())
headers = input().split()
H = int(input())
data = [input().split() for _ in range(H)]

# テーブルの生成と出力
output = generate_output(headers, data)
print(output)
'''
generate_table(headers, data)関数は、与えられた見出しとデータから表を生成するための関数です。まず、各列の最大幅を計算します。
その後、ヘッダー行、区切り行、データ行を生成し、それらを結合してテーブルを作成します。最終的に、生成したテーブルを返します。
generate_output(headers, data)関数は、generate_table()関数を呼び出してテーブルを生成し、出力用の文字列を作成します。
テーブルの前後に余分な空白がないようにし、最終的な出力用文字列を返します。
入力部分では、まず見出しの個数 W を取得し、次に見出しのリスト headers を取得します。
続いて、データ行の行数 H を取得し、H 行分のデータをリストとして取得します。
最後に、generate_output()関数を呼び出してテーブルを生成し、出力します。
'''

# B034 ロボットの歩行実験
# utf-8
# 入力値の読み込み
sp_x, sp_y = map(int, input().split())  # 初期位置
move_forward, move_right, move_backward, move_left = map(int, input().split())  # 移動量
mCN = int(input())  # 移動コマンドの数
move_command = [list(map(str, input().split())) for _ in range(mCN)]  # 移動コマンド

current_state = 0
# 0 : F (前進)
# 1 : R (右に移動)
# 2 : B (後退)
# 3 : L (左に移動)

for i in range(mCN):
    if move_command[i][0] == 'm':  # 移動コマンド
        if move_command[i][1] == 'F':  # 前進
            if current_state == 0:
                sp_y += move_forward
            elif current_state == 1:
                sp_x += move_forward
            elif current_state == 2:
                sp_y -= move_forward
            elif current_state == 3:
                sp_x -= move_forward
        elif move_command[i][1] == 'R':  # 右に移動
            if current_state == 0:
                sp_x += move_right
            elif current_state == 1:
                sp_y -= move_right
            elif current_state == 2:
                sp_x -= move_right
            elif current_state == 3:
                sp_y += move_right
        elif move_command[i][1] == 'B':  # 後退
            if current_state == 0:
                sp_y -= move_backward
            elif current_state == 1:
                sp_x -= move_backward
            elif current_state == 2:
                sp_y += move_backward
            elif current_state == 3:
                sp_x += move_backward
        elif move_command[i][1] == 'L':  # 左に移動
            if current_state == 0:
                sp_x -= move_left
            elif current_state == 1:
                sp_y += move_left
            elif current_state == 2:
                sp_x += move_left
            elif current_state == 3:
                sp_y -= move_left
    elif move_command[i][0] == 't':  # 回転コマンド
        if move_command[i][1] == 'R':  # 右に回転
            current_state = (current_state + 1) % 4
        elif move_command[i][1] == 'B':  # 後ろ向きに回転
            current_state = (current_state + 2) % 4
        elif move_command[i][1] == 'L':  # 左に回転
            current_state = current_state - 1
            if current_state == -1:
                current_state = 3

    # 座標の範囲を制限
    if sp_x < -1000:
        sp_x = -1000
    elif sp_x > 1000:
        sp_x = 1000
    if sp_y < -1000:
        sp_y = -1000
    elif sp_y > 1000:
        sp_y = 1000

# 結果を出力
print(sp_x, sp_y)
'''
与えられた入力に基づいてロボットの移動をシミュレートし、最終的な座標を出力するものです。以下、コードの解説をします。

最初に、初期位置と移動量、移動コマンドの数を入力します。
次に、移動コマンドを入力します。移動コマンドは、移動（'m'）か回転（'t'）のどちらかであり、移動の場合は方向（'F', 'R', 'B', 'L'）も指定されます。
ロボットの現在の状態を表す変数 current_state を初期化します。0は前進（F）、1は右に移動（R）、2は後退（B）、3は左に移動（L）を表します。
移動コマンドの数だけループを実行します。
ループ内では、移動コマンドが移動の場合と回転の場合に分かれます。
移動の場合は、現在の状態に応じて座標を更新します。例えば、前進の場合は現在の状態に応じて sp_x や sp_y を増減させます。
回転の場合は、現在の状態を変更します。右回転（R）の場合は現在の状態に1を加え、後ろ向きに回転（B）の場合は2を加えます。左回転（L）の場合は現在の状態から1を引きますが、-1になる場合は3に戻します。
移動後に、座標の範囲を制限します。sp_x や sp_y が範囲外（-1000未満または1000を超える）の場合は、最小値または最大値に制限します。
最後に、最終的な座標 sp_x と sp_y を出力します。
このコードは、与えられた移動コマンドに従ってロボットを移動させ、最終的な座標を制限しながら計算します。移動と回転の操作を適切に行い、最終的な座標を正確に計算できるようになっています。
'''

# B035 ジョギングランキング
# utf-8
# 部員数 N、ジョギング記録数 M、上位人数 T を入力として受け取る
N, M, T = map(int, input().split())

# 前月のジョギング成績を格納するリスト
post_mon = []

# 前月のジョギング成績を受け取り、リストに追加する
for _ in range(N):
    post_mon.append(input().split())

# 今月のジョギング記録を格納するリスト
this_mon = []

# 今月のジョギング記録を受け取り、リストに追加する
for _ in range(M):
    this_mon.append(input().split())

# リストを距離の降順にソートする関数
def range_sort(lst):
    lst.sort(key=lambda x: (-int(x[1]), x[0]))
    return lst

# 前月のジョギング成績をソートする
post_mon = range_sort(post_mon)

# 上位のジョギング記録を取得する
top_post = post_mon[:T]

# 今月のジョギング記録の合計を計算し、名前と合計距離を格納するリスト
this_mon_sum = []

# 今月のジョギング記録の合計を計算する
for name in set(record[1] for record in this_mon):
    total_distance = sum(int(record[2]) for record in this_mon if record[1] == name)
    this_mon_sum.append([name, str(total_distance)])

# 前月のジョギング成績と今月のジョギング記録の合計を結合し、ソートする
this_mon_sum += [[name, '0'] for name in set(record[0] for record in post_mon) - set(record[0] for record in this_mon_sum)]
this_mon_sum = range_sort(this_mon_sum)

# 上位のジョギング記録を取得する
top_this = this_mon_sum[:T]

# 変動を判定し、結果を追加する
for i in range(T):
    if top_this[i][0] == top_post[i][0]:
        top_this[i].append("same")
    elif any(top_this[i][0] == record[0] for record in top_post[i + 1:]):
        top_this[i].append("up")
    elif any(top_this[i][0] == record[0] for record in top_post[:i]):
        top_this[i].append("down")
    else:
        top_this[i].append("new")

# 結果を出力する
for record in top_this:
    print(" ".join(record))
'''
まず、与えられた入力を受け取ります。N, M, T = map(int, input().split())を使って、整数値の N, M, T を取得します。
次に、post_monというリストに前月のジョギング成績を格納します。post_mon = [input().split() for _ in range(N)]の部分で、N 回のループを実行して、各行から名前と距離を受け取って post_mon リストに追加しています。
同様に、this_monというリストに今月のジョギング記録を格納します。this_mon = [input().split() for _ in range(M)]の部分で、M 回のループを実行して、各行から日付、名前、距離を受け取って this_mon リストに追加しています。
次に、range_sort関数を使って post_mon リストと this_mon_sum リストをソートします。range_sort関数は与えられたリストを距離の降順にソートし、距離が同じ場合は名前の辞書順でソートする関数です。
その後、上位のジョギング記録を top_post リストと top_this リストに格納します。top_post リストは post_mon リストの上位 T 件の記録を格納し、top_this リストは this_mon_sum リストの上位 T 件の記録を格納します。
top_post リストと top_this リストを比較し、各記録の変動を判定します。結果を top_this リストの各要素の3番目の要素に追加します。
最後に、top_this リストを出力します。各要素の名前、距離、変動結果がスペース区切りで表示されます。
'''

# B036 大統領選挙
# utf-8
def calculate_winner(candidate_num, candidates, voter_num, voter_preferences):
    voted_candidates = [0] * (candidate_num + 1)  # 候補者ごとの得票数を保持するリスト
    repub_vote = 0  # 共和党候補の得票数
    demo_vote = 0  # 民主党候補の得票数

    # 最初の投票
    for preferences in voter_preferences:
        for check in range(2):
            for candidate in preferences:
                if candidates[candidate] == check:
                    voted_candidates[candidate] += 1  # 候補者の得票数をインクリメント
                    break

    # 最初の投票結果
    repub = max((c for c in range(1, candidate_num + 1) if candidates[c] == 0), key=lambda x: voted_candidates[x])
    demo = max((c for c in range(1, candidate_num + 1) if candidates[c] == 1), key=lambda x: voted_candidates[x])

    # 最後の投票
    for preferences in voter_preferences:
        for candidate in preferences:
            if candidate == repub:
                repub_vote += 1
                break
            elif candidate == demo:
                demo_vote += 1
                break

    # 結果の出力
    if repub_vote > demo_vote:
        return repub
    else:
        return demo

# 入力
candidate_num = int(input())  # 候補者数の入力
candidates = [0] * (candidate_num + 1)  # 候補者の所属パーティーを保持するリスト
for i in range(1, candidate_num + 1):
    if input() == "Republican":
        candidates[i] = 0
    else:
        candidates[i] = 1

voter_num = int(input())  # 投票者数の入力
voter_preferences = []  # 投票者の選好順位を保持するリスト
for _ in range(voter_num):
    preferences = list(map(int, input().split()))  # 投票者の選好順位をリストとして入力
    voter_preferences.append(preferences)

# 勝者の計算
winner = calculate_winner(candidate_num, candidates, voter_num, voter_preferences)

# 結果の出力
print(winner)
'''
calculate_winner 関数は、候補者数、候補者の所属パーティー、投票者数、投票者の選好順位を受け取り、最終的な勝者を計算する関数です。共和党候補と民主党候補の得票数を数えて、最終的な勝者を決定します。
入力値を受け取ります。まず、候補者数と候補者の所属パーティーを入力し、その後、投票者数と各投票者の選好順位を入力します。
calculate_winner 関数を使用して最終的な勝者を計算し、結果を出力します。
このコードでは、最初の投票で各候補者の得票数をカウントし、その結果から共和党候補と民主党候補を決定します。その後、最後の投票で選好順位に基づいて得票数をカウントし、最終的な勝者を決定します。最終的な勝者の候補者番号が返され、結果が出力されます。
'''

# B037 幸運な1年
# utf-8
def get_lucky_day(M, D, a, b, m):
    w, x, y, z = 0, 0, 0, 0
    d = {}
    date = '{:0=2}'.format(M) + '{:0=2}'.format(D)
    datenum = set(date)
    
    # 日付の桁数と出現回数をカウント
    for i in datenum:
        d[i] = date.count(i)
    
    for i in range(10000):
        flag = True
        w = (a[0] * w + b[0]) % m[0]
        x = (a[1] * x + b[1]) % m[1]
        y = (a[2] * y + b[2]) % m[2]
        z = (a[3] * z + b[3]) % m[3]
        date2 = str(w % 10) + str(x % 10) + str(y % 10) + str(z % 10)
        
        # カードの数字と日付を比較
        for key in d:
            if key not in date2:
                flag = False
                break
            if date2.count(key) != d[key]:
                flag = False
                break
        
        if flag:
            return i + 1
    
    return -1

# 入力値の取得
M, D = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
m = list(map(int, input().split()))

# 幸運な日を取得
result = get_lucky_day(M, D, a, b, m)
print(result)
'''
get_lucky_day 関数は、引数として今日の日付 (M, D)、カードのパラメータ (a, b, m) を受け取り、幸運な日になるために必要なカードの引き直し回数を計算します。
変数 w, x, y, z はカードの擬似乱数を表すための変数で、初期値は 0 です。
辞書 d は日付の桁数と出現回数を保持します。桁数と出現回数の対応は、日付を文字列に変換してカウントします。
次に、10,000 回までのループを実行します。
フラグ flag は幸運な日になるかどうかを示す変数で、初期値は True です。
カードの擬似乱数を生成し、それぞれのカードの数字を 10 で割った余りを取得して date2 に格納します。
date2 と辞書 d を比較して、カードの数字が日付を作るために必要な条件を満たしているかどうかを判定します。条件を満たさない場合、flag を False に設定します。
もし flag が True のままであれば、ループ回数に 1 を加えた値を返します。これが幸運になるために必要なカードの引き直し回数です。
もしループが終了しても幸運な日になる条件を満たすカードの引き直し回数が見つからない場合、-1 を返します。
最後に、入力値を受け取り、get_lucky_day 関数を呼び出して結果を出力します。
'''

# B038 つるかめ算　※テストケース90点　条件内の特殊ケースで不一致
# utf-8
def estimate_animals(a, b, c, d):
    # パイザ鶴とパイザ亀の匹数を推定する関数

    # パイザ鶴の匹数を x、パイザ亀の匹数を y とする
    # 足の本数と頭の数から以下の連立方程式が成り立つ
    # c*x + d*y = a
    # x + y = b

    # 連立方程式を解く
    # 解が整数でない場合や一意に定まらない場合は "miss" を返す
    if c != d:
        x = (a - b*d) // (c - d)
        y = b - x
        if x >= 1 and y >= 1 and (a == c*x + d*y) and (b == x + y):
            return x, y

    return "miss"

# 入力の読み込み
a, b, c, d = map(int, input().split())

result = estimate_animals(a, b, c, d)
if result == "miss":
    print("miss")
else:
    print(result[0], result[1])

# utf-8　※入力例ではOK　テストケース通過せず
dat = input().split()

foot_all = int(dat[0])
head_all = int(dat[1])
tsuru = int(dat[2])
kame = int(dat[3])

tsuru_search = foot_all - head_all * tsuru
kame_search = head_all * kame - foot_all

res_tsuru = 0
res_kame = 0

if tsuru_search > 0:
	res_tsuru = tsuru_search/2
elif tsuru_search == 0:
	if tsuru == 1:
		res_tsuru = 1
	else:
		res_tsuru = -1

if kame_search > 0:
	res_kame = kame_search/2
elif kame_search == 0:
	if kame == 1:
		res_kame = 1
	else:
		res_kame = -1
	
if res_tsuru < 1:
	print("miss")
elif res_kame < 1:
	print("miss")
else:
	print(int(res_kame), int(res_tsuru))
	
# B039 雨上がりの道　※テストケース通過せず
# utf-8
def find_accessible_ponds(n, s, ponds):
    amembo_pond = ponds[s-1]  # アメンボがいる水たまりの座標
    accessible_ponds = []

    for i, pond in enumerate(ponds):
        if (amembo_pond[0] <= pond[2] and amembo_pond[2] >= pond[0] and
            amembo_pond[1] <= pond[3] and amembo_pond[3] >= pond[1]):
            accessible_ponds.append(i+1)

    return accessible_ponds

# 入力の解析と処理
n = int(input())
s = int(input())
ponds = []
for _ in range(n):
    x, y, a, b = map(int, input().split())
    ponds.append((x, y, a, b))

accessible_ponds = find_accessible_ponds(n, s, ponds)

# 結果の出力
print('\n'.join(map(str, accessible_ponds)))

# B040 たのしい暗号解読
# 入力値の取得
lines = []
while True:
    try:
        line = input()
        lines.append(line)
    except EOFError:
        break

# 回答方針
# [1] 必要な値を変数/配列化する。置換回数(count), 暗号文(codeText), 暗号ルール(codeRule), アルファベット(alphabet)
# [2] 暗号文を一文字ずつ置換ルールと比較。暗号文文字 = 暗号ルールとなる時の、置換ルールの文字列順を取得
# [3] [2]で取得した番号のアルファベット文字列を取得する。
# [4] [2][3]を暗号文の文字列回数分繰り返す
# [5] [2][3][4]の処理を置換回数(count)回、繰り返す。
# [5]で得られた文字列を表示する

alphabet = "abcdefghijklmnopqrstuvwxyz"
count, codeRule = lines[0].split()
count = int(count)
codeText = lines[1].strip()
decryption = ''

for c in range(count):
    for char in codeText:
        if char == ' ':
            decryption += ' '
            continue
        for n in range(len(codeRule)):
            if char == codeRule[n]:
                decryption += alphabet[n]
    codeText = decryption
    decryption = ''

print(codeText)
'''
最初に、入力を受け取るための処理が行われています。input()関数を使って一行ずつ入力を読み込み、linesリストに格納しています。EOFError例外が発生するまで繰り返します。
次に、アルファベットの文字列や復号に必要な変数を初期化しています。alphabet変数にはアルファベットの文字列が格納されています。count変数には置換回数が、codeRule変数には置換のルールが格納されます。countは整数に変換しています。また、codeText変数には暗号文が格納されます。strip()関数を使って行末の改行文字を削除しています。decryption変数は復号結果を格納するための空の文字列です。
指定された回数だけ復号処理を繰り返します。外側のループはcount回繰り返されます。内側のループでは、暗号文の各文字を一つずつ処理します。文字がスペースの場合は、スペースを復号結果に追加し、次の文字の処理へ進みます。それ以外の場合は、暗号ルールを順番に比較し、一致するルールの位置に対応するアルファベットを復号結果に追加します。
内側のループが終わった後、codeTextを更新して復号結果を反映します。そして、decryptionを空の文字列にリセットします。
最後に、復号された結果を出力します。
このコードでは、与えられた置換回数と置換ルールを使って暗号文を復号する処理が行われます。指定された回数だけ復号処理が繰り返され、最終的な復号結果が出力されます。
'''
--------------------------------------------- B041　※欠番 ◆
# B041 繰り返し模様
# utf-8
K = int(input())  # 繰り返し手順の回数を取得
N = int(input())  # 最初の正方形の辺の長さを取得
s = [list(input()) for _ in range(N)]  # 初期状態の模様を取得

for m in range(K):
    s1 = []  # 新しい模様を生成するためのリスト

    for i in range(N):
        for j in range(N):
            if s[i][j] == '.':
                if j == 0:
                    # 白色の場合は、同じ大きさの白い正方形を生成
                    for k in range(N):
                        s1.append(['.'] * N)
                elif j > 0:
                    # 白色の場合は、同じ大きさの白い正方形を追加
                    for k in range(N):
                        s1[i * N + k][len(s1[i * N + k]):len(s1[i * N + k])] = ['.'] * N
            else:
                if j == 0:
                    # 青色の場合は、元の模様をそのまま追加
                    for k in range(N):
                        s1.append(s[k][:])
                elif j > 0:
                    # 青色の場合は、元の模様を追加
                    for k in range(N):
                        s1[i * N + k][len(s1[i * N + k]):len(s1[i * N + k])] = s[k]

    N *= N  # 新しい模様の辺の長さを更新
    s = s1[:]  # 新しい模様で元の模様を上書き

for row in s1:
    print("".join(row))  # 生成された最終的な模様を出力
'''
入力値の受け取り:
K = int(input()): 繰り返し手順の回数を整数として受け取ります。
N = int(input()): 最初の正方形の辺の長さを整数として受け取ります。
s = [list(input()) for _ in range(N)]: N行の文字列を受け取り、それぞれの文字列をリストに変換して二次元リスト s に格納します。これにより、初期状態の模様が表現されます。

模様の生成と更新のループ:
for m in range(K):: K回の繰り返しを行います。各繰り返しでは、新しい模様が生成されて元の模様と入れ替わります。
s1 = []: 新しい模様を生成するための空のリスト s1 を作成します。

新しい模様の生成:
2重ループを使用して、元の模様を基に新しい模様を生成します。
if s[i][j] == '.':: もし現在の正方形が白色であれば、同じ大きさの白い正方形で置き換えます。
else:: もし現在の正方形が青色であれば、元の模様をそのまま追加します。

新しい模様の更新:
N *= N: 新しい模様の辺の長さを更新します。元の辺の長さの N 倍になります。
s = s1[:]: 生成された新しい模様で元の模様を上書きします。
最終的な模様の出力:

for row in s1: print("".join(row)): 生成された最終的な模様を出力します。各行の文字列を結合して表示します。
このコードは、与えられた繰り返し手順に基づいて模様を生成し、最終的な模様を出力します。初期状態の模様に対して、白色の正方形は同じ大きさの白い正方形で置き換えられ、青色の正方形は元の模様に置き換えられます。
この操作を指定された回数繰り返すことで、最終的な模様が生成されます。
'''

# B042 横入りするネコ
# utf-8
def check_cat(cat_num, M, cat_info, eat_time_info, cat_line):
    # 猫の順番を組み合わせて全パターンを調べる再帰関数
    if len(cat_line) == cat_num:
        cat_M = check_M(cat_num, cat_info, cat_line)
        if cat_M <= M:
            eat_time = check_eat_time(cat_num, cat_info, cat_line)
            eat_time_info.add(eat_time)
    else:
        for i in range(cat_num):
            if i + 1 not in cat_line:
                new_cat_line = cat_line.copy()
                new_cat_line.append(i + 1)
                check_cat(cat_num, M, cat_info, eat_time_info, new_cat_line)


def check_M(cat_num, cat_info, cat_line):
    # 各猫の不満度の合計を計算する関数
    cat_M = [0] * cat_num
    cat_line_info = [0] * cat_num
    sum_cat_M = 0

    for index, value in enumerate(cat_line):
        cat_line_info[index] = value

    for i in range(1, cat_num):
        for j in range(i):
            if cat_line_info[i] < cat_line_info[j]:
                cat_M[cat_line_info[i] - 1] += 1

    for i in range(cat_num):
        sum_cat_M += cat_M[i] * cat_info[i][1]

    return sum_cat_M


def check_eat_time(cat_num, cat_info, cat_line):
    # 各猫の食事時間の合計を計算する関数
    eat_time = 0
    eat_time_sum = 0
    cat_line_info = [0] * cat_num

    for index, value in enumerate(cat_line):
        cat_line_info[index] = value

    for i in range(cat_num):
        eat_time += eat_time_sum + cat_info[cat_line_info[i] - 1][0]
        eat_time_sum += cat_info[cat_line_info[i] - 1][0]

    return eat_time


cat_num, M = map(int, input().split())

cat_info = []
for _ in range(cat_num):
    cat_info.append(list(map(int, input().split())))

eat_time_info = set()
cat_line = []

check_cat(cat_num, M, cat_info, eat_time_info, cat_line)

min_eat_time = min(eat_time_info)

print(min_eat_time)
'''
check_cat関数:
引数:
cat_num: 猫の数
M: 許容される不満度の合計
cat_info: 猫の情報を格納した2次元リスト
eat_time_info: 結果として得られる食事時間の集合
cat_line: 現在の猫の順番のリスト
再帰的に全ての猫の順番の組み合わせをチェックし、条件を満たす場合に食事時間を計算して集合に追加します。
まだ順番が割り当てられていない猫に対して順番を割り当てて再帰呼び出しを行います。

check_M関数:
引数:
cat_num: 猫の数
cat_info: 猫の情報を格納した2次元リスト
cat_line: 現在の猫の順番のリスト
各猫の不満度の合計を計算して返します。
猫の順番が入れ替わった場合、その猫より前にいる猫の不満度を増やします。

check_eat_time関数:
引数:
cat_num: 猫の数
cat_info: 猫の情報を格納した2次元リスト
cat_line: 現在の猫の順番のリスト
各猫の食事時間の合計を計算して返します。
猫の順番に従って、各猫の食事時間を計算し合計します。

メイン部分:
ユーザーからの入力を受け取り、cat_numとMに代入します。
cat_infoリストを作成し、猫の情報を格納します。
結果の食事時間を格納するための集合eat_time_infoと、現在の猫の順番を格納するためのリストcat_lineを初期化します。
check_cat関数を呼び出して、全ての猫の順番の組み合わせをチェックします。
得られた食事時間の集合eat_time_infoから最小値を取得し、結果を出力します。
このコードは、猫の順番の組み合わせを全て試す方法を用いて最適解を求める力まで持っています。
ただし、猫の数が増えると組み合わせの数が爆発的に増えるため、実行時間が長くなる可能性があります。
より効率的なアルゴリズムを検討する必要があるかもしれません。
'''

# B043 ねずみ小僧
# utf-8
# 町の大きさを入力
H, W = map(int, input().split())

# ねずみ小僧の初期位置を入力
h0, w0 = map(int, input().split())

# 町の各家の状態を入力
houses = [list(input().strip()) for _ in range(H)]

# ねずみ小僧の初期設定
axis = 1  # 初期方向は北を示す
num = 1  # 移動回数の初期値
x, y = h0 - 1, w0 - 1  # 座標の初期値（0-indexedに変換）

# ねずみ小僧の移動ループ
while num <= 2000 and 0 <= x < H and 0 <= y < W:
    num += 1
    
    # 現在の座標の家の状態に応じて行動を決定
    if houses[x][y] == '.':  # 庶民の家の場合
        houses[x][y] = '*'  # 富豪の家に変更
        if axis == 1:  # 北を向いている場合
            axis = 2  # 東に方向転換
            y += 1
        elif axis == 2:  # 東を向いている場合
            axis = 3  # 南に方向転換
            x += 1
        elif axis == 3:  # 南を向いている場合
            axis = 4  # 西に方向転換
            y -= 1
        elif axis == 4:  # 西を向いている場合
            axis = 1  # 北に方向転換
            x -= 1
    else:  # 富豪の家の場合
        houses[x][y] = '.'  # 庶民の家に変更
        if axis == 1:  # 北を向いている場合
            axis = 4  # 西に方向転換
            y -= 1
        elif axis == 2:  # 東を向いている場合
            axis = 1  # 北に方向転換
            x -= 1
        elif axis == 3:  # 南を向いている場合
            axis = 2  # 東に方向転換
            y += 1
        elif axis == 4:  # 西を向いている場合
            axis = 3  # 南に方向転換
            x += 1

# 町の最終状態を出力
for row in houses:
    print("".join(row))
'''
最初の部分では、入力値を受け取り、必要な変数を初期化しています。

hとwには町の大きさが格納されます。
xとyにはねずみ小僧の初期位置が格納されます。
sは町の状態を表す二次元リストです。
axisはねずみ小僧の向いている方向を表す変数で、初期値は1です（北を意味します）。
numはねずみ小僧の移動回数を表す変数で、初期値は1です。
xとyは座標のインデックスとして使用されるため、1から0始まりのインデックスに変換しています。

while文からはねずみ小僧の移動ループです。ループは以下の条件を満たす間、繰り返されます:

numが2000以下であり、ねずみ小僧が町の範囲内にいること。
xが0以上h未満、yが0以上w未満であること。
ループ内の処理は次のようになっています:

s[x][y]が'.'（庶民の家）の場合、その家を'*'（富豪の家）に変えます。
ねずみ小僧の向き(axis)に応じて、座標を更新します。向きが1の場合、y座標を増やし、向きが2の場合、x座標を増やします。向きが3の場合、y座標を減らし、向きが4の場合、x座標を減らします。
s[x][y]が'*'（富豪の家）の場合、その家を'.'（庶民の家）に変えます。
ねずみ小僧の向き(axis)に応じて、座標を更新します。向きが1の場合、y座標を減らし、向きが2の場合、x座標を減らします。向きが3の場合、y座標を増やし、向きが4の場合、x座標を増やします。
移動が終了すると、ねずみ小僧が通過した後の町の状態が得られます。

最後の部分では、町の状態を出力しています。二次元リストsの各行を文字列に変換し、改行なしで出力します。
'''

# B044 爆弾ゲーム　※テストケース通過せず
# utf-8
def is_enemy_defeated(board):
    H, W = len(board), len(board[0])

    # 盤面を拡張して周囲を壁で囲む
    extended_board = ['#' * (W + 2)]
    for row in board:
        extended_board.append('#' + row + '#')
    extended_board.append('#' * (W + 2))

    bombs = []  # 爆弾の位置と火力を格納するリスト

    # 爆弾の位置と火力を取得
    for i in range(1, H + 1):
        for j in range(1, W + 1):
            if extended_board[i][j].isdigit():
                bombs.append((i, j, int(extended_board[i][j])))

    # 爆弾を順に試し、爆風の範囲にいる敵を倒せるか判定
    for bomb in bombs:
        i, j, power = bomb
        # 上方向の爆風
        for k in range(1, power + 1):
            if extended_board[i - k][j] == '#':
                break
            if extended_board[i - k][j] == 'X':
                extended_board[i - k] = extended_board[i - k][:j] + '.' + extended_board[i - k][j+1:]

        # 下方向の爆風
        for k in range(1, power + 1):
            if extended_board[i + k][j] == '#':
                break
            if extended_board[i + k][j] == 'X':
                extended_board[i + k] = extended_board[i + k][:j] + '.' + extended_board[i + k][j+1:]

        # 左方向の爆風
        for k in range(1, power + 1):
            if extended_board[i][j - k] == '#':
                break
            if extended_board[i][j - k] == 'X':
                extended_board[i] = extended_board[i][:j - k] + '.' + extended_board[i][j - k + 1:j] + 'X' + extended_board[i][j + 1:]

        # 右方向の爆風
        for k in range(1, power + 1):
            if extended_board[i][j + k] == '#':
                break
            if extended_board[i][j + k] == 'X':
                extended_board[i] = extended_board[i][:j] + 'X' + extended_board[i][j + 1:j + k] + '.' + extended_board[i][j + k + 1:]

    # 盤面上に敵(X)が残っているか判定
    for i in range(1, H + 1):
        if 'X' in extended_board[i]:
            return "NO"

    return "YES"


def main():
    H, W = map(int, input().split())
    board = [input() for _ in range(H)]
    result = is_enemy_defeated(board)
    print(result)


if __name__ == "__main__":
    main()

# B045 計算ドリル
# utf-8
import random

# 入力を取得し、足し算の問題数と引き算の問題数を設定する
setting = input()
set_data = setting.split()
plus = int(set_data[0])
minus = int(set_data[1])

problems = []  # 問題を格納するリスト

# 足し算の問題を生成
while len(problems) < plus:
    left = random.randint(0, 99)  # 0から99までのランダムな左辺を生成
    right = random.randint(0, 99 - left)  # 左辺以下の範囲でランダムな右辺を生成
    problem = f"{left} + {right} ="  # 問題文を作成
    if problem not in problems:  # 重複しない問題文の場合にリストに追加
        problems.append(problem)

# 引き算の問題を生成
while len(problems) < plus + minus:
    left = random.randint(0, 99)  # 0から99までのランダムな被減数を生成
    right = random.randint(0, left)  # 被減数以下の範囲でランダムな減数を生成
    problem = f"{left} - {right} ="  # 問題文を作成
    if problem not in problems:  # 重複しない問題文の場合にリストに追加
        problems.append(problem)

random.shuffle(problems)  # 問題の順序をランダムにシャッフル

# 問題を出力
for problem in problems:
    print(problem)
'''
このコードでは、random モジュールを使用してランダムな数値を生成しています。足し算の問題を生成する際には、0から99までのランダムな左辺と、左辺以下の範囲でランダムな右辺を生成し、問題文を作成しています。
同様に、引き算の問題を生成する際には、0から99までのランダムな被減数と、被減数以下の範囲でランダムな減数を生成して問題文を作成しています。
問題文の重複を防ぐため、生成した問題文が既にリストに存在するかをチェックしています。存在しない場合にのみリストに追加されます。
最後に、random.shuffle() 関数を使用して問題の順序をランダムにシャッフルしています。最終的に生成された問題は、for ループを使用して一つずつ出力されます。
このコードによって、与えられた条件を満たし、効率的かつランダムな問題のドリルが生成されます。
'''

# B046 街の距離
# utf-8
import math

class B046:
    def __init__(self, rounds):
        # 同心円の数
        self.rounds = int(rounds)
        # 現在位置の同心円番号
        self.now_around = None
        # 現在位置の方角
        self.now_direction = None
        # 目的地の同心円番号
        self.purpose_around = None
        # 目的地の方角
        self.purpose_direction = None
        # 最短距離
        self.distance = None

    def set_now_position_info(self, info):
        # 現在位置の同心円番号と方角を設定
        self.now_around, self.now_direction = info.split()

    def set_purpose_position_info(self, info):
        # 目的地の同心円番号と方角を設定
        self.purpose_around, self.purpose_direction = info.split()

    def calculation_shortest_distance(self):
        # 方向の組み合わせパターン
        check_direction = self.now_direction + self.purpose_direction
        one_line_direction = ["NS", "SN", "WE", "EW", "NN", "SS", "WW", "EE"]

        if check_direction in one_line_direction:
            if self.now_direction == self.purpose_direction:
                # 同じ直線上にいる場合は、直線距離のみ
                self.distance = abs(int(self.now_around) - int(self.purpose_around)) * 100
            else:
                # 直線上にいる場合は、同心円同士の距離を加算
                self.distance = (int(self.now_around) + int(self.purpose_around)) * 100
        else:
            if int(self.now_around) < int(self.purpose_around):
                # 短い方向に半周し、直線距離を加算
                self.distance = abs(int(self.now_around) - int(self.purpose_around)) * 100 + math.pi * 100 * int(self.now_around) / 2
            elif int(self.now_around) > int(self.purpose_around):
                # 短い方向に半周し、直線距離を加算
                self.distance = abs(int(self.now_around) - int(self.purpose_around)) * 100 + math.pi * 100 * int(self.purpose_around) / 2
            else:
                # 同心円上の同じ位置にいる場合は、半周距離のみ
                self.distance = math.pi * 100 * int(self.purpose_around) / 2

        return self.distance

N = input().strip()  # 同心円の数を入力
B046 = B046(N)  # B046クラスのインスタンスを生成
B046.set_now_position_info(input().strip())  # 現在位置情報を入力
B046.set_purpose_position_info(input().strip())  # 目的地情報を入力
B046.calculation_shortest_distance()  # 最短距離を計算
print("{:.9f}".format(B046.distance))  # 最短距離を表示
'''
このコードは、同心円状の道路が配置された環境で、現在位置と目的地の情報から最短距離を計算しています。
B046 クラスは、最短距離の計算と情報の設定を行うためのメソッドを提供します。インスタンス化された B046 オブジェクトを使用して、現在位置情報と目的地情報を設定し、最短距離を計算します。
set_now_position_info メソッドは、現在位置情報を設定します。文字列として渡された情報を分割して、現在の同心円位置と方角を設定します。
set_purpose_position_info メソッドは、目的地情報を設定します。文字列として渡された情報を分割して、目的地の同心円位置と方角を設定します。
calculation_shortest_distance メソッドは、現在位置と目的地から最短距離を計算します。まず、現在位置と目的地の方角の組み合わせをチェックし、直線上に位置する場合と曲線上に位置する場合で処理を分岐します。最短距離を計算して distance 属性に代入します。
メインの処理部分では、入力から同心円の数、現在位置情報、目的地情報を受け取り、B046 クラスのインスタンスを生成し、必要な情報を設定します。最後に最短距離を計算して表示します。
'''

# B047 ホームポジション　※テストケース通過しない
# utf-8
class Point:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

def is_miss_type(now, prev):
    return prev.y == now.y and ((prev.x == 4 and now.x == 5) or (now.x == 4 and prev.x == 5))

def is_neighbor(now, prev):
    return (now.y == prev.y and (prev.x - 1 <= now.x <= prev.x + 1)) or (now.x == prev.x and (prev.y - 1 <= now.y <= prev.y + 1))

def solve(input_str, point_map):
    count = 0
    mode = False
    prev = Point(-1, -1)
    for c in input_str:
        p = point_map[c]
        if mode:
            if is_neighbor(p, prev):
                count += 1
            else:
                mode = False
        else:
            if is_miss_type(p, prev):
                count += 1
                mode = True
        prev = p
    return count

def parse_input(input_str):
    lines = input_str.strip().split("\n")
    s = lines[0]
    return s

def format_output(output):
    return str(output)

def main():
    point_map = {}
    table = [
        "qwertyuiop",
        "asdfghjkl",
        "zxcvbnm"
    ]

    for y in range(len(table)):
        line = table[y]
        for x in range(len(line)):
            c = line[x]
            point_map[c] = Point(x, y)

    input_str = input()
    s = parse_input(input_str)

    output = solve(s, point_map)
    formatted_output = format_output(output)
    print(formatted_output)

main()

# B048 理想のビンゴ
# utf-8
N, M = map(int, input().split())
bingo_card = []  # ビンゴカードの盤面を格納するリスト
bingo_count = 0  # ビンゴ数をカウントする変数

# ビンゴカードの盤面を入力として受け取り、リストに格納する
for _ in range(N):
    row = list(map(int, input().split()))
    bingo_card.append(row)

# M-1回の数字の呼び出しを処理する
for _ in range(M - 1):
    called_number = int(input())
    for i in range(N):
        for j in range(N):
            if called_number == bingo_card[i][j]:
                bingo_card[i][j] = 0  # 呼び出された数字を0に置き換える

# 行のビンゴをチェック
for i in range(N):
    if bingo_card[i].count(0) == N:
        bingo_count += 1

columns = []  # 列ごとの数字を格納するリスト
for i in range(N):
    column = []
    for j in range(N):
        column.append(bingo_card[j][i])
    columns.append(column)
    if column.count(0) == N:
        bingo_count += 1

diagonal = []  # 対角線の数字を格納するリスト
for i in range(N):
    diagonal.append(bingo_card[i][i])

reverse_diagonal = []  # 逆対角線の数字を格納するリスト
for i in range(1, N + 1):
    reverse_diagonal.append(bingo_card[-i][i - 1])

lines = [diagonal, reverse_diagonal]  # 対角線と逆対角線をまとめたリスト

# 対角線と逆対角線のビンゴをチェック
for line in lines:
    if line.count(0) == N:
        bingo_count += 1

extra_numbers = []  # ビンゴの候補となる数字を格納するリスト

# ビンゴの候補となる数字を抽出
for i in range(N):
    if bingo_card[i].count(0) == N - 1:
        for j in range(N):
            if bingo_card[i][j] != 0:
                extra_numbers.append(bingo_card[i][j])

for i in range(N):
    if columns[i].count(0) == N - 1:
        for j in range(N):
            if columns[i][j] != 0:
                extra_numbers.append(columns[i][j])

for line in lines:
    if line.count(0) == N - 1:
        for j in range(N):
            if line[j] != 0:
                extra_numbers.append(line[j])

frequency = []  # ビンゴの候補数字の出現回数を格納するリスト

# ビンゴの候補数字の出現回数を計算し、最大のビンゴ数を更新
if len(extra_numbers) > 0:
    for i in range(len(extra_numbers)):
        frequency.append(extra_numbers.count(extra_numbers[i]))
    bingo_count += max(frequency)

print(bingo_count)  # 最大のビンゴ数を出力
'''
入力の受け取りと初期化:
N, M = map(int, input().split()): ビンゴカードのサイズと呼び出し回数を受け取ります。
bingo_card = []: ビンゴカードの盤面を格納するための空のリストを作成します。
bingo_count = 0: ビンゴ数をカウントする変数を初期化します。

ビンゴカードの入力と数字の呼び出し処理:
for _ in range(N): ...: ビンゴカードの盤面を入力として受け取り、リスト bingo_card に格納します。
for _ in range(M - 1): ...: 呼び出された数字を処理し、ビンゴカード上の該当する数字を0に置き換えます。

行・列・対角線のビンゴをチェック:
行のビンゴをチェックし、ビンゴ数をカウントします。
列ごとの数字を格納するリスト columns を作成し、列のビンゴをチェックし、ビンゴ数をカウントします。
対角線と逆対角線の数字を格納するリスト diagonal と reverse_diagonal を作成し、対角線と逆対角線のビンゴをチェックし、ビンゴ数をカウントします。

追加のビンゴの候補数字を抽出:
ビンゴの候補となる数字を格納するリスト extra_numbers を作成し、行・列・対角線・逆対角線のビンゴの候補数字を抽出します。

追加のビンゴ数の計算:
ビンゴの候補数字が存在する場合、その出現回数を計算し、最大のビンゴ数を更新します。

結果の出力:
最大のビンゴ数を出力します。
このコードでは、ビンゴカードの盤面と呼び出された数字を処理し、行・列・対角線・逆対角線のビンゴをチェックして最大のビンゴ数を求めるアルゴリズムが実装されています。ビンゴ数の計算は、ビンゴの候補数字が存在する場合にのみ行われます。最終的な結果は、最大のビンゴ数が出力されます。
'''

# B049 ◆
# B050 有効なチケット
# utf-8
# 入力の受け取りと制約のチェック
N = int(input())  # チケットの枚数
if not 1 <= N <= 100:
    raise ValueError("Nの値が制約を満たしていません")

S = input()  # 暗号チケットの指定された文字列
if not 1 <= len(S) <= 10 or not S.islower():
    raise ValueError("Sの値が制約を満たしていません")

valid_tickets = []
for _ in range(N):
    T = input()  # チケットに書かれた文字列
    if not 1 <= len(T) <= 20 or not T.islower():
        raise ValueError("Tの値が制約を満たしていません")
    
    if S in T:  # SがTに含まれる場合は有効
        valid_tickets.append("valid")
    elif any(S in T[:i] + T[i+1:] for i in range(len(T))):  # Tから1文字を削除してSが含まれる場合は有効
        valid_tickets.append("valid")
    else:  # 上記の条件に該当しない場合は無効
        valid_tickets.append("invalid")

# 有効/無効なチケットを出力
for ticket in valid_tickets:
    print(ticket)
'''
入力の受け取りと制約のチェック

N = int(input()): チケットの枚数を整数として受け取ります。
S = input(): 暗号チケットの指定された文字列を受け取ります。
制約を満たしていない場合は、ValueErrorを発生させます。
有効なチケットの判定

valid_tickets = []: 有効なチケットを格納するリストを初期化します。
for _ in range(N):: チケットの枚数分だけループを行います。
T = input(): チケットに書かれた文字列を受け取ります。
if S in T:: もし指定された文字列 S がチケット文字列 T に含まれる場合は、有効なチケットとして判定します。
elif any(S in T[:i] + T[i+1:] for i in range(len(T))):: それ以外の場合、チケット文字列 T から1文字ずつ削除した文字列に指定された文字列 S が含まれるかどうかを判定します。任意のインデックス i に対して、T[:i] + T[i+1:] で T の i 番目の文字を削除した文字列が得られます。
valid_tickets.append("valid"): 上記のいずれかの条件に該当する場合は、有効なチケットとしてリストに追加します。
else: valid_tickets.append("invalid"): 上記の条件に該当しない場合は、無効なチケットとしてリストに追加します。
有効/無効なチケットの出力

for ticket in valid_tickets: print(ticket): 有効/無効なチケットのリストを出力します。
'''
--------------------------------------------- B051　※欠番 ◆
# B051 ◆
# B052 積もる粒子
# utf-8
def location_selector(x, y, field, H, W):
    # 現在の地点の高さ
    location_num = field[y][x]
    
    # 隣接地点の高さの初期値を無限大で設定
    kita = float("inf")
    higashi = float("inf")
    minami = float("inf")
    nishi = float("inf")
    
    # 移動先の選択
    for _ in range(max(max(field))):
        if y >= 1:
            kita = field[y - 1][x]  # 北の地点の高さ
        if x < int(W) - 1:
            higashi = field[y][x + 1]  # 東の地点の高さ
        if y < int(H) - 1:
            minami = field[y + 1][x]  # 南の地点の高さ
        if x >= 1:
            nishi = field[y][x - 1]  # 西の地点の高さ
            
        # 高さの比較を行い、移動先を決定
        if kita < location_num:
            y -= 1  # 北に移動
        elif higashi < location_num:
            x += 1  # 東に移動
        elif minami < location_num:
            y += 1  # 南に移動
        elif nishi < location_num:
            x -= 1  # 西に移動
        else:
            break  # 移動できる場所がない場合、ループを終了
    
    return x, y
    
# 入力の受け取り
H, W, N = map(int, input().split())
particle = []
field = [[0 for _ in range(W)] for _ in range(H)]
for _ in range(N):
    x, y = map(int, input().split())
    particle.append([x, y])

# 粒子を順番に落として地形を形成する
for i in range(N):
    x = particle[i][0] - 1
    y = particle[i][1] - 1
    x, y = location_selector(x, y, field, H, W)
    field[y][x] += 1

# 地形の高さを出力
for i in range(H):
    print(' '.join(map(str, field[i])))

# B053 表の自動作成
# utf-8
import numpy as np

# 行数と列数を入力から取得
H, W = input().rstrip().split(' ')

# 表を格納するためのnumpy配列を作成し、初期値を0で初期化
table = np.zeros((2, int(W)))

# オートフィルを適用する必要がある残りの行数と列数を計算
row_left = int(H) - 2
col_left = int(W) - 2

# 2行目から始まる各行について、入力を受け取り、オートフィルを適用して行を完成させる
for h in range(2):
    retu = input().rstrip().split(' ')
    retu = np.array(retu)
    retu = retu.astype(np.int64)
    
    # 行の初項と公差を計算
    sa = retu[1] - retu[0]
    
    # オートフィルを適用して行を完成させる
    for i in range(int(W) - col_left, int(W)):
        retu = np.append(retu, retu[i - 1] + sa)
    
    # 行を表に格納
    table[h, :] = retu

# 2行目以降の行について、前の行との差からオートフィルを適用して行を完成させる
div = table[1] - table[0]
for j in range(int(H) - row_left, int(H)):
    table = np.vstack([table, table[j - 1] + div])

# 最終的な表をリスト形式に変換し、各要素をスペース区切りで出力
table = list(table)
for i in range(int(H)):
    for j in range(int(W)):
        if j == int(W) - 1:
            print(int(table[i][j]), end='')
        else:
            print(int(table[i][j]), end=' ')
    print()
'''
最初に、入力から表のサイズである行数と列数を取得します。表を格納するためのnumpy配列を作成し、初期値として全ての要素を0で初期化します。
行数と列数から、オートフィルを適用する必要がある残りの行数と列数を計算します。2行目から始まる各行について、入力を受け取り、その数列の初項と公差を計算します。そして、オートフィルを適用して行を完成させます。
2行目以降の行について、前の行との差からオートフィルを適用して行を完成させます。最終的な表をリスト形式に変換し、各要素をスペース区切りで出力します。
'''

# B054 不思議な足し算
# utf-8
# 入力の読み込み
s1, s2 = input().split()
s1 = list(s1)
s2 = list(s2)

# 文字列を数値に変換
for i in range(len(s1)):
    if s1[i] == "A":
        s1[i] = '0'
    elif s1[i] == "B":
        s1[i] = '1'
    elif s1[i] == "C":
        s1[i] = "2"
    elif s1[i] == "D":
        s1[i] = "3"
    else:
        s1[i] = "4"

for i in range(len(s2)):
    if s2[i] == "A":
        s2[i] = '0'
    elif s2[i] == "B":
        s2[i] = '1'
    elif s2[i] == "C":
        s2[i] = "2"
    elif s2[i] == "D":
        s2[i] = "3"
    else:
        s2[i] = "4"

# 数値に変換
s1 = int(''.join(map(str, s1)))
s2 = int(''.join(map(str, s2)))

# 5進数から10進数への変換と足し算
ss1 = int(str(s1), 5)
ss2 = int(str(s2), 5)
b = ss1 + ss2

# 10進数から5進数への変換
def base5int(value):
    if int(value / 5):
        return base5int(int(value / 5)) + str(value % 5)
    return str(value % 5)

d = base5int(b)
d = list(d)

# 数値を文字列に変換
for i in range(len(d)):
    if d[i] == "0":
        d[i] = 'A'
    elif d[i] == "1":
        d[i] = 'B'
    elif d[i] == "2":
        d[i] = "C"
    elif d[i] == "3":
        d[i] = "D"
    else:
        d[i] = "E"

# 結果の出力
print(''.join(map(str, d)))
'''
入力文字列 s1 と s2 をスペースで分割して読み込みます。その後、文字列をリストに変換します。
文字列リスト内の各文字を適切な数値に変換します。"A" から "E" までの文字はそれぞれ "0" から "4" の数値に対応しています。
文字列リストを結合し、int() を使用して整数に変換します。それぞれの数値を 5 進数から 10 進数に変換し、足し合わせます。
base5int() 関数を使用して、10 進数の数値 b を 5 進数に逆変換します。変換後の数値をリストに変換し、最後に文字列リストを結合して PAIZA 表記の数値を得ます。最終結果を出力します。
'''

# B055 ◆
# B056 リズムゲームの分析
# utf-8
def check_sharp_pattern(N, sharp, v):
    # "#" のパターンが正しいかをチェックする関数
    # sharp 列目が "+" であり、他の列が "-" であるかを確認する
    for j in range(N):
        if v[j] != ('+' if sharp == j else '-'):
            return False
    return True

def calculate_max_combo(N, M, data):
    max_combo = 0
    prev = False
    prev_sharp = False
    combo = 0
    for i in range(M):
        d = list(data[i][0])  # 譜面データ
        p = list(data[i][1])  # プレイデータ

        sharp = -1
        for j in range(N):
            if d[j] == '#':
                sharp = j
                break

        if sharp >= 0:
            # "#" のパターンの場合
            if check_sharp_pattern(N, sharp, p):
                if prev:
                    combo += 1
                elif not prev_sharp:
                    combo = 1
                    prev = True
                if max_combo < combo:
                    max_combo = combo
            else:
                prev = False
            prev_sharp = True
        else:
            # "#" のパターンでない場合
            if d == p:
                if prev:
                    combo += 1
                else:
                    combo = 1
                    prev = True
                if max_combo < combo:
                    max_combo = combo
            else:
                prev = False
            prev_sharp = False

    return max_combo

# 入力の読み込み
N, M = map(int, input().split())
data = []
for _ in range(M):
    line = input().split()
    data.append((line[0], line[1]))

# 最大コンボ数の計算
max_combo = calculate_max_combo(N, M, data)

# 結果の出力
print(max_combo)
'''
check_sharp_pattern 関数
sharp 列目が "+" であり、他の列が "-" であるかを確認する関数です。
引数としてボタンの数 N、sharp 列目のインデックス、譜面データのリスト v を受け取ります。
v の各要素をチェックし、sharp 列目の要素が "+" であり、他の列の要素が "-" であるかを確認します。
正しいパターンであれば True を、そうでなければ False を返します。

calculate_max_combo 関数
最大コンボ数を計算する関数です。
引数としてボタンの数 N、タイミングの数 M、ログデータのリスト data を受け取ります。
変数 max_combo に最大コンボ数を格納するための初期値 0 を設定します。
変数 prev は直前のタイミングでコンボが続いているかを示すフラグで、初期値は False です。
変数 prev_sharp は直前のタイミングで "#" のパターンが出現したかを示すフラグで、初期値も False です。
ループを通じて各タイミングを処理し、最大コンボ数を更新していきます。
data の各要素に対して、譜面データとプレイデータを取得します。
譜面データに "#" が含まれるかを確認し、含まれる場合と含まれない場合で処理を分岐します。
"#" のパターンの場合は、check_sharp_pattern 関数を用いて正しいパターンであるかをチェックします。
正しいパターンであればコンボ数を更新し、最大コンボ数を更新します。
"#" のパターンでない場合は、譜面データとプレイデータを比較し、一致していればコンボ数を更新し、最大コンボ数を更新します。
各タイミングの処理が終わったら最大コンボ数を返します。

入力の読み込み
最初にボタンの数 N とタイミングの数 M を入力から読み込みます。
その後、M 行分のループを行い、ログデータを読み込みます。
calculate_max_combo 関数の呼び出しと結果の出力
calculate_max_combo 関数を呼び出し、ボタンの数 N、タイミングの数 M、ログデータのリストを渡します。
返された最大コンボ数を出力します。
'''

# B057 回転寿司　※入力例2,3でNG
# utf-8
def simulate_sushi_eating(L, sushi_positions, seat_positions):
    sushi_positions.sort()
    seat_positions.sort()

    max_time = 0
    for seat in seat_positions:
        min_distance = L
        for sushi in sushi_positions:
            distance = (sushi - seat) % L
            min_distance = min(min_distance, distance)

        eating_time = min_distance + 10
        max_time = max(max_time, eating_time)

    return max_time


L, N, M = map(int, input().split())
sushi_positions = list(map(int, input().split()))
seat_positions = list(map(int, input().split()))

result = simulate_sushi_eating(L, sushi_positions, seat_positions)

print(result)

# B058 ◆
# B059 占領区域
# utf-8
def calculate_occupation(H, W, N, countries):
    # マップの初期化
    map = [['?' for _ in range(W)] for _ in range(H)]

    # 各国の占領区域を計算
    for i in range(N):
        a, x, y = countries[i]
        x, y = x - 1, y - 1  # 座標を0-indexedに変換
        map[y][x] = a

    # 各土地からの最短距離を計算し、占領国を更新
    for y in range(H):
        for x in range(W):
            if map[y][x] != '?':
                continue
            min_distance = float('inf')
            occupying_country = ''
            for i in range(N):
                a, cx, cy = countries[i]
                cx, cy = cx - 1, cy - 1  # 座標を0-indexedに変換
                distance = abs(cx - x) + abs(cy - y)
                if distance < min_distance:
                    min_distance = distance
                    occupying_country = a
                elif distance == min_distance:
                    occupying_country = '?'  # 距離が同じ場合は境界上の土地
            map[y][x] = occupying_country

    # 結果の出力
    for row in map:
        print(''.join(row))


# 入力の読み込み
H, W, N = map(int, input().split())
countries = []
for _ in range(N):
    # 各国の情報を読み込む
    a, x, y = input().split()
    countries.append((a, int(x), int(y)))

# 占領区域の計算と出力
calculate_occupation(H, W, N, countries)
'''
このプログラムは、ストラテジーゲームのマップ上で各国の占領している区域を計算し、表示するためのものです。
calculate_occupation 関数を定義します。この関数は、マップの高さ H、幅 W、国の数 N、各国の情報 countries を受け取り、占領区域を計算します。
マップの初期化を行います。map という二次元リストを作成し、マップの全ての要素を '?' で初期化します。
各国の占領区域を計算します。countries リストに格納された各国の情報を取り出し、座標を0-indexedに変換してマップ上の対応する位置に占領国の頭文字をセットします。
各土地からの最短距離を計算し、占領国を更新します。マップ上の各土地について、まだ占領国がセットされていない土地に対して、各国の首都との距離を計算します。
最も距離が近い国を占領国として設定し、距離が同じ場合は境界上の土地として '?' をセットします。
最終的な占領区域を出力します。マップの各行を連結して表示し、各土地がどの国に占領されているかを表示します。
メインの処理として、入力を読み込んでマップの情報を取得し、calculate_occupation 関数を呼び出して占領区域の計算と表示を行います。
'''

# B060 サイコロころがし
# utf-8
N, H, W = list(map(int, input().split()))  # 入力値を取得
sy, sx = list(map(int, input().split()))  # 初期位置を取得
s = input()  # 移動方法を取得
ij = [[0 for i in range(W)] for j in range(H)]  # 旗のマス目の初期化

class Roll:
    def __init__(self, sx, sy):
        self.sx, self.sy, self.stamp, self.u, self.d, self.l, self.r, self.t = sx, sy, 6, 2, 5, 3, 4, 1
    '''
        # サイコロの初期位置と面の初期値を設定する
    self.sx, self.sy = sx, sy  # サイコロの現在位置のx座標とy座標
    self.stamp = 6  # サイコロの現在の面の値
    self.u = 2  # サイコロの上面の値
    self.d = 5  # サイコロの下面の値
    self.l = 3  # サイコロの左面の値
    self.r = 4  # サイコロの右面の値
    self.t = 1  # サイコロの手前面の値
    '''

    def up(self):
        self.sy -= 1
        tmp = self.t
        self.t = self.d
        self.d = self.stamp
        self.stamp = self.u
        self.u = tmp
        return self.stamp

    def down(self):
        self.sy += 1
        tmp = self.t
        self.t = self.u
        self.u = self.stamp
        self.stamp = self.d
        self.d = tmp
        return self.stamp

    def left(self):
        self.sx -= 1
        tmp = self.t
        self.t = self.r
        self.r = self.stamp
        self.stamp = self.l
        self.l = tmp
        return self.stamp

    def right(self):
        self.sx += 1
        tmp = self.t
        self.t = self.l
        self.l = self.stamp
        self.stamp = self.r
        self.r = tmp
        return self.stamp

dice = Roll(sx, sy)  # サイコロを作成し初期位置を設定
ij[sy - 1][sx - 1] = dice.stamp  # 初期位置のマスにサイコロの目の値を設定
for i in s:
    if i == 'U':
        ij[dice.sy - 1][dice.sx - 1] = dice.up()  # 上方向に移動し、そのマスにサイコロの目の値を設定
    if i == 'D':
        ij[dice.sy - 1][dice.sx - 1] = dice.down()  # 下方向に移動し、そのマスにサイコロの目の値を設定
    if i == 'L':
        ij[dice.sy - 1][dice.sx - 1] = dice.left()  # 左方向に移動し、そのマスにサイコロの目の値を設定
    if i == 'R':
        ij[dice.sy - 1][dice.sx - 1] = dice.right()  # 右方向に移動し、そのマスにサイコロの目の値を設定

# 旗のマス目を出力
for i in ij:
    rs = [str(n) for n in i]
    print(" ".join(rs))
'''
まず、入力から回転する回数N、旗のマス目の縦の大きさH、旗のマス目の横の大きさWが取得されます。また、最初にサイコロを置く位置の行syと列sxも取得されます。
その後、文字列sが取得され、これはサイコロの移動方法を表しています。具体的には、"U"は上方向、"D"は下方向、"L"は左方向、"R"は右方向の移動を示します。
次に、H行W列の二次元リストijが作成されます。このリストは、旗の各マスの色を表します。初期状態ではすべてのマスが0（白色）で初期化されます。
そして、Rollクラスが定義されます。このクラスはサイコロの動作を管理します。サイコロの現在位置と各面の値を保持します。
クラスには、上方向への移動を表すupメソッド、下方向への移動を表すdownメソッド、左方向への移動を表すleftメソッド、右方向への移動を表すrightメソッドが定義されています。
これらのメソッドは、サイコロの位置と面の値を適切に変更し、移動後の面の値を返します。
Rollクラスのインスタンスdiceが作成され、初期位置であるsy行sx列のマスにサイコロの面の値（stamp）が設定されます。
その後、文字列sを順に処理し、各移動に応じてサイコロを移動させます。移動方法に従ってサイコロの位置と面の値が変更され、ijリストの対応するマスに面の値が記録されます。
最後に、ijリストの各行を順に出力します。各行はスペースで区切られた数字のシーケンスとなり、それぞれの数字は旗の各マスの色を表します。この出力によって、シミュレーション後の旗のデザインが表示されます。
'''
--------------------------------------------- B061　※欠番 ◆
# B061 福袋詰め
# utf-8
import itertools

def count_lucky_bags(S, N, values):
    '''
    福袋に詰める商品の組み合わせの数を計算する関数

    Parameters:
        S (int): 福袋に詰める商品の価値の合計の最小値
        N (int): 福袋に詰める候補となる商品の数
        values (list): 商品の価値を表す整数のリスト

    Returns:
        int: 福袋に詰める商品の組み合わせの数
    '''
    count = 0
    # 商品の個数で組み合わせを生成
    for i in range(1, N+1):
        for combination in itertools.combinations(values, i):
            # 組み合わせの値の合計がS以上であるかを確認
            if sum(combination) >= S:
                valid = True
                for j in combination:
                    # 商品を1つ取り除いた場合の値の合計がS未満であるかを確認
                    if sum(combination) - j >= S:
                        valid = False
                        break
                if valid:
                    count += 1

    return count

# 入力の受け取り
S = int(input())
N = int(input())
values = [int(input()) for _ in range(N)]

# 福袋の詰め方の組み合わせの数を計算
result = count_lucky_bags(S, N, values)

# 結果の出力
print(result)
'''
福袋に詰める商品の組み合わせの数を計算するための関数 count_lucky_bags が定義されています。
この関数は、以下の手順で組み合わせの数を計算します。
count_lucky_bags 関数の引数として、福袋に詰める商品の価値の合計の最小値 S、福袋に詰める候補となる商品の数 N、および商品の価値を表す整数のリスト values が与えられます。
初期化: 組み合わせの数をカウントするための変数 count を0で初期化します。
商品の個数ごとの組み合わせ生成: for ループを使用して、商品の個数ごとに組み合わせを生成します。range(1, N+1) の範囲でループし、1つからN個の商品を含む組み合わせを生成します。
組み合わせの条件判定: itertools.combinations を使用して、与えられた商品リスト values から i 個の商品を選んだ組み合わせを生成します。生成された組み合わせの値の合計が S 以上であるかを確認します。
条件を満たす組み合わせの特定: 組み合わせの値の合計が S 以上の場合、さらに個別の商品を1つずつ取り除いた場合の組み合わせの値の合計が S 未満であるかを確認します。この確認を行い、条件を満たす組み合わせを特定します。
条件を満たす組み合わせのカウント: 条件を満たす組み合わせが特定された場合、カウンター変数 count をインクリメントします。
結果の返却: ループが終了したら、最終的な count の値を返します。
コードの最後では、入力の受け取り、count_lucky_bags 関数の呼び出し、結果の出力が行われています。
'''

# B062 部屋掃除ロボット
# utf-8
N = int(input())  # 掃除する時間
H, W = map(int, input().split())  # 部屋の縦と横のマスの数

s = []  # 部屋の状態を格納するリスト
for _ in range(H):
    s.append(input())  # 部屋の各行の状態をリストに追加

h, w = 0, 0  # ロボットの現在位置 (初期位置は左上)
d = 0  # 掃除したマスの数
c = 'right'  # ロボットの進行方向

for _ in range(N):
    if c == 'right':
        if s[h][w] == '#':  # 現在位置が汚れている場合
            d += 1  # マスを掃除する
        s[h] = s[h][:w] + '*' + s[h][w+1:]  # マスの状態を掃除済みに更新
        if w < W-1 and s[h][w+1] != '*':  # 右に進める場合
            w += 1  # 右に進む
        elif h < H-1 and s[h+1][w] != '*':  # 下に進める場合
            c = 'down'  # 進行方向を変更して下に進む
            h += 1
        else:
            break  # 進める方向がない場合は終了
    elif c == 'down':
        # 以下同様の処理をコメント追加しながら繰り返す
        if s[h][w] == '#':
            d += 1
        s[h] = s[h][:w] + '*' + s[h][w+1:]
        if h < H-1 and s[h+1][w] != '*':
            h += 1
        elif w > 0 and s[h][w-1] != '*':
            c = 'left'
            w -= 1
        else:
            break
    elif c == 'left':
        if s[h][w] == '#':
            d += 1
        s[h] = s[h][:w] + '*' + s[h][w+1:]
        if w > 0 and s[h][w-1] != '*':
            w -= 1
        elif h > 0 and s[h-1][w] != '*':
            c = 'up'
            h -= 1
        else:
            break
    elif c == 'up':
        if s[h][w] == '#':
            d += 1
        s[h] = s[h][:w] + '*' + s[h][w+1:]
        if h > 0 and s[h-1][w] != '*':
            h -= 1
        elif w < W-1 and s[h][w+1] != '*':
            c = 'right'
            w += 1
        else:
            break

print(d)  # 掃除したマスの数を出力
'''
掃除ロボットが指定された時間内に部屋のマスを掃除する機能を実装しています。
最初に、入力から掃除する時間を表す整数 N、部屋の縦と横のマスの数を表す整数 H と W を受け取ります。次に、部屋の状態を示す文字列を入力として受け取り、それをリスト s に格納します。
掃除ロボットの初期位置は部屋の左上のマスであり、ロボットの現在位置を h と w の変数で追跡します。また、掃除したマスの数を表す変数 d を初期化し、ロボットの進行方向を表す変数 c を初期値 'right' で設定します。
次に、指定された時間 N の回数だけ以下の処理を繰り返します。
まず、現在の進行方向が 'right' の場合を考えます。現在位置が汚れている場合、d をインクリメントしてマスを掃除します。その後、現在位置を掃除済みに更新します。次に、右に進むことができる場合は w をインクリメントします。もし右に進めない場合は、下に進むことができるかを確認し、できる場合は進行方向を 'down' に変更して h をインクリメントします。右にも下にも進めない場合は、掃除を終了します。
同様の手順で、進行方向が 'down'、'left'、'up' の場合についても処理を行います。進行方向ごとに、現在位置が汚れている場合は d をインクリメントし、現在位置を掃除済みに更新します。進行方向に応じて次のマスに進むかを判断し、進める場合は位置を更新します。進めない場合は、掃除を終了します。
最後に、掃除したマスの数 d を出力します。
'''

# B063 支払う枚数とお釣りの枚数　※入力例全てでNG
# utf-8
def minimize_coins(X):
    coins = [500, 100, 50, 10, 5, 1]
    num_coins = 0

    for coin in coins:
        num_coins += X // coin
        X %= coin

    return num_coins


# 入力値を受け取る
X = int(input().rstrip())

# バリデーションチェック
if X < 1 or X > 999:
    print("入力値は1以上999以下の範囲で指定してください。")
else:
    # 最小の支払いとお釣りの硬貨枚数を計算
    min_coins = float('inf')
    for i in range(X + 1):
        coins_used = minimize_coins(i) + minimize_coins(X - i)
        min_coins = min(min_coins, coins_used)
    
    # 結果を出力
    print(min_coins)

# B064 うずを探せ　※テストケース70点　ランタイムエラー
# utf-8
import copy
H,W=map(int,input().split())
s1=[list(input()) for _ in range(H)]
# print(s1)
x,y,ans=0,0,0
s=copy.deepcopy(s1)
for h in range(H):
    for w in range(W):
        # print(s[h][w])
        # s=copy.deepcopy(s1)
        # 今いるマス目に書かれた方向
        ss=s[h][w]
        # 最初のスタート位置を決める処理
        # マス目が*だったら次のマス目にスキップする
        if ss=='*':
            continue
        # 今いるマス目を*にしている
        s[h][w]='*'
        # 表よりはみ出てたら抜ける
        if (h==0 and ss=='U') or (w==0 and ss=='L') or (h==H-1 and ss=='D') or (w==W-1 and ss=='R'):
            continue
        # スタート地点を決めている
        x=h
        y=w
        # 全マス目文回している。渦があるかどうか探している
        for i in range(H*W):
            # 渦を辿っている
            if ss=='U':
                x-=1
            elif ss=='L':
                y-=1
            elif ss=='D':
                x+=1
            elif ss=='R':
                y+=1
            # １マス先の文字を代入している
            ss=s[x][y]
            # 辿ったマス目を*にしている
            s[x][y]='*'
            # 一周したかどうか確認している
            if x==h and y==w:
                ans+=1
                s1=copy.deepcopy(s)
                # print(s)
                break
            # 一周していないけど*があったら抜ける
            if ss=='*':
                s=copy.deepcopy(s1)
                break
# print(s)
print(ans)

# B065 小さなライフゲーム　※テストケース80点
# utf-8
def is_reversible(initial_board, update_rules):
    current_board = initial_board
    board_states = set()  # 盤面の状態を保存するセット
    board_states.add(current_board)

    for _ in range(10):  # 最大で10回の更新を試行する
        new_board = ""

        for i in range(len(current_board)):
            left_neighbor = current_board[i - 1]
            right_neighbor = current_board[(i + 1) % len(current_board)]
            update_index = (left_neighbor == "-") * 2 + (right_neighbor == "-")
            new_symbol = update_rules[update_index]
            new_board += new_symbol

        if new_board == initial_board:
            return True

        if new_board in board_states:
            return False

        board_states.add(new_board)
        current_board = new_board

    return False


# 入力の読み込み
initial_board, update_rules = input().split()

# 制約条件のチェック
if len(initial_board) != 10 or len(update_rules) != 4 or not all(symbol in "+-" for symbol in initial_board + update_rules):
    print("NO")
else:
    # 判定結果の出力
    if is_reversible(initial_board, update_rules):
        print("YES")
    else:
        print("NO")

# B066 色のパズル　※入力例のみ通過
# utf-8
import copy
X,N,M = list(map(int,input().split()))
c,cc=[],[]
p=[[] for i in range(X)]
for i in range(N):
    c.append(list(input()))
for i in range(X):
    for j in range(M):
        p[i].append(list(input()))
    p[i]=sum(p[i],[])
# ピースの個数を表す整数 X、パズルの大きさを表す整数 N、ピースの大きさを表す整数 M 
# cの整形 
nm=N//M # パズルの一辺がピース何個分か
for i in range(nm**2): # 0,1,2,3
    ccc=[]
    for j in range(M): # 0,1,2
        ccc.append(c[i//nm*M+j][i%nm*M:i%nm*M+M])
    cc.append(ccc)
pp=[[] for i in range(X)]
for i in range(X):
    for j in range(M):
        pp[i].append(p[i][j*M:j*M+M])
for i in range(X):
    flag=False
    # ピースと完成図の合うものを探す
    for j in range(nm**2):
        if pp[i]==cc[j]:
            print(j//2*2+1,j%2*2+1,0)
            flag=True
            break
    # もし見つかったら、次のピースに移る
    if flag:
        continue
    # ピースの回転
    ppp=[[' ' for i in range(M)] for j in range(M)]
    p4=pp[i]
    # ピースを最大3回転させる
    for n in range(3):
        for k in range(M):
            for m in range(M):
                ppp[m][M-1-k]=p4[k][m]
        # ピースを回転させた後、合うものを探している。
        for j in range(nm**2):
            if ppp==cc[j]:
                print(j//nm*M+1,j%nm*M+1,n+1)
                flag=True
                break
        if flag:
            break
        p4=copy.deepcopy(ppp)
    if flag==False:
        print(-1)

# B067 タスクの管理
# utf-8
schelde_input = []
N = 0
while not (1 <= N <= 100):
    N = int(input())  # タスクの数を入力

condition_ness_day = []  # タスクの必要日数を格納するリスト
condition_start_day = []  # タスクの開始日を格納するリスト
condition_end_day = []  # タスクの終了日を格納するリスト

# タスクの入力を受け取り、条件を満たすものをリストに追加する
for _ in range(N):
    i_n = input().split(' ')
    i_n = list(map(int, i_n))
    if (i_n[2] >= i_n[1]) and (i_n[0] <= (i_n[2] - i_n[1] + 1)):
        schelde_input.append(i_n)

is_check = True

# 各タスクの必要日数、開始日、終了日をリストに分割して格納する
for n in schelde_input:
    condition_ness_day.append(n[0])
    condition_start_day.append(n[1])
    condition_end_day.append(n[2])

# タスクを終了日までに完了できるか判定する
if sum(condition_ness_day) <= (max(condition_end_day) - min(condition_start_day) + 1):
    if (condition_start_day[-1] + sum(condition_ness_day) <= condition_end_day[-1]):
        is_check = True
    else:
        is_check = False
else:
    is_check = False

# 結果を出力する
if is_check:
    print("YES")
else:
    print("NO")
'''
タスクの数と各タスクの情報を入力として受け取り、それらの条件を満たすかどうかを判定します。
最初に、タスクの数を入力します。この値は1以上100以下でなければなりません。
次に、タスクの数だけタスクの情報を入力します。各タスクの情報は必要日数、開始日、終了日の順で半角スペース区切りで与えられます。
入力されたタスクの情報が条件を満たすかどうかを判定します。条件は以下の通りです。
タスクの開始日が終了日以下であること
タスクの必要日数が終了日 - 開始日 + 1以下であること
全てのタスクの情報が条件を満たす場合、タスクを終了日までに完了できるかどうかを判定します。
タスクの必要日数の合計が、最後のタスクの終了日 - 最初のタスクの開始日 + 1以下であること
タスクの開始日と必要日数の合計が最後のタスクの終了日以下であること
最終的な結果を出力します。タスクを終了日までに完了できる場合は「YES」を、できない場合は「NO」を出力します。
'''

# B068 チョコの分割　※テストケース90点　条件内の境界値で不一致
# utf-8
def check(allSugarList):
    # 各行の糖度の合計が偶数であるかを判定する関数
    result = []
    for i in allSugarList:
        if sum(i) % 2 == 0:
            result.append(True)
        else:
            result.append(False)
    return all(result)

def check2(allSugarList):
    # 各行の糖度をアリスとボブで分割できるかを判定する関数
    result = []
    for i in allSugarList:
        if sum(i) % 2 == 0:
            wa = 0
            for j in i:
                wa += j
                if wa == sum(i) // 2:
                    result.append(True)
                    break
            else:
                result.append(False)
    return True in result

# 入力のバリデーションチェックとエラーハンドリング
try:
    # 入力の受け取り
    H, W = map(int, input().split())

    # 入力値のバリデーションチェック
    if not (1 <= H <= 100):
        raise ValueError("Hは1から100の範囲内である必要があります。")
    if not (2 <= W <= 100):
        raise ValueError("Wは2から100の範囲内である必要があります。")

    # チョコレートの糖度リストの初期化
    allSugarList = []

    # チョコレートの糖度の入力
    for _ in range(H):
        sugarList = list(map(int, input().split()))
        if not all(1 <= a <= 1000 for a in sugarList):
            raise ValueError("チョコレートの要素は1から1000の範囲内である必要があります。")
        allSugarList.append(sugarList)

    # チョコレートの分割と出力
    if check(allSugarList) and check2(allSugarList):
        print("Yes")
        for row in allSugarList:
            result = []
            wa = sum(row) // 2
            for j in range(W):
                if wa != 0:
                    wa -= row[j]
                    result.append("A")
                else:
                    result.append("B")
            print("".join(result))
    else:
        print("No")

except ValueError as e:
    print(f"入力エラー: {str(e)}")
    
# B069 蟻の餌探し　※テストケース通過せず　50点
# utf-8
def check_ant_reachability(H, W, cage, food_positions):
    # 蟻の巣の位置
    nest = (1, 1)
    # フェロモンの状態を管理する配列
    pheromones = [[False] * W for _ in range(H)]

    # 蟻の巣にフェロモンを付ける
    pheromones[nest[0] - 1][nest[1] - 1] = True

    # フェロモンをたどって餌にたどり着けるかを判定
    def dfs(y, x):
        # ゴールに到達した場合
        if (y, x) in food_positions:
            return True

        # 上下左右の座標を探索
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        for dy, dx in directions:
            ny, nx = y + dy, x + dx
            # ケージの範囲内でフェロモンがあり、未探索の場合
            if 0 <= ny < H and 0 <= nx < W and cage[ny][nx] == "#" and not pheromones[ny][nx]:
                pheromones[ny][nx] = True  # フェロモンを付ける
                if dfs(ny, nx):  # 再帰的に探索
                    return True

        return False

    # 蟻の巣から探索を開始
    if dfs(nest[0] - 1, nest[1] - 1):
        return "NO"
    else:
        return "YES"

# 入力を受け取る
H, W = map(int, input().split())
cage = [input() for _ in range(H)]
N = int(input())
food_positions = [tuple(map(int, input().split())) for _ in range(N)]

# 蟻がすべての餌にたどり着けるかを判定
result = check_ant_reachability(H, W, cage, food_positions)

# 結果を出力
print(result)

# B070 駒の到達範囲 ※0点
def count_reachable_cells(N, H, W, K):
    # バリデーションチェック
    if not (1 <= N <= 10):
        return 0
    if not (1 <= H <= N):
        return 0
    if not (1 <= W <= N):
        return 0
    if not (1 <= K <= 10):
        return 0

    # 駒の初期位置
    start_row = H - 1
    start_col = W - 1

    # 駒が到達可能なマスの数をカウント
    count = 0

    # 上下左右および斜めの移動方向を定義
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1), (0, 0)]

    # 駒の移動回数に応じて探索
    for k in range(K + 1):
        # 上下左右および斜め方向に移動
        for d in directions:
            row = start_row + k * d[0]
            col = start_col + k * d[1]

            # 移動後の位置がチェスボード上にある場合、到達可能なマスとしてカウント
            if 0 <= row < N and 0 <= col < N:
                count += 1

    return count


# 入力を受け取る
N, H, W, K = map(int, input().split())

reachable_cells = count_reachable_cells(N, H, W, K)
print(reachable_cells)

--------------------------------------------- B071　※欠番 ◆
# B071 ダンベルトレーニング　※テストケース通過せず　80点　境界値で不一致
# utf-8
import itertools

def find_nearest_weight(N, weights, M):
    nearest_weight = float('inf')  # Mに最も近い重さを表す変数を無限大で初期化

    # おもりの組み合わせをすべて試す
    for r in range(1, N+1):
        combinations = itertools.combinations(weights, r)  # おもりの組み合わせを生成

        for combination in combinations:
            total_weight = sum(combination)  # 組み合わせの合計重さ

            # バーの両端の重さが等しくなる条件を満たす場合、nearest_weightを更新する
            if total_weight % 2 == 0 and total_weight <= M and abs(M - total_weight) < abs(M - nearest_weight):
                nearest_weight = total_weight

    if nearest_weight == float('inf'):  # 条件を満たす組み合わせが存在しない場合
        return 0
    else:
        return nearest_weight

# 入力を受け取る
N, M = map(int, input().split())

# バリデーションチェック
if not (1 <= N <= 10):
    print("Nの値が範囲外です")
    exit()
if not (1 <= M <= 100):
    print("Mの値が範囲外です")
    exit()

weights = []
for _ in range(N):
    weight = int(input())
    if not (1 <= weight <= 10):
        print("おもりの重さが範囲外です")
        exit()
    weights.append(weight)

nearest = find_nearest_weight(N, weights, M)
print(nearest)

# B072 反転スイッチ
# utf-8
def toggle_screen(screen_size, pattern_size, pattern, num_switches, switches):
    # 画面の初期化
    screen = [['_' for _ in range(screen_size[1])] for _ in range(screen_size[0])]

    # スイッチを押す回数だけ繰り返す
    for _ in range(num_switches):
        # パターンの行ごとに繰り返す
        for i in range(pattern_size[0]):
            # パターンの列ごとに繰り返す
            for j in range(pattern_size[1]):
                # 画面の範囲内かをチェック
                if 0 <= i < screen_size[0] and 0 <= j < screen_size[1]:
                    # パターンが '#' の場合は反転させる
                    if pattern[i][j] == '#':
                        # スイッチの座標を基準にして画面の状態を反転させる
                        screen[i + switches[_][1] - 1][j + switches[_][0] - 1] = '#' if screen[i + switches[_][1] - 1][j + switches[_][0] - 1] == '_' else '_'

    return screen

# 入力の読み込み
# 画面の縦の大きさ H、横の大きさ W
H, W = map(int, input().split())
# パターンの縦の大きさ N、横の大きさ M
N, M = map(int, input().split())

pattern = []
for _ in range(N):
    pattern.append(list(input()))
    
# スイッチを押す回数 Q
Q = int(input())
switches = []
# スイッチを押す回数だけ繰り返す
for _ in range(Q):
    # スイッチの対応するパターンの左上の x 座標 x_k、y 座標 y_k 
    switches.append(list(map(int, input().split())))

# 画面の状態を計算
result = toggle_screen((H, W), (N, M), pattern, Q, switches)

# 結果の出力
for row in result:
    print(''.join(row))
'''
toggle_screen 関数は、画面の状態を反転させる処理を行います。引数として、画面のサイズ screen_size、パターンのサイズ pattern_size、パターンの反転模様 pattern、スイッチの回数 num_switches、スイッチの座標情報 switches を受け取ります。
screen は二次元リストとして初期化され、画面のサイズに応じて全ての要素が '_'（白色）で埋められます。
スイッチを押す回数だけ繰り返すループがあります。各スイッチの回数に対して、以下の処理が行われます。
パターンの行ごとに繰り返すループがあります。
パターンの列ごとに繰り返すループがあります。
画面の範囲内かをチェックします。行番号 i と列番号 j が画面の範囲内にあるかを確認します。
パターンが '#' の場合は、スイッチの座標情報を基準にして画面の状態を反転させます。スイッチの座標情報 switches[_] の x 座標 switches[_][0] と y 座標 switches[_][1] を使用して、対応する画面上の座標を計算し、その位置の要素を反転させます。
toggle_screen 関数は最終的に、スイッチを押した後の画面の状態 screen を返します。
入力の読み込みが行われます。まず、画面の縦と横のサイズを H と W に読み込みます。
パターンの縦と横のサイズを N と M に読み込みます。
パターンの反転模様を読み込み、二次元リストとして pattern に格納します。
スイッチの回数を Q に読み込みます。
スイッチの座標情報を読み込み、リストとして switches に格納します。
toggle_screen 関数を呼び出し、最終的な画面の状態を result に格納します。
最終的な画面の状態を出力します。各行を結合して一つの文字列にし、それを行ごとに出力します。

これにより、与えられた入力に基づいてスイッチの押し操作をシミュレートし、最終的な画面の状態を出力するプログラムが実行されます。
'''

# B073 イルミネーションの調査　※入力例1で通過せず
# utf-8　
def add_light_bulbs(tree_count, light_bulbs, intervals, safety_standard):
    for interval in intervals:
        start = interval[0]
        end = interval[1]

        # 区間内の木の電球の合計を計算
        total_bulbs = sum(light_bulbs[start-1:end])

        # 区間内の木の個数を計算
        tree_count_in_interval = end - start + 1

        # 区間内の電球の平均個数を計算
        average_bulbs = total_bulbs / tree_count_in_interval

        # 平均個数が安全基準を満たしていない場合、電球を追加
        if average_bulbs < safety_standard:
            additional_bulbs = safety_standard * tree_count_in_interval - total_bulbs

            # 各木に追加する電球の個数を計算し、追加する
            for i in range(start-1, end):
                required_bulbs = safety_standard * tree_count_in_interval - total_bulbs
                additional_bulbs_per_tree = min(required_bulbs, safety_standard - light_bulbs[i], 100 - light_bulbs[i])
                light_bulbs[i] += additional_bulbs_per_tree
                additional_bulbs -= additional_bulbs_per_tree

    return light_bulbs


# 入力の読み込み
N, M = map(int, input().split())
A = list(map(int, input().split()))
Q = int(input())
intervals = []
for _ in range(Q):
    S, E = map(int, input().split())
    intervals.append((S, E))

# 電球の追加
result = add_light_bulbs(N, A.copy(), intervals, M)

# 結果の出力
print(*result)

# B074 コメントの順序
# utf-8
def calculate_comment_popularity(comment_id, comments):
    """
    特定のコメントの注目度を計算する関数
    """
    comment = comments[comment_id]
    likes = comment["likes"]
    replies = comment["replies"]

    popularity = likes
    for reply_id in replies:
        popularity += calculate_comment_popularity(reply_id, comments)

    return popularity


def find_most_popular_comment(comments):
    """
    最も注目度の高いコメントのIDを見つける関数
    """
    max_popularity = -1
    most_popular_comment_id = None

    for comment_id in comments:
        popularity = calculate_comment_popularity(comment_id, comments)
        if popularity > max_popularity or (popularity == max_popularity and comment_id < most_popular_comment_id):
            max_popularity = popularity
            most_popular_comment_id = comment_id

    return most_popular_comment_id


# 入力の読み込み
N = int(input())
comments = {}

for _ in range(N):
    comment_info = input().split()
    comment_id = int(comment_info[0])
    parent_id = comment_info[1]
    likes = int(comment_info[2])

    if parent_id == "None":
        parent_id = None
    else:
        parent_id = int(parent_id)

    comments[comment_id] = {
        "parent_id": parent_id,
        "likes": likes,
        "replies": []
    }

# 子コメントのリストを親コメントに追加する
for comment_id, comment in comments.items():
    parent_id = comment["parent_id"]
    if parent_id is not None:
        parent_comment = comments[parent_id]
        parent_comment["replies"].append(comment_id)

# 注目度の一番高いコメントのIDを求める
most_popular_comment_id = find_most_popular_comment(comments)

# 結果の出力
print(most_popular_comment_id)
'''
calculate_comment_popularity 関数は、特定のコメントの注目度を再帰的に計算するための関数です。与えられたコメントIDに対応するコメントの「いいね」数を取得し、それに対して返信コメントの注目度の合計を再帰的に計算して注目度を求めます。
find_most_popular_comment 関数は、与えられたコメントリストから最も注目度の高いコメントのIDを見つけるための関数です。各コメントの注目度を計算し、最大の注目度を持つコメントのIDを返します。注目度が同じ場合は、IDが最小のコメントを選択します。
入力を読み込み、コメント情報を辞書形式で保持します。コメントID、親コメントID、いいね数を取得し、コメント辞書に追加します。親コメントがある場合は、子コメントのリストを親コメントの辞書に追加します。
最も注目度の高いコメントのIDを求め、結果を出力します。
'''

# B075 商品の表示
# utf-8
def calculate_score(N, M, products):
    scores = []  # スコアを保持するリスト

    # スコア計算
    for i in range(N):
        score = 0
        ranks = []  # 各指標の順位を保持するリスト
        for j in range(M):
            rank = 1
            for k in range(N):
                if products[k][j] > products[i][j]:
                    rank += 1
            ranks.append(rank)
        for j in range(M):
            score += N - ranks[j] + 1
        scores.append((i + 1, score))  # 商品番号とスコアの組を追加

    # スコアの高い順にソート
    scores.sort(key=lambda x: x[1], reverse=True)

    # 結果の出力
    for score in scores:
        print(score[0])

# 入力の読み込み
N, M = map(int, input().split())  # 表示する商品の数を表す整数 N、商品の指標の数を表す整数 M
products = []
for _ in range(N):
    product = list(map(int, input().split()))  # i番目の商品の j 番目の指標の値
    products.append(product)

# スコア計算と結果の出力
calculate_score(N, M, products)
'''
calculate_scoreという関数を定義します。この関数は、商品のスコアを計算するための処理を行います。scoresという空のリストを用意して、スコアを保持します。
指定されたルールに基づいて、商品のスコアを計算します。まず、商品の数だけループします。内部のループでは、各指標ごとに順位を計算し、ranksリストに順位を追加します。次に、各指標の順位を使用してスコアを計算し、scoresリストに商品番号とスコアの組を追加します。
計算されたスコアを高い順にソートします。sortメソッドを使用して、スコアを基準にリストを降順に並び替えます。
ソートされたスコアを順番に取り出し、商品番号を出力します。入力値を読み込みます。
まず、map関数とsplitメソッドを使用して、商品の数を表す整数Nと商品の指標の数を表す整数Mを取得します。次に、商品の指標の値を入力として受け取り、それを二重リストとしてproductsリストに追加します。
calculate_score関数を呼び出して、スコアの計算と結果の出力を行います。
'''

# B076 パン屋さん
# utf-8
# N（パンの種類数）とQ（クエリの数）を読み込む
N, Q = map(int, input().split())

# NとQのバリデーションチェック
assert 1 <= N <= 30, "Nが無効です"
assert 1 <= Q <= 50, "Qが無効です"

# パンの価格と在庫数のリストを初期化する
prices = []  # パンの価格リスト
stock = []  # パンの在庫数リスト

# パンの価格と在庫数を読み込む
for _ in range(N):
    # 各パンの種類ごとに価格と在庫数を読み込む
    price, quantity = map(int, input().split())

    # 価格と在庫数のバリデーションチェック
    assert 1 <= price <= 500, "価格が無効です"
    assert 0 <= quantity <= 20, "在庫数が無効です"

    # 価格と在庫数をそれぞれのリストに追加する
    prices.append(price)
    stock.append(quantity)

# 結果のリストを初期化する
results = []

# クエリを処理する
for _ in range(Q):
    # クエリの種類とパンの個数を読み込む
    query, *quantities = input().split()

    # クエリの種類のバリデーションチェック
    assert query in ["bake", "buy"], "クエリの種類が無効です"

    # パンの個数を整数に変換する
    quantities = list(map(int, quantities))

    # パンの個数のバリデーションチェック
    assert all(0 <= q <= 1000 for q in quantities), "パンの個数が無効です"

    # "bake" クエリの処理
    if query == "bake":
        # 各パンの種類ごとに在庫数を増やす
        for i in range(N):
            stock[i] += quantities[i]

    # "buy" クエリの処理
    elif query == "buy":
        # 合計金額を初期化する
        total_cost = 0

        # 全てのパンを購入できるかを示すフラグを初期化する
        can_buy = True

        # 在庫の確認と合計金額の計算を行う
        for i in range(N):
            # 現在のパンの種類の在庫が購入個数に対して十分かチェックする
            if stock[i] >= quantities[i]:
                # 在庫数を減らし、金額を計算する
                stock[i] -= quantities[i]
                total_cost += prices[i] * quantities[i]
            else:
                # 在庫が不足している場合はフラグをFalseにする
                can_buy = False
                break

        # 結果を結果のリストに追加する
        if can_buy:
            results.append(total_cost)
        else:
            results.append(-1)

# 結果を出力する
for result in results:
    print(result)
'''
最初に、パンの種類数を表す整数 N とクエリの個数を表す整数 Q を入力します。このとき、N の値が 1 以上 30 以下であり、Q の値が 1 以上 50 以下であることをバリデーションチェックします。
パンの値段と在庫数を表す整数 a_i, b_i を N 回繰り返し入力します。各パラメータの値が以下の条件を満たしていることをバリデーションチェックします:
a_i の値が 1 以上 500 以下であること
b_i の値が 0 以上 20 以下であること
結果を格納するリスト results を初期化します。
クエリを Q 回繰り返し入力します。各クエリは以下の形式で与えられます:
"bake" クエリの場合: bake 0 c_{i, 1} c_{i, 2} ... c_{i, N}
"buy" クエリの場合: buy c_{i, 1} c_{i, 2} ... c_{i, N}
このとき、クエリの種類が "bake" または "buy" のいずれかであることをバリデーションチェックし、各パンの個数 c_{i, j} の値が 0 以上 1000 以下であることをバリデーションチェックします。
クエリの種類に応じて処理を行います:
"bake" クエリの場合: 各パンの在庫数を c_{i, j} だけ増やします。
"buy" クエリの場合: 各パンの在庫数と購入可能性をチェックし、在庫が足りる場合は購入に必要な合計金額を計算し、在庫数を減らします。在庫が足りない場合はエラーとして -1 を結果リストに追加します。
結果リストの値を順に出力します。
'''

# B077 チケットの売り場
# utf-8
# 入力の読み込み
N, M = map(int, input().split())
processing_times = []
for _ in range(N):
    t = int(input())
    if 1 <= t <= 1000:
        processing_times.append(t)
    else:
        print("処理時間の値は1以上1,000以下である必要があります。")
        exit()

# カウンターの数と人数の制約条件をチェック
if not (1 <= N <= 1000):
    print("カウンターの数は1以上1,000以下である必要があります。")
    exit()
if not (N <= M <= 10000):
    print("並んでいる人数はカウンターの数以上であり、10,000以下である必要があります。")
    exit()

# カウンターの処理時間でソート
processing_times.sort()

# カウンターの処理終了時刻を保持する配列
counters = [0] * N

# シミュレーションの実行
time = 0
for i in range(M):
    min_counter = 0
    for j in range(1, N):
        if counters[j] < counters[min_counter]:
            min_counter = j
    counters[min_counter] += processing_times[min_counter]
    time = max(time, counters[min_counter])

# 出力
print(time)
'''
最初に、入力の読み込みを行います。
NとMを半角スペース区切りで受け取り、それぞれカウンターの数と並んでいる人数を表します。
その後、N個の処理時間を入力として受け取り、processing_timesリストに格納します。
この際、各処理時間が1以上1,000以下の範囲に収まっているかどうかをバリデーションチェックします。
カウンターの数と人数の制約条件をチェックします。
Nが1以上1,000以下であるかをチェックします。そうでない場合、エラーメッセージを表示してプログラムを終了します。
MがN以上かつ10,000以下であるかをチェックします。そうでない場合、エラーメッセージを表示してプログラムを終了します。
カウンターの処理時間を昇順にソートします。
カウンターの処理終了時刻を保持するためのcountersリストを作成し、初期値を0に設定します。
シミュレーションを実行します。

M回のループで、順番に人がカウンターに並びます。
空いているカウンターの中で、最も早く処理が終わるカウンターを選びます。
選ばれたカウンターの処理終了時刻を更新します。
カウンターの処理終了時刻をもとに、全員がチケットを買い終わるまでの最終的な時間を計算します。
計算された時間を出力します。
'''

# B078 動画視聴スケジュール　※入力例2でNG
# utf-8
def maximum_videos(N, schedule):
    videos = []
    for i in range(N):
        start_time, duration = map(int, schedule[i].split())
        videos.append((start_time, duration))

    videos = sorted(videos)  # 開始時間でソート
    count = 0
    end_time = 0

    for start_time, duration in videos:
        if start_time >= end_time:
            count += 1
            end_time = start_time + duration

    return count


N = int(input())
schedule = []
for _ in range(N):
    schedule.append(input())

result = maximum_videos(N, schedule)
print(result)

# B079 相性チェック
# utf-8
def calculate_compatibility(name1, name2):
    # 1. 名前を小文字に変換し、アルファベットの数値に変換する
    nums1 = [ord(c) - ord('a') + 1 for c in name1]
    nums2 = [ord(c) - ord('a') + 1 for c in name2]

    # 2. 数列を作成する
    def create_sequence(nums):
        while len(nums) > 1:
            new_nums = []
            for i in range(len(nums) - 1):
                new_nums.append((nums[i] + nums[i+1]) % 101)
            nums = new_nums
            if nums[0] > 101:
                nums[0] -= 101
        return nums[0]

    # 3. 2通りの相性を計算し、大きい方を返す
    compatibility1 = create_sequence(nums1 + nums2)
    compatibility2 = create_sequence(nums2 + nums1)
    return max(compatibility1, compatibility2)

# 入力を受け取る
s, t = input().strip().split()

# 相性を計算する
compatibility = calculate_compatibility(s, t)

# 結果を出力
print(compatibility)
'''
calculate_compatibility関数は、2つの名前を受け取り、相性を計算します。
名前を小文字に変換し、アルファベットの数値に変換します。アルファベット"a"は1、"b"は2、...、"z"は26と対応付けられます。
数列を作成します。隣り合う2つの数を足し合わせて新しい数列を作成します。ただし、要素の値が101を超えた場合は101を引きます。この手順を繰り返し、数列の要素数が1になるまで行います。
2通りの相性を計算し、大きい方を返します。1つ目の名前を前にして計算する場合と、2つ目の名前を前にして計算する場合の2通りの相性を求め、大きい方の結果を採用します。
'''
# B080 みんなでスゴロク
--------------------------------------------- B081　※欠番 ◆
# B081 花壇のロープ
# B082 休暇の取り方
# B083 宝の地図
# B084 オススメのお店
# B085 宝探しの手順
# B086 公平な分割
# B087 隠された数
# B088 ロボットのデバッグ
# B089 秘密の言葉
# B090 選挙の議席
--------------------------------------------- B091　※欠番 ◆
# B091 山頂を探せ
# B092 セーブポイント
# B093 SNSの検索機能
# B094 ◆
# B095 カラオケ大会
# B096 ビンゴゲーム
# B096(2) 爆弾の大爆発
# B097 カウンター席
# B098 バズの検出
# B099 台風の接近
# B100 計算の遅延
--------------------------------------------- B101　※欠番 ◆
# B101 ◆
# B102 膨張と収縮
# B103 ◆
# B104 データのクレンジング
# B105 マッピングゲーム
# B106 席替えの席決め
# B107 カードシャッフル
# B108 観覧車の稼働状況
# B109 映画館の席の予約
# B110 解像度の向上
--------------------------------------------- B111　※欠番 ◆
# B111 天秤のつりあい
# B112 くじの作成
# B113 2のべき連結ゲーム
# B114 PAIZA運動会
# B115 アナグラムパズル
# B116 プレゼント交換
# B117 回る教習車
# B118 背の順
# B119 投網
# B120 ◆
--------------------------------------------- B121　※欠番 ◆
# B121 床の模様替え
# B122 うわさ
# B123 ビットゲーム
# B124 名前が似ている友達
# B125 工場のボトルネック
# B126 ダンスパーティー
# B127 ◆
# B128 簡易的二次元バーコード
# B129 n毛作
# B130 ブロック挿入
--------------------------------------------- B131　※欠番 ◆
# B131 運賃計算
# B131(2) 復号の処理
# B132
# B133
# B134
# B135
# B136
# B137
# B138
# B139
# B140
-----------------------------------------------B141　※欠番◆
