※欠番が存在する理由につきましては、出題自体を公開終了した問題が欠番となっております。

--------------------------------------------- B001　※欠番 ◆
# B001 ◆
# B002 ◆
# B003 ◆
# B004 ログファイルの抽出
# utf-8
def isValidIp(m, c):
    ret = False
    if m == "*" or m == c:
        ret = True
    elif m[0] == "[":
        a = m.split("-")
        ss = int(a[0].replace("[", ""))
        ee = int(a[1].replace("]", ""))
        if ss <= int(c) <= ee:
            ret = True
    return ret


def main():
    # IPアドレスを読み込む
    mip = input().strip().split(".")
    
    # ログの数を読み込む
    n = int(input())
    
    # ログを1行ずつ読み込み、IPアドレスをチェックする
    for i in range(n):
        s = input().strip().split(" ")
        tip = s[0].split(".")
        if mip[0] == tip[0] and \
           mip[1] == tip[1] and \
           isValidIp(mip[2], tip[2]) and \
           isValidIp(mip[3], tip[3]):
            print(s[0] + " " + s[3][1:] + " " + s[6])


if __name__ == '__main__':
    main()
'''
1 標準入力からIPアドレスとログの数を取得し、IPアドレスを「.」で分割してリストに格納する
2 ログの数だけ繰り返し、1行ずつログを取得する
3 取得したログのIPアドレスを「.」で分割してリストに格納する
4 IPアドレスの1〜3オクテットが一致し、4オクテットが以下の条件を満たす場合に、ログの情報を出力する
　・IPアドレスの4オクテットが、IPアドレスの4オクテットと完全一致する場合
　・IPアドレスの4オクテットが、ワイルドカード「*」の場合
　・IPアドレスの4オクテットが、範囲指定の場合（「[」と「]」で囲まれた範囲内の数値のみ許可される）
具体的には、以下のような関数を定義して使用しています。
isValidIp(m, c)
　・引数mが「*」またはcと完全一致する場合はTrueを返す
　・引数mが範囲指定の場合は、引数cが範囲内にある場合はTrueを返す
このコードは、ログのIPアドレスが与えられたIPアドレスにマッチするかどうかを判定する処理を行っており、与えられたIPアドレスがワイルドカードや範囲指定を含んでいる場合にも対応しています。
'''

# B005 ◆　
# B006 ダーツゲーム
# utf-8
# 標準入力からの値の取得
import sys
input_line = sys.stdin.read()
input_list = input_line.split()

# 初期値の設定
o_y = float(input_list[0])
s = float(input_list[1])
theta = float(input_list[2])
x = float(input_list[3])
y = float(input_list[4])
a = float(input_list[5])

# 矢が当たるかどうかの判定
import math
g = 9.8
rad = math.radians(theta)
t = x / (s * math.cos(rad))
y2 = o_y + s * math.sin(rad) * t - (g * t ** 2) / 2
if y - a / 2 <= y2 <= y + a / 2:
    # 当たった場合、的の中心からの距離を出力
    dist = abs(y2 - y)
    print("Hit {:.1f}".format(round(dist, 1)))
else:
    # 当たらなかった場合、Missを出力
    print("Miss")
'''
以下の手順で矢が的に当たるかどうかを判定し、当たった場合には的の中心からの距離を出力します。
まず、sys.stdin.read()で標準入力から値を読み込み、split()でスペース区切りの文字列をリストに変換します。
次に、リストから必要な値を取り出し、float()で数値に変換します。
これで、矢の初期値点の高さ o_y、初速 s、角度 theta、的までの距離 x、的の高さ y、的の大きさ a がそれぞれ変数に格納されました。

矢が当たるかどうかの判定には、以下の計算式を使用します。
y2 = o_y + s * sin(rad) * t - (g * t^2) / 2
ここで、radはthetaをラジアンに変換したもの、tは矢が的に当たるまでの時間です。この式は、矢の初期値点から投げた瞬間の高さ o_y に、矢が的に当たるまでに到達する高さを足し合わせたものを計算し、的の高さ y ± 的の大きさ a の範囲内にあるかどうかを判定します。

具体的には、以下のように計算します。
import math

# 重力加速度
g = 9.8

# 角度をラジアンに変換
rad = math.radians(theta)

# 矢が的に当たるまでの時間
t = x / (s * math.cos(rad))

# 矢が的に当たるときの高さ
y2 = o_y + s * math.sin(rad) * t - (g * t ** 2) / 2

矢が当たるかどうかを判定する部分では、まず重力加速度を9.8[m/s^2]として、投射角度θに対しての水平方向と鉛直方向の初速度を求めます。そして、投射角度θと初速度sを用いて、到達時間tを求めます。tを用いて、矢の到達位置y2を計算します。その後、的の位置yから、的の半径a/2の範囲内に矢の到達位置y2があるかどうかを判定しています。
当たった場合は、的の中心からの距離を求めています。このとき、求めた距離を絶対値をとっているのは、矢が的の上側に当たった場合でも、的の中心からの距離を正しく求めるためです。また、四捨五入して小数点第1位までの数値を出力するには、Pythonの組み込み関数であるround()関数を使います。
当たらなかった場合は、"Miss"を出力しています。
'''

# B007 ◆
# B008 ◆
# B009 カンファレンスのタイムテーブル作成
# utf-8
# coding: utf-8

# 分を時刻表記に変換する関数　m分をhh:mm形式の文字列に変換する関数
def m2h(m):
    hour = m // 60 % 24  # 24時間制での時間を算出
    minute = m % 60  # 分を算出
    return f'{hour:02}:{minute:02}'  # hh:mm形式の文字列に変換して返す

# 時刻表記を分に変換する関数　hh:mm形式の文字列をm分に変換する関数
def h2m(h):
    hour, minute = map(int, h.split(':'))  # : を区切り文字として文字列を分割して、時と分に分ける
    return hour * 60 + minute  # 時を分に変換して分と合算し、分単位で返す

# 各プレゼンテーションの開始・終了時刻を計算する関数　スケジュールの時間計算を行う関数
def presentation_time(start_time, duration):
    global rest   # お昼休憩のフラグ　# グローバル変数 rest を参照するため、global宣言
    noon = h2m('12:00')  # 12:00を分単位に変換して、お昼の時間として取得
    end_time = start_time + duration  # 終了時刻を算出
    if not rest and noon < end_time:  # お昼休憩が必要かどうかを判定　# 休憩をとっておらず、終了時刻がお昼を過ぎている場合
        start_time += 60 - 10  # お昼休憩をとるために開始時刻をずらす　# お昼休憩を含む1時間の空きを作るために10分引いた時間に移動
        end_time = start_time + duration  # 新しい終了時刻を再度算出
        rest = True  # 休憩を取ったことをフラグに設定
    return start_time, end_time  # スケジュールの開始時間と終了時間を返す

n = int(input())  # # プレゼンテーションスケジュールの個数を入力

start_time = h2m('10:00')  # 最初のプレゼンテーションの開始時刻を10:00として、分単位に変換して取得

rest = False  # お昼休憩をとっていないことをフラグに設定　お昼休憩のフラグを初期化
for _ in range(n):  # スケジュールの個数だけ繰り返し処理を実行
    name, duration = input().split()  # スケジュール名と時間を入力として受け取る
    start_time, end_time = presentation_time(start_time, int(duration))  # スケジュールの開始時間と終了時間を計算
    print(f'{m2h(start_time)} - {m2h(end_time)} {name}')  # スケジュールの時間と名前を出力
    start_time = end_time + 10 # 休憩時間10分を加算して次のプレゼンテーションの開始時刻を計算する
'''
m2h() 関数
この関数は、分単位の時間を時:分の形式の文字列に変換するためのものです。
入力された分を60で割った余りが分の値、60で割った商を24で割った余りが時の値として取得します。
最後に、f-string を使って、"時:分" の形式で文字列を生成し、それを返します。

h2m() 関数
この関数は、時:分の形式の文字列を分単位の時間に変換するためのものです。
split() 関数を使って、文字列を ":" で分割し、時と分の値を取得します。
時を60で掛けたものに分を足し合わせて、分単位の時間を計算し、それを返します。

presentation_time() 関数
この関数は、スピーカーのプレゼンテーションの開始時間と終了時間を計算するためのものです。
引数として、スピーカーのプレゼンテーションの開始時間と時間の長さを受け取ります。
global キーワードを使って、rest 変数をグローバル変数として宣言します。
noon 変数には、12:00の分単位の時間を代入します。
end_time 変数には、プレゼンテーションの終了時間を代入します。
rest 変数が False かつ noon より end_time が後の場合、つまり、プレゼンテーションがお昼休憩をまたいでいる場合、開始時間にお昼休憩の10分を足した時間から再スタートし、終了時間を再計算します。
最後に、開始時間と終了時間を返します。

それ以降のメイン部分
まず、n = int(input())で発表する人数nを受け取ります。
次に、発表が始まる開始時間を表す変数start_timeに、10:00の時間をh2m('10:00')を使って分単位で代入します。
そして、restフラグをFalseで初期化します。これは、お昼休憩のチェックのために使用されます。
forループを使って、各発表の時間を処理します。forループの中で、name, duration = input().split()で発表者の名前nameと発表時間durationを受け取ります。このdurationは単位が分であり、整数型であることに注意してください。
次に、presentation_time(start_time, int(duration))を呼び出して、発表の終了時刻を計算し、その時間を人間が読みやすい形式で出力します。presentation_time関数は、start_timeと発表時間durationを引数として受け取り、終了時間のタイムスタンプ（分単位）を返します。
また、restフラグがFalseである場合は、終了時間が12:00を超える場合に、お昼休憩の時間（10分）を追加します。noon = h2m('12:00')で、12:00の時間を分単位で取得します。そして、noonよりも終了時間が後である場合に、start_time += 60 - 10で、お昼休憩を考慮した新しい開始時間を計算します。最後に、restフラグをTrueに設定します。
各発表が終わった後、start_timeにend_time + 10を代入して、次の発表の開始時間を計算します。この+ 10は、前の発表の終了時間と次の発表の開始時間の間に10分の休憩時間が必要であることを示しています。
'''

# B010 サッカーのオフサイド判定
# utf-8
def team_lineup(players, reverse=False):
    if reverse:
        players = list(map(lambda x:-x, players))
    return zip(range(1, 12), players)

def is_offside(x_player, x_passer, x_offside_line):
    return x_passer < x_offside_line < x_player

def get_offside_players(offence_team, diffence_team, x_passer, x_offside_line):
    offside_players = []
    for idx, x_p in enumerate(offence_team):
        if is_offside(x_p, x_passer, x_offside_line):
            offside_players.append(idx+1)
    return offside_players

def get_offside_line(diffence_team):
    return sorted(diffence_team, reverse=True)[1]

def get_opponent(name):
    return 'A' if name == 'B' else 'B'

# main
offence_name, passer = input().split()
team = {}
team['A'] = list(map(int, input().split()))
team['B'] = list(map(int, input().split()))

if offence_name == 'B':
    for t in team:
        team[t] = list(map(lambda x:-x, team[t]))

diffence_name = get_opponent(offence_name)
offence_team = team[offence_name]
diffence_team = team[diffence_name]

x_offside_line = get_offside_line(diffence_team)
x_passer = int(offence_team[int(passer)-1])

offside_players = get_offside_players(offence_team, diffence_team, x_passer, x_offside_line)

if offside_players:
    for p in offside_players:
        print(p)
else:
    print('None')
'''
与えられたサッカーの試合状況に対して、次のパスを受け取るとオフサイドと判定される選手の背番号を小さいものから順に1行ずつ出力するものです。
まず、input()関数を使って標準入力から入力を受け取ります。1行目では攻撃するチームの名前(offence_name)と、パスを受け取る選手の背番号(passer)をスペース区切りで受け取り、
2行目と3行目ではそれぞれ攻撃するチームの選手の背番号(team_a_numbers, team_b_numbers)をスペース区切りで受け取ります。
次に、攻撃するチームと守備するチームの背番号をリストで保持します。if文で、offence_nameが'B'の場合、攻撃するチームと守備するチームの背番号を反転させます。
この処理によって、攻撃するチームが必ずAチームになるようにしています。
次に、守備するチームの最後尾から2番目の背番号を取得します。この背番号より前に攻撃するチームの選手がいる場合、オフサイドの判定が行われます。
最後に、攻撃するチームの選手の中でオフサイドとなる選手の背番号を出力します。オフサイドとなる選手がいない場合には、"None"を出力します。
このコードのポイントは、オフサイド判定を行うis_offside関数にあります。この関数は、与えられた選手の背番号(x_player)、パスを出した選手の背番号(x_passer)、
そして守備するチームのオフサイドラインの背番号(x_offside_line)を受け取り、オフサイド判定を行います。
オフサイド判定は、パスを出した選手より前方に守備するチームのオフサイドラインと、パスを受けた選手が存在する場合に成立します。
'''

--------------------------------------------- B011　※欠番 ◆
# B011 名刺バインダー管理
# utf-8
n, m = map(int, input().split())

# m番目の名刺が含まれるページを計算する
page = (m - 1) // (n * 2) + 1

# そのページの最後の名刺番号と最初の名刺番号を計算する
last_card_num = page * n * 2
first_card_num = last_card_num - (n * 2 - 1)

# m番目の名刺が表面か裏面かによって、裏側の名刺の番号を計算する
if m <= (first_card_num + n - 1):
    back_card_num = last_card_num - (m - first_card_num)
else:
    back_card_num = first_card_num + (last_card_num - m)

print(back_card_num)
'''
1行目では、入力された文字列をスペースで分割し、それぞれ整数型に変換して、nとmに代入しています。
2行目では、m番目の名刺が属するページ数を求めています。m-1をn*2で割り、+1をしているのは、pythonで整数を割った場合、小数点以下が切り捨てられるためです。
また、m-1をする理由は、1番目の名刺が0ページ目にあるとみなすためです。3行目では、pageページに含まれる最後の名刺の番号を計算しています。pageページには、n2枚の名刺があるため、pmaxにn2をかけ、その後page-1をかけます。
それに1を足すのは、1ページ目が0番目のページであるとしているためです。4行目では、pageページに含まれる最初の名刺の番号を計算しています。pminには、pmaxからn*2-1を引いた数が入ります。
この式は、pageページの最初の名刺の番号がpage-1ページの最後の名刺の番号に1を足したものであることから導かれます。
5行目では、m番目の名刺の裏面にある名刺の番号を計算しています。mは、pageページの中で何番目の名刺なのかを計算します。pageページの最初の名刺の番号から、m番目の名刺の番号を引いたものが、m番目の名刺の裏面にある名刺の番号になります。
'''

# B012 ◆
# B013 ◆
# B014 3Dプリンタ
# utf-8
X,Y,Z=list(map(int,input().split()))
m=[['.' for j in range(Y)] for i in range(Z)]
for k in range(Z):
    for i in range(X):
        n=input()
        for j in range(Y):
            if n[j]=='#':
                m[k][j]='#'
    l=input()
for i in reversed(range(Z)):
    l=map(str,m[i])
    s=''.join(l)
    print(s)
'''
入力されたX,Y,Zに対して、Z枚のX行Y列のマス目を作成しています。マス目は、二次元リストで表現されています。
そして、入力されたマス目の状態を、マス目に反映させます。
最後に、マス目を反転させ、反転したマス目を出力します。
ここで、マス目の反転は、reversed(range(Z))を使用して、Zから0までの範囲を逆順に取得していることで実現されています。
また、map(str, m[i])を使用して、マス目を文字列に変換し、join()関数でつなげて、横一列の文字列として出力しています。
'''

# B015 7セグメントディスプレイ（デジタル表示の数字）
# B016 ここはどこ？
# utf-8
class B016:
    def __init__(self):
        info = input().split()
        self.board = {"W": int(info[0]), "H": int(info[1])}
        self.move_times = int(info[2])
        self.player = {}

    def set_player_position(self):
        position = input().split()
        self.player["X"] = int(position[0])
        self.player["Y"] = int(position[1])

    def set_move_info(self):
        self.move_info = []
        for i in range(self.move_times):
            move = input().split()
            self.move_info.append({"dir": move[0], "step": int(move[1])})

    def get_final_position(self):
        for move in self.move_info:
            self.move(move["dir"], move["step"])

    def move(self, direction, step):
        if direction == "U":
            step = step % self.board["H"]
            if self.player["Y"] + step > self.board["H"] - 1:
                self.player["Y"] = step - (self.board["H"] - self.player["Y"])
            else:
                self.player["Y"] += step
        elif direction == "D":
            step = step % self.board["H"]
            if self.player["Y"] - step < 0:
                self.player["Y"] = self.board["H"] - (step - self.player["Y"])
            else:
                self.player["Y"] -= step
        elif direction == "L":
            step = step % self.board["W"]
            if self.player["X"] - step < 0:
                self.player["X"] = self.board["W"] - (step - self.player["X"])
            else:
                self.player["X"] -= step
        elif direction == "R":
            step = step % self.board["W"]
            if self.player["X"] + step > self.board["W"] - 1:
                self.player["X"] = step - (self.board["W"] - self.player["X"])
            else:
                self.player["X"] += step

    def display(self):
        print("{} {}".format(self.player["X"], self.player["Y"]))

b016 = B016()
b016.set_player_position()
b016.set_move_info()
b016.get_final_position()
b016.display()
'''
このコードは、与えられた初期位置と移動ログに基づいて、移動後の位置を計算して出力するプログラムです。
まず、1行目でマップの横幅 w、縦幅 h、移動ログの個数 nを読み取ります。2行目では初期位置 x, yを読み取り、3行目からn+2行目までの各行で移動ログを読み取ります。
移動ログには、「dir_i」と「m_i」があり、「dir_i」は移動する方向（"U"、"D"、"R"、"L"）を、「m_i」は移動する距離を表しています。各ログに基づいて、プログラムは現在の位置から移動後の位置を計算し、最後に移動後の位置を出力します。
「move」メソッドは、与えられた方向と距離に応じて、与えられた座標を更新する関数です。プログラムは、与えられた移動ログに基づいて、「move」メソッドを呼び出し、プレイヤーの位置を更新します。
最後に、「display」メソッドは、プレイヤーの最終位置を出力します。
'''

# B017 手役の強さ(花札)
# B018 ◆
# B019 グレースケールの画像の縮小
# B020 ネットサーフィン
--------------------------------------------- B021　※欠番 ◆
# B021 ◆
# B022 ◆
# B023 マッチ棒パズル
# B024 格子を円で切り取る
# B025 うさぎジャンプ
# B026 自動販売機
# B027 ◆
# B028 チャット記録
# B029 地価の予想
# B030 氷のダンジョン
--------------------------------------------- B031　※欠番 ◆
# B031 コインのウラとオモテ
# B032 デジタル計算機
# B033 テーブルジェネレーター
# B034 ロボットの歩行実験
# B035 ジョギングランキング
# B036 大統領選挙
# B037 幸運な1年
# B038 つるかめ算
# B039 雨上がりの道
# B040 たのしい暗号解読
--------------------------------------------- B041　※欠番 ◆
# B041 繰り返し模様
# B042 横入りするネコ
# B043 ねずみ小僧
# B044 爆弾ゲーム
# B045 計算ドリル
# B046 街の距離
# B047 ホームポジション
# B048 理想のビンゴ
# B049 ◆
# B050 有効なチケット
--------------------------------------------- B051　※欠番 ◆
# B051 ◆
# B052 積もる粒子
# B053 表の自動作成
# B054 不思議な足し算
# B055 ◆
# B056 リズムゲームの分析
# B057 回転寿司
# B058 ◆
# B059 占領区域
# B060 サイコロころがし
--------------------------------------------- B061　※欠番 ◆
# B061 福袋詰め
# B062 部屋掃除ロボット
# B063 支払う枚数とお釣りの枚数
# B064 うずを探せ
# B065 小さなライフゲーム
# B066 色のパズル
# B067 タスクの管理
# B068 チョコの分割
# B069 蟻の餌探し
# B070 駒の到達範囲
--------------------------------------------- B071　※欠番 ◆
# B071 ダンベルトレーニング
# B072 反転スイッチ
# B073 イルミネーションの調査
# B074 コメントの順序
# B075 商品の表示
# B076 パン屋さん
# B077 チケットの売り場
# B078 動画視聴スケジュール
# B079 相性チェック
# B080 みんなでスゴロク
--------------------------------------------- B081　※欠番 ◆
# B081 花壇のロープ
# B082 休暇の取り方
# B083 宝の地図
# B084 オススメのお店
# B085 宝探しの手順
# B086 公平な分割
# B087 隠された数
# B088 ロボットのデバッグ
# B089 秘密の言葉
# B090 選挙の議席
--------------------------------------------- B091　※欠番 ◆
# B091 山頂を探せ
# B092 セーブポイント
# B093 SNSの検索機能
# B094 ◆
# B095 カラオケ大会
# B096 ビンゴゲーム
# B096(2) 爆弾の大爆発
# B097 カウンター席
# B098 バズの検出
# B099 台風の接近
# B100 計算の遅延
--------------------------------------------- B101　※欠番 ◆
# B101 ◆
# B102 膨張と収縮
# B103 ◆
# B104 データのクレンジング
# B105 マッピングゲーム
# B106 席替えの席決め
# B107 カードシャッフル
# B108 観覧車の稼働状況
# B109 映画館の席の予約
# B110 解像度の向上
--------------------------------------------- B111　※欠番 ◆
# B111 天秤のつりあい
# B112 くじの作成
# B113 2のべき連結ゲーム
# B114 PAIZA運動会
# B115 アナグラムパズル
# B116 プレゼント交換
# B117 回る教習車
# B118 背の順
# B119 投網
# B120 ◆
--------------------------------------------- B121　※欠番 ◆
# B121 床の模様替え
# B122 うわさ
# B123 ビットゲーム
# B124 名前が似ている友達
# B125 工場のボトルネック
# B126 ダンスパーティー
# B127 ◆
# B128 簡易的二次元バーコード
# B129 n毛作
# B130 ブロック挿入
--------------------------------------------- B131　※欠番 ◆
# B131 運賃計算
# B131(2) 復号の処理
# B132
# B133
# B134
# B135
# B136
# B137
# B138
# B139
# B140
-----------------------------------------------B141　※欠番◆
