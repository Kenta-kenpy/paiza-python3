※欠番が存在する理由につきましては、出題自体を公開終了した問題が欠番となっております。

--------------------------------------------- B001　※欠番 ◆
# B001 ◆
# B002 ◆
# B003 ◆
# B004 ログファイルの抽出
# utf-8
def isValidIp(m, c):
    ret = False
    if m == "*" or m == c:
        ret = True
    elif m[0] == "[":
        a = m.split("-")
        ss = int(a[0].replace("[", ""))
        ee = int(a[1].replace("]", ""))
        if ss <= int(c) <= ee:
            ret = True
    return ret


def main():
    # IPアドレスを読み込む
    mip = input().strip().split(".")
    
    # ログの数を読み込む
    n = int(input())
    
    # ログを1行ずつ読み込み、IPアドレスをチェックする
    for i in range(n):
        s = input().strip().split(" ")
        tip = s[0].split(".")
        if mip[0] == tip[0] and \
           mip[1] == tip[1] and \
           isValidIp(mip[2], tip[2]) and \
           isValidIp(mip[3], tip[3]):
            print(s[0] + " " + s[3][1:] + " " + s[6])


if __name__ == '__main__':
    main()
'''
1 標準入力からIPアドレスとログの数を取得し、IPアドレスを「.」で分割してリストに格納する
2 ログの数だけ繰り返し、1行ずつログを取得する
3 取得したログのIPアドレスを「.」で分割してリストに格納する
4 IPアドレスの1〜3オクテットが一致し、4オクテットが以下の条件を満たす場合に、ログの情報を出力する
　・IPアドレスの4オクテットが、IPアドレスの4オクテットと完全一致する場合
　・IPアドレスの4オクテットが、ワイルドカード「*」の場合
　・IPアドレスの4オクテットが、範囲指定の場合（「[」と「]」で囲まれた範囲内の数値のみ許可される）
具体的には、以下のような関数を定義して使用しています。
isValidIp(m, c)
　・引数mが「*」またはcと完全一致する場合はTrueを返す
　・引数mが範囲指定の場合は、引数cが範囲内にある場合はTrueを返す
このコードは、ログのIPアドレスが与えられたIPアドレスにマッチするかどうかを判定する処理を行っており、与えられたIPアドレスがワイルドカードや範囲指定を含んでいる場合にも対応しています。
'''

# B005 ◆　
# B006 ダーツゲーム
# utf-8
# 標準入力からの値の取得
import sys
input_line = sys.stdin.read()
input_list = input_line.split()

# 初期値の設定
o_y = float(input_list[0])
s = float(input_list[1])
theta = float(input_list[2])
x = float(input_list[3])
y = float(input_list[4])
a = float(input_list[5])

# 矢が当たるかどうかの判定
import math
g = 9.8
rad = math.radians(theta)
t = x / (s * math.cos(rad))
y2 = o_y + s * math.sin(rad) * t - (g * t ** 2) / 2
if y - a / 2 <= y2 <= y + a / 2:
    # 当たった場合、的の中心からの距離を出力
    dist = abs(y2 - y)
    print("Hit {:.1f}".format(round(dist, 1)))
else:
    # 当たらなかった場合、Missを出力
    print("Miss")
'''
以下の手順で矢が的に当たるかどうかを判定し、当たった場合には的の中心からの距離を出力します。
まず、sys.stdin.read()で標準入力から値を読み込み、split()でスペース区切りの文字列をリストに変換します。
次に、リストから必要な値を取り出し、float()で数値に変換します。
これで、矢の初期値点の高さ o_y、初速 s、角度 theta、的までの距離 x、的の高さ y、的の大きさ a がそれぞれ変数に格納されました。

矢が当たるかどうかの判定には、以下の計算式を使用します。
y2 = o_y + s * sin(rad) * t - (g * t^2) / 2
ここで、radはthetaをラジアンに変換したもの、tは矢が的に当たるまでの時間です。この式は、矢の初期値点から投げた瞬間の高さ o_y に、矢が的に当たるまでに到達する高さを足し合わせたものを計算し、的の高さ y ± 的の大きさ a の範囲内にあるかどうかを判定します。

具体的には、以下のように計算します。
import math

# 重力加速度
g = 9.8

# 角度をラジアンに変換
rad = math.radians(theta)

# 矢が的に当たるまでの時間
t = x / (s * math.cos(rad))

# 矢が的に当たるときの高さ
y2 = o_y + s * math.sin(rad) * t - (g * t ** 2) / 2

矢が当たるかどうかを判定する部分では、まず重力加速度を9.8[m/s^2]として、投射角度θに対しての水平方向と鉛直方向の初速度を求めます。そして、投射角度θと初速度sを用いて、到達時間tを求めます。tを用いて、矢の到達位置y2を計算します。その後、的の位置yから、的の半径a/2の範囲内に矢の到達位置y2があるかどうかを判定しています。
当たった場合は、的の中心からの距離を求めています。このとき、求めた距離を絶対値をとっているのは、矢が的の上側に当たった場合でも、的の中心からの距離を正しく求めるためです。また、四捨五入して小数点第1位までの数値を出力するには、Pythonの組み込み関数であるround()関数を使います。
当たらなかった場合は、"Miss"を出力しています。
'''

# B007 ◆
# B008 ◆
# B009 カンファレンスのタイムテーブル作成
# utf-8
# coding: utf-8

# 分を時刻表記に変換する関数　m分をhh:mm形式の文字列に変換する関数
def m2h(m):
    hour = m // 60 % 24  # 24時間制での時間を算出
    minute = m % 60  # 分を算出
    return f'{hour:02}:{minute:02}'  # hh:mm形式の文字列に変換して返す

# 時刻表記を分に変換する関数　hh:mm形式の文字列をm分に変換する関数
def h2m(h):
    hour, minute = map(int, h.split(':'))  # : を区切り文字として文字列を分割して、時と分に分ける
    return hour * 60 + minute  # 時を分に変換して分と合算し、分単位で返す

# 各プレゼンテーションの開始・終了時刻を計算する関数　スケジュールの時間計算を行う関数
def presentation_time(start_time, duration):
    global rest   # お昼休憩のフラグ　# グローバル変数 rest を参照するため、global宣言
    noon = h2m('12:00')  # 12:00を分単位に変換して、お昼の時間として取得
    end_time = start_time + duration  # 終了時刻を算出
    if not rest and noon < end_time:  # お昼休憩が必要かどうかを判定　# 休憩をとっておらず、終了時刻がお昼を過ぎている場合
        start_time += 60 - 10  # お昼休憩をとるために開始時刻をずらす　# お昼休憩を含む1時間の空きを作るために10分引いた時間に移動
        end_time = start_time + duration  # 新しい終了時刻を再度算出
        rest = True  # 休憩を取ったことをフラグに設定
    return start_time, end_time  # スケジュールの開始時間と終了時間を返す

n = int(input())  # # プレゼンテーションスケジュールの個数を入力

start_time = h2m('10:00')  # 最初のプレゼンテーションの開始時刻を10:00として、分単位に変換して取得

rest = False  # お昼休憩をとっていないことをフラグに設定　お昼休憩のフラグを初期化
for _ in range(n):  # スケジュールの個数だけ繰り返し処理を実行
    name, duration = input().split()  # スケジュール名と時間を入力として受け取る
    start_time, end_time = presentation_time(start_time, int(duration))  # スケジュールの開始時間と終了時間を計算
    print(f'{m2h(start_time)} - {m2h(end_time)} {name}')  # スケジュールの時間と名前を出力
    start_time = end_time + 10 # 休憩時間10分を加算して次のプレゼンテーションの開始時刻を計算する
'''
m2h() 関数
この関数は、分単位の時間を時:分の形式の文字列に変換するためのものです。
入力された分を60で割った余りが分の値、60で割った商を24で割った余りが時の値として取得します。
最後に、f-string を使って、"時:分" の形式で文字列を生成し、それを返します。

h2m() 関数
この関数は、時:分の形式の文字列を分単位の時間に変換するためのものです。
split() 関数を使って、文字列を ":" で分割し、時と分の値を取得します。
時を60で掛けたものに分を足し合わせて、分単位の時間を計算し、それを返します。

presentation_time() 関数
この関数は、スピーカーのプレゼンテーションの開始時間と終了時間を計算するためのものです。
引数として、スピーカーのプレゼンテーションの開始時間と時間の長さを受け取ります。
global キーワードを使って、rest 変数をグローバル変数として宣言します。
noon 変数には、12:00の分単位の時間を代入します。
end_time 変数には、プレゼンテーションの終了時間を代入します。
rest 変数が False かつ noon より end_time が後の場合、つまり、プレゼンテーションがお昼休憩をまたいでいる場合、開始時間にお昼休憩の10分を足した時間から再スタートし、終了時間を再計算します。
最後に、開始時間と終了時間を返します。

それ以降のメイン部分
まず、n = int(input())で発表する人数nを受け取ります。
次に、発表が始まる開始時間を表す変数start_timeに、10:00の時間をh2m('10:00')を使って分単位で代入します。
そして、restフラグをFalseで初期化します。これは、お昼休憩のチェックのために使用されます。
forループを使って、各発表の時間を処理します。forループの中で、name, duration = input().split()で発表者の名前nameと発表時間durationを受け取ります。このdurationは単位が分であり、整数型であることに注意してください。
次に、presentation_time(start_time, int(duration))を呼び出して、発表の終了時刻を計算し、その時間を人間が読みやすい形式で出力します。presentation_time関数は、start_timeと発表時間durationを引数として受け取り、終了時間のタイムスタンプ（分単位）を返します。
また、restフラグがFalseである場合は、終了時間が12:00を超える場合に、お昼休憩の時間（10分）を追加します。noon = h2m('12:00')で、12:00の時間を分単位で取得します。そして、noonよりも終了時間が後である場合に、start_time += 60 - 10で、お昼休憩を考慮した新しい開始時間を計算します。最後に、restフラグをTrueに設定します。
各発表が終わった後、start_timeにend_time + 10を代入して、次の発表の開始時間を計算します。この+ 10は、前の発表の終了時間と次の発表の開始時間の間に10分の休憩時間が必要であることを示しています。
'''

# B010 サッカーのオフサイド判定
# utf-8
def team_lineup(players, reverse=False):
    if reverse:
        players = list(map(lambda x:-x, players))
    return zip(range(1, 12), players)

def is_offside(x_player, x_passer, x_offside_line):
    return x_passer < x_offside_line < x_player

def get_offside_players(offence_team, diffence_team, x_passer, x_offside_line):
    offside_players = []
    for idx, x_p in enumerate(offence_team):
        if is_offside(x_p, x_passer, x_offside_line):
            offside_players.append(idx+1)
    return offside_players

def get_offside_line(diffence_team):
    return sorted(diffence_team, reverse=True)[1]

def get_opponent(name):
    return 'A' if name == 'B' else 'B'

# main
offence_name, passer = input().split()
team = {}
team['A'] = list(map(int, input().split()))
team['B'] = list(map(int, input().split()))

if offence_name == 'B':
    for t in team:
        team[t] = list(map(lambda x:-x, team[t]))

diffence_name = get_opponent(offence_name)
offence_team = team[offence_name]
diffence_team = team[diffence_name]

x_offside_line = get_offside_line(diffence_team)
x_passer = int(offence_team[int(passer)-1])

offside_players = get_offside_players(offence_team, diffence_team, x_passer, x_offside_line)

if offside_players:
    for p in offside_players:
        print(p)
else:
    print('None')
'''
与えられたサッカーの試合状況に対して、次のパスを受け取るとオフサイドと判定される選手の背番号を小さいものから順に1行ずつ出力するものです。
まず、input()関数を使って標準入力から入力を受け取ります。1行目では攻撃するチームの名前(offence_name)と、パスを受け取る選手の背番号(passer)をスペース区切りで受け取り、
2行目と3行目ではそれぞれ攻撃するチームの選手の背番号(team_a_numbers, team_b_numbers)をスペース区切りで受け取ります。
次に、攻撃するチームと守備するチームの背番号をリストで保持します。if文で、offence_nameが'B'の場合、攻撃するチームと守備するチームの背番号を反転させます。
この処理によって、攻撃するチームが必ずAチームになるようにしています。
次に、守備するチームの最後尾から2番目の背番号を取得します。この背番号より前に攻撃するチームの選手がいる場合、オフサイドの判定が行われます。
最後に、攻撃するチームの選手の中でオフサイドとなる選手の背番号を出力します。オフサイドとなる選手がいない場合には、"None"を出力します。
このコードのポイントは、オフサイド判定を行うis_offside関数にあります。この関数は、与えられた選手の背番号(x_player)、パスを出した選手の背番号(x_passer)、
そして守備するチームのオフサイドラインの背番号(x_offside_line)を受け取り、オフサイド判定を行います。
オフサイド判定は、パスを出した選手より前方に守備するチームのオフサイドラインと、パスを受けた選手が存在する場合に成立します。
'''

--------------------------------------------- B011　※欠番 ◆
# B011 名刺バインダー管理
# utf-8
n, m = map(int, input().split())

# m番目の名刺が含まれるページを計算する
page = (m - 1) // (n * 2) + 1

# そのページの最後の名刺番号と最初の名刺番号を計算する
last_card_num = page * n * 2
first_card_num = last_card_num - (n * 2 - 1)

# m番目の名刺が表面か裏面かによって、裏側の名刺の番号を計算する
if m <= (first_card_num + n - 1):
    back_card_num = last_card_num - (m - first_card_num)
else:
    back_card_num = first_card_num + (last_card_num - m)

print(back_card_num)
'''
1行目では、入力された文字列をスペースで分割し、それぞれ整数型に変換して、nとmに代入しています。
2行目では、m番目の名刺が属するページ数を求めています。m-1をn*2で割り、+1をしているのは、pythonで整数を割った場合、小数点以下が切り捨てられるためです。
また、m-1をする理由は、1番目の名刺が0ページ目にあるとみなすためです。3行目では、pageページに含まれる最後の名刺の番号を計算しています。pageページには、n2枚の名刺があるため、pmaxにn2をかけ、その後page-1をかけます。
それに1を足すのは、1ページ目が0番目のページであるとしているためです。4行目では、pageページに含まれる最初の名刺の番号を計算しています。pminには、pmaxからn*2-1を引いた数が入ります。
この式は、pageページの最初の名刺の番号がpage-1ページの最後の名刺の番号に1を足したものであることから導かれます。
5行目では、m番目の名刺の裏面にある名刺の番号を計算しています。mは、pageページの中で何番目の名刺なのかを計算します。pageページの最初の名刺の番号から、m番目の名刺の番号を引いたものが、m番目の名刺の裏面にある名刺の番号になります。
'''

# B012 ◆
# B013 ◆
# B014 3Dプリンタ
# utf-8
X,Y,Z=list(map(int,input().split()))
m=[['.' for j in range(Y)] for i in range(Z)]
for k in range(Z):
    for i in range(X):
        n=input()
        for j in range(Y):
            if n[j]=='#':
                m[k][j]='#'
    l=input()
for i in reversed(range(Z)):
    l=map(str,m[i])
    s=''.join(l)
    print(s)
'''
入力されたX,Y,Zに対して、Z枚のX行Y列のマス目を作成しています。マス目は、二次元リストで表現されています。
そして、入力されたマス目の状態を、マス目に反映させます。
最後に、マス目を反転させ、反転したマス目を出力します。
ここで、マス目の反転は、reversed(range(Z))を使用して、Zから0までの範囲を逆順に取得していることで実現されています。
また、map(str, m[i])を使用して、マス目を文字列に変換し、join()関数でつなげて、横一列の文字列として出力しています。
'''

# B015 7セグメントディスプレイ（デジタル表示の数字）　※テストケース通過せず
# utf-8
def check_display(a, b):
    # 各数字に対応する7セグメントディスプレイの状態
    digits = {
        0: [1, 1, 1, 1, 1, 1, 0],
        1: [0, 1, 1, 0, 0, 0, 0],
        2: [1, 1, 0, 1, 1, 0, 1],
        3: [1, 1, 1, 1, 0, 0, 1],
        4: [0, 1, 1, 0, 0, 1, 1],
        5: [1, 0, 1, 1, 0, 1, 1],
        6: [1, 0, 1, 1, 1, 1, 1],
        7: [1, 1, 1, 0, 0, 0, 0],
        8: [1, 1, 1, 1, 1, 1, 1],
        9: [1, 1, 1, 1, 0, 1, 1]
    }

    def is_valid_display(display):
        # ディスプレイの状態が各数字のいずれかと一致するかを判定
        for digit in digits.values():
            if display == digit:
                return True
        return False

    def symmetric_move(display):
        # 対称移動を行った後のディスプレイの状態を返す
        return display[::-1]

    def rotate_move(display):
        # 回転移動を行った後のディスプレイの状態を返す
        return display[-1:] + display[:-1]

    # 1. 装置が正しく2桁の数字を表すかを判定
    condition1 = is_valid_display(a) and is_valid_display(b)

    # 2. 装置を対称移動すると正しく2桁の数字を表すかを判定
    a_symmetric = symmetric_move(a)
    b_symmetric = symmetric_move(b)
    condition2 = is_valid_display(a_symmetric) and is_valid_display(b_symmetric)

    # 3. 装置を回転移動すると正しく2桁の数字を表すかを判定
    a_rotated = rotate_move(a)
    b_rotated = rotate_move(b)
    condition3 = is_valid_display(a_rotated) and is_valid_display(b_rotated)

    # 結果を出力
    result = ["Yes" if condition else "No" for condition in [condition1, condition2, condition3]]
    return "\n".join(result)


# 入力の読み込みと結果の出力
a = list(map(int, input().split()))
b = list(map(int, input().split()))
print(check_display(a, b))

# B016 ここはどこ？
# utf-8
class B016:
    def __init__(self):
        info = input().split()
        self.board = {"W": int(info[0]), "H": int(info[1])}
        self.move_times = int(info[2])
        self.player = {}

    def set_player_position(self):
        position = input().split()
        self.player["X"] = int(position[0])
        self.player["Y"] = int(position[1])

    def set_move_info(self):
        self.move_info = []
        for i in range(self.move_times):
            move = input().split()
            self.move_info.append({"dir": move[0], "step": int(move[1])})

    def get_final_position(self):
        for move in self.move_info:
            self.move(move["dir"], move["step"])

    def move(self, direction, step):
        if direction == "U":
            step = step % self.board["H"]
            if self.player["Y"] + step > self.board["H"] - 1:
                self.player["Y"] = step - (self.board["H"] - self.player["Y"])
            else:
                self.player["Y"] += step
        elif direction == "D":
            step = step % self.board["H"]
            if self.player["Y"] - step < 0:
                self.player["Y"] = self.board["H"] - (step - self.player["Y"])
            else:
                self.player["Y"] -= step
        elif direction == "L":
            step = step % self.board["W"]
            if self.player["X"] - step < 0:
                self.player["X"] = self.board["W"] - (step - self.player["X"])
            else:
                self.player["X"] -= step
        elif direction == "R":
            step = step % self.board["W"]
            if self.player["X"] + step > self.board["W"] - 1:
                self.player["X"] = step - (self.board["W"] - self.player["X"])
            else:
                self.player["X"] += step

    def display(self):
        print("{} {}".format(self.player["X"], self.player["Y"]))

b016 = B016()
b016.set_player_position()
b016.set_move_info()
b016.get_final_position()
b016.display()
'''
このコードは、与えられた初期位置と移動ログに基づいて、移動後の位置を計算して出力するプログラムです。
まず、1行目でマップの横幅 w、縦幅 h、移動ログの個数 nを読み取ります。2行目では初期位置 x, yを読み取り、3行目からn+2行目までの各行で移動ログを読み取ります。
移動ログには、「dir_i」と「m_i」があり、「dir_i」は移動する方向（"U"、"D"、"R"、"L"）を、「m_i」は移動する距離を表しています。各ログに基づいて、プログラムは現在の位置から移動後の位置を計算し、最後に移動後の位置を出力します。
「move」メソッドは、与えられた方向と距離に応じて、与えられた座標を更新する関数です。プログラムは、与えられた移動ログに基づいて、「move」メソッドを呼び出し、プレイヤーの位置を更新します。
最後に、「display」メソッドは、プレイヤーの最終位置を出力します。
'''

# B017 手役の強さ(花札)
# utf-8
class StrongestMeans:
    def __init__(self, cards):
        self.cards = cards
        self.countOfCard = {}

    def getMeans(self):
        self.countCard()

        means = ""
        max_count = max(self.countOfCard.values())
        if max_count == 1:
            means = "NoPair"
        elif max_count == 2:
            means = "TwoPair" if len(self.countOfCard) == 2 else "OnePair"
        elif max_count == 3:
            means = "ThreeCard"
        elif max_count == 4:
            means = "FourCard"

        return means


    def countCard(self):
        for card in self.cards:
            if card == "*":
                self.plusAllKindCardOne()
            else:
                self.plusSpecifiedCardOne(card)


    def plusAllKindCardOne(self):
        cards = set(self.cards)
        for card in cards:
            if card != "*":
                self.plusSpecifiedCardOne(card)


    def plusSpecifiedCardOne(self, card):
        self.countOfCard[card] = self.countOfCard.get(card, 0) + 1


cards = input().strip()
strongMeans = StrongestMeans(list(cards))
print(strongMeans.getMeans())
'''
このコードは、入力のフォーマットに合わせてカードの入力を受け取り、StrongestMeansクラスのインスタンスを作成して、getMeansメソッドを呼び出し、結果を表示しています。
注意点：
カードの入力は、スペースで区切られた4つの文字列として受け取ります。
input().strip()を使って末尾の改行文字を除去します。
入力の最後には余分な文字や空行が含まれていないことを確認してください。
このコードを使用して、与えられた入力に基づいて最高の手役を判定し、出力することができます。

まず、StrongestMeansという名前のクラスが定義されています。このクラスは、カードの集合から手役の強さを判定するためのメソッドを提供します。
__init__メソッドは、cardsという引数を受け取り、インスタンスの初期化を行います。cardsは入力されたカードのリストです。countOfCardはカードの出現回数を格納するための辞書です。
getMeansメソッドは手役の強さを返します。まず、countCardメソッドを呼び出してカードの出現回数を数えます。
次に、countOfCard辞書の値の中で最大の数を取得します。その最大数に応じて手役を判定し、meansに結果を格納します。

countCardメソッドは、カードの出現回数を数えるためのメソッドです。self.cardsの各カードについて、cardとして処理します。
もしcardがワイルドカード "*" ならば、plusAllKindCardOneメソッドを呼び出します。
そうでない場合は、plusSpecifiedCardOneメソッドを呼び出して指定されたカードの出現回数を増やします。

plusAllKindCardOneメソッドは、ワイルドカード "*" の場合に他のすべてのカードの出現回数を増やすためのメソッドです。
self.cardsのユニークな要素を取得し、それぞれのカードについて処理します。
'''

# B018 ◆
# B019 グレースケールの画像の縮小
# utf-8
def shrink_image(N, K, pixels):
    # N/K × N/Kの画像を作成
    new_N = N // K
    new_pixels = [[0] * new_N for _ in range(new_N)]

    # 各ブロックの平均値を計算
    for r in range(new_N):
        for c in range(new_N):
            block_sum = 0
            for i in range(r * K, (r + 1) * K):
                for j in range(c * K, (c + 1) * K):
                    block_sum += pixels[i][j]
            average = block_sum // (K * K)
            new_pixels[r][c] = average

    return new_pixels

# 入力を受け取る
N, K = map(int, input().split())
pixels = []
for _ in range(N):
    row = list(map(int, input().split()))
    pixels.append(row)

# 画像を縮小
result = shrink_image(N, K, pixels)

# 結果を出力
for row in result:
    print(*row)
'''
shrink_image(N, K, pixels) 関数は、元の画像を指定されたブロックサイズで縮小するための関数です。関数は以下の手順で動作します。

元の画像のサイズ N とブロックサイズ K を受け取ります。
新しい画像のサイズ new_N を計算します。new_N は N を K で割った商です。
新しい画像を表現するための二次元リスト new_pixels を作成します。サイズは new_N × new_N です。
各ブロックの平均値を計算し、新しい画像のピクセル値として new_pixels に格納します。
最終的に new_pixels を返します。
メインのプログラムでは、以下の手順で処理が行われます。

元の画像のサイズ N とブロックサイズ K を入力します。
N 行のピクセル値を受け取り、二次元リスト pixels に格納します。
shrink_image(N, K, pixels) 関数を呼び出して、画像を縮小します。結果は result に格納されます。
result を出力します。
'''

# B020 ネットサーフィン
# utf-8
n = int(input())  # クエリの数を取得
queries = []  # クエリを保持するリスト
history = ["blank page"]  # ページの履歴を保持するリスト

# クエリを入力してリストに追加
for _ in range(n):
    queries.append(input())

# 各クエリを処理
for query in queries:
    if query == "use the back button":
        if len(history) > 1:
            history.pop()  # 直前のページを履歴から削除
        print(history[-1])  # 現在のページを出力
    else:
        page_name = query[6:]  # ページ名を取得
        history.append(page_name)  # ページを履歴に追加
        print(page_name)  # ページ名を出力

print()  # 最後の改行を出力
'''
このコードでは、まずクエリの数を取得し、その後のクエリをリストに追加します。それぞれのクエリに対して以下の処理を行います。

"use the back button" の場合:

履歴が1つ以上存在する場合は、直前のページを履歴から削除します。
現在のページを出力します。
"go to [page_name]" の場合:

ページ名を取得し、履歴に追加します。
ページ名を出力します。
最後に改行を出力します。

この修正により、最初のページが "blank page" であること、"use the back button" の場合でも "blank page" 以外の指定されたページを開くこと、各テストケースでの出力例が要件を満たすようになります。

修正後のコードでは、入力例に対する出力例も要件を満たすようになります。それぞれのクエリに対して適切なページを開き、履歴を保持しながら出力しています。
'''
--------------------------------------------- B021　※欠番 ◆
# B021 ◆
# B022 ◆
# B023 マッチ棒パズル
# utf-8
def get_another(a, b):
    for i in range(len(a)):
        a[i] = b[i]
    return a


def set_number(number):
    number[0][0] = "69"
    number[0][1] = "8"
    number[0][2] = ""

    number[1][0] = ""
    number[1][1] = "7"
    number[1][2] = ""

    number[2][0] = "3"
    number[2][1] = ""
    number[2][2] = ""

    number[3][0] = "25"
    number[3][1] = "9"
    number[3][2] = ""

    number[4][0] = ""
    number[4][1] = ""
    number[4][2] = ""

    number[5][0] = "3"
    number[5][1] = "69"
    number[5][2] = ""

    number[6][0] = "09"
    number[6][1] = "8"
    number[6][2] = "5"

    number[7][0] = ""
    number[7][1] = ""
    number[7][2] = "1"

    number[8][0] = ""
    number[8][1] = ""
    number[8][2] = "069"

    number[9][0] = "06"
    number[9][1] = "8"
    number[9][2] = "35"

    return number


def main():
    charS = input().strip()
    result = []

    number = [["" for _ in range(3)] for _ in range(10)]
    number = set_number(number)

    temp = list(charS)
    temp = get_another(temp, list(charS))
    for i in range(len(charS)):
        for j in range(3):
            point = int(charS[i])

            for k in range(len(number[point][j])):
                if j == 0:
                    temp[i] = number[point][0][k]
                    output = "".join(temp)
                    result.append(output)
                    temp = get_another(temp, list(charS))
                elif j == 1:
                    for l in range(i + 1, len(charS)):
                        point2 = int(charS[l])
                        for m in range(len(number[point2][2])):
                            temp[i] = number[point][1][k]
                            temp[l] = number[point2][2][m]
                            output = "".join(temp)
                            result.append(output)
                            temp = get_another(temp, list(charS))
                else:
                    for l in range(i + 1, len(charS)):
                        point2 = int(charS[l])
                        for m in range(len(number[point2][1])):
                            temp[i] = number[point][2][k]
                            temp[l] = number[point2][1][m]
                            output = "".join(temp)
                            result.append(output)
                            temp = get_another(temp, list(charS))

    result.sort()

    if len(result) == 0:
        print("none")
    else:
        for i in range(len(result)):
            print(result[i])
main()
'''
get_another(a, b) 関数:
リスト a をリスト b の要素で上書きする関数です。
a と b の要素数は同じである必要があります。
set_number(number) 関数:
number という2次元リストを引数として受け取り、特定のパターンで要素を初期化します。
この関数は number リストを返します。
main() 関数:
・プログラムのエントリーポイントとなる関数です。
・入力文字列 charS を受け取り、結果のリスト result を初期化します。
・2次元リスト number を set_number() 関数で初期化します。
・charS の各文字を処理するループを開始します。
・charS の各文字について、3つのパターン (j の値) に対してループを開始します。
・パターンごとに、数字の置換を行い、結果を result リストに追加します。
・最後に result をソートし、結果を出力します。

このコードのアルゴリズムは、与えられた文字列 charS の各文字に対して、異なるパターンで数字の置換を行い、結果を生成しています。
これにより、全ての可能な置換パターンを網羅的に生成することができます。最終的な結果は辞書順にソートされています。
ただし、このコードでは一部の箇所で冗長な処理が行われており、効率的ではないと言えます。特に、リストのコピー (temp = get_another(temp, list(charS))) や結果のリストに要素を追加する際のループ処理が、改善の余地があります。
'''

# B024 格子を円で切り取る　※数学的アプローチが必要
# utf-8
import math # mathモジュールをインポートして円周率の計算や平方根の計算を行います。

while True: # 無限ループを開始
    try: # 入力を試みます。もし例外が発生した場合、exceptブロックに移動します。
        r = float(input()) # 半径 r の値を浮動小数点数として入力します。
        if r <= 0: # もし r が0以下の場合、無効な入力値として扱い、エラーメッセージを表示して次のループに移ります。
            print("Invalid input: r must be a positive number.")
            continue
        total = 0 # 格子点の合計数を初期化します。
        n = math.ceil(r) # r の値を切り上げて最も近い整数 n にします。これは最小の正方形の一辺の長さとなります。
        for i in range(n + 1): # 0から n までの範囲でループ
            if r * r - i * i < 0: # もし r * r - i * i が0より小さい場合、円の内部にないのでスキップします。
                continue
            total += math.ceil(math.sqrt(r * r - i * i)) # 円の内部にある格子点の数を計算し、それを total に加算します。
        print(total * 4) # 計算された格子点の合計数に4を乗算して出力します。
    except (ValueError, EOFError): # 入力時に ValueError や EOFError の例外が発生した場合、ループを終了します。
        break
'''
このコードでは、入力された半径 r をもとに最小の正方形内の格子点の数を求め、さらに円の内部にある格子点の数を計算しています。
最終的に、格子点の数に4を乗算して出力します。なお、無効な入力や入力の終了（EOF）に対しても適切に処理しているため、例外が発生しても安全に終了できます。
'''

# B025 うさぎジャンプ
# utf-8
# N, M, Kの入力を受け取る
N, M, K = map(int, input().split())

# 各うさぎの現在の位置をリストに格納する
s = [int(input()) for _ in range(M)]

# しげみの状態を管理するリストを作成する（初期値は0）
grass = [0] * N

# 各うさぎの初期位置をしげみのリストに反映する
for i in s:
    grass[i - 1] = i

# Kセットのジャンプを行う
for _ in range(K):
    for j in range(M):
        # うさぎがジャンプ先として選ぶしげみの番号（% nを行うことで範囲内に収める）
        grass_num = s[j] % N
        # ジャンプ先が他のうさぎに占拠されている場合、空いているしげみを探す
        while grass[grass_num] != 0:
            grass_num = (grass_num + 1) % N
        # ジャンプ元のしげみからうさぎを移動させる
        grass[grass_num] = grass[s[j] - 1]
        grass[s[j] - 1] = 0
        # うさぎの位置情報を更新する
        s[j] = grass_num + 1

# 各うさぎの最終位置を出力する
for i in s:
    print(i)
'''
標準入力からN、M、Kの値を受け取ります。それぞれ、しげみの数N、うさぎの数M、ジャンプ回数Kを表します。
うさぎの現在位置をリストsに格納しています。range(m)でうさぎの数M回ループし、int(input())によって各うさぎの位置を受け取ります。
しげみの状態を管理するためのリストgrassを作成、初期値は全て0です。次のループでは、リストsに格納されている各うさぎの位置情報を、リストgrassに反映させています。
各うさぎの位置-1のインデックスに対応する要素にうさぎの番号を代入しています。Kセットのジャンプを行っています。
外側のループはK回ループします。内側のループでは、各うさぎに対してジャンプ処理を行います。
grass_numはうさぎがジャンプ先として選ぶしげみの番号です。s[j] % nによって範囲内に収められます。
grass[grass_num] != 0は、ジャンプ先のしげみが他のうさぎに占拠されているかどうかを判定しています。もし占拠されている場合、次の空いているしげみを探すためにgrass_numを1ずつ増やしていきます。whileループを抜けた時点で、grass_numには空いているしげみの番号が格納されます。
ジャンプ元のしげみからうさぎを移動させるために、grass[grass_num]にジャンプ元のうさぎの番号を代入し、ジャンプ元のしげみを空にします。
最後に、うさぎの位置情報を更新するためにs[j]にgrass_num + 1を代入します。+ 1はインデックスと番号の差を調整するためです。
'''

# B026 自動販売機　※テストケース通過せず
# utf-8
class VendingMachine:
    def __init__(self, coin_in_machine):
        self.coin_in_machine = coin_in_machine

    def sell_result(self, customers):
        for customer in customers:
            arr_customer = customer.split(" ")
            product_price = int(arr_customer[0])
            use_coin = {
                500: int(arr_customer[1]),
                100: int(arr_customer[2]),
                50: int(arr_customer[3]),
                10: int(arr_customer[4])
            }
            change_coin = {
                500: 0,
                100: 0,
                50: 0,
                10: 0
            }

            change = 500 * use_coin[500] + 100 * use_coin[100] + 50 * use_coin[50] + 10 * use_coin[10] - product_price
            tmp_change = change

            for coin, coin_number in self.coin_in_machine.items():
                self.change(coin, coin_number, change, change_coin[coin])

            message = ""
            if self.check_if_pass(change_coin, tmp_change):
                for coin, count in change_coin.items():
                    message += str(count)
                    if coin != 10:
                        message += " "
            else:
                message = "impossible"
            
            print(message)

    def change(self, coin, coin_number, change, change_coin):
        if change < coin:
            return
        for num in range(coin_number, -1, -1):
            price = change - num * coin
            if price >= 0:
                change -= num * coin
                change_coin = num
                return

    def check_if_pass(self, change_coin, tmp_change):
        if change_coin[50] * 50 + change_coin[10] * 10 >= 100:
            return False
        for coin, coin_number in self.coin_in_machine.items():
            if change_coin[coin] > coin_number:
                return False
        if sum(change_coin.values()) != tmp_change:
            return False
        return True


info = input().strip().split(" ")
coin_in_machine = {
    500: int(info[0]),
    100: int(info[1]),
    50: int(info[2]),
    10: int(info[3])
}

count_of_customer = int(input().strip())
customers = []
for _ in range(count_of_customer):
    customers.append(input().strip())

vending_machine = VendingMachine(coin_in_machine)
vending_machine.sell_result(customers)

# B027 ◆
# B028 チャット記録
# utf-8
# 入力を取得
n, g, m = list(map(int, input().split()))
# グループの情報を取得
k = [list(map(int, input().split())) for i in range(g)]
# 各社員の画面に表示されるメッセージを格納するリストを初期化
N = [[] for i in range(n)]
# メッセージの数だけループ
for i in range(m):
    # メッセージの情報を入力し、送信者、受信者の種類、ターゲット、内容を取得
    s = input().split()
    sender = int(s[0])
    recipient_type = int(s[1])
    target = int(s[2])
    content = s[3:]
    
    # 受信者の種類が0の場合、送信者と受信者の両方の画面にメッセージを追加
    if recipient_type == 0 and sender != target:
        N[sender-1] += content
        N[target-1] += content
    
    # 受信者の種類が1の場合、対象のグループに所属するすべての社員の画面にメッセージを追加
    if recipient_type == 1:
        group_members = k[target-1][1:]  # グループのメンバーを取得
        for member in group_members:
            N[member-1] += content
    
# 各社員の画面に表示されるメッセージを出力
for i in range(n-1):
    print('\n'.join(N[i]))
    print('--')
print('\n'.join(N[-1]))
'''
このコードは、与えられた入力に基づいてメッセージのやり取りをシミュレーションし、各社員の画面に表示されるメッセージを出力します。
まず、社員数 n、グループ数 g、メッセージ数 m を入力します。次に、各グループの情報を入力し、グループに所属する社員のリストを作成します。
その後、メッセージの数だけループを回し、各メッセージに対して以下の処理を行います。
メッセージの情報を入力し、送信者と受信者の種類、ターゲット、内容を取得します。
受信者の種類が 0 の場合、送信者と受信者の両方の画面にメッセージを追加します。
受信者の種類が 1 の場合、対象のグループに所属するすべての社員の画面にメッセージを追加します。
最後に、各社員の画面に表示されるメッセージを出力します。各社員の画面ごとに、メッセージを改行区切りで表示し、最後にハイフンで区切ります。
'''

# B029 地価の予想　※テストケース通過せず
# utf-8
import math
# 入力を受け取る
x, y = map(int, input().split())
k = int(input())
N = int(input())

# 地価データを受け取る
data = []
for _ in range(N):
    xi, yi, pi = map(int, input().split())
    data.append((xi, yi, pi))

# Aからの距離を計算して地点データに追加する
for i in range(N):
    xi, yi, pi = data[i]
    distance = math.sqrt((x - xi) ** 2 + (y - yi) ** 2)
    data[i] = (xi, yi, pi, distance)

# 距離で地点データをソートする
data.sort(key=lambda d: d[3])

# 上位k個の地点の地価を取得して平均を計算する
average_price = sum(d[2] for d in data[:k]) // k  # 整数の除算に修正

# 結果を出力
print(average_price)

# B030 氷のダンジョン　※手順は間違っていないはずだが間違った出力になる
# utf-8
# ダンジョンの情報を受け取る
H, W = map(int, input().split())
dungeon = []
for _ in range(H):
    row = input()
    dungeon.append(row)

# スタート地点の座標を受け取る
s_x, s_y = map(int, input().split())

# 移動回数を受け取る
N = int(input())

# 各移動方向を受け取る
directions = []
for _ in range(N):
    direction = input()
    directions.append(direction)

# 各添字の範囲をチェック
assert 3 <= H <= 100, "Hは3以上100以下の整数である必要があります"
assert 3 <= W <= 100, "Wは3以上100以下の整数である必要があります"
assert 1 <= s_x <= W, "s_xは1以上W以下の整数である必要があります"
assert 1 <= s_y <= H, "s_yは1以上H以下の整数である必要があります"
assert 1 <= N <= 100, "Nは1以上100以下の整数である必要があります"

for i in range(H):
    assert len(dungeon[i]) == W, f"g_{i+1}の長さはWと等しくなる必要があります"
    assert all(c in "#." for c in dungeon[i]), f"g_{i+1}は'#'と'.'で構成されている必要があります"

assert dungeon[s_y-1][s_x-1] == ".", "最初のマスは土の床である必要があります"

for k in range(N):
    assert directions[k] in ["U", "R", "D", "L"], f"d_{k+1}は'U', 'R', 'D', 'L'のいずれかである必要があります"

# 座標値の y が小さくなる方向を上、x が大きくなる方向を右とする
# 移動方向を辞書で表現
direction_dict = {
    "U": (-1, 0),  # 上に移動
    "R": (0, 1),   # 右に移動
    "D": (1, 0),   # 下に移動
    "L": (0, -1)   # 左に移動
}

# 初期位置の設定
x, y = s_x, s_y

# 移動を行う
for direction in directions:
    dx, dy = direction_dict[direction]
    nx, ny = x + dx, y + dy
    # 移動先が氷の床である場合、土の床または壁にぶつかるまで進む
    while dungeon[ny-1][nx-1] == ".":
        nx, ny = x + dx, y + dy
        if dungeon[ny-1][nx-1] == "#":
            break
        x, y = nx, ny

# 結果を出力
print(x, y)

--------------------------------------------- B031　※欠番 ◆
# B031 コインのウラとオモテ　※テストケース通過せず
# utf-8
N = int(input())  # ボードの横の長さNを入力
s = input().strip()  # ゲーム開始時のコインの並びsを入力

def flip_coins(board):
    new_board = list(board)  # ボードをリストに変換
    flipped = False  # 反転が行われたかを示すフラグ

    for i in range(1, N - 1):
        # 黒コインで挟まれた白コインを黒に反転
        if board[i - 1] == 'b' and board[i + 1] == 'b' and board[i] == 'w':
            new_board[i] = 'b'
            flipped = True
        # 白コインで挟まれた黒コインを白に反転
        elif board[i - 1] == 'w' and board[i + 1] == 'w' and board[i] == 'b':
            new_board[i] = 'w'
            flipped = True

    return new_board, flipped

board = list(s)  # コインの並びをリストに変換
flips = 0  # 反転回数のカウンタ

while True:
    board, flipped = flip_coins(board)  # 反転操作を実行
    if not flipped:
        break  # 反転が行われなかった場合、ループを終了
    flips += 1  # 反転回数をインクリメント

black_coins = board.count('b')  # 黒コインの数を数える

if black_coins == 0 or black_coins == N:
    print(black_coins)  # 黒コインが0またはN枚の場合、そのまま出力
else:
    print(black_coins - 1)  # それ以外の場合、黒コインの数から1を引いて出力

# B032 デジタル計算機
# utf-8
class Abacus:
    def __init__(self, width):
        self.width = width

    def get_number(self):
        numbers = []
        # そろばんの状態を入力
        for _ in range(8):
            pearls = input().strip()
            numbers.append(list(pearls))
        
        result = ''
        # 列ごとに珠の移動をシミュレーション
        for pearls in zip(*numbers):
            tmp = 0
            for position, pearl in enumerate(pearls):
                if position < 2:
                    if position == 1 and pearl == '*':
                        tmp += 5  # 上の桁で2つ目の珠が存在し、'*' の場合は5を加算
                    continue
                if position == 2:
                    continue # 3つ目の位置は無視して次の位置へ進む
                if position > 2:
                    if pearl == '|':
                        break   # '|' が現れた場合は珠の移動が終了し、ループから抜ける
                    tmp += 1    # '|' が出現するまで、珠の移動回数をカウント
            result += str(tmp)  # 珠の移動回数を結果に追加

        return int(result.rjust(self.width, '0')) # 結果を指定の桁数に合わせてゼロで左詰めし、整数として返す

    def get_result(self, number):
        result = [['*' if i != 2 else '=' for _ in range(self.width)] for i in range(8)]
        # そろばんの初期状態を生成
        number = str(number).rjust(self.width, '0')
 
        # 数字をそろばんの状態に変換
        for i, digit in enumerate(number):
            digit = int(digit)
            if digit < 5:
                result[0][i] = '*'  # 上の桁の珠
                result[1][i] = '|'  # 下の桁の珠
            else:
                result[0][i] = '|'  # 上の桁の珠

            number = str(digit - 5) if digit >= 5 else str(digit)
            # 数字が5以上の場合は珠を1つ上に移動させた後の数字
            # 数字が5未満の場合は珠を移動させずそのままの数字
            # 条件が真の場合、珠を1つ上に移動させた後の数字を表す文字列に変換しています。
            # 条件が偽の場合、珠を移動させず、元の数字のままとなります。
            # 下の桁の珠を配置
            for j in range(3, 8):
                if j - 3 == int(number):
                    result[j][i] = '|'  # 下の桁の珠

        # 結果を表示
        for row in result:
            print(''.join(row))


W = int(input())  # そろばんの長さを入力
abacus = Abacus(W)
A = abacus.get_number()  # 数字 A のそろばんを取得
B = abacus.get_number()  # 数字 B のそろばんを取得
abacus.get_result(A + B)  # A + B のそろばんを表示
'''
Abacus クラスのコンストラクタで、そろばんの幅（桁数）を受け取り、インスタンス変数 width に設定します。
get_number メソッドは、そろばんの状態を入力として受け取り、その状態に対応する数値を返します。
入力されたそろばんの状態は、8行分の文字列として受け取ります。各行は桁ごとの珠の状態を表しています。それぞれの珠は '*' または '|' のいずれかです。
列ごとに珠の移動をシミュレーションし、数値に変換しています。具体的な処理は以下の通りです。

position と pearl には珠の位置と状態が順番に渡されます。
position が 0 または 1 の場合、2つ目の珠の位置であることを判定しています。
もし pearl が '*' の場合、上の桁で2つ目の珠が存在することを意味し、結果に 5 を加算します。
position が 2 の場合、3つ目の位置であることを判定して無視します。
position が 2 より大きい場合、下の桁の位置であることを意味します。
もし pearl が '|' の場合、珠の移動が終了し、ループから抜けます。
それ以外の場合、珠の移動回数を 1 加算します。
最終的に、結果を文字列 result に追加し、指定の桁数に合わせて左詰めし、整数として返します。

get_result メソッドは、数値をそろばんの状態に変換して表示します。
まず、数値 number を文字列に変換し、指定の桁数に合わせて左詰めします。
それぞれの桁の数字をそろばんの状態に変換して result に格納します。具体的な処理は以下の通りです。

i と digit には桁のインデックスと数字が順番に渡されます。
digit を整数に変換し、その値に応じて上の桁と下の桁の珠の状態を設定します。
もし digit が 5 未満の場合、上の桁の珠に '*' を、下の桁の珠に '|' を設定します。
もし digit が 5 以上の場合、上の桁の珠に '|' を設定します。
digit を 5 を引いた値に変換し、その結果を number に再代入します。これにより、次の桁の珠の配置に移ります。
下の桁の珠の位置 j が、j - 3 と number の値が一致する場合、下の桁の珠に '|' を設定します。
最終的に、結果のそろばんの状態を表示します。
'''

# B033 テーブルジェネレーター
# utf-8
def generate_table(headers, data):
    # 各列の最大幅を計算
    column_widths = [max(len(header), max(len(str(row[i])) for row in data)) for i, header in enumerate(headers)]

    # ヘッダー行を生成
    header_row = "| " + " | ".join(header.ljust(width) for header, width in zip(headers, column_widths)) + " |"

    # 区切り行を生成
    separator_row = "|-" + "-|-".join("-" * width for width in column_widths) + "-|"

    # データ行を生成
    data_rows = ""
    for row in data:
        data_row = "| " + " | ".join(str(cell).ljust(width) for cell, width in zip(row, column_widths)) + " |\n"
        data_rows += data_row

    # テーブルを結合して返す
    table = header_row + "\n" + separator_row + "\n" + data_rows
    return table

def generate_output(headers, data):
    # テーブルを生成
    table = generate_table(headers, data)
    # 改行と余分な空白を削除して出力用文字列を作成
    output = ""
    output += table.strip() + "\n"

    return output

# 入力の取得
W = int(input())
headers = input().split()
H = int(input())
data = [input().split() for _ in range(H)]

# テーブルの生成と出力
output = generate_output(headers, data)
print(output)
'''
generate_table(headers, data)関数は、与えられた見出しとデータから表を生成するための関数です。まず、各列の最大幅を計算します。
その後、ヘッダー行、区切り行、データ行を生成し、それらを結合してテーブルを作成します。最終的に、生成したテーブルを返します。
generate_output(headers, data)関数は、generate_table()関数を呼び出してテーブルを生成し、出力用の文字列を作成します。
テーブルの前後に余分な空白がないようにし、最終的な出力用文字列を返します。
入力部分では、まず見出しの個数 W を取得し、次に見出しのリスト headers を取得します。
続いて、データ行の行数 H を取得し、H 行分のデータをリストとして取得します。
最後に、generate_output()関数を呼び出してテーブルを生成し、出力します。
'''

# B034 ロボットの歩行実験
# utf-8
# 入力値の読み込み
sp_x, sp_y = map(int, input().split())  # 初期位置
move_forward, move_right, move_backward, move_left = map(int, input().split())  # 移動量
mCN = int(input())  # 移動コマンドの数
move_command = [list(map(str, input().split())) for _ in range(mCN)]  # 移動コマンド

current_state = 0
# 0 : F (前進)
# 1 : R (右に移動)
# 2 : B (後退)
# 3 : L (左に移動)

for i in range(mCN):
    if move_command[i][0] == 'm':  # 移動コマンド
        if move_command[i][1] == 'F':  # 前進
            if current_state == 0:
                sp_y += move_forward
            elif current_state == 1:
                sp_x += move_forward
            elif current_state == 2:
                sp_y -= move_forward
            elif current_state == 3:
                sp_x -= move_forward
        elif move_command[i][1] == 'R':  # 右に移動
            if current_state == 0:
                sp_x += move_right
            elif current_state == 1:
                sp_y -= move_right
            elif current_state == 2:
                sp_x -= move_right
            elif current_state == 3:
                sp_y += move_right
        elif move_command[i][1] == 'B':  # 後退
            if current_state == 0:
                sp_y -= move_backward
            elif current_state == 1:
                sp_x -= move_backward
            elif current_state == 2:
                sp_y += move_backward
            elif current_state == 3:
                sp_x += move_backward
        elif move_command[i][1] == 'L':  # 左に移動
            if current_state == 0:
                sp_x -= move_left
            elif current_state == 1:
                sp_y += move_left
            elif current_state == 2:
                sp_x += move_left
            elif current_state == 3:
                sp_y -= move_left
    elif move_command[i][0] == 't':  # 回転コマンド
        if move_command[i][1] == 'R':  # 右に回転
            current_state = (current_state + 1) % 4
        elif move_command[i][1] == 'B':  # 後ろ向きに回転
            current_state = (current_state + 2) % 4
        elif move_command[i][1] == 'L':  # 左に回転
            current_state = current_state - 1
            if current_state == -1:
                current_state = 3

    # 座標の範囲を制限
    if sp_x < -1000:
        sp_x = -1000
    elif sp_x > 1000:
        sp_x = 1000
    if sp_y < -1000:
        sp_y = -1000
    elif sp_y > 1000:
        sp_y = 1000

# 結果を出力
print(sp_x, sp_y)
'''
与えられた入力に基づいてロボットの移動をシミュレートし、最終的な座標を出力するものです。以下、コードの解説をします。

最初に、初期位置と移動量、移動コマンドの数を入力します。
次に、移動コマンドを入力します。移動コマンドは、移動（'m'）か回転（'t'）のどちらかであり、移動の場合は方向（'F', 'R', 'B', 'L'）も指定されます。
ロボットの現在の状態を表す変数 current_state を初期化します。0は前進（F）、1は右に移動（R）、2は後退（B）、3は左に移動（L）を表します。
移動コマンドの数だけループを実行します。
ループ内では、移動コマンドが移動の場合と回転の場合に分かれます。
移動の場合は、現在の状態に応じて座標を更新します。例えば、前進の場合は現在の状態に応じて sp_x や sp_y を増減させます。
回転の場合は、現在の状態を変更します。右回転（R）の場合は現在の状態に1を加え、後ろ向きに回転（B）の場合は2を加えます。左回転（L）の場合は現在の状態から1を引きますが、-1になる場合は3に戻します。
移動後に、座標の範囲を制限します。sp_x や sp_y が範囲外（-1000未満または1000を超える）の場合は、最小値または最大値に制限します。
最後に、最終的な座標 sp_x と sp_y を出力します。
このコードは、与えられた移動コマンドに従ってロボットを移動させ、最終的な座標を制限しながら計算します。移動と回転の操作を適切に行い、最終的な座標を正確に計算できるようになっています。
'''

# B035 ジョギングランキング
# B036 大統領選挙
# B037 幸運な1年
# B038 つるかめ算
# B039 雨上がりの道
# B040 たのしい暗号解読
--------------------------------------------- B041　※欠番 ◆
# B041 繰り返し模様
# B042 横入りするネコ
# B043 ねずみ小僧
# B044 爆弾ゲーム
# B045 計算ドリル
# B046 街の距離
# B047 ホームポジション
# B048 理想のビンゴ
# B049 ◆
# B050 有効なチケット
--------------------------------------------- B051　※欠番 ◆
# B051 ◆
# B052 積もる粒子
# B053 表の自動作成
# B054 不思議な足し算
# B055 ◆
# B056 リズムゲームの分析
# B057 回転寿司
# B058 ◆
# B059 占領区域
# B060 サイコロころがし
--------------------------------------------- B061　※欠番 ◆
# B061 福袋詰め
# B062 部屋掃除ロボット
# B063 支払う枚数とお釣りの枚数
# B064 うずを探せ
# B065 小さなライフゲーム
# B066 色のパズル
# B067 タスクの管理
# B068 チョコの分割
# B069 蟻の餌探し
# B070 駒の到達範囲
--------------------------------------------- B071　※欠番 ◆
# B071 ダンベルトレーニング
# B072 反転スイッチ
# B073 イルミネーションの調査
# B074 コメントの順序
# B075 商品の表示
# B076 パン屋さん
# B077 チケットの売り場
# B078 動画視聴スケジュール
# B079 相性チェック
# B080 みんなでスゴロク
--------------------------------------------- B081　※欠番 ◆
# B081 花壇のロープ
# B082 休暇の取り方
# B083 宝の地図
# B084 オススメのお店
# B085 宝探しの手順
# B086 公平な分割
# B087 隠された数
# B088 ロボットのデバッグ
# B089 秘密の言葉
# B090 選挙の議席
--------------------------------------------- B091　※欠番 ◆
# B091 山頂を探せ
# B092 セーブポイント
# B093 SNSの検索機能
# B094 ◆
# B095 カラオケ大会
# B096 ビンゴゲーム
# B096(2) 爆弾の大爆発
# B097 カウンター席
# B098 バズの検出
# B099 台風の接近
# B100 計算の遅延
--------------------------------------------- B101　※欠番 ◆
# B101 ◆
# B102 膨張と収縮
# B103 ◆
# B104 データのクレンジング
# B105 マッピングゲーム
# B106 席替えの席決め
# B107 カードシャッフル
# B108 観覧車の稼働状況
# B109 映画館の席の予約
# B110 解像度の向上
--------------------------------------------- B111　※欠番 ◆
# B111 天秤のつりあい
# B112 くじの作成
# B113 2のべき連結ゲーム
# B114 PAIZA運動会
# B115 アナグラムパズル
# B116 プレゼント交換
# B117 回る教習車
# B118 背の順
# B119 投網
# B120 ◆
--------------------------------------------- B121　※欠番 ◆
# B121 床の模様替え
# B122 うわさ
# B123 ビットゲーム
# B124 名前が似ている友達
# B125 工場のボトルネック
# B126 ダンスパーティー
# B127 ◆
# B128 簡易的二次元バーコード
# B129 n毛作
# B130 ブロック挿入
--------------------------------------------- B131　※欠番 ◆
# B131 運賃計算
# B131(2) 復号の処理
# B132
# B133
# B134
# B135
# B136
# B137
# B138
# B139
# B140
-----------------------------------------------B141　※欠番◆
