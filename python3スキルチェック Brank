※欠番が存在する理由につきましては、出題自体を公開終了した問題が欠番となっております。

--------------------------------------------- B001　※欠番 ◆
# B001 ◆
# B002 ◆
# B003 ◆
# B004 ログファイルの抽出
# utf-8
def isValidIp(m, c):
    ret = False
    if m == "*" or m == c:
        ret = True
    elif m[0] == "[":
        a = m.split("-")
        ss = int(a[0].replace("[", ""))
        ee = int(a[1].replace("]", ""))
        if ss <= int(c) <= ee:
            ret = True
    return ret


def main():
    # IPアドレスを読み込む
    mip = input().strip().split(".")
    
    # ログの数を読み込む
    n = int(input())
    
    # ログを1行ずつ読み込み、IPアドレスをチェックする
    for i in range(n):
        s = input().strip().split(" ")
        tip = s[0].split(".")
        if mip[0] == tip[0] and \
           mip[1] == tip[1] and \
           isValidIp(mip[2], tip[2]) and \
           isValidIp(mip[3], tip[3]):
            print(s[0] + " " + s[3][1:] + " " + s[6])


if __name__ == '__main__':
    main()
'''
1 標準入力からIPアドレスとログの数を取得し、IPアドレスを「.」で分割してリストに格納する
2 ログの数だけ繰り返し、1行ずつログを取得する
3 取得したログのIPアドレスを「.」で分割してリストに格納する
4 IPアドレスの1〜3オクテットが一致し、4オクテットが以下の条件を満たす場合に、ログの情報を出力する
　・IPアドレスの4オクテットが、IPアドレスの4オクテットと完全一致する場合
　・IPアドレスの4オクテットが、ワイルドカード「*」の場合
　・IPアドレスの4オクテットが、範囲指定の場合（「[」と「]」で囲まれた範囲内の数値のみ許可される）
具体的には、以下のような関数を定義して使用しています。
isValidIp(m, c)
　・引数mが「*」またはcと完全一致する場合はTrueを返す
　・引数mが範囲指定の場合は、引数cが範囲内にある場合はTrueを返す
このコードは、ログのIPアドレスが与えられたIPアドレスにマッチするかどうかを判定する処理を行っており、与えられたIPアドレスがワイルドカードや範囲指定を含んでいる場合にも対応しています。
'''

# B005 ◆　
# B006 ダーツゲーム
# utf-8
# 標準入力からの値の取得
import sys
input_line = sys.stdin.read()
input_list = input_line.split()

# 初期値の設定
o_y = float(input_list[0])
s = float(input_list[1])
theta = float(input_list[2])
x = float(input_list[3])
y = float(input_list[4])
a = float(input_list[5])

# 矢が当たるかどうかの判定
import math
g = 9.8
rad = math.radians(theta)
t = x / (s * math.cos(rad))
y2 = o_y + s * math.sin(rad) * t - (g * t ** 2) / 2
if y - a / 2 <= y2 <= y + a / 2:
    # 当たった場合、的の中心からの距離を出力
    dist = abs(y2 - y)
    print("Hit {:.1f}".format(round(dist, 1)))
else:
    # 当たらなかった場合、Missを出力
    print("Miss")
'''
以下の手順で矢が的に当たるかどうかを判定し、当たった場合には的の中心からの距離を出力します。
まず、sys.stdin.read()で標準入力から値を読み込み、split()でスペース区切りの文字列をリストに変換します。
次に、リストから必要な値を取り出し、float()で数値に変換します。
これで、矢の初期値点の高さ o_y、初速 s、角度 theta、的までの距離 x、的の高さ y、的の大きさ a がそれぞれ変数に格納されました。

矢が当たるかどうかの判定には、以下の計算式を使用します。
y2 = o_y + s * sin(rad) * t - (g * t^2) / 2
ここで、radはthetaをラジアンに変換したもの、tは矢が的に当たるまでの時間です。この式は、矢の初期値点から投げた瞬間の高さ o_y に、矢が的に当たるまでに到達する高さを足し合わせたものを計算し、的の高さ y ± 的の大きさ a の範囲内にあるかどうかを判定します。

具体的には、以下のように計算します。
import math

# 重力加速度
g = 9.8

# 角度をラジアンに変換
rad = math.radians(theta)

# 矢が的に当たるまでの時間
t = x / (s * math.cos(rad))

# 矢が的に当たるときの高さ
y2 = o_y + s * math.sin(rad) * t - (g * t ** 2) / 2

矢が当たるかどうかを判定する部分では、まず重力加速度を9.8[m/s^2]として、投射角度θに対しての水平方向と鉛直方向の初速度を求めます。そして、投射角度θと初速度sを用いて、到達時間tを求めます。tを用いて、矢の到達位置y2を計算します。その後、的の位置yから、的の半径a/2の範囲内に矢の到達位置y2があるかどうかを判定しています。
当たった場合は、的の中心からの距離を求めています。このとき、求めた距離を絶対値をとっているのは、矢が的の上側に当たった場合でも、的の中心からの距離を正しく求めるためです。また、四捨五入して小数点第1位までの数値を出力するには、Pythonの組み込み関数であるround()関数を使います。
当たらなかった場合は、"Miss"を出力しています。
'''

# B007 ◆
# B008 ◆
# B009 カンファレンスのタイムテーブル作成
# utf-8
# coding: utf-8

# 分を時刻表記に変換する関数　m分をhh:mm形式の文字列に変換する関数
def m2h(m):
    hour = m // 60 % 24  # 24時間制での時間を算出
    minute = m % 60  # 分を算出
    return f'{hour:02}:{minute:02}'  # hh:mm形式の文字列に変換して返す

# 時刻表記を分に変換する関数　hh:mm形式の文字列をm分に変換する関数
def h2m(h):
    hour, minute = map(int, h.split(':'))  # : を区切り文字として文字列を分割して、時と分に分ける
    return hour * 60 + minute  # 時を分に変換して分と合算し、分単位で返す

# 各プレゼンテーションの開始・終了時刻を計算する関数　スケジュールの時間計算を行う関数
def presentation_time(start_time, duration):
    global rest   # お昼休憩のフラグ　# グローバル変数 rest を参照するため、global宣言
    noon = h2m('12:00')  # 12:00を分単位に変換して、お昼の時間として取得
    end_time = start_time + duration  # 終了時刻を算出
    if not rest and noon < end_time:  # お昼休憩が必要かどうかを判定　# 休憩をとっておらず、終了時刻がお昼を過ぎている場合
        start_time += 60 - 10  # お昼休憩をとるために開始時刻をずらす　# お昼休憩を含む1時間の空きを作るために10分引いた時間に移動
        end_time = start_time + duration  # 新しい終了時刻を再度算出
        rest = True  # 休憩を取ったことをフラグに設定
    return start_time, end_time  # スケジュールの開始時間と終了時間を返す

n = int(input())  # # プレゼンテーションスケジュールの個数を入力

start_time = h2m('10:00')  # 最初のプレゼンテーションの開始時刻を10:00として、分単位に変換して取得

rest = False  # お昼休憩をとっていないことをフラグに設定　お昼休憩のフラグを初期化
for _ in range(n):  # スケジュールの個数だけ繰り返し処理を実行
    name, duration = input().split()  # スケジュール名と時間を入力として受け取る
    start_time, end_time = presentation_time(start_time, int(duration))  # スケジュールの開始時間と終了時間を計算
    print(f'{m2h(start_time)} - {m2h(end_time)} {name}')  # スケジュールの時間と名前を出力
    start_time = end_time + 10 # 休憩時間10分を加算して次のプレゼンテーションの開始時刻を計算する
'''
m2h() 関数
この関数は、分単位の時間を時:分の形式の文字列に変換するためのものです。
入力された分を60で割った余りが分の値、60で割った商を24で割った余りが時の値として取得します。
最後に、f-string を使って、"時:分" の形式で文字列を生成し、それを返します。

h2m() 関数
この関数は、時:分の形式の文字列を分単位の時間に変換するためのものです。
split() 関数を使って、文字列を ":" で分割し、時と分の値を取得します。
時を60で掛けたものに分を足し合わせて、分単位の時間を計算し、それを返します。

presentation_time() 関数
この関数は、スピーカーのプレゼンテーションの開始時間と終了時間を計算するためのものです。
引数として、スピーカーのプレゼンテーションの開始時間と時間の長さを受け取ります。
global キーワードを使って、rest 変数をグローバル変数として宣言します。
noon 変数には、12:00の分単位の時間を代入します。
end_time 変数には、プレゼンテーションの終了時間を代入します。
rest 変数が False かつ noon より end_time が後の場合、つまり、プレゼンテーションがお昼休憩をまたいでいる場合、開始時間にお昼休憩の10分を足した時間から再スタートし、終了時間を再計算します。
最後に、開始時間と終了時間を返します。

それ以降のメイン部分
まず、n = int(input())で発表する人数nを受け取ります。
次に、発表が始まる開始時間を表す変数start_timeに、10:00の時間をh2m('10:00')を使って分単位で代入します。
そして、restフラグをFalseで初期化します。これは、お昼休憩のチェックのために使用されます。
forループを使って、各発表の時間を処理します。forループの中で、name, duration = input().split()で発表者の名前nameと発表時間durationを受け取ります。このdurationは単位が分であり、整数型であることに注意してください。
次に、presentation_time(start_time, int(duration))を呼び出して、発表の終了時刻を計算し、その時間を人間が読みやすい形式で出力します。presentation_time関数は、start_timeと発表時間durationを引数として受け取り、終了時間のタイムスタンプ（分単位）を返します。
また、restフラグがFalseである場合は、終了時間が12:00を超える場合に、お昼休憩の時間（10分）を追加します。noon = h2m('12:00')で、12:00の時間を分単位で取得します。そして、noonよりも終了時間が後である場合に、start_time += 60 - 10で、お昼休憩を考慮した新しい開始時間を計算します。最後に、restフラグをTrueに設定します。
各発表が終わった後、start_timeにend_time + 10を代入して、次の発表の開始時間を計算します。この+ 10は、前の発表の終了時間と次の発表の開始時間の間に10分の休憩時間が必要であることを示しています。
'''

# B010 サッカーのオフサイド判定
# utf-8
def team_lineup(players, reverse=False):
    if reverse:
        players = list(map(lambda x:-x, players))
    return zip(range(1, 12), players)

def is_offside(x_player, x_passer, x_offside_line):
    return x_passer < x_offside_line < x_player

def get_offside_players(offence_team, diffence_team, x_passer, x_offside_line):
    offside_players = []
    for idx, x_p in enumerate(offence_team):
        if is_offside(x_p, x_passer, x_offside_line):
            offside_players.append(idx+1)
    return offside_players

def get_offside_line(diffence_team):
    return sorted(diffence_team, reverse=True)[1]

def get_opponent(name):
    return 'A' if name == 'B' else 'B'

# main
offence_name, passer = input().split()
team = {}
team['A'] = list(map(int, input().split()))
team['B'] = list(map(int, input().split()))

if offence_name == 'B':
    for t in team:
        team[t] = list(map(lambda x:-x, team[t]))

diffence_name = get_opponent(offence_name)
offence_team = team[offence_name]
diffence_team = team[diffence_name]

x_offside_line = get_offside_line(diffence_team)
x_passer = int(offence_team[int(passer)-1])

offside_players = get_offside_players(offence_team, diffence_team, x_passer, x_offside_line)

if offside_players:
    for p in offside_players:
        print(p)
else:
    print('None')
'''
与えられたサッカーの試合状況に対して、次のパスを受け取るとオフサイドと判定される選手の背番号を小さいものから順に1行ずつ出力するものです。
まず、input()関数を使って標準入力から入力を受け取ります。1行目では攻撃するチームの名前(offence_name)と、パスを受け取る選手の背番号(passer)をスペース区切りで受け取り、
2行目と3行目ではそれぞれ攻撃するチームの選手の背番号(team_a_numbers, team_b_numbers)をスペース区切りで受け取ります。
次に、攻撃するチームと守備するチームの背番号をリストで保持します。if文で、offence_nameが'B'の場合、攻撃するチームと守備するチームの背番号を反転させます。
この処理によって、攻撃するチームが必ずAチームになるようにしています。
次に、守備するチームの最後尾から2番目の背番号を取得します。この背番号より前に攻撃するチームの選手がいる場合、オフサイドの判定が行われます。
最後に、攻撃するチームの選手の中でオフサイドとなる選手の背番号を出力します。オフサイドとなる選手がいない場合には、"None"を出力します。
このコードのポイントは、オフサイド判定を行うis_offside関数にあります。この関数は、与えられた選手の背番号(x_player)、パスを出した選手の背番号(x_passer)、
そして守備するチームのオフサイドラインの背番号(x_offside_line)を受け取り、オフサイド判定を行います。
オフサイド判定は、パスを出した選手より前方に守備するチームのオフサイドラインと、パスを受けた選手が存在する場合に成立します。
'''

--------------------------------------------- B011　※欠番 ◆
# B011 名刺バインダー管理
# utf-8
n, m = map(int, input().split())

# m番目の名刺が含まれるページを計算する
page = (m - 1) // (n * 2) + 1

# そのページの最後の名刺番号と最初の名刺番号を計算する
last_card_num = page * n * 2
first_card_num = last_card_num - (n * 2 - 1)

# m番目の名刺が表面か裏面かによって、裏側の名刺の番号を計算する
if m <= (first_card_num + n - 1):
    back_card_num = last_card_num - (m - first_card_num)
else:
    back_card_num = first_card_num + (last_card_num - m)

print(back_card_num)
'''
1行目では、入力された文字列をスペースで分割し、それぞれ整数型に変換して、nとmに代入しています。
2行目では、m番目の名刺が属するページ数を求めています。m-1をn*2で割り、+1をしているのは、pythonで整数を割った場合、小数点以下が切り捨てられるためです。
また、m-1をする理由は、1番目の名刺が0ページ目にあるとみなすためです。3行目では、pageページに含まれる最後の名刺の番号を計算しています。pageページには、n2枚の名刺があるため、pmaxにn2をかけ、その後page-1をかけます。
それに1を足すのは、1ページ目が0番目のページであるとしているためです。4行目では、pageページに含まれる最初の名刺の番号を計算しています。pminには、pmaxからn*2-1を引いた数が入ります。
この式は、pageページの最初の名刺の番号がpage-1ページの最後の名刺の番号に1を足したものであることから導かれます。
5行目では、m番目の名刺の裏面にある名刺の番号を計算しています。mは、pageページの中で何番目の名刺なのかを計算します。pageページの最初の名刺の番号から、m番目の名刺の番号を引いたものが、m番目の名刺の裏面にある名刺の番号になります。
'''

# B012 ◆
# B013 ◆
# B014 3Dプリンタ
# utf-8
X,Y,Z=list(map(int,input().split()))
m=[['.' for j in range(Y)] for i in range(Z)]
for k in range(Z):
    for i in range(X):
        n=input()
        for j in range(Y):
            if n[j]=='#':
                m[k][j]='#'
    l=input()
for i in reversed(range(Z)):
    l=map(str,m[i])
    s=''.join(l)
    print(s)
'''
入力されたX,Y,Zに対して、Z枚のX行Y列のマス目を作成しています。マス目は、二次元リストで表現されています。
そして、入力されたマス目の状態を、マス目に反映させます。
最後に、マス目を反転させ、反転したマス目を出力します。
ここで、マス目の反転は、reversed(range(Z))を使用して、Zから0までの範囲を逆順に取得していることで実現されています。
また、map(str, m[i])を使用して、マス目を文字列に変換し、join()関数でつなげて、横一列の文字列として出力しています。
'''

# B015 7セグメントディスプレイ（デジタル表示の数字）　※テストケース通過せず
# utf-8
def is_valid_display(display):
    digits = {
        '0': '1111110',
        '1': '0110000',
        '2': '1101101',
        '3': '1111001',
        '4': '0110011',
        '5': '1011011',
        '6': '1011111',
        '7': '1110010',
        '8': '1111111',
        '9': '1111011'
    }
    return display in digits.values()

def symmetric_move(display):
    return display[::-1]

def rotate_move(display):
    return display[-1] + display[:-1]

a = input().split()[:7]  # 最大7桁まで
b = input().split()[:7]  # 最大7桁まで

condition1 = is_valid_display(''.join(a)) and is_valid_display(''.join(b))
condition2 = is_valid_display(''.join(symmetric_move(a))) and is_valid_display(''.join(symmetric_move(b)))
condition3 = is_valid_display(''.join(rotate_move(''.join(a)))) and is_valid_display(''.join(rotate_move(''.join(b))))

result = "Yes" if condition1 else "No"
result += "\n" + ("Yes" if condition2 else "No")
result += "\n" + ("Yes" if condition3 else "No")

print(result)

# B016 ここはどこ？
# utf-8
class B016:
    def __init__(self):
        info = input().split()
        self.board = {"W": int(info[0]), "H": int(info[1])}
        self.move_times = int(info[2])
        self.player = {}

    def set_player_position(self):
        position = input().split()
        self.player["X"] = int(position[0])
        self.player["Y"] = int(position[1])

    def set_move_info(self):
        self.move_info = []
        for i in range(self.move_times):
            move = input().split()
            self.move_info.append({"dir": move[0], "step": int(move[1])})

    def get_final_position(self):
        for move in self.move_info:
            self.move(move["dir"], move["step"])

    def move(self, direction, step):
        if direction == "U":
            step = step % self.board["H"]
            if self.player["Y"] + step > self.board["H"] - 1:
                self.player["Y"] = step - (self.board["H"] - self.player["Y"])
            else:
                self.player["Y"] += step
        elif direction == "D":
            step = step % self.board["H"]
            if self.player["Y"] - step < 0:
                self.player["Y"] = self.board["H"] - (step - self.player["Y"])
            else:
                self.player["Y"] -= step
        elif direction == "L":
            step = step % self.board["W"]
            if self.player["X"] - step < 0:
                self.player["X"] = self.board["W"] - (step - self.player["X"])
            else:
                self.player["X"] -= step
        elif direction == "R":
            step = step % self.board["W"]
            if self.player["X"] + step > self.board["W"] - 1:
                self.player["X"] = step - (self.board["W"] - self.player["X"])
            else:
                self.player["X"] += step

    def display(self):
        print("{} {}".format(self.player["X"], self.player["Y"]))

b016 = B016()
b016.set_player_position()
b016.set_move_info()
b016.get_final_position()
b016.display()
'''
このコードは、与えられた初期位置と移動ログに基づいて、移動後の位置を計算して出力するプログラムです。
まず、1行目でマップの横幅 w、縦幅 h、移動ログの個数 nを読み取ります。2行目では初期位置 x, yを読み取り、3行目からn+2行目までの各行で移動ログを読み取ります。
移動ログには、「dir_i」と「m_i」があり、「dir_i」は移動する方向（"U"、"D"、"R"、"L"）を、「m_i」は移動する距離を表しています。各ログに基づいて、プログラムは現在の位置から移動後の位置を計算し、最後に移動後の位置を出力します。
「move」メソッドは、与えられた方向と距離に応じて、与えられた座標を更新する関数です。プログラムは、与えられた移動ログに基づいて、「move」メソッドを呼び出し、プレイヤーの位置を更新します。
最後に、「display」メソッドは、プレイヤーの最終位置を出力します。
'''

# B017 手役の強さ(花札)
# utf-8
class StrongestMeans:
    def __init__(self, cards):
        self.cards = cards
        self.countOfCard = {}

    def getMeans(self):
        self.countCard()

        means = ""
        max_count = max(self.countOfCard.values())
        if max_count == 1:
            means = "NoPair"
        elif max_count == 2:
            means = "TwoPair" if len(self.countOfCard) == 2 else "OnePair"
        elif max_count == 3:
            means = "ThreeCard"
        elif max_count == 4:
            means = "FourCard"

        return means

    def countCard(self):
        for card in self.cards:
            if card == "*":
                self.plusAllKindCardOne()
            else:
                self.plusSpecifiedCardOne(card)

    def plusAllKindCardOne(self):
        cards = set(self.cards)
        for card in cards:
            if card != "*":
                self.plusSpecifiedCardOne(card)

    def plusSpecifiedCardOne(self, card):
        self.countOfCard[card] = self.countOfCard.get(card, 0) + 1

cards = input().strip()
strongMeans = StrongestMeans(list(cards))
print(strongMeans.getMeans())
'''
このコードは、入力のフォーマットに合わせてカードの入力を受け取り、StrongestMeansクラスのインスタンスを作成して、getMeansメソッドを呼び出し、結果を表示しています。
注意点：
カードの入力は、スペースで区切られた4つの文字列として受け取ります。
input().strip()を使って末尾の改行文字を除去します。
入力の最後には余分な文字や空行が含まれていないことを確認してください。
このコードを使用して、与えられた入力に基づいて最高の手役を判定し、出力することができます。

まず、StrongestMeansという名前のクラスが定義されています。このクラスは、カードの集合から手役の強さを判定するためのメソッドを提供します。
__init__メソッドは、cardsという引数を受け取り、インスタンスの初期化を行います。cardsは入力されたカードのリストです。countOfCardはカードの出現回数を格納するための辞書です。
getMeansメソッドは手役の強さを返します。まず、countCardメソッドを呼び出してカードの出現回数を数えます。
次に、countOfCard辞書の値の中で最大の数を取得します。その最大数に応じて手役を判定し、meansに結果を格納します。

countCardメソッドは、カードの出現回数を数えるためのメソッドです。self.cardsの各カードについて、cardとして処理します。
もしcardがワイルドカード "*" ならば、plusAllKindCardOneメソッドを呼び出します。
そうでない場合は、plusSpecifiedCardOneメソッドを呼び出して指定されたカードの出現回数を増やします。

plusAllKindCardOneメソッドは、ワイルドカード "*" の場合に他のすべてのカードの出現回数を増やすためのメソッドです。
self.cardsのユニークな要素を取得し、それぞれのカードについて処理します。
'''

# B018 ◆
# B019 グレースケールの画像の縮小
# utf-8
def shrink_image(N, K, pixels):
    # N/K × N/Kの画像を作成
    new_N = N // K
    new_pixels = [[0] * new_N for _ in range(new_N)]

    # 各ブロックの平均値を計算
    for r in range(new_N):
        for c in range(new_N):
            block_sum = 0
            for i in range(r * K, (r + 1) * K):
                for j in range(c * K, (c + 1) * K):
                    block_sum += pixels[i][j]
            average = block_sum // (K * K)
            new_pixels[r][c] = average

    return new_pixels

# 入力を受け取る
N, K = map(int, input().split())
pixels = []
for _ in range(N):
    row = list(map(int, input().split()))
    pixels.append(row)

# 画像を縮小
result = shrink_image(N, K, pixels)

# 結果を出力
for row in result:
    print(*row)
'''
shrink_image(N, K, pixels) 関数は、元の画像を指定されたブロックサイズで縮小するための関数です。関数は以下の手順で動作します。

元の画像のサイズ N とブロックサイズ K を受け取ります。
新しい画像のサイズ new_N を計算します。new_N は N を K で割った商です。
新しい画像を表現するための二次元リスト new_pixels を作成します。サイズは new_N × new_N です。
各ブロックの平均値を計算し、新しい画像のピクセル値として new_pixels に格納します。
最終的に new_pixels を返します。
メインのプログラムでは、以下の手順で処理が行われます。

元の画像のサイズ N とブロックサイズ K を入力します。
N 行のピクセル値を受け取り、二次元リスト pixels に格納します。
shrink_image(N, K, pixels) 関数を呼び出して、画像を縮小します。結果は result に格納されます。
result を出力します。
'''

# B020 ネットサーフィン
# utf-8
n = int(input())  # クエリの数を取得
queries = []  # クエリを保持するリスト
history = ["blank page"]  # ページの履歴を保持するリスト

# クエリを入力してリストに追加
for _ in range(n):
    queries.append(input())

# 各クエリを処理
for query in queries:
    if query == "use the back button":
        if len(history) > 1:
            history.pop()  # 直前のページを履歴から削除
        print(history[-1])  # 現在のページを出力
    else:
        page_name = query[6:]  # ページ名を取得
        history.append(page_name)  # ページを履歴に追加
        print(page_name)  # ページ名を出力

print()  # 最後の改行を出力
'''
このコードでは、まずクエリの数を取得し、その後のクエリをリストに追加します。それぞれのクエリに対して以下の処理を行います。

"use the back button" の場合:

履歴が1つ以上存在する場合は、直前のページを履歴から削除します。
現在のページを出力します。
"go to [page_name]" の場合:

ページ名を取得し、履歴に追加します。
ページ名を出力します。
最後に改行を出力します。

この修正により、最初のページが "blank page" であること、"use the back button" の場合でも "blank page" 以外の指定されたページを開くこと、各テストケースでの出力例が要件を満たすようになります。

修正後のコードでは、入力例に対する出力例も要件を満たすようになります。それぞれのクエリに対して適切なページを開き、履歴を保持しながら出力しています。
'''
--------------------------------------------- B021　※欠番 ◆
# B021 ◆
# B022 ◆
# B023 マッチ棒パズル
# utf-8
def get_another(a, b):
    for i in range(len(a)):
        a[i] = b[i]
    return a


def set_number(number):
    number[0][0] = "69"
    number[0][1] = "8"
    number[0][2] = ""

    number[1][0] = ""
    number[1][1] = "7"
    number[1][2] = ""

    number[2][0] = "3"
    number[2][1] = ""
    number[2][2] = ""

    number[3][0] = "25"
    number[3][1] = "9"
    number[3][2] = ""

    number[4][0] = ""
    number[4][1] = ""
    number[4][2] = ""

    number[5][0] = "3"
    number[5][1] = "69"
    number[5][2] = ""

    number[6][0] = "09"
    number[6][1] = "8"
    number[6][2] = "5"

    number[7][0] = ""
    number[7][1] = ""
    number[7][2] = "1"

    number[8][0] = ""
    number[8][1] = ""
    number[8][2] = "069"

    number[9][0] = "06"
    number[9][1] = "8"
    number[9][2] = "35"

    return number


def main():
    charS = input().strip()
    result = []

    number = [["" for _ in range(3)] for _ in range(10)]
    number = set_number(number)

    temp = list(charS)
    temp = get_another(temp, list(charS))
    for i in range(len(charS)):
        for j in range(3):
            point = int(charS[i])

            for k in range(len(number[point][j])):
                if j == 0:
                    temp[i] = number[point][0][k]
                    output = "".join(temp)
                    result.append(output)
                    temp = get_another(temp, list(charS))
                elif j == 1:
                    for l in range(i + 1, len(charS)):
                        point2 = int(charS[l])
                        for m in range(len(number[point2][2])):
                            temp[i] = number[point][1][k]
                            temp[l] = number[point2][2][m]
                            output = "".join(temp)
                            result.append(output)
                            temp = get_another(temp, list(charS))
                else:
                    for l in range(i + 1, len(charS)):
                        point2 = int(charS[l])
                        for m in range(len(number[point2][1])):
                            temp[i] = number[point][2][k]
                            temp[l] = number[point2][1][m]
                            output = "".join(temp)
                            result.append(output)
                            temp = get_another(temp, list(charS))

    result.sort()

    if len(result) == 0:
        print("none")
    else:
        for i in range(len(result)):
            print(result[i])
main()
'''
get_another(a, b) 関数:
リスト a をリスト b の要素で上書きする関数です。
a と b の要素数は同じである必要があります。
set_number(number) 関数:
number という2次元リストを引数として受け取り、特定のパターンで要素を初期化します。
この関数は number リストを返します。
main() 関数:
・プログラムのエントリーポイントとなる関数です。
・入力文字列 charS を受け取り、結果のリスト result を初期化します。
・2次元リスト number を set_number() 関数で初期化します。
・charS の各文字を処理するループを開始します。
・charS の各文字について、3つのパターン (j の値) に対してループを開始します。
・パターンごとに、数字の置換を行い、結果を result リストに追加します。
・最後に result をソートし、結果を出力します。

このコードのアルゴリズムは、与えられた文字列 charS の各文字に対して、異なるパターンで数字の置換を行い、結果を生成しています。
これにより、全ての可能な置換パターンを網羅的に生成することができます。最終的な結果は辞書順にソートされています。
ただし、このコードでは一部の箇所で冗長な処理が行われており、効率的ではないと言えます。特に、リストのコピー (temp = get_another(temp, list(charS))) や結果のリストに要素を追加する際のループ処理が、改善の余地があります。
'''

# B024 格子を円で切り取る　※数学的アプローチが必要
# utf-8
import math # mathモジュールをインポートして円周率の計算や平方根の計算を行います。

while True: # 無限ループを開始
    try: # 入力を試みます。もし例外が発生した場合、exceptブロックに移動します。
        r = float(input()) # 半径 r の値を浮動小数点数として入力します。
        if r <= 0: # もし r が0以下の場合、無効な入力値として扱い、エラーメッセージを表示して次のループに移ります。
            print("Invalid input: r must be a positive number.")
            continue
        total = 0 # 格子点の合計数を初期化します。
        n = math.ceil(r) # r の値を切り上げて最も近い整数 n にします。これは最小の正方形の一辺の長さとなります。
        for i in range(n + 1): # 0から n までの範囲でループ
            if r * r - i * i < 0: # もし r * r - i * i が0より小さい場合、円の内部にないのでスキップします。
                continue
            total += math.ceil(math.sqrt(r * r - i * i)) # 円の内部にある格子点の数を計算し、それを total に加算します。
        print(total * 4) # 計算された格子点の合計数に4を乗算して出力します。
    except (ValueError, EOFError): # 入力時に ValueError や EOFError の例外が発生した場合、ループを終了します。
        break
'''
このコードでは、入力された半径 r をもとに最小の正方形内の格子点の数を求め、さらに円の内部にある格子点の数を計算しています。
最終的に、格子点の数に4を乗算して出力します。なお、無効な入力や入力の終了（EOF）に対しても適切に処理しているため、例外が発生しても安全に終了できます。
'''

# B025 うさぎジャンプ
# utf-8
# N, M, Kの入力を受け取る
N, M, K = map(int, input().split())

# 各うさぎの現在の位置をリストに格納する
s = [int(input()) for _ in range(M)]

# しげみの状態を管理するリストを作成する（初期値は0）
grass = [0] * N

# 各うさぎの初期位置をしげみのリストに反映する
for i in s:
    grass[i - 1] = i

# Kセットのジャンプを行う
for _ in range(K):
    for j in range(M):
        # うさぎがジャンプ先として選ぶしげみの番号（% nを行うことで範囲内に収める）
        grass_num = s[j] % N
        # ジャンプ先が他のうさぎに占拠されている場合、空いているしげみを探す
        while grass[grass_num] != 0:
            grass_num = (grass_num + 1) % N
        # ジャンプ元のしげみからうさぎを移動させる
        grass[grass_num] = grass[s[j] - 1]
        grass[s[j] - 1] = 0
        # うさぎの位置情報を更新する
        s[j] = grass_num + 1

# 各うさぎの最終位置を出力する
for i in s:
    print(i)
'''
標準入力からN、M、Kの値を受け取ります。それぞれ、しげみの数N、うさぎの数M、ジャンプ回数Kを表します。
うさぎの現在位置をリストsに格納しています。range(m)でうさぎの数M回ループし、int(input())によって各うさぎの位置を受け取ります。
しげみの状態を管理するためのリストgrassを作成、初期値は全て0です。次のループでは、リストsに格納されている各うさぎの位置情報を、リストgrassに反映させています。
各うさぎの位置-1のインデックスに対応する要素にうさぎの番号を代入しています。Kセットのジャンプを行っています。
外側のループはK回ループします。内側のループでは、各うさぎに対してジャンプ処理を行います。
grass_numはうさぎがジャンプ先として選ぶしげみの番号です。s[j] % nによって範囲内に収められます。
grass[grass_num] != 0は、ジャンプ先のしげみが他のうさぎに占拠されているかどうかを判定しています。もし占拠されている場合、次の空いているしげみを探すためにgrass_numを1ずつ増やしていきます。whileループを抜けた時点で、grass_numには空いているしげみの番号が格納されます。
ジャンプ元のしげみからうさぎを移動させるために、grass[grass_num]にジャンプ元のうさぎの番号を代入し、ジャンプ元のしげみを空にします。
最後に、うさぎの位置情報を更新するためにs[j]にgrass_num + 1を代入します。+ 1はインデックスと番号の差を調整するためです。
'''

# B026 自動販売機
# utf-8
class VendingMachine:
    def __init__(self, coin_in_machine):
        self.coin_in_machine = coin_in_machine

    def sell_result(self, customers):
        for customer in customers:
            arr_customer = customer.split(" ")

            # お客様が購入した商品の価格及び入れた各コインの枚数
            product_price = int(arr_customer[0])
            use_coin = {
                500: int(arr_customer[1]),
                100: int(arr_customer[2]),
                50: int(arr_customer[3]),
                10: int(arr_customer[4])
            }

            change_coin = {
                500: 0,
                100: 0,
                50: 0,
                10: 0
            }

            # お釣り
            change = [500 * use_coin[500] + 100 * use_coin[100] + 50 * use_coin[50] + 10 * use_coin[10] - product_price]
            tmp_change = change[0]

            for coin, coin_number in self.coin_in_machine.items():
                self.change(coin, coin_number, change, change_coin)

            message = ""
            if self.check_if_pass(change_coin, tmp_change):

                # 自動販売機内部コインの変化
                for coin, coin_number in self.coin_in_machine.items():
                    self.coin_in_machine[coin] = coin_number + use_coin[coin] - change_coin[coin]

                # 出力
                k = 0
                for coin, count in change_coin.items():
                    message += str(count)
                    if k == len(change_coin) - 1:
                        break
                    message += " "
                    k += 1

            else:
                message += "impossible"
            print(message)

    def change(self, coin, coin_number, change, change_coin):
        # お釣りの残りがcoin以下の場合は計算不要なので処理を終了する
        if change[0] < coin:
            return
        for num in range(coin_number, -1, -1):
            price = change[0] - num * coin
            # 残りのお釣りがcoinを使ってprice円支払える場合
            if price >= 0:
                change[0] -= num * coin
                change_coin[coin] = num
                return

    def check_if_pass(self, change_coin, tmp_change):
        # 50円玉と10円玉の合計が100円以上の場合は条件を満たさない
        if change_coin[50] * 50 + change_coin[10] * 10 >= 100:
            return False
        for coin, coin_number in self.coin_in_machine.items():
            # 自動販売機内のコインの枚数を超える場合は条件を満たさない
            if change_coin[coin] > coin_number:
                return False
        # お釣りの合計金額がtmp_change円と一致しない場合は条件を満たさない
        if change_coin[500] * 500 + change_coin[100] * 100 + change_coin[50] * 50 + change_coin[10] * 10 != tmp_change:
            return False
        return True


# 入力値の読み込み
info = input().strip()
arr_info = info.split(" ")

coin_in_machine = {
    500: int(arr_info[0]),
    100: int(arr_info[1]),
    50: int(arr_info[2]),
    10: int(arr_info[3])
}

count_of_customer = int(input().strip())
customers = []
for _ in range(count_of_customer):
    customers.append(input().strip())

# 自動販売機オブジェクトの作成と売り上げ結果の表示
vending_machine = VendingMachine(coin_in_machine)
vending_machine.sell_result(customers)
'''
VendingMachine クラス:
coin_in_machine インスタンス変数: 自動販売機内の各コインの枚数を格納する辞書です。
__init__ メソッド: coin_in_machine 辞書を受け取り、インスタンス変数に設定します。
sell_result メソッド: 複数の顧客の購入情報を受け取り、結果を表示します。
change メソッド: お釣りの計算を行います。指定されたコインで支払い可能な最大枚数を計算し、お釣りと使用したコインの枚数を更新します。
check_if_pass メソッド: お釣りの条件をチェックし、条件を満たすかどうかを判定します。

入力の読み込み:
最初の入力は自動販売機内のコインの枚数を表す文字列です。空白で区切られた各要素は、500円、100円、50円、10円のコインの枚数を表します。
2番目の入力は顧客の数を表す整数です。
続く入力は各顧客の購入情報を表す文字列です。空白で区切られた各要素は、商品の価格、500円、100円、50円、10円のコインの枚数を表します。

自動販売機オブジェクトの作成と売り上げ結果の出力:
入力から得られた情報をもとに、VendingMachine オブジェクトを作成します。
sell_result メソッドを呼び出し、顧客ごとの売り上げ結果を出力します。
'''

# B027 ◆
# B028 チャット記録
# utf-8
# 入力を取得
n, g, m = list(map(int, input().split()))
# グループの情報を取得
k = [list(map(int, input().split())) for i in range(g)]
# 各社員の画面に表示されるメッセージを格納するリストを初期化
N = [[] for i in range(n)]
# メッセージの数だけループ
for i in range(m):
    # メッセージの情報を入力し、送信者、受信者の種類、ターゲット、内容を取得
    s = input().split()
    sender = int(s[0])
    recipient_type = int(s[1])
    target = int(s[2])
    content = s[3:]
    
    # 受信者の種類が0の場合、送信者と受信者の両方の画面にメッセージを追加
    if recipient_type == 0 and sender != target:
        N[sender-1] += content
        N[target-1] += content
    
    # 受信者の種類が1の場合、対象のグループに所属するすべての社員の画面にメッセージを追加
    if recipient_type == 1:
        group_members = k[target-1][1:]  # グループのメンバーを取得
        for member in group_members:
            N[member-1] += content
    
# 各社員の画面に表示されるメッセージを出力
for i in range(n-1):
    print('\n'.join(N[i]))
    print('--')
print('\n'.join(N[-1]))
'''
このコードは、与えられた入力に基づいてメッセージのやり取りをシミュレーションし、各社員の画面に表示されるメッセージを出力します。
まず、社員数 n、グループ数 g、メッセージ数 m を入力します。次に、各グループの情報を入力し、グループに所属する社員のリストを作成します。
その後、メッセージの数だけループを回し、各メッセージに対して以下の処理を行います。
メッセージの情報を入力し、送信者と受信者の種類、ターゲット、内容を取得します。
受信者の種類が 0 の場合、送信者と受信者の両方の画面にメッセージを追加します。
受信者の種類が 1 の場合、対象のグループに所属するすべての社員の画面にメッセージを追加します。
最後に、各社員の画面に表示されるメッセージを出力します。各社員の画面ごとに、メッセージを改行区切りで表示し、最後にハイフンで区切ります。
'''

# B029 地価の予想
# utf-8
import math

def main():
    # 地点Aの座標を入力
    x, y = map(int, input().split())
    # k-近傍法のパラメータkを入力
    k = int(input())
    # 既知の地点の総数Nを入力
    N = int(input())

    info = []
    # 既知の地点の座標と価格を入力し、距離を計算してinfoリストに追加
    for _ in range(N):
        xi, yi, pi = map(int, input().split())
        distance = math.sqrt((x - xi) ** 2 + (y - yi) ** 2)
        info.append([xi, yi, pi, distance])

    # 距離を基準にinfoリストをソート
    info.sort(key=lambda x: x[3])

    # k個の地点の価格の合計を計算
    sum_price = sum(info[i][2] for i in range(int(k)))
    # 平均地価を求め、四捨五入して結果とする
    result = int(sum_price / k) + int((sum_price / k * 10) % 10) // 5

    # 結果を出力
    print(result)

if __name__ == "__main__":
    main()
'''
このコードは、与えられた地点Aと既知の地点の座標と価格を利用して、k-近傍法に基づいた地価の予測を行います。
main関数では、まず地点Aの座標を入力します。x, y = map(int, input().split())の部分で、空白区切りの入力を整数として受け取っています。
次に、k-近傍法のパラメータkと既知の地点の総数Nを入力します。k = int(input())とN = int(input())の部分で、整数の入力を受け取ります。
その後、infoリストを用意し、N回のループで既知の地点の座標と価格を入力し、距離を計算してinfoリストに追加しています。
xi, yi, pi = map(int, input().split())の部分で、空白区切りの入力を整数として受け取り、distance = math.sqrt((x - xi) ** 2 + (y - yi) ** 2)の部分で地点Aからの距離を計算しています。
その後、infoリストを距離を基準にソートします。info.sort(key=lambda x: x[3])の部分で、lambda関数を用いて要素の3番目（距離）を基準にソートしています。
次に、k個の地点の価格の合計を計算します。sum_price = sum(info[i][2] for i in range(int(k)))の部分で、リスト内包表記を用いてk個の地点の価格を合計しています。
最後に、平均地価を求めて四捨五入し、結果を出力します。result = int(sum_price / k) + int((sum_price / k * 10) % 10) // 5の部分で、合計をkで割った商と剰余を用いて四捨五入を行っています。
'''

# B030 氷のダンジョン
※入力例1のみOK
# utf-8
def explore_dungeon(H, W, dungeon, s_x, s_y, N, directions):
    # 方向ごとの座標の変化量
    dx = {'U': 0, 'R': 1, 'D': 0, 'L': -1}
    dy = {'U': -1, 'R': 0, 'D': 1, 'L': 0}

    # 初期座標
    x = s_x
    y = s_y

    # 移動を実行
    for direction in directions:
        while True:
            # 移動先の座標を計算
            nx = x + dx[direction]
            ny = y + dy[direction]

            # 移動先がダンジョン内かどうかをチェック
            if nx < 1 or nx > W or ny < 1 or ny > H:
                break  # 移動先がダンジョン外なら終了

            # 移動先が壁なら終了
            if dungeon[ny][nx] == '#':
                break

            # 移動先が土の床なら移動
            x = nx
            y = ny

    return x, y


# 入力の読み込み
H, W = map(int, input().split())
dungeon = []
for _ in range(H):
    dungeon.append(input().strip())
s_x, s_y = map(int, input().split())
N = int(input())
directions = []
for _ in range(N):
    directions.append(input().strip())

# ダンジョンの探索
final_x, final_y = explore_dungeon(H, W, dungeon, s_x, s_y, N, directions)

# 結果の出力
print(final_x, final_y)

※入力例2のみOK
# utf-8
def explore_dungeon():
    # 入力読み取り
    H, W = map(int, input().split())

    # 制約条件のバリデーションチェック
    if not (1 <= H <= 100) or not (1 <= W <= 100):
        raise ValueError("Invalid dungeon size")

    dungeon = [input() for _ in range(H)]
    s_x, s_y = map(int, input().split())

    # 制約条件のバリデーションチェック
    if not (1 <= s_x <= W) or not (1 <= s_y <= H):
        raise ValueError("Invalid starting position")

    # 初期位置の土のマスチェック
    if dungeon[s_y - 1][s_x - 1] != '.':
        raise ValueError("Invalid starting position")

    N = int(input())

    # 制約条件のバリデーションチェック
    if not (1 <= N <= 100):
        raise ValueError("Invalid number of movements")

    directions = [input().strip() for _ in range(N)]

    # 移動関数
    def move(x, y, direction):
        if direction == 'U':
            return x, y - 1
        elif direction == 'R':
            return x + 1, y
        elif direction == 'D':
            return x, y + 1
        elif direction == 'L':
            return x - 1, y

    # 初期位置
    current_x, current_y = s_x - 1, s_y - 1  # 0-indexed に変換

    # 移動
    for direction in directions:
        next_x, next_y = move(current_x, current_y, direction)

        # 次のマスが氷のマスならば進む
        while dungeon[next_y][next_x] == '#':
            next_x, next_y = move(next_x, next_y, direction)

        current_x, current_y = next_x, next_y

    # 結果出力
    print(f"{current_x + 1} {current_y + 1}")  # 1-indexed に戻す

explore_dungeon()

--------------------------------------------- B031　※欠番 ◆
# B031 コインのウラとオモテ
# utf-8
def count_black_coins(N, s):
    board = list(s)  # 入力文字列をリストに変換してボードとして扱う
    black_count = board.count('b')  # 最初の黒コインの数を数える

    flipped = True  # 反転が行われたかどうかを表すフラグ
    while flipped:
        flipped = False  # 初期値は反転が行われなかったとする
        i = 0
        while i < N:
            if board[i] == 'b':  # 黒コインの場合
                j = i
                while j < N and board[j] == 'b':
                    j += 1
                if i > 0 and j < N and 'w' not in board[i:j]:
                    # 黒コインが白コインを挟めない場合、反転させる
                    for k in range(i, j):
                        board[k] = 'w'
                    flipped = True  # 反転が行われたのでフラグを立てる
            elif board[i] == 'w':  # 白コインの場合
                j = i
                while j < N and board[j] == 'w':
                    j += 1
                if i > 0 and j < N and 'b' not in board[i:j]:
                    # 白コインが黒コインを挟めない場合、反転させる
                    for k in range(i, j):
                        board[k] = 'b'
                    flipped = True  # 反転が行われたのでフラグを立てる
            i = j

    black_count = board.count('b')  # 最終的な黒コインの数を数える
    return black_count

# 入力の読み込み
N = int(input())
s = input().rstrip()

# 黒コインの個数の計算
result = count_black_coins(N, s)

# 結果の出力
print(result)
'''
まず、count_black_coinsという関数が定義されています。この関数は、引数としてボードの横の長さを表すNとゲーム開始時のコインの並びを表す文字列sを受け取り、最終的な黒コインの数を返します。
関数内では、boardというリストを作成し、sを文字ごとに分割して格納します。また、最初の黒コインの数を数えるための変数black_countを用意します。
flippedというフラグ変数をTrueで初期化します。この変数は、反転が行われたかどうかを示す役割を果たします。
次に、whileループが開始されます。ループ内では、まずflippedをFalseに設定します。これは、反転が行われなかった場合のデフォルトの状態です。
次に、インデックスiを初期化し、iがNより小さい間ループを繰り返します。ループ内では、以下の処理が行われます。

board[i]が黒コインの場合：
jをiとし、jがN以下かつboard[j]が黒コインである間ループを繰り返します。つまり、連続する黒コインの範囲を見つけます。
もしiより前に白コインがなく、jより後に白コインがない場合、つまり黒コインが白コインを挟めない状態であれば、その範囲のコインを反転させます。具体的には、board[i:j]の要素をすべて白コインに置き換えます。
反転が行われた場合、flippedをTrueに設定します。

board[i]が白コインの場合：
jをiとし、jがN以下かつboard[j]が白コインである間ループを繰り返します。つまり、連続する白コインの範囲を見つけます。
もしiより前に黒コインがなく、jより後に黒コインがない場合、つまり白コインが黒コインを挟めない状態であれば、その範囲のコインを反転させます。具体的には、board[i:j]の要素をすべて黒コインに置き換えます。
反転が行われた場合、flippedをTrueに設定します。
iをjの値に更新します。

ループの最後で、もしflippedがTrueのままであれば、まだ反転が行われる可能性があるため、再度の反転処理を行います。これは、連続するコインの範囲に対しての反転を繰り返し行うためです。
最後に、最終的なボードの状態で黒コインの数を数え、その結果をblack_countとして返します。
メインの処理では、入力を受け取り、count_black_coins関数を呼び出して最終的な黒コインの数を計算し、結果を出力します。
'''

# B032 デジタル計算機
# utf-8
class Abacus:
    def __init__(self, width):
        self.width = width

    def get_number(self):
        numbers = []
        # そろばんの状態を入力
        for _ in range(8):
            pearls = input().strip()
            numbers.append(list(pearls))
        
        result = ''
        # 列ごとに珠の移動をシミュレーション
        for pearls in zip(*numbers):
            tmp = 0
            for position, pearl in enumerate(pearls):
                if position < 2:
                    if position == 1 and pearl == '*':
                        tmp += 5  # 上の桁で2つ目の珠が存在し、'*' の場合は5を加算
                    continue
                if position == 2:
                    continue # 3つ目の位置は無視して次の位置へ進む
                if position > 2:
                    if pearl == '|':
                        break   # '|' が現れた場合は珠の移動が終了し、ループから抜ける
                    tmp += 1    # '|' が出現するまで、珠の移動回数をカウント
            result += str(tmp)  # 珠の移動回数を結果に追加

        return int(result.rjust(self.width, '0')) # 結果を指定の桁数に合わせてゼロで左詰めし、整数として返す

    def get_result(self, number):
        result = [['*' if i != 2 else '=' for _ in range(self.width)] for i in range(8)]
        # そろばんの初期状態を生成
        number = str(number).rjust(self.width, '0')
 
        # 数字をそろばんの状態に変換
        for i, digit in enumerate(number):
            digit = int(digit)
            if digit < 5:
                result[0][i] = '*'  # 上の桁の珠
                result[1][i] = '|'  # 下の桁の珠
            else:
                result[0][i] = '|'  # 上の桁の珠

            number = str(digit - 5) if digit >= 5 else str(digit)
            # 数字が5以上の場合は珠を1つ上に移動させた後の数字
            # 数字が5未満の場合は珠を移動させずそのままの数字
            # 条件が真の場合、珠を1つ上に移動させた後の数字を表す文字列に変換しています。
            # 条件が偽の場合、珠を移動させず、元の数字のままとなります。
            # 下の桁の珠を配置
            for j in range(3, 8):
                if j - 3 == int(number):
                    result[j][i] = '|'  # 下の桁の珠

        # 結果を表示
        for row in result:
            print(''.join(row))


W = int(input())  # そろばんの長さを入力
abacus = Abacus(W)
A = abacus.get_number()  # 数字 A のそろばんを取得
B = abacus.get_number()  # 数字 B のそろばんを取得
abacus.get_result(A + B)  # A + B のそろばんを表示
'''
Abacus クラスのコンストラクタで、そろばんの幅（桁数）を受け取り、インスタンス変数 width に設定します。
get_number メソッドは、そろばんの状態を入力として受け取り、その状態に対応する数値を返します。
入力されたそろばんの状態は、8行分の文字列として受け取ります。各行は桁ごとの珠の状態を表しています。それぞれの珠は '*' または '|' のいずれかです。
列ごとに珠の移動をシミュレーションし、数値に変換しています。具体的な処理は以下の通りです。

position と pearl には珠の位置と状態が順番に渡されます。
position が 0 または 1 の場合、2つ目の珠の位置であることを判定しています。
もし pearl が '*' の場合、上の桁で2つ目の珠が存在することを意味し、結果に 5 を加算します。
position が 2 の場合、3つ目の位置であることを判定して無視します。
position が 2 より大きい場合、下の桁の位置であることを意味します。
もし pearl が '|' の場合、珠の移動が終了し、ループから抜けます。
それ以外の場合、珠の移動回数を 1 加算します。
最終的に、結果を文字列 result に追加し、指定の桁数に合わせて左詰めし、整数として返します。

get_result メソッドは、数値をそろばんの状態に変換して表示します。
まず、数値 number を文字列に変換し、指定の桁数に合わせて左詰めします。
それぞれの桁の数字をそろばんの状態に変換して result に格納します。具体的な処理は以下の通りです。

i と digit には桁のインデックスと数字が順番に渡されます。
digit を整数に変換し、その値に応じて上の桁と下の桁の珠の状態を設定します。
もし digit が 5 未満の場合、上の桁の珠に '*' を、下の桁の珠に '|' を設定します。
もし digit が 5 以上の場合、上の桁の珠に '|' を設定します。
digit を 5 を引いた値に変換し、その結果を number に再代入します。これにより、次の桁の珠の配置に移ります。
下の桁の珠の位置 j が、j - 3 と number の値が一致する場合、下の桁の珠に '|' を設定します。
最終的に、結果のそろばんの状態を表示します。
'''

# B033 テーブルジェネレーター
# utf-8
def generate_table(headers, data):
    # 各列の最大幅を計算
    column_widths = [max(len(header), max(len(str(row[i])) for row in data)) for i, header in enumerate(headers)]

    # ヘッダー行を生成
    header_row = "| " + " | ".join(header.ljust(width) for header, width in zip(headers, column_widths)) + " |"

    # 区切り行を生成
    separator_row = "|-" + "-|-".join("-" * width for width in column_widths) + "-|"

    # データ行を生成
    data_rows = ""
    for row in data:
        data_row = "| " + " | ".join(str(cell).ljust(width) for cell, width in zip(row, column_widths)) + " |\n"
        data_rows += data_row

    # テーブルを結合して返す
    table = header_row + "\n" + separator_row + "\n" + data_rows
    return table

def generate_output(headers, data):
    # テーブルを生成
    table = generate_table(headers, data)
    # 改行と余分な空白を削除して出力用文字列を作成
    output = ""
    output += table.strip() + "\n"

    return output

# 入力の取得
W = int(input())
headers = input().split()
H = int(input())
data = [input().split() for _ in range(H)]

# テーブルの生成と出力
output = generate_output(headers, data)
print(output)
'''
generate_table(headers, data)関数は、与えられた見出しとデータから表を生成するための関数です。まず、各列の最大幅を計算します。
その後、ヘッダー行、区切り行、データ行を生成し、それらを結合してテーブルを作成します。最終的に、生成したテーブルを返します。
generate_output(headers, data)関数は、generate_table()関数を呼び出してテーブルを生成し、出力用の文字列を作成します。
テーブルの前後に余分な空白がないようにし、最終的な出力用文字列を返します。
入力部分では、まず見出しの個数 W を取得し、次に見出しのリスト headers を取得します。
続いて、データ行の行数 H を取得し、H 行分のデータをリストとして取得します。
最後に、generate_output()関数を呼び出してテーブルを生成し、出力します。
'''

# B034 ロボットの歩行実験
# utf-8
# 入力値の読み込み
sp_x, sp_y = map(int, input().split())  # 初期位置
move_forward, move_right, move_backward, move_left = map(int, input().split())  # 移動量
mCN = int(input())  # 移動コマンドの数
move_command = [list(map(str, input().split())) for _ in range(mCN)]  # 移動コマンド

current_state = 0
# 0 : F (前進)
# 1 : R (右に移動)
# 2 : B (後退)
# 3 : L (左に移動)

for i in range(mCN):
    if move_command[i][0] == 'm':  # 移動コマンド
        if move_command[i][1] == 'F':  # 前進
            if current_state == 0:
                sp_y += move_forward
            elif current_state == 1:
                sp_x += move_forward
            elif current_state == 2:
                sp_y -= move_forward
            elif current_state == 3:
                sp_x -= move_forward
        elif move_command[i][1] == 'R':  # 右に移動
            if current_state == 0:
                sp_x += move_right
            elif current_state == 1:
                sp_y -= move_right
            elif current_state == 2:
                sp_x -= move_right
            elif current_state == 3:
                sp_y += move_right
        elif move_command[i][1] == 'B':  # 後退
            if current_state == 0:
                sp_y -= move_backward
            elif current_state == 1:
                sp_x -= move_backward
            elif current_state == 2:
                sp_y += move_backward
            elif current_state == 3:
                sp_x += move_backward
        elif move_command[i][1] == 'L':  # 左に移動
            if current_state == 0:
                sp_x -= move_left
            elif current_state == 1:
                sp_y += move_left
            elif current_state == 2:
                sp_x += move_left
            elif current_state == 3:
                sp_y -= move_left
    elif move_command[i][0] == 't':  # 回転コマンド
        if move_command[i][1] == 'R':  # 右に回転
            current_state = (current_state + 1) % 4
        elif move_command[i][1] == 'B':  # 後ろ向きに回転
            current_state = (current_state + 2) % 4
        elif move_command[i][1] == 'L':  # 左に回転
            current_state = current_state - 1
            if current_state == -1:
                current_state = 3

    # 座標の範囲を制限
    if sp_x < -1000:
        sp_x = -1000
    elif sp_x > 1000:
        sp_x = 1000
    if sp_y < -1000:
        sp_y = -1000
    elif sp_y > 1000:
        sp_y = 1000

# 結果を出力
print(sp_x, sp_y)
'''
与えられた入力に基づいてロボットの移動をシミュレートし、最終的な座標を出力するものです。以下、コードの解説をします。

最初に、初期位置と移動量、移動コマンドの数を入力します。
次に、移動コマンドを入力します。移動コマンドは、移動（'m'）か回転（'t'）のどちらかであり、移動の場合は方向（'F', 'R', 'B', 'L'）も指定されます。
ロボットの現在の状態を表す変数 current_state を初期化します。0は前進（F）、1は右に移動（R）、2は後退（B）、3は左に移動（L）を表します。
移動コマンドの数だけループを実行します。
ループ内では、移動コマンドが移動の場合と回転の場合に分かれます。
移動の場合は、現在の状態に応じて座標を更新します。例えば、前進の場合は現在の状態に応じて sp_x や sp_y を増減させます。
回転の場合は、現在の状態を変更します。右回転（R）の場合は現在の状態に1を加え、後ろ向きに回転（B）の場合は2を加えます。左回転（L）の場合は現在の状態から1を引きますが、-1になる場合は3に戻します。
移動後に、座標の範囲を制限します。sp_x や sp_y が範囲外（-1000未満または1000を超える）の場合は、最小値または最大値に制限します。
最後に、最終的な座標 sp_x と sp_y を出力します。
このコードは、与えられた移動コマンドに従ってロボットを移動させ、最終的な座標を制限しながら計算します。移動と回転の操作を適切に行い、最終的な座標を正確に計算できるようになっています。
'''

# B035 ジョギングランキング
# utf-8
# 部員数 N、ジョギング記録数 M、上位人数 T を入力として受け取る
N, M, T = map(int, input().split())

# 前月のジョギング成績を格納するリスト
post_mon = []

# 前月のジョギング成績を受け取り、リストに追加する
for _ in range(N):
    post_mon.append(input().split())

# 今月のジョギング記録を格納するリスト
this_mon = []

# 今月のジョギング記録を受け取り、リストに追加する
for _ in range(M):
    this_mon.append(input().split())

# リストを距離の降順にソートする関数
def range_sort(lst):
    lst.sort(key=lambda x: (-int(x[1]), x[0]))
    return lst

# 前月のジョギング成績をソートする
post_mon = range_sort(post_mon)

# 上位のジョギング記録を取得する
top_post = post_mon[:T]

# 今月のジョギング記録の合計を計算し、名前と合計距離を格納するリスト
this_mon_sum = []

# 今月のジョギング記録の合計を計算する
for name in set(record[1] for record in this_mon):
    total_distance = sum(int(record[2]) for record in this_mon if record[1] == name)
    this_mon_sum.append([name, str(total_distance)])

# 前月のジョギング成績と今月のジョギング記録の合計を結合し、ソートする
this_mon_sum += [[name, '0'] for name in set(record[0] for record in post_mon) - set(record[0] for record in this_mon_sum)]
this_mon_sum = range_sort(this_mon_sum)

# 上位のジョギング記録を取得する
top_this = this_mon_sum[:T]

# 変動を判定し、結果を追加する
for i in range(T):
    if top_this[i][0] == top_post[i][0]:
        top_this[i].append("same")
    elif any(top_this[i][0] == record[0] for record in top_post[i + 1:]):
        top_this[i].append("up")
    elif any(top_this[i][0] == record[0] for record in top_post[:i]):
        top_this[i].append("down")
    else:
        top_this[i].append("new")

# 結果を出力する
for record in top_this:
    print(" ".join(record))
'''
まず、与えられた入力を受け取ります。N, M, T = map(int, input().split())を使って、整数値の N, M, T を取得します。
次に、post_monというリストに前月のジョギング成績を格納します。post_mon = [input().split() for _ in range(N)]の部分で、N 回のループを実行して、各行から名前と距離を受け取って post_mon リストに追加しています。
同様に、this_monというリストに今月のジョギング記録を格納します。this_mon = [input().split() for _ in range(M)]の部分で、M 回のループを実行して、各行から日付、名前、距離を受け取って this_mon リストに追加しています。
次に、range_sort関数を使って post_mon リストと this_mon_sum リストをソートします。range_sort関数は与えられたリストを距離の降順にソートし、距離が同じ場合は名前の辞書順でソートする関数です。
その後、上位のジョギング記録を top_post リストと top_this リストに格納します。top_post リストは post_mon リストの上位 T 件の記録を格納し、top_this リストは this_mon_sum リストの上位 T 件の記録を格納します。
top_post リストと top_this リストを比較し、各記録の変動を判定します。結果を top_this リストの各要素の3番目の要素に追加します。
最後に、top_this リストを出力します。各要素の名前、距離、変動結果がスペース区切りで表示されます。
'''

# B036 大統領選挙
# utf-8
def calculate_winner(candidate_num, candidates, voter_num, voter_preferences):
    voted_candidates = [0] * (candidate_num + 1)  # 候補者ごとの得票数を保持するリスト
    repub_vote = 0  # 共和党候補の得票数
    demo_vote = 0  # 民主党候補の得票数

    # 最初の投票
    for preferences in voter_preferences:
        for check in range(2):
            for candidate in preferences:
                if candidates[candidate] == check:
                    voted_candidates[candidate] += 1  # 候補者の得票数をインクリメント
                    break

    # 最初の投票結果
    repub = max((c for c in range(1, candidate_num + 1) if candidates[c] == 0), key=lambda x: voted_candidates[x])
    demo = max((c for c in range(1, candidate_num + 1) if candidates[c] == 1), key=lambda x: voted_candidates[x])

    # 最後の投票
    for preferences in voter_preferences:
        for candidate in preferences:
            if candidate == repub:
                repub_vote += 1
                break
            elif candidate == demo:
                demo_vote += 1
                break

    # 結果の出力
    if repub_vote > demo_vote:
        return repub
    else:
        return demo

# 入力
candidate_num = int(input())  # 候補者数の入力
candidates = [0] * (candidate_num + 1)  # 候補者の所属パーティーを保持するリスト
for i in range(1, candidate_num + 1):
    if input() == "Republican":
        candidates[i] = 0
    else:
        candidates[i] = 1

voter_num = int(input())  # 投票者数の入力
voter_preferences = []  # 投票者の選好順位を保持するリスト
for _ in range(voter_num):
    preferences = list(map(int, input().split()))  # 投票者の選好順位をリストとして入力
    voter_preferences.append(preferences)

# 勝者の計算
winner = calculate_winner(candidate_num, candidates, voter_num, voter_preferences)

# 結果の出力
print(winner)
'''
calculate_winner 関数は、候補者数、候補者の所属パーティー、投票者数、投票者の選好順位を受け取り、最終的な勝者を計算する関数です。共和党候補と民主党候補の得票数を数えて、最終的な勝者を決定します。
入力値を受け取ります。まず、候補者数と候補者の所属パーティーを入力し、その後、投票者数と各投票者の選好順位を入力します。
calculate_winner 関数を使用して最終的な勝者を計算し、結果を出力します。
このコードでは、最初の投票で各候補者の得票数をカウントし、その結果から共和党候補と民主党候補を決定します。その後、最後の投票で選好順位に基づいて得票数をカウントし、最終的な勝者を決定します。最終的な勝者の候補者番号が返され、結果が出力されます。
'''

# B037 幸運な1年
# utf-8
def get_lucky_day(M, D, a, b, m):
    w, x, y, z = 0, 0, 0, 0
    d = {}
    date = '{:0=2}'.format(M) + '{:0=2}'.format(D)
    datenum = set(date)
    
    # 日付の桁数と出現回数をカウント
    for i in datenum:
        d[i] = date.count(i)
    
    for i in range(10000):
        flag = True
        w = (a[0] * w + b[0]) % m[0]
        x = (a[1] * x + b[1]) % m[1]
        y = (a[2] * y + b[2]) % m[2]
        z = (a[3] * z + b[3]) % m[3]
        date2 = str(w % 10) + str(x % 10) + str(y % 10) + str(z % 10)
        
        # カードの数字と日付を比較
        for key in d:
            if key not in date2:
                flag = False
                break
            if date2.count(key) != d[key]:
                flag = False
                break
        
        if flag:
            return i + 1
    
    return -1

# 入力値の取得
M, D = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
m = list(map(int, input().split()))

# 幸運な日を取得
result = get_lucky_day(M, D, a, b, m)
print(result)
'''
get_lucky_day 関数は、引数として今日の日付 (M, D)、カードのパラメータ (a, b, m) を受け取り、幸運な日になるために必要なカードの引き直し回数を計算します。
変数 w, x, y, z はカードの擬似乱数を表すための変数で、初期値は 0 です。
辞書 d は日付の桁数と出現回数を保持します。桁数と出現回数の対応は、日付を文字列に変換してカウントします。
次に、10,000 回までのループを実行します。
フラグ flag は幸運な日になるかどうかを示す変数で、初期値は True です。
カードの擬似乱数を生成し、それぞれのカードの数字を 10 で割った余りを取得して date2 に格納します。
date2 と辞書 d を比較して、カードの数字が日付を作るために必要な条件を満たしているかどうかを判定します。条件を満たさない場合、flag を False に設定します。
もし flag が True のままであれば、ループ回数に 1 を加えた値を返します。これが幸運になるために必要なカードの引き直し回数です。
もしループが終了しても幸運な日になる条件を満たすカードの引き直し回数が見つからない場合、-1 を返します。
最後に、入力値を受け取り、get_lucky_day 関数を呼び出して結果を出力します。
'''

# B038 つるかめ算　※テストケース90点
# utf-8
def estimate_pyzas(a, b, c, d):
    estimated_pyzas = []

    # どちらの動物も最低1匹ずついる場合
    if a >= 1 and b >= 1 and c == 1 and d == 1:
        estimated_pyzas.append((1, 1))
    # どちらの動物も最低1匹ずついない場合または入力値が条件を満たさない場合
    elif a < 0 or b < 0 or c < 0 or d < 0 or a > 100 or b > 100 or c > 100 or d > 100:
        estimated_pyzas.append("miss")
    # 特殊ケース: 鶴と亀の足の合計が0の場合
    elif a == 0 and b == 0 and (c + d) == 0:
        estimated_pyzas.append("miss")
    # 特殊ケース: 鶴と亀の頭の数が同じで、足の合計が一致しない場合
    elif a == b and (c + d) != a:
        estimated_pyzas.append("miss")
    # 特殊ケース: 鶴と亀の頭の数が同じであり、足の合計も同じ場合
    elif a == b and (c + d) == a:
        estimated_pyzas.append("miss")
    # 特殊ケース: 鶴と亀の足の数が0で、頭の数が0以外の場合
    elif a == 0 and b == 0 and c != 0:
        estimated_pyzas.append("miss")
    # 特殊ケース: 鶴と亀の頭の数が0であり、足の数が異なる場合
    elif a == 0 and b == 0 and c != d:
        estimated_pyzas.append("miss")
    # 特殊ケース: 鶴と亀の足の数が0で、頭の数が異なる場合
    elif c == 0 and d == 0 and a != b:
        estimated_pyzas.append("miss")
    # 特殊ケース: 鶴と亀の足の数が0で、頭の数が一致する場合
    elif c == 0 and d == 0 and a == b:
        estimated_pyzas.append("miss")
    # 特殊ケース: どちらか一方の動物が正の整数にならない場合
    elif (a < c and b < d) or (a < d and b < c):
        estimated_pyzas.append("miss")
    # 特殊ケース: 鶴と亀の数が一意に定まらない場合
    elif (c - d) == 0:
        estimated_pyzas.append("miss")
    # それ以外の場合
    else:
        try:
            x = (a - b * d) // (c - d)
            y = b - x
            # 推定されるパイザ鶴とパイザ亀の数が正の整数になるかを確認
            if x >= 1 and y >= 1 and a == x * c + y * d and b == x + y:
                estimated_pyzas.append((x, y))
            else:
                estimated_pyzas.append("miss")
        except ZeroDivisionError:
            estimated_pyzas.append("miss")

    return estimated_pyzas


# 入力の受け取り
a, b, c, d = map(int, input().split())

# 推定の実行
estimated_pyzas = estimate_pyzas(a, b, c, d)

# 出力
for result in estimated_pyzas:
    if result == "miss":
        print("miss")
    else:
        print(result[0], result[1])

# B039 雨上がりの道
# utf-8
class UnionFind:
    def __init__(self, n):
        self.parent = [i for i in range(n)]  # 各要素の親を格納するリスト
        self.rank = [0] * n  # 各要素のランク（深さ）を格納するリスト

    def find(self, x):
        if self.parent[x] != x:  # 親が自身でない場合、再帰的に親をたどる
            self.parent[x] = self.find(self.parent[x])  # 親を根に直接設定し、経路圧縮を行う
        return self.parent[x]  # 根を返す

    def union(self, x, y):
        root_x = self.find(x)  # xの根を取得
        root_y = self.find(y)  # yの根を取得

        if root_x != root_y:  # 異なる根を持つ場合のみ結合処理を行う
            if self.rank[root_x] < self.rank[root_y]:  # root_xのランクが小さい場合
                self.parent[root_x] = root_y  # root_xの親をroot_yに設定
            elif self.rank[root_x] > self.rank[root_y]:  # root_yのランクが小さい場合
                self.parent[root_y] = root_x  # root_yの親をroot_xに設定
            else:
                self.parent[root_y] = root_x  # root_yの親をroot_xに設定
                self.rank[root_x] += 1  # root_xのランクを増加させる


def check_overlap(rect1, rect2):
    # 2つの長方形が重なっているかを判定する関数
    x_overlap = (rect1[0][0] <= rect2[1][0]) and (rect1[1][0] >= rect2[0][0])
    y_overlap = (rect1[0][1] <= rect2[1][1]) and (rect1[1][1] >= rect2[0][1])
    return x_overlap and y_overlap


def find_accessible_puddles(n, s, puddles):
    uf = UnionFind(n)  # UnionFindオブジェクトを初期化

    for i in range(n):
        for j in range(i + 1, n):
            if check_overlap(puddles[i], puddles[j]):  # 水たまりが重なっている場合
                uf.union(i, j)  # 水たまりを結合

    accessible_puddles = []  # アメンボが入ることのできる水たまりのリスト
    root = uf.find(s - 1)  # アメンボがいる水たまりの根を取得

    for i in range(n):
        if uf.find(i) == root:  # 同じ根に属する水たまりはアメンボが入れる
            accessible_puddles.append(i + 1)  # 水たまりの番号をリストに追加

    return accessible_puddles


# 入力値の読み込み
n = int(input())  # 水たまりの個数
s = int(input())  # アメンボがいる水たまりの番号

puddles = []
for _ in range(n):
    x, y, a, b = map(int, input().split())
    puddles.append(((x, y), (a, b)))  # 水たまりの座標をタプルとしてリストに追加

accessible_puddles = find_accessible_puddles(n, s, puddles)  # アメンボが入れる水たまりを求める

for puddle in accessible_puddles:
    print(puddle)  # 結果を出力
'''
ここでは、Union-Find法による解法のコード例の解説を行います。
まず、UnionFindクラスを定義しています。このクラスは、Union-Findデータ構造を表現するためのものです。
__init__メソッドでは、要素の数を指定してUnionFindオブジェクトを初期化します。parentリストは各要素の親を表し、最初は自身を親として初期化します。rankリストは各要素のランク（深さ）を表し、最初はすべて0で初期化します。
findメソッドは、指定された要素の親を再帰的に辿り、根（ルート）の要素を返します。また、途中で辿った要素の親を根に直接設定することで経路圧縮を行っています。これにより、次回以降のfind操作の際に効率的に根を特定することができます。
unionメソッドは、2つの要素を結合します。まず、それぞれの要素の根（ルート）を取得し、異なる根を持つ場合にのみ結合処理を行います。結合時には、ランク（深さ）を考慮して低いランクの木を高いランクの木に結合し、木のバランスを保ちます。
次に、find_accessible_puddles関数では、与えられた水たまりの情報を基にアメンボが入ることのできる水たまりを特定します。
まず、UnionFindオブジェクトを初期化します。その後、2重ループを使ってすべての水たまりの組み合わせをチェックします。check_overlap関数を利用して重なっているかを判定し、重なっている場合はそれらの水たまりを結合します。
結合処理が終わった後、アメンボがいる水たまりのルートを取得します（s - 1で指定）。そのルートに属する水たまりがアメンボが入ることのできる水たまりとなります。最後に、結果を出力します。
この解法では、Union-Findデータ構造を使って水たまりの重なりを効率的に判定し、アメンボが入ることのできる水たまりを特定しています。Union-Find法は連結性の管理に優れたデータ構造であり、効率的なグループ化が可能です。これにより、問題の制約条件に合わせた高速な解法を実現しています。
'''

# B040 たのしい暗号解読
# 入力値の取得
lines = []
while True:
    try:
        line = input()
        lines.append(line)
    except EOFError:
        break

# 回答方針
# [1] 必要な値を変数/配列化する。置換回数(count), 暗号文(codeText), 暗号ルール(codeRule), アルファベット(alphabet)
# [2] 暗号文を一文字ずつ置換ルールと比較。暗号文文字 = 暗号ルールとなる時の、置換ルールの文字列順を取得
# [3] [2]で取得した番号のアルファベット文字列を取得する。
# [4] [2][3]を暗号文の文字列回数分繰り返す
# [5] [2][3][4]の処理を置換回数(count)回、繰り返す。
# [5]で得られた文字列を表示する

alphabet = "abcdefghijklmnopqrstuvwxyz"
count, codeRule = lines[0].split()
count = int(count)
codeText = lines[1].strip()
decryption = ''

for c in range(count):
    for char in codeText:
        if char == ' ':
            decryption += ' '
            continue
        for n in range(len(codeRule)):
            if char == codeRule[n]:
                decryption += alphabet[n]
    codeText = decryption
    decryption = ''

print(codeText)
'''
最初に、入力を受け取るための処理が行われています。input()関数を使って一行ずつ入力を読み込み、linesリストに格納しています。EOFError例外が発生するまで繰り返します。
次に、アルファベットの文字列や復号に必要な変数を初期化しています。alphabet変数にはアルファベットの文字列が格納されています。count変数には置換回数が、codeRule変数には置換のルールが格納されます。countは整数に変換しています。また、codeText変数には暗号文が格納されます。strip()関数を使って行末の改行文字を削除しています。decryption変数は復号結果を格納するための空の文字列です。
指定された回数だけ復号処理を繰り返します。外側のループはcount回繰り返されます。内側のループでは、暗号文の各文字を一つずつ処理します。文字がスペースの場合は、スペースを復号結果に追加し、次の文字の処理へ進みます。それ以外の場合は、暗号ルールを順番に比較し、一致するルールの位置に対応するアルファベットを復号結果に追加します。
内側のループが終わった後、codeTextを更新して復号結果を反映します。そして、decryptionを空の文字列にリセットします。
最後に、復号された結果を出力します。
このコードでは、与えられた置換回数と置換ルールを使って暗号文を復号する処理が行われます。指定された回数だけ復号処理が繰り返され、最終的な復号結果が出力されます。
'''
--------------------------------------------- B041　※欠番 ◆
# B041 繰り返し模様
# utf-8
K = int(input())  # 繰り返し手順の回数を取得
N = int(input())  # 最初の正方形の辺の長さを取得
s = [list(input()) for _ in range(N)]  # 初期状態の模様を取得

for m in range(K):
    s1 = []  # 新しい模様を生成するためのリスト

    for i in range(N):
        for j in range(N):
            if s[i][j] == '.':
                if j == 0:
                    # 白色の場合は、同じ大きさの白い正方形を生成
                    for k in range(N):
                        s1.append(['.'] * N)
                elif j > 0:
                    # 白色の場合は、同じ大きさの白い正方形を追加
                    for k in range(N):
                        s1[i * N + k][len(s1[i * N + k]):len(s1[i * N + k])] = ['.'] * N
            else:
                if j == 0:
                    # 青色の場合は、元の模様をそのまま追加
                    for k in range(N):
                        s1.append(s[k][:])
                elif j > 0:
                    # 青色の場合は、元の模様を追加
                    for k in range(N):
                        s1[i * N + k][len(s1[i * N + k]):len(s1[i * N + k])] = s[k]

    N *= N  # 新しい模様の辺の長さを更新
    s = s1[:]  # 新しい模様で元の模様を上書き

for row in s1:
    print("".join(row))  # 生成された最終的な模様を出力
'''
入力値の受け取り:
K = int(input()): 繰り返し手順の回数を整数として受け取ります。
N = int(input()): 最初の正方形の辺の長さを整数として受け取ります。
s = [list(input()) for _ in range(N)]: N行の文字列を受け取り、それぞれの文字列をリストに変換して二次元リスト s に格納します。これにより、初期状態の模様が表現されます。

模様の生成と更新のループ:
for m in range(K):: K回の繰り返しを行います。各繰り返しでは、新しい模様が生成されて元の模様と入れ替わります。
s1 = []: 新しい模様を生成するための空のリスト s1 を作成します。

新しい模様の生成:
2重ループを使用して、元の模様を基に新しい模様を生成します。
if s[i][j] == '.':: もし現在の正方形が白色であれば、同じ大きさの白い正方形で置き換えます。
else:: もし現在の正方形が青色であれば、元の模様をそのまま追加します。

新しい模様の更新:
N *= N: 新しい模様の辺の長さを更新します。元の辺の長さの N 倍になります。
s = s1[:]: 生成された新しい模様で元の模様を上書きします。
最終的な模様の出力:

for row in s1: print("".join(row)): 生成された最終的な模様を出力します。各行の文字列を結合して表示します。
このコードは、与えられた繰り返し手順に基づいて模様を生成し、最終的な模様を出力します。初期状態の模様に対して、白色の正方形は同じ大きさの白い正方形で置き換えられ、青色の正方形は元の模様に置き換えられます。
この操作を指定された回数繰り返すことで、最終的な模様が生成されます。
'''

# B042 横入りするネコ
# utf-8
def check_cat(cat_num, M, cat_info, eat_time_info, cat_line):
    # 猫の順番を組み合わせて全パターンを調べる再帰関数
    if len(cat_line) == cat_num:
        cat_M = check_M(cat_num, cat_info, cat_line)
        if cat_M <= M:
            eat_time = check_eat_time(cat_num, cat_info, cat_line)
            eat_time_info.add(eat_time)
    else:
        for i in range(cat_num):
            if i + 1 not in cat_line:
                new_cat_line = cat_line.copy()
                new_cat_line.append(i + 1)
                check_cat(cat_num, M, cat_info, eat_time_info, new_cat_line)


def check_M(cat_num, cat_info, cat_line):
    # 各猫の不満度の合計を計算する関数
    cat_M = [0] * cat_num
    cat_line_info = [0] * cat_num
    sum_cat_M = 0

    for index, value in enumerate(cat_line):
        cat_line_info[index] = value

    for i in range(1, cat_num):
        for j in range(i):
            if cat_line_info[i] < cat_line_info[j]:
                cat_M[cat_line_info[i] - 1] += 1

    for i in range(cat_num):
        sum_cat_M += cat_M[i] * cat_info[i][1]

    return sum_cat_M


def check_eat_time(cat_num, cat_info, cat_line):
    # 各猫の食事時間の合計を計算する関数
    eat_time = 0
    eat_time_sum = 0
    cat_line_info = [0] * cat_num

    for index, value in enumerate(cat_line):
        cat_line_info[index] = value

    for i in range(cat_num):
        eat_time += eat_time_sum + cat_info[cat_line_info[i] - 1][0]
        eat_time_sum += cat_info[cat_line_info[i] - 1][0]

    return eat_time


cat_num, M = map(int, input().split())

cat_info = []
for _ in range(cat_num):
    cat_info.append(list(map(int, input().split())))

eat_time_info = set()
cat_line = []

check_cat(cat_num, M, cat_info, eat_time_info, cat_line)

min_eat_time = min(eat_time_info)

print(min_eat_time)
'''
check_cat関数:
引数:
cat_num: 猫の数
M: 許容される不満度の合計
cat_info: 猫の情報を格納した2次元リスト
eat_time_info: 結果として得られる食事時間の集合
cat_line: 現在の猫の順番のリスト
再帰的に全ての猫の順番の組み合わせをチェックし、条件を満たす場合に食事時間を計算して集合に追加します。
まだ順番が割り当てられていない猫に対して順番を割り当てて再帰呼び出しを行います。

check_M関数:
引数:
cat_num: 猫の数
cat_info: 猫の情報を格納した2次元リスト
cat_line: 現在の猫の順番のリスト
各猫の不満度の合計を計算して返します。
猫の順番が入れ替わった場合、その猫より前にいる猫の不満度を増やします。

check_eat_time関数:
引数:
cat_num: 猫の数
cat_info: 猫の情報を格納した2次元リスト
cat_line: 現在の猫の順番のリスト
各猫の食事時間の合計を計算して返します。
猫の順番に従って、各猫の食事時間を計算し合計します。

メイン部分:
ユーザーからの入力を受け取り、cat_numとMに代入します。
cat_infoリストを作成し、猫の情報を格納します。
結果の食事時間を格納するための集合eat_time_infoと、現在の猫の順番を格納するためのリストcat_lineを初期化します。
check_cat関数を呼び出して、全ての猫の順番の組み合わせをチェックします。
得られた食事時間の集合eat_time_infoから最小値を取得し、結果を出力します。
このコードは、猫の順番の組み合わせを全て試す方法を用いて最適解を求める力まで持っています。
ただし、猫の数が増えると組み合わせの数が爆発的に増えるため、実行時間が長くなる可能性があります。
より効率的なアルゴリズムを検討する必要があるかもしれません。
'''

# B043 ねずみ小僧
# utf-8
# 町の大きさを入力
H, W = map(int, input().split())

# ねずみ小僧の初期位置を入力
h0, w0 = map(int, input().split())

# 町の各家の状態を入力
houses = [list(input().strip()) for _ in range(H)]

# ねずみ小僧の初期設定
axis = 1  # 初期方向は北を示す
num = 1  # 移動回数の初期値
x, y = h0 - 1, w0 - 1  # 座標の初期値（0-indexedに変換）

# ねずみ小僧の移動ループ
while num <= 2000 and 0 <= x < H and 0 <= y < W:
    num += 1
    
    # 現在の座標の家の状態に応じて行動を決定
    if houses[x][y] == '.':  # 庶民の家の場合
        houses[x][y] = '*'  # 富豪の家に変更
        if axis == 1:  # 北を向いている場合
            axis = 2  # 東に方向転換
            y += 1
        elif axis == 2:  # 東を向いている場合
            axis = 3  # 南に方向転換
            x += 1
        elif axis == 3:  # 南を向いている場合
            axis = 4  # 西に方向転換
            y -= 1
        elif axis == 4:  # 西を向いている場合
            axis = 1  # 北に方向転換
            x -= 1
    else:  # 富豪の家の場合
        houses[x][y] = '.'  # 庶民の家に変更
        if axis == 1:  # 北を向いている場合
            axis = 4  # 西に方向転換
            y -= 1
        elif axis == 2:  # 東を向いている場合
            axis = 1  # 北に方向転換
            x -= 1
        elif axis == 3:  # 南を向いている場合
            axis = 2  # 東に方向転換
            y += 1
        elif axis == 4:  # 西を向いている場合
            axis = 3  # 南に方向転換
            x += 1

# 町の最終状態を出力
for row in houses:
    print("".join(row))
'''
最初の部分では、入力値を受け取り、必要な変数を初期化しています。

hとwには町の大きさが格納されます。
xとyにはねずみ小僧の初期位置が格納されます。
sは町の状態を表す二次元リストです。
axisはねずみ小僧の向いている方向を表す変数で、初期値は1です（北を意味します）。
numはねずみ小僧の移動回数を表す変数で、初期値は1です。
xとyは座標のインデックスとして使用されるため、1から0始まりのインデックスに変換しています。

while文からはねずみ小僧の移動ループです。ループは以下の条件を満たす間、繰り返されます:

numが2000以下であり、ねずみ小僧が町の範囲内にいること。
xが0以上h未満、yが0以上w未満であること。
ループ内の処理は次のようになっています:

s[x][y]が'.'（庶民の家）の場合、その家を'*'（富豪の家）に変えます。
ねずみ小僧の向き(axis)に応じて、座標を更新します。向きが1の場合、y座標を増やし、向きが2の場合、x座標を増やします。向きが3の場合、y座標を減らし、向きが4の場合、x座標を減らします。
s[x][y]が'*'（富豪の家）の場合、その家を'.'（庶民の家）に変えます。
ねずみ小僧の向き(axis)に応じて、座標を更新します。向きが1の場合、y座標を減らし、向きが2の場合、x座標を減らします。向きが3の場合、y座標を増やし、向きが4の場合、x座標を増やします。
移動が終了すると、ねずみ小僧が通過した後の町の状態が得られます。

最後の部分では、町の状態を出力しています。二次元リストsの各行を文字列に変換し、改行なしで出力します。
'''

# B044 爆弾ゲーム
# utf-8
def is_enemy_defeated(H, W, board):
    # 盤面の初期化と敵の数のカウント
    num_enemies = 0
    for row in board:
        num_enemies += row.count('X')

    # 爆弾が爆発した際の敵の倒れる範囲を計算する関数
    def explode_bomb(r, c, power):
        nonlocal num_enemies
        if power == 0:
            return
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            for i in range(1, power + 1):
                nr, nc = r + i * dr, c + i * dc
                if 0 <= nr < H and 0 <= nc < W:
                    if board[nr][nc] == 'X':
                        num_enemies -= 1
                        board[nr][nc] = '.'
                    elif board[nr][nc] == '#':
                        break
                else:
                    break

    # 盤面の爆弾を探索し、爆発させる
    for r in range(H):
        for c in range(W):
            if board[r][c].isnumeric():
                power = int(board[r][c])
                explode_bomb(r, c, power)

    # 全ての爆弾が爆発した後に敵が残っているか判定
    if num_enemies == 0:
        return "YES"
    else:
        return "NO"


# 入力の読み込み
H, W = map(int, input().split())
board = []

# 盤面の読み込みと周囲を壁で囲む
board.append(['#'] * (W + 2))
for _ in range(H):
    row = list(input().strip())
    row.insert(0, '#')
    row.append('#')
    board.append(row)
board.append(['#'] * (W + 2))

# 判定結果の出力
result = is_enemy_defeated(H, W, board)
print(result)
'''
まず、is_enemy_defeated 関数を定義します。この関数は盤面の縦幅 H、横幅 W、および盤面の情報 board を受け取ります。
関数内部では、敵の数をカウントするための変数 num_enemies を初期化します。そして、board 内の各行を走査し、'X' の出現回数を数えて num_enemies に加算します。
次に、explode_bomb 関数を定義します。この関数は爆弾の位置と火力を受け取り、爆発した際の敵の倒れる範囲を計算します。
関数内部では、爆発の方向を表すベクトル (dr, dc) を定義し、それを用いて爆発範囲を走査します。具体的には、爆発の中心から 1 から power までの距離を順に増やしながら、範囲内にあるマスをチェックします。
マスが範囲内にあり、敵 'X' であれば num_enemies を減算し、そのマスを '.' (空マス) に変更します。マスが壁 '#' であれば、それ以上の範囲へは進めず、ループを抜けます。
最後に、全ての爆弾が爆発した後に敵が残っているかを判定します。num_enemies の値が 0 であれば、全ての敵が倒されたことを意味し、"YES" を返します。そうでなければ、残っている敵がいることを意味し、"NO" を返します。
メインの処理の後、盤面の情報を受け取ります。入力の読み込み部分では、最初に盤面の縦幅 H と横幅 W を読み込みます。そして、次に盤面の情報を board に格納していきます。
board の各行を読み込む際に、行の前後に壁 '#' を追加して、盤面の周囲を壁で囲むようにします。
最後に、is_enemy_defeated 関数を呼び出して判定結果を得て、それを出力します。
以上が修正版のプログラムの解説です。このプログラムは、与えられた盤面の全ての爆弾を同時に爆発させた際に敵が全滅するかどうかを判定します。
'''

# B045 計算ドリル
# utf-8
import random

# 入力を取得し、足し算の問題数と引き算の問題数を設定する
setting = input()
set_data = setting.split()
plus = int(set_data[0])
minus = int(set_data[1])

problems = []  # 問題を格納するリスト

# 足し算の問題を生成
while len(problems) < plus:
    left = random.randint(0, 99)  # 0から99までのランダムな左辺を生成
    right = random.randint(0, 99 - left)  # 左辺以下の範囲でランダムな右辺を生成
    problem = f"{left} + {right} ="  # 問題文を作成
    if problem not in problems:  # 重複しない問題文の場合にリストに追加
        problems.append(problem)

# 引き算の問題を生成
while len(problems) < plus + minus:
    left = random.randint(0, 99)  # 0から99までのランダムな被減数を生成
    right = random.randint(0, left)  # 被減数以下の範囲でランダムな減数を生成
    problem = f"{left} - {right} ="  # 問題文を作成
    if problem not in problems:  # 重複しない問題文の場合にリストに追加
        problems.append(problem)

random.shuffle(problems)  # 問題の順序をランダムにシャッフル

# 問題を出力
for problem in problems:
    print(problem)
'''
このコードでは、random モジュールを使用してランダムな数値を生成しています。足し算の問題を生成する際には、0から99までのランダムな左辺と、左辺以下の範囲でランダムな右辺を生成し、問題文を作成しています。
同様に、引き算の問題を生成する際には、0から99までのランダムな被減数と、被減数以下の範囲でランダムな減数を生成して問題文を作成しています。
問題文の重複を防ぐため、生成した問題文が既にリストに存在するかをチェックしています。存在しない場合にのみリストに追加されます。
最後に、random.shuffle() 関数を使用して問題の順序をランダムにシャッフルしています。最終的に生成された問題は、for ループを使用して一つずつ出力されます。
このコードによって、与えられた条件を満たし、効率的かつランダムな問題のドリルが生成されます。
'''

# B046 街の距離
# utf-8
import math

class B046:
    def __init__(self, rounds):
        # 同心円の数
        self.rounds = int(rounds)
        # 現在位置の同心円番号
        self.now_around = None
        # 現在位置の方角
        self.now_direction = None
        # 目的地の同心円番号
        self.purpose_around = None
        # 目的地の方角
        self.purpose_direction = None
        # 最短距離
        self.distance = None

    def set_now_position_info(self, info):
        # 現在位置の同心円番号と方角を設定
        self.now_around, self.now_direction = info.split()

    def set_purpose_position_info(self, info):
        # 目的地の同心円番号と方角を設定
        self.purpose_around, self.purpose_direction = info.split()

    def calculation_shortest_distance(self):
        # 方向の組み合わせパターン
        check_direction = self.now_direction + self.purpose_direction
        one_line_direction = ["NS", "SN", "WE", "EW", "NN", "SS", "WW", "EE"]

        if check_direction in one_line_direction:
            if self.now_direction == self.purpose_direction:
                # 同じ直線上にいる場合は、直線距離のみ
                self.distance = abs(int(self.now_around) - int(self.purpose_around)) * 100
            else:
                # 直線上にいる場合は、同心円同士の距離を加算
                self.distance = (int(self.now_around) + int(self.purpose_around)) * 100
        else:
            if int(self.now_around) < int(self.purpose_around):
                # 短い方向に半周し、直線距離を加算
                self.distance = abs(int(self.now_around) - int(self.purpose_around)) * 100 + math.pi * 100 * int(self.now_around) / 2
            elif int(self.now_around) > int(self.purpose_around):
                # 短い方向に半周し、直線距離を加算
                self.distance = abs(int(self.now_around) - int(self.purpose_around)) * 100 + math.pi * 100 * int(self.purpose_around) / 2
            else:
                # 同心円上の同じ位置にいる場合は、半周距離のみ
                self.distance = math.pi * 100 * int(self.purpose_around) / 2

        return self.distance

N = input().strip()  # 同心円の数を入力
B046 = B046(N)  # B046クラスのインスタンスを生成
B046.set_now_position_info(input().strip())  # 現在位置情報を入力
B046.set_purpose_position_info(input().strip())  # 目的地情報を入力
B046.calculation_shortest_distance()  # 最短距離を計算
print("{:.9f}".format(B046.distance))  # 最短距離を表示
'''
このコードは、同心円状の道路が配置された環境で、現在位置と目的地の情報から最短距離を計算しています。
B046 クラスは、最短距離の計算と情報の設定を行うためのメソッドを提供します。インスタンス化された B046 オブジェクトを使用して、現在位置情報と目的地情報を設定し、最短距離を計算します。
set_now_position_info メソッドは、現在位置情報を設定します。文字列として渡された情報を分割して、現在の同心円位置と方角を設定します。
set_purpose_position_info メソッドは、目的地情報を設定します。文字列として渡された情報を分割して、目的地の同心円位置と方角を設定します。
calculation_shortest_distance メソッドは、現在位置と目的地から最短距離を計算します。まず、現在位置と目的地の方角の組み合わせをチェックし、直線上に位置する場合と曲線上に位置する場合で処理を分岐します。最短距離を計算して distance 属性に代入します。
メインの処理部分では、入力から同心円の数、現在位置情報、目的地情報を受け取り、B046 クラスのインスタンスを生成し、必要な情報を設定します。最後に最短距離を計算して表示します。
'''

# B047 ホームポジション
# utf-8
def check_habit(key_input):
    result_habit = 0
    keyboard = [['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'],
                ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', '0'],
                ['z', 'x', 'c', 'v', 'b', 'n', 'm', '0', '0', '0']]

    def check_true_key(char):
        # タイプするキーが左手のキーか右手のキーかをチェックする関数
        # 右手のキーなら1、左手のキーなら2を返す
        for i in range(3):
            for j in range(5, 10):
                if char == keyboard[i][j]:
                    return 1  # 右手のキー
        return 2  # 左手のキー

    def check_near(cur_get, post_get):
        """
        タイプするキーが直前に打ったキーの隣接するキーかをチェックする関数

        Args:
            cur_get (str): タイプするキー
            post_get (str): 直前に打ったキー

        Returns:
            bool: タイプするキーが直前に打ったキーの隣接するキーならTrue、そうでなければFalseを返す
        """
        x, y = -1, -1
        for i in range(len(keyboard)):
            for j in range(len(keyboard[0])):
                if keyboard[i][j] == cur_get:
                    x, y = i, j
                    break
            if x > -1 or y > -1:
                break

        if x > 0:
            if keyboard[x - 1][y] == post_get:
                return True
        if x + 1 < len(keyboard):
            if keyboard[x + 1][y] == post_get:
                return True
        if y > 0:
            if keyboard[x][y - 1] == post_get:
                return True
        if y + 1 < len(keyboard[0]):
            if keyboard[x][y + 1] == post_get:
                return True
        if keyboard[x][y] == post_get:
            return True

        return False

    check = 0
    prev_key = '0'

    for cur_key in key_input:
        if check == 1:  # 左手
            if check_near(cur_key, prev_key):
                if check_true_key(cur_key) == 1:  # 右手のキー
                    result_habit += 1
            else:
                check = 0
        elif check == 2:  # 右手
            if check_near(cur_key, prev_key):
                if check_true_key(cur_key) == 2:  # 左手のキー
                    result_habit += 1
            else:
                check = 0
        elif prev_key != '0':
            if (cur_key == 'y' and prev_key == 't') or \
               (cur_key == 'h' and prev_key == 'g') or \
               (cur_key == 'n' and prev_key == 'b'):
                result_habit += 1
                check = 1  # 左手
            elif (cur_key == 't' and prev_key == 'y') or \
                 (cur_key == 'g' and prev_key == 'h') or \
                 (cur_key == 'b' and prev_key == 'n'):
                result_habit += 1
                check = 2  # 右手
        prev_key = cur_key

    return result_habit


if __name__ == "__main__":
    key_input = input().strip()

    result = check_habit(key_input)
    print(result)
'''
関数 check_habit の定義と、キーボードの配置を表す二次元リスト keyboard の初期化を行っています。
関数 check_true_key は、与えられたキーが左手のキーか右手のキーかを判定する関数です。キーボードの配置を参照し、右手のキーなら1を、左手のキーなら2を返します。
関数 check_near は、与えられたキーが直前に打ったキーの隣接するキーかを判定する関数です。キーボードの配置を参照し、タイプするキーが直前に打ったキーの隣接するキーなら True を、そうでなければ False を返します。
メインの処理は、与えられた文字列 key_input を順番に処理しながら、タイピングの癖によって違う手でタイプする回数を数える部分です。

変数 check は、現在どの手でタイピングしているかを表します。0 は初期状態（どちらの手でもない）を表します。
変数 prev_key は、直前に打ったキーを保持します。初期値は '0' としています。
文字列 key_input の各文字に対してループを実行します。
check の値に応じて、適切な手でキーをタイプしているか判定します。
check が 1 の場合は左手でタイピングしている状態を表し、check_near 関数を使って隣接するキーかどうかをチェックします。
もし隣接するキーであり、かつ check_true_key 関数が右手のキーを示す場合、癖によって違う手でタイプしていると判断し、result_habit をインクリメントします。
check が 2 の場合は右手でタイピングしている状態を表し、同様の判定を行います。
check の値が 0 の場合は、直前のキーとの組み合わせによる手の切り替えの可能性を判定します。
最後に、処理が終わった後の result_habit の値を返しています。
メインの処理の下に、キーボード入力を受け取り、check_habit 関数を呼び出して結果を表示する部分を記述します。
'''

# B048 理想のビンゴ
# utf-8
N, M = map(int, input().split())
bingo_card = []  # ビンゴカードの盤面を格納するリスト
bingo_count = 0  # ビンゴ数をカウントする変数

# ビンゴカードの盤面を入力として受け取り、リストに格納する
for _ in range(N):
    row = list(map(int, input().split()))
    bingo_card.append(row)

# M-1回の数字の呼び出しを処理する
for _ in range(M - 1):
    called_number = int(input())
    for i in range(N):
        for j in range(N):
            if called_number == bingo_card[i][j]:
                bingo_card[i][j] = 0  # 呼び出された数字を0に置き換える

# 行のビンゴをチェック
for i in range(N):
    if bingo_card[i].count(0) == N:
        bingo_count += 1

columns = []  # 列ごとの数字を格納するリスト
for i in range(N):
    column = []
    for j in range(N):
        column.append(bingo_card[j][i])
    columns.append(column)
    if column.count(0) == N:
        bingo_count += 1

diagonal = []  # 対角線の数字を格納するリスト
for i in range(N):
    diagonal.append(bingo_card[i][i])

reverse_diagonal = []  # 逆対角線の数字を格納するリスト
for i in range(1, N + 1):
    reverse_diagonal.append(bingo_card[-i][i - 1])

lines = [diagonal, reverse_diagonal]  # 対角線と逆対角線をまとめたリスト

# 対角線と逆対角線のビンゴをチェック
for line in lines:
    if line.count(0) == N:
        bingo_count += 1

extra_numbers = []  # ビンゴの候補となる数字を格納するリスト

# ビンゴの候補となる数字を抽出
for i in range(N):
    if bingo_card[i].count(0) == N - 1:
        for j in range(N):
            if bingo_card[i][j] != 0:
                extra_numbers.append(bingo_card[i][j])

for i in range(N):
    if columns[i].count(0) == N - 1:
        for j in range(N):
            if columns[i][j] != 0:
                extra_numbers.append(columns[i][j])

for line in lines:
    if line.count(0) == N - 1:
        for j in range(N):
            if line[j] != 0:
                extra_numbers.append(line[j])

frequency = []  # ビンゴの候補数字の出現回数を格納するリスト

# ビンゴの候補数字の出現回数を計算し、最大のビンゴ数を更新
if len(extra_numbers) > 0:
    for i in range(len(extra_numbers)):
        frequency.append(extra_numbers.count(extra_numbers[i]))
    bingo_count += max(frequency)

print(bingo_count)  # 最大のビンゴ数を出力
'''
入力の受け取りと初期化:
N, M = map(int, input().split()): ビンゴカードのサイズと呼び出し回数を受け取ります。
bingo_card = []: ビンゴカードの盤面を格納するための空のリストを作成します。
bingo_count = 0: ビンゴ数をカウントする変数を初期化します。

ビンゴカードの入力と数字の呼び出し処理:
for _ in range(N): ...: ビンゴカードの盤面を入力として受け取り、リスト bingo_card に格納します。
for _ in range(M - 1): ...: 呼び出された数字を処理し、ビンゴカード上の該当する数字を0に置き換えます。

行・列・対角線のビンゴをチェック:
行のビンゴをチェックし、ビンゴ数をカウントします。
列ごとの数字を格納するリスト columns を作成し、列のビンゴをチェックし、ビンゴ数をカウントします。
対角線と逆対角線の数字を格納するリスト diagonal と reverse_diagonal を作成し、対角線と逆対角線のビンゴをチェックし、ビンゴ数をカウントします。

追加のビンゴの候補数字を抽出:
ビンゴの候補となる数字を格納するリスト extra_numbers を作成し、行・列・対角線・逆対角線のビンゴの候補数字を抽出します。

追加のビンゴ数の計算:
ビンゴの候補数字が存在する場合、その出現回数を計算し、最大のビンゴ数を更新します。

結果の出力:
最大のビンゴ数を出力します。
このコードでは、ビンゴカードの盤面と呼び出された数字を処理し、行・列・対角線・逆対角線のビンゴをチェックして最大のビンゴ数を求めるアルゴリズムが実装されています。ビンゴ数の計算は、ビンゴの候補数字が存在する場合にのみ行われます。最終的な結果は、最大のビンゴ数が出力されます。
'''

# B049 ◆
# B050 有効なチケット
# utf-8
# 入力の受け取りと制約のチェック
N = int(input())  # チケットの枚数
if not 1 <= N <= 100:
    raise ValueError("Nの値が制約を満たしていません")

S = input()  # 暗号チケットの指定された文字列
if not 1 <= len(S) <= 10 or not S.islower():
    raise ValueError("Sの値が制約を満たしていません")

valid_tickets = []
for _ in range(N):
    T = input()  # チケットに書かれた文字列
    if not 1 <= len(T) <= 20 or not T.islower():
        raise ValueError("Tの値が制約を満たしていません")
    
    if S in T:  # SがTに含まれる場合は有効
        valid_tickets.append("valid")
    elif any(S in T[:i] + T[i+1:] for i in range(len(T))):  # Tから1文字を削除してSが含まれる場合は有効
        valid_tickets.append("valid")
    else:  # 上記の条件に該当しない場合は無効
        valid_tickets.append("invalid")

# 有効/無効なチケットを出力
for ticket in valid_tickets:
    print(ticket)
'''
入力の受け取りと制約のチェック

N = int(input()): チケットの枚数を整数として受け取ります。
S = input(): 暗号チケットの指定された文字列を受け取ります。
制約を満たしていない場合は、ValueErrorを発生させます。
有効なチケットの判定

valid_tickets = []: 有効なチケットを格納するリストを初期化します。
for _ in range(N):: チケットの枚数分だけループを行います。
T = input(): チケットに書かれた文字列を受け取ります。
if S in T:: もし指定された文字列 S がチケット文字列 T に含まれる場合は、有効なチケットとして判定します。
elif any(S in T[:i] + T[i+1:] for i in range(len(T))):: それ以外の場合、チケット文字列 T から1文字ずつ削除した文字列に指定された文字列 S が含まれるかどうかを判定します。任意のインデックス i に対して、T[:i] + T[i+1:] で T の i 番目の文字を削除した文字列が得られます。
valid_tickets.append("valid"): 上記のいずれかの条件に該当する場合は、有効なチケットとしてリストに追加します。
else: valid_tickets.append("invalid"): 上記の条件に該当しない場合は、無効なチケットとしてリストに追加します。
有効/無効なチケットの出力

for ticket in valid_tickets: print(ticket): 有効/無効なチケットのリストを出力します。
'''
--------------------------------------------- B051　※欠番 ◆
# B051 ◆
# B052 積もる粒子
# utf-8
def simulate_landscape(H, W, N, particles):
    landscape = [[0] * W for _ in range(H)]
    
    def is_valid_position(x, y):
        return 0 <= x < W and 0 <= y < H
    
    def get_lowest_neighbor(x, y):
        lowest_height = landscape[y][x]
        lowest_position = (x, y)
        
        # Check north neighbor
        if is_valid_position(x, y - 1) and landscape[y - 1][x] < lowest_height:
            lowest_height = landscape[y - 1][x]
            lowest_position = (x, y - 1)
        
        # Check east neighbor
        if is_valid_position(x + 1, y) and landscape[y][x + 1] < lowest_height:
            lowest_height = landscape[y][x + 1]
            lowest_position = (x + 1, y)
        
        # Check south neighbor
        if is_valid_position(x, y + 1) and landscape[y + 1][x] < lowest_height:
            lowest_height = landscape[y + 1][x]
            lowest_position = (x, y + 1)
        
        # Check west neighbor
        if is_valid_position(x - 1, y) and landscape[y][x - 1] < lowest_height:
            lowest_height = landscape[y][x - 1]
            lowest_position = (x - 1, y)
        
        return lowest_position
    
    for x, y in particles:
        while True:
            lowest_neighbor = get_lowest_neighbor(x, y)
            if lowest_neighbor == (x, y):
                landscape[y][x] += 1
                break
            else:
                x, y = lowest_neighbor
    
    return landscape

# 入力を受け取る
H, W, N = map(int, input().split())
particles = []
for _ in range(N):
    x, y = map(int, input().split())
    particles.append((x - 1, y - 1))  # 座標を0-indexedに変換

# 地形をシミュレーションして結果を出力
result = simulate_landscape(H, W, N, particles)
for row in result:
    print(" ".join(map(str, row)))
'''
simulate_landscape 関数は、地形をシミュレーションし、最終的な地形を表す二次元リスト landscape を作成します。初期状態では全ての要素が 0 で初期化されます。
is_valid_position 関数は、指定された座標がマップ内に存在するかどうかを判定します。x が 0 以上 W 未満であり、y が 0 以上 H 未満であれば有効な座標と判定します。
get_lowest_neighbor 関数は、指定された座標 (x, y) の隣接地点のうち、最も低い高さを持つ地点を求めます。まず、(x, y) の高さを lowest_height として初期化し、(x, y) 自体を lowest_position に設定します。その後、順番に北、東、南、西の順で隣接地点をチェックし、最も低い高さを持つ地点が見つかれば lowest_height と lowest_position を更新します。
メインの処理部分では、各粒子に対してシミュレーションを行います。粒子の座標 (x, y) を受け取り、隣接地点のうち最も低い地点を lowest_neighbor として取得します。もし lowest_neighbor が (x, y) 自体であれば、その地点に粒子が固定されるため、landscape[y][x] の高さを 1 増やしてループを抜けます。そうでなければ、lowest_neighbor の座標を新たな (x, y) として更新し、再度隣接地点をチェックします。
最後に、関数から最終的な地形の状態を表す二次元リスト landscape を返します。
メイン部分では、入力を受け取り、粒子の座標をリスト particles に格納しています。その後、simulate_landscape 関数を呼び出し、結果を出力します。
このコードは、指定された条件に基づいて地形をシミュレーションするためのものです。入力例に対して実行すると、最終的な地形の状態が出力されます。
'''

# B053 表の自動作成
# utf-8
import numpy as np

# 行数と列数を入力から取得
H, W = input().rstrip().split(' ')

# 表を格納するためのnumpy配列を作成し、初期値を0で初期化
table = np.zeros((2, int(W)))

# オートフィルを適用する必要がある残りの行数と列数を計算
row_left = int(H) - 2
col_left = int(W) - 2

# 2行目から始まる各行について、入力を受け取り、オートフィルを適用して行を完成させる
for h in range(2):
    retu = input().rstrip().split(' ')
    retu = np.array(retu)
    retu = retu.astype(np.int64)
    
    # 行の初項と公差を計算
    sa = retu[1] - retu[0]
    
    # オートフィルを適用して行を完成させる
    for i in range(int(W) - col_left, int(W)):
        retu = np.append(retu, retu[i - 1] + sa)
    
    # 行を表に格納
    table[h, :] = retu

# 2行目以降の行について、前の行との差からオートフィルを適用して行を完成させる
div = table[1] - table[0]
for j in range(int(H) - row_left, int(H)):
    table = np.vstack([table, table[j - 1] + div])

# 最終的な表をリスト形式に変換し、各要素をスペース区切りで出力
table = list(table)
for i in range(int(H)):
    for j in range(int(W)):
        if j == int(W) - 1:
            print(int(table[i][j]), end='')
        else:
            print(int(table[i][j]), end=' ')
    print()
'''
最初に、入力から表のサイズである行数と列数を取得します。表を格納するためのnumpy配列を作成し、初期値として全ての要素を0で初期化します。
行数と列数から、オートフィルを適用する必要がある残りの行数と列数を計算します。2行目から始まる各行について、入力を受け取り、その数列の初項と公差を計算します。そして、オートフィルを適用して行を完成させます。
2行目以降の行について、前の行との差からオートフィルを適用して行を完成させます。最終的な表をリスト形式に変換し、各要素をスペース区切りで出力します。
'''

# B054 不思議な足し算
# utf-8
# 入力の読み込み
s1, s2 = input().split()
s1 = list(s1)
s2 = list(s2)

# 文字列を数値に変換
for i in range(len(s1)):
    if s1[i] == "A":
        s1[i] = '0'
    elif s1[i] == "B":
        s1[i] = '1'
    elif s1[i] == "C":
        s1[i] = "2"
    elif s1[i] == "D":
        s1[i] = "3"
    else:
        s1[i] = "4"

for i in range(len(s2)):
    if s2[i] == "A":
        s2[i] = '0'
    elif s2[i] == "B":
        s2[i] = '1'
    elif s2[i] == "C":
        s2[i] = "2"
    elif s2[i] == "D":
        s2[i] = "3"
    else:
        s2[i] = "4"

# 数値に変換
s1 = int(''.join(map(str, s1)))
s2 = int(''.join(map(str, s2)))

# 5進数から10進数への変換と足し算
ss1 = int(str(s1), 5)
ss2 = int(str(s2), 5)
b = ss1 + ss2

# 10進数から5進数への変換
def base5int(value):
    if int(value / 5):
        return base5int(int(value / 5)) + str(value % 5)
    return str(value % 5)

d = base5int(b)
d = list(d)

# 数値を文字列に変換
for i in range(len(d)):
    if d[i] == "0":
        d[i] = 'A'
    elif d[i] == "1":
        d[i] = 'B'
    elif d[i] == "2":
        d[i] = "C"
    elif d[i] == "3":
        d[i] = "D"
    else:
        d[i] = "E"

# 結果の出力
print(''.join(map(str, d)))
'''
入力文字列 s1 と s2 をスペースで分割して読み込みます。その後、文字列をリストに変換します。
文字列リスト内の各文字を適切な数値に変換します。"A" から "E" までの文字はそれぞれ "0" から "4" の数値に対応しています。
文字列リストを結合し、int() を使用して整数に変換します。それぞれの数値を 5 進数から 10 進数に変換し、足し合わせます。
base5int() 関数を使用して、10 進数の数値 b を 5 進数に逆変換します。変換後の数値をリストに変換し、最後に文字列リストを結合して PAIZA 表記の数値を得ます。最終結果を出力します。
'''

# B055 ◆
# B056 リズムゲームの分析
# utf-8
def check_sharp_pattern(N, sharp, v):
    # "#" のパターンが正しいかをチェックする関数
    # sharp 列目が "+" であり、他の列が "-" であるかを確認する
    for j in range(N):
        if v[j] != ('+' if sharp == j else '-'):
            return False
    return True

def calculate_max_combo(N, M, data):
    max_combo = 0
    prev = False
    prev_sharp = False
    combo = 0
    for i in range(M):
        d = list(data[i][0])  # 譜面データ
        p = list(data[i][1])  # プレイデータ

        sharp = -1
        for j in range(N):
            if d[j] == '#':
                sharp = j
                break

        if sharp >= 0:
            # "#" のパターンの場合
            if check_sharp_pattern(N, sharp, p):
                if prev:
                    combo += 1
                elif not prev_sharp:
                    combo = 1
                    prev = True
                if max_combo < combo:
                    max_combo = combo
            else:
                prev = False
            prev_sharp = True
        else:
            # "#" のパターンでない場合
            if d == p:
                if prev:
                    combo += 1
                else:
                    combo = 1
                    prev = True
                if max_combo < combo:
                    max_combo = combo
            else:
                prev = False
            prev_sharp = False

    return max_combo

# 入力の読み込み
N, M = map(int, input().split())
data = []
for _ in range(M):
    line = input().split()
    data.append((line[0], line[1]))

# 最大コンボ数の計算
max_combo = calculate_max_combo(N, M, data)

# 結果の出力
print(max_combo)
'''
check_sharp_pattern 関数
sharp 列目が "+" であり、他の列が "-" であるかを確認する関数です。
引数としてボタンの数 N、sharp 列目のインデックス、譜面データのリスト v を受け取ります。
v の各要素をチェックし、sharp 列目の要素が "+" であり、他の列の要素が "-" であるかを確認します。
正しいパターンであれば True を、そうでなければ False を返します。

calculate_max_combo 関数
最大コンボ数を計算する関数です。
引数としてボタンの数 N、タイミングの数 M、ログデータのリスト data を受け取ります。
変数 max_combo に最大コンボ数を格納するための初期値 0 を設定します。
変数 prev は直前のタイミングでコンボが続いているかを示すフラグで、初期値は False です。
変数 prev_sharp は直前のタイミングで "#" のパターンが出現したかを示すフラグで、初期値も False です。
ループを通じて各タイミングを処理し、最大コンボ数を更新していきます。
data の各要素に対して、譜面データとプレイデータを取得します。
譜面データに "#" が含まれるかを確認し、含まれる場合と含まれない場合で処理を分岐します。
"#" のパターンの場合は、check_sharp_pattern 関数を用いて正しいパターンであるかをチェックします。
正しいパターンであればコンボ数を更新し、最大コンボ数を更新します。
"#" のパターンでない場合は、譜面データとプレイデータを比較し、一致していればコンボ数を更新し、最大コンボ数を更新します。
各タイミングの処理が終わったら最大コンボ数を返します。

入力の読み込み
最初にボタンの数 N とタイミングの数 M を入力から読み込みます。
その後、M 行分のループを行い、ログデータを読み込みます。
calculate_max_combo 関数の呼び出しと結果の出力
calculate_max_combo 関数を呼び出し、ボタンの数 N、タイミングの数 M、ログデータのリストを渡します。
返された最大コンボ数を出力します。
'''

# B057 回転寿司　※入力例3でNG
# utf-8
def calculate_completion_time(L, sushi_positions, seat_positions):
    sushi_positions.sort()
    seat_positions.sort()

    max_time = 0
    sushi_count = len(sushi_positions)
    seat_count = len(seat_positions)

    for i in range(sushi_count):
        eating_time = 0

        for j in range(seat_count):
            distance = (sushi_positions[i] - seat_positions[j] + L) % L
            time_to_eat = distance + 10
            eating_time = max(eating_time, time_to_eat)

        max_time = max(max_time, eating_time)

    return max_time


L, N, M = map(int, input().split())
sushi_positions = list(map(int, input().split()))
seat_positions = list(map(int, input().split()))

completion_time = calculate_completion_time(L, sushi_positions, seat_positions)

print(completion_time)

別解 # utf-8　※入力例1でNG
def calculate_completion_time(sushi_positions, seat_positions, L):
    sushi_positions.sort()
    seat_positions.sort()

    max_time = 0
    for seat in seat_positions:
        min_distance = L
        for sushi in sushi_positions:
            distance = (sushi - seat) % L
            min_distance = min(min_distance, distance)

        eating_time = (min_distance + L) % L + 10
        max_time = max(max_time, eating_time)

    return max_time


L, N, M = map(int, input().split())
sushi_positions = list(map(int, input().split()))
seat_positions = list(map(int, input().split()))

completion_time = calculate_completion_time(sushi_positions, seat_positions, L)

print(completion_time)

# B058 ◆
# B059 占領区域
# utf-8
def calculate_occupation(H, W, N, countries):
    # マップの初期化
    map = [['?' for _ in range(W)] for _ in range(H)]

    # 各国の占領区域を計算
    for i in range(N):
        a, x, y = countries[i]
        x, y = x - 1, y - 1  # 座標を0-indexedに変換
        map[y][x] = a

    # 各土地からの最短距離を計算し、占領国を更新
    for y in range(H):
        for x in range(W):
            if map[y][x] != '?':
                continue
            min_distance = float('inf')
            occupying_country = ''
            for i in range(N):
                a, cx, cy = countries[i]
                cx, cy = cx - 1, cy - 1  # 座標を0-indexedに変換
                distance = abs(cx - x) + abs(cy - y)
                if distance < min_distance:
                    min_distance = distance
                    occupying_country = a
                elif distance == min_distance:
                    occupying_country = '?'  # 距離が同じ場合は境界上の土地
            map[y][x] = occupying_country

    # 結果の出力
    for row in map:
        print(''.join(row))


# 入力の読み込み
H, W, N = map(int, input().split())
countries = []
for _ in range(N):
    # 各国の情報を読み込む
    a, x, y = input().split()
    countries.append((a, int(x), int(y)))

# 占領区域の計算と出力
calculate_occupation(H, W, N, countries)
'''
このプログラムは、ストラテジーゲームのマップ上で各国の占領している区域を計算し、表示するためのものです。
calculate_occupation 関数を定義します。この関数は、マップの高さ H、幅 W、国の数 N、各国の情報 countries を受け取り、占領区域を計算します。
マップの初期化を行います。map という二次元リストを作成し、マップの全ての要素を '?' で初期化します。
各国の占領区域を計算します。countries リストに格納された各国の情報を取り出し、座標を0-indexedに変換してマップ上の対応する位置に占領国の頭文字をセットします。
各土地からの最短距離を計算し、占領国を更新します。マップ上の各土地について、まだ占領国がセットされていない土地に対して、各国の首都との距離を計算します。
最も距離が近い国を占領国として設定し、距離が同じ場合は境界上の土地として '?' をセットします。
最終的な占領区域を出力します。マップの各行を連結して表示し、各土地がどの国に占領されているかを表示します。
メインの処理として、入力を読み込んでマップの情報を取得し、calculate_occupation 関数を呼び出して占領区域の計算と表示を行います。
'''

# B060 サイコロころがし
# utf-8
N, H, W = list(map(int, input().split()))  # 入力値を取得
sy, sx = list(map(int, input().split()))  # 初期位置を取得
s = input()  # 移動方法を取得
ij = [[0 for i in range(W)] for j in range(H)]  # 旗のマス目の初期化

class Roll:
    def __init__(self, sx, sy):
        self.sx, self.sy, self.stamp, self.u, self.d, self.l, self.r, self.t = sx, sy, 6, 2, 5, 3, 4, 1
    '''
        # サイコロの初期位置と面の初期値を設定する
    self.sx, self.sy = sx, sy  # サイコロの現在位置のx座標とy座標
    self.stamp = 6  # サイコロの現在の面の値
    self.u = 2  # サイコロの上面の値
    self.d = 5  # サイコロの下面の値
    self.l = 3  # サイコロの左面の値
    self.r = 4  # サイコロの右面の値
    self.t = 1  # サイコロの手前面の値
    '''

    def up(self):
        self.sy -= 1
        tmp = self.t
        self.t = self.d
        self.d = self.stamp
        self.stamp = self.u
        self.u = tmp
        return self.stamp

    def down(self):
        self.sy += 1
        tmp = self.t
        self.t = self.u
        self.u = self.stamp
        self.stamp = self.d
        self.d = tmp
        return self.stamp

    def left(self):
        self.sx -= 1
        tmp = self.t
        self.t = self.r
        self.r = self.stamp
        self.stamp = self.l
        self.l = tmp
        return self.stamp

    def right(self):
        self.sx += 1
        tmp = self.t
        self.t = self.l
        self.l = self.stamp
        self.stamp = self.r
        self.r = tmp
        return self.stamp

dice = Roll(sx, sy)  # サイコロを作成し初期位置を設定
ij[sy - 1][sx - 1] = dice.stamp  # 初期位置のマスにサイコロの目の値を設定
for i in s:
    if i == 'U':
        ij[dice.sy - 1][dice.sx - 1] = dice.up()  # 上方向に移動し、そのマスにサイコロの目の値を設定
    if i == 'D':
        ij[dice.sy - 1][dice.sx - 1] = dice.down()  # 下方向に移動し、そのマスにサイコロの目の値を設定
    if i == 'L':
        ij[dice.sy - 1][dice.sx - 1] = dice.left()  # 左方向に移動し、そのマスにサイコロの目の値を設定
    if i == 'R':
        ij[dice.sy - 1][dice.sx - 1] = dice.right()  # 右方向に移動し、そのマスにサイコロの目の値を設定

# 旗のマス目を出力
for i in ij:
    rs = [str(n) for n in i]
    print(" ".join(rs))
'''
まず、入力から回転する回数N、旗のマス目の縦の大きさH、旗のマス目の横の大きさWが取得されます。また、最初にサイコロを置く位置の行syと列sxも取得されます。
その後、文字列sが取得され、これはサイコロの移動方法を表しています。具体的には、"U"は上方向、"D"は下方向、"L"は左方向、"R"は右方向の移動を示します。
次に、H行W列の二次元リストijが作成されます。このリストは、旗の各マスの色を表します。初期状態ではすべてのマスが0（白色）で初期化されます。
そして、Rollクラスが定義されます。このクラスはサイコロの動作を管理します。サイコロの現在位置と各面の値を保持します。
クラスには、上方向への移動を表すupメソッド、下方向への移動を表すdownメソッド、左方向への移動を表すleftメソッド、右方向への移動を表すrightメソッドが定義されています。
これらのメソッドは、サイコロの位置と面の値を適切に変更し、移動後の面の値を返します。
Rollクラスのインスタンスdiceが作成され、初期位置であるsy行sx列のマスにサイコロの面の値（stamp）が設定されます。
その後、文字列sを順に処理し、各移動に応じてサイコロを移動させます。移動方法に従ってサイコロの位置と面の値が変更され、ijリストの対応するマスに面の値が記録されます。
最後に、ijリストの各行を順に出力します。各行はスペースで区切られた数字のシーケンスとなり、それぞれの数字は旗の各マスの色を表します。この出力によって、シミュレーション後の旗のデザインが表示されます。
'''
--------------------------------------------- B061　※欠番 ◆
# B061 福袋詰め
# utf-8
import itertools

def count_lucky_bags(S, N, values):
    '''
    福袋に詰める商品の組み合わせの数を計算する関数

    Parameters:
        S (int): 福袋に詰める商品の価値の合計の最小値
        N (int): 福袋に詰める候補となる商品の数
        values (list): 商品の価値を表す整数のリスト

    Returns:
        int: 福袋に詰める商品の組み合わせの数
    '''
    count = 0
    # 商品の個数で組み合わせを生成
    for i in range(1, N+1):
        for combination in itertools.combinations(values, i):
            # 組み合わせの値の合計がS以上であるかを確認
            if sum(combination) >= S:
                valid = True
                for j in combination:
                    # 商品を1つ取り除いた場合の値の合計がS未満であるかを確認
                    if sum(combination) - j >= S:
                        valid = False
                        break
                if valid:
                    count += 1

    return count

# 入力の受け取り
S = int(input())
N = int(input())
values = [int(input()) for _ in range(N)]

# 福袋の詰め方の組み合わせの数を計算
result = count_lucky_bags(S, N, values)

# 結果の出力
print(result)
'''
福袋に詰める商品の組み合わせの数を計算するための関数 count_lucky_bags が定義されています。
この関数は、以下の手順で組み合わせの数を計算します。
count_lucky_bags 関数の引数として、福袋に詰める商品の価値の合計の最小値 S、福袋に詰める候補となる商品の数 N、および商品の価値を表す整数のリスト values が与えられます。
初期化: 組み合わせの数をカウントするための変数 count を0で初期化します。
商品の個数ごとの組み合わせ生成: for ループを使用して、商品の個数ごとに組み合わせを生成します。range(1, N+1) の範囲でループし、1つからN個の商品を含む組み合わせを生成します。
組み合わせの条件判定: itertools.combinations を使用して、与えられた商品リスト values から i 個の商品を選んだ組み合わせを生成します。生成された組み合わせの値の合計が S 以上であるかを確認します。
条件を満たす組み合わせの特定: 組み合わせの値の合計が S 以上の場合、さらに個別の商品を1つずつ取り除いた場合の組み合わせの値の合計が S 未満であるかを確認します。この確認を行い、条件を満たす組み合わせを特定します。
条件を満たす組み合わせのカウント: 条件を満たす組み合わせが特定された場合、カウンター変数 count をインクリメントします。
結果の返却: ループが終了したら、最終的な count の値を返します。
コードの最後では、入力の受け取り、count_lucky_bags 関数の呼び出し、結果の出力が行われています。
'''

# B062 部屋掃除ロボット
# utf-8
N = int(input())  # 掃除する時間
H, W = map(int, input().split())  # 部屋の縦と横のマスの数

s = []  # 部屋の状態を格納するリスト
for _ in range(H):
    s.append(input())  # 部屋の各行の状態をリストに追加

h, w = 0, 0  # ロボットの現在位置 (初期位置は左上)
d = 0  # 掃除したマスの数
c = 'right'  # ロボットの進行方向

for _ in range(N):
    if c == 'right':
        if s[h][w] == '#':  # 現在位置が汚れている場合
            d += 1  # マスを掃除する
        s[h] = s[h][:w] + '*' + s[h][w+1:]  # マスの状態を掃除済みに更新
        if w < W-1 and s[h][w+1] != '*':  # 右に進める場合
            w += 1  # 右に進む
        elif h < H-1 and s[h+1][w] != '*':  # 下に進める場合
            c = 'down'  # 進行方向を変更して下に進む
            h += 1
        else:
            break  # 進める方向がない場合は終了
    elif c == 'down':
        # 以下同様の処理をコメント追加しながら繰り返す
        if s[h][w] == '#':
            d += 1
        s[h] = s[h][:w] + '*' + s[h][w+1:]
        if h < H-1 and s[h+1][w] != '*':
            h += 1
        elif w > 0 and s[h][w-1] != '*':
            c = 'left'
            w -= 1
        else:
            break
    elif c == 'left':
        if s[h][w] == '#':
            d += 1
        s[h] = s[h][:w] + '*' + s[h][w+1:]
        if w > 0 and s[h][w-1] != '*':
            w -= 1
        elif h > 0 and s[h-1][w] != '*':
            c = 'up'
            h -= 1
        else:
            break
    elif c == 'up':
        if s[h][w] == '#':
            d += 1
        s[h] = s[h][:w] + '*' + s[h][w+1:]
        if h > 0 and s[h-1][w] != '*':
            h -= 1
        elif w < W-1 and s[h][w+1] != '*':
            c = 'right'
            w += 1
        else:
            break

print(d)  # 掃除したマスの数を出力
'''
掃除ロボットが指定された時間内に部屋のマスを掃除する機能を実装しています。
最初に、入力から掃除する時間を表す整数 N、部屋の縦と横のマスの数を表す整数 H と W を受け取ります。次に、部屋の状態を示す文字列を入力として受け取り、それをリスト s に格納します。
掃除ロボットの初期位置は部屋の左上のマスであり、ロボットの現在位置を h と w の変数で追跡します。また、掃除したマスの数を表す変数 d を初期化し、ロボットの進行方向を表す変数 c を初期値 'right' で設定します。
次に、指定された時間 N の回数だけ以下の処理を繰り返します。
まず、現在の進行方向が 'right' の場合を考えます。現在位置が汚れている場合、d をインクリメントしてマスを掃除します。その後、現在位置を掃除済みに更新します。次に、右に進むことができる場合は w をインクリメントします。もし右に進めない場合は、下に進むことができるかを確認し、できる場合は進行方向を 'down' に変更して h をインクリメントします。右にも下にも進めない場合は、掃除を終了します。
同様の手順で、進行方向が 'down'、'left'、'up' の場合についても処理を行います。進行方向ごとに、現在位置が汚れている場合は d をインクリメントし、現在位置を掃除済みに更新します。進行方向に応じて次のマスに進むかを判断し、進める場合は位置を更新します。進めない場合は、掃除を終了します。
最後に、掃除したマスの数 d を出力します。
'''

# B063 支払う枚数とお釣りの枚数　※テストケース60点
# utf-8
def count(x):
    coins = [500, 100, 50, 10, 5, 1]
    c = 0

    for coin in coins:
        while x >= coin:
            c += 1
            x -= coin

    return c

def total_count(x, y):
    return count(y) + count(y - x)

x = int(input())
minc = count(x)
y = x

if y % 10 > 0 and y % 10 < 5:
    y = (y // 10) * 10 + 5
    c = total_count(x, y)
    if minc > c:
        minc = c

if y % 10 > 0:
    y = (y // 10) * 10 + 10
    c = total_count(x, y)
    if minc > c:
        minc = c

if y % 100 > 0 and y % 100 < 50:
    y = (y // 100) * 100 + 50
    c = total_count(x, y)
    if minc > c:
        minc = c

if y % 100 > 0:
    y = (y // 100) * 100 + 100
    c = total_count(x, y)
    if minc > c:
        minc = c

if y < 500:
    y = 500
    c = total_count(x, y)
    if minc > c:
        minc = c

y = 1000
c = total_count(x, y)
if minc > c:
    minc = c

print(minc)

# B064 うずを探せ
# utf-8
import copy

H, W = map(int, input().split())
s = [list(input()) for _ in range(H)]

# 入力値のバリデーションチェック
if not (1 <= H <= 10) or not (1 <= W <= 10):
    print("縦と横のサイズは1以上10以下である必要があります。")
    exit()

for row in s:
    if len(row) != W or any(direction not in "RLUD" for direction in row):
        print("入力が正しくありません。各行は長さWの文字列で、R, L, U, Dのみが使用できます。")
        exit()

x, y, ans = 0, 0, 0
s1 = copy.deepcopy(s)

for h in range(H):
    for w in range(W):
        ss = s[h][w]
        if ss == '*':
            continue
        s[h][w] = '*'
        # スタート地点の範囲チェック
        if (h == 0 and ss == 'U') or (w == 0 and ss == 'L') or (h == H-1 and ss == 'D') or (w == W-1 and ss == 'R'):
            continue
        x = h
        y = w
        for i in range(H * W):
            # 移動先の座標の範囲チェック
            if not (0 <= x < H) or not (0 <= y < W):
                break
            if ss == 'U':
                x -= 1
            elif ss == 'L':
                y -= 1
            elif ss == 'D':
                x += 1
            elif ss == 'R':
                y += 1
            ss = s[x][y]
            s[x][y] = '*'
            if x == h and y == w:
                ans += 1
                s1 = copy.deepcopy(s)
                break
            if ss == '*':
                s = copy.deepcopy(s1)
                break

print(ans)
'''
与えられた天気図のグリッド上で渦の個数を求める
最初に、入力された縦幅と横幅を取得します。また、天気図の状態を表す文字列のリスト s を作成します。
入力値のバリデーションチェックを行います。縦幅と横幅が1以上10以下であること、および各行が長さWの文字列であり、文字は'R', 'L', 'U', 'D'のいずれかであることを確認します。
変数 x, y, ans を初期化します。x, y は現在の位置を表す変数で、ans は渦の個数を数えるための変数です。
天気図の状態を保持するリスト s1 を作成します。このリストは、渦の探索中に一時的な変更を保持するために使用されます。
全てのマスを順番に探索します。二重のループを使用し、各マスについて以下の処理を行います。
マスの風向きを取得し、変数 ss に代入します。
もしマスがすでに探索済みであればスキップし、探索を続けます。
マスを探索済みとしてマークします。
スタート地点の範囲チェックを行い、範囲外であればスキップし、次のマスへ移動します。
スタート地点を設定し、渦の探索を開始します。
一周するまで渦を辿り、マスを探索済みとしてマークします。一周した場合は、渦の個数 ans をインクリメントし、s1 を現在の天気図の状態に更新します。
一周せずにすでに探索済みのマスに到達した場合、探索を終了します。
最終的な渦の個数 ans を出力します。
'''

# B065 小さなライフゲーム
# utf-8
def mass_change(left, right):
    # マスの左右の組み合わせに応じてキーを返す
    left_right = left + right
    if left_right == "--":
        return 0  # 左右が "-" の場合、キーは0
    elif left_right == "-+":
        return 1  # 左が "-" で右が "+" の場合、キーは1
    elif left_right == "+-":
        return 2  # 左が "+" で右が "-" の場合、キーは2
    elif left_right == "++":
        return 3  # 左右が "+" の場合、キーは3

def mass_game(mass_arr, rule_arr):
    # マスゲームの実行
    result_arr = []
    for i in range(10):
        if i == 0:
            left = mass_arr[9]  # 左隣のマスの値
            right = mass_arr[i + 1]  # 右隣のマスの値
        elif i == 9:
            left = mass_arr[i - 1]  # 左隣のマスの値
            right = mass_arr[0]  # 右隣のマスの値
        else:
            left = mass_arr[i - 1]  # 左隣のマスの値
            right = mass_arr[i + 1]  # 右隣のマスの値

        key = mass_change(left, right)  # マスの左右の組み合わせに応じてキーを取得
        ans = rule_arr[key]  # キーに対応するルールを取得
        result_arr.append(ans)  # 結果を配列に追加

    return result_arr

# 入力の読み込み
S, T = input().split()
mass_arr = list(S)  # 初期盤面のマス配列
rule_arr = list(T)  # 更新ルールの配列
result_arr = mass_arr  # マスゲームの結果の配列
ans = "NO"  # 初期値はNO

# マス配列、ルール配列を1024回ループしてゲームを実行
for _ in range(1024):
    result_arr = mass_game(result_arr, rule_arr)
    if result_arr == mass_arr:
        ans = "YES"  # 初期盤面に戻った場合はYESとする
        break

# 結果の出力
print(ans)
'''
与えられた初期盤面と更新ルールに基づいてミニライフゲームを実行し、初期盤面に戻るかどうかを判定するプログラムです。
まず、入力から初期盤面の文字列 S と更新ルールの文字列 T を読み込みます。それぞれをマス配列 mass_arr とルール配列 rule_arr に変換します。
また、マスゲームの結果を保持するための配列 result_arr を初期盤面と同じに設定します。そして、初期値として判定結果の文字列 ans を "NO" とします。
次に、1024回のループを実行します。ループ内では、mass_game 関数を使用してマスゲームの結果を計算し、結果を result_arr に更新します。その後、result_arr が初期盤面と一致するかを確認します。
一致した場合は、ans を "YES" に変更し、ループを抜けます。
最後に、最終的な判定結果を出力します。

関数 mass_change は、与えられた左隣と右隣のマスの値に応じて、適切なキーを返します。
キーは以下のように対応しています：
左右が "-" の場合はキーが0
左が "-" で右が "+" の場合はキーが1
左が "+" で右が "-" の場合はキーが2
左右が "+" の場合はキーが3
関数 mass_game は、与えられたマス配列とルール配列に基づいてマスゲームの結果を計算します。
各マスに対して、左隣と右隣のマスの値を取得し、mass_change 関数でキーを求めます。キーに対応するルールをルール配列から取得し、結果配列に追加します。最終的に結果配列を返します。
'''

# B066 色のパズル
# utf-8
import itertools
import copy

X, N, M = list(map(int, input().split()))
c, cc = [], []
p = [[] for i in range(X)]

# パズルの状態とピースの情報を入力
for i in range(N):
    c.append(list(input()))

for i in range(X):
    for j in range(M):
        p[i].append(list(input()))
    p[i] = sum(p[i], [])

# パズルのピースの配置を整形
nm = N // M  # パズルの一辺がピース何個分か
for i in range(nm ** 2):
    ccc = []
    for j in range(M):
        ccc.append(c[i // nm * M + j][i % nm * M:i % nm * M + M])
    cc.append(ccc)

pp = [[] for i in range(X)]
for i in range(X):
    for j in range(M):
        pp[i].append(p[i][j * M:j * M + M])

# 各ピースをチェック
for i in range(X):
    flag = False
    # ピースと完成図の合うものを探す
    for j in range(nm ** 2):
        if pp[i] == cc[j]:
            print(j // nm * M + 1, j % nm * M + 1, 0)  # 回転なしで合致した場合
            flag = True
            break
    # もし見つかったら、次のピースに移る
    if flag:
        continue
    # ピースの回転
    ppp = [[' ' for i in range(M)] for j in range(M)]
    p4 = pp[i]
    # ピースを最大3回転させる
    for n in range(3):
        for k in range(M):
            for m in range(M):
                ppp[m][M - 1 - k] = p4[k][m]
        # ピースを回転させた後、合うものを探している。
        for j in range(nm ** 2):
            if ppp == cc[j]:
                print(j // nm * M + 1, j % nm * M + 1, n + 1)  # 回転後に合致した場合
                flag = True
                break
        if flag:
            break
        p4 = copy.deepcopy(ppp)
    if not flag:
        print(-1)  # 合致するピースが見つからなかった場合
'''
このプログラムは、与えられたピースとパズルの状態から、パズルのピースを組み合わせて完成形を作り出すための解法を提供します。
最初に、itertoolsモジュールとcopyモジュールをインポートします。これらのモジュールは、組み合わせの生成とオブジェクトのコピーを行うために使用されます。
ピースの個数を表す整数X、パズルの大きさを表す整数N、ピースの大きさを表す整数Mを入力します。
パズルの状態を表すリストcとピースの情報を格納するリストpを初期化します。
パズルの状態を入力し、リストcに格納します。
各ピースの情報を入力し、リストpに格納します。また、ピースを1次元のリストに変換しています。
パズルのピースの配置を整形し、リストccに格納します。これにより、パズルの一辺がMマスのピース何個分かを正確に表現することができます。
ピースの情報を整形し、リストppに格納します。これにより、各ピースをM x Mの2次元リストとして表現することができます。
各ピースを順番にチェックします。
ピースと完成図の合致を探し、見つかった場合はその位置と回転回数を出力します。合致するピースが見つかった場合、flagフラグを立ててループを抜けます。
もし合致するピースが見つからなかった場合、ピースを最大3回転させながら再度合致を探します。
合致するピースが見つかった場合は、その位置と回転回数を出力し、flagフラグを立ててループを抜けます。
もし合致するピースが見つからなかった場合、-1を出力します。
'''

# B067 タスクの管理
# utf-8
schelde_input = []
N = 0
while not (1 <= N <= 100):
    N = int(input())  # タスクの数を入力

condition_ness_day = []  # タスクの必要日数を格納するリスト
condition_start_day = []  # タスクの開始日を格納するリスト
condition_end_day = []  # タスクの終了日を格納するリスト

# タスクの入力を受け取り、条件を満たすものをリストに追加する
for _ in range(N):
    i_n = input().split(' ')
    i_n = list(map(int, i_n))
    if (i_n[2] >= i_n[1]) and (i_n[0] <= (i_n[2] - i_n[1] + 1)):
        schelde_input.append(i_n)

is_check = True

# 各タスクの必要日数、開始日、終了日をリストに分割して格納する
for n in schelde_input:
    condition_ness_day.append(n[0])
    condition_start_day.append(n[1])
    condition_end_day.append(n[2])

# タスクを終了日までに完了できるか判定する
if sum(condition_ness_day) <= (max(condition_end_day) - min(condition_start_day) + 1):
    if (condition_start_day[-1] + sum(condition_ness_day) <= condition_end_day[-1]):
        is_check = True
    else:
        is_check = False
else:
    is_check = False

# 結果を出力する
if is_check:
    print("YES")
else:
    print("NO")
'''
タスクの数と各タスクの情報を入力として受け取り、それらの条件を満たすかどうかを判定します。
最初に、タスクの数を入力します。この値は1以上100以下でなければなりません。
次に、タスクの数だけタスクの情報を入力します。各タスクの情報は必要日数、開始日、終了日の順で半角スペース区切りで与えられます。
入力されたタスクの情報が条件を満たすかどうかを判定します。条件は以下の通りです。
タスクの開始日が終了日以下であること
タスクの必要日数が終了日 - 開始日 + 1以下であること
全てのタスクの情報が条件を満たす場合、タスクを終了日までに完了できるかどうかを判定します。
タスクの必要日数の合計が、最後のタスクの終了日 - 最初のタスクの開始日 + 1以下であること
タスクの開始日と必要日数の合計が最後のタスクの終了日以下であること
最終的な結果を出力します。タスクを終了日までに完了できる場合は「YES」を、できない場合は「NO」を出力します。
'''

# B068 チョコの分割
# utf-8
def check(allSugarList):
    """
    与えられたチョコレートの糖度リストが条件1を満たすかをチェックする関数

    Parameters:
        allSugarList (list): チョコレートの糖度リスト

    Returns:
        bool: 条件1を満たす場合はTrue、そうでない場合はFalse
    """
    result = []
    for i in allSugarList:
        if sum(i) % 2 == 0:
            result.append(True)
        else:
            result.append(False)

    if False in result:
        return False
    else:
        return True


def check2(allSugarList):
    """
    与えられたチョコレートの糖度リストが条件2を満たすかをチェックする関数

    Parameters:
        allSugarList (list): チョコレートの糖度リスト

    Returns:
        bool: 条件2を満たす場合はTrue、そうでない場合はFalse
    """
    result = []
    for i in allSugarList:
        if sum(i) % 2 == 0:
            wa = 0
            for j in i:
                wa += j
                if wa == sum(i) // 2:
                    result.append(True)
        if True not in result:
            result.append(False)
    if False in result:
        return False
    else:
        return True


# チョコレートの行数と列数を取得
h, w = map(int, input().split())
allSugarList = []

# チョコレートのかけらの糖度を入力し、リストに追加
for i in range(h):
    result = []
    sugarList = list(map(int, input().split()))
    allSugarList.append(sugarList)

# 2つの条件を満たすかをチェックし、結果に応じて出力
if check(allSugarList) and check2(allSugarList):
    print("Yes")
    for i in allSugarList:
        result = []
        wa = sum(i) // 2
        for j in range(w):
            if wa != 0:
                wa -= i[j]
                result.append("A")
            else:
                result.append("B")
        print("".join(result))
else:
    print("No")
'''
まず、check関数は、与えられたチョコレートの糖度リストが条件1を満たすかどうかをチェックする関数です。
条件1は、「それぞれの行ごとに、アリスとボブが得る糖度の和が等しくなるようにチョコを分ける」というものです。check関数は、糖度リストの各行の糖度の和が偶数であればTrueを、奇数であればFalseを返します。
次に、check2関数は、与えられたチョコレートの糖度リストが条件2を満たすかどうかをチェックする関数です。条件2は、「それぞれの行ごとに、左端から連続したかけらをアリスがもらい、残りはボブがもらう」というものです。
check2関数は、糖度リストの各行に対して、左端から順にかけらの糖度を足していき、アリスがもらうかけらの糖度の和がその行の糖度の和の半分になるかどうかをチェックします。
条件を満たす場合はTrueを、満たさない場合はFalseを返します。
メインの処理部分では、まずチョコレートの行数と列数を入力として受け取ります。その後、糖度リストを入力として受け取り、allSugarListに格納します。
次に、check関数とcheck2関数を使って、与えられたチョコレートが2つの条件を満たすかどうかを判定します。条件を満たす場合は"Yes"を出力し、各行に対してアリスとボブがもらうかけらを割り当てます。
アリスがもらうかけらは左端から連続していき、残りはボブがもらうようにします。条件を満たさない場合は"No"を出力します。
'''
    
# B069 蟻の餌探し
# utf-8
import numpy as np
import sys

sys.setrecursionlimit(10**6)

def isPheromone(ant_map, y, x):
    # 指定された座標がフェロモンのある座標かどうかを判定
    if ant_map[y, x] != '#':
        return False
    else:
        return True

def isreachable(ant_map, search_map, feed_y, feed_x, H, W):
    # 目的地に到達可能かどうかを判定する再帰関数
    if (feed_y == 0) and (feed_x == 0):
        return True

    search_map[feed_y, feed_x] = True

    directions = [(feed_y - 1, feed_x), (feed_y, feed_x - 1), (feed_y + 1, feed_x), (feed_y, feed_x + 1)]
    for next_y, next_x in directions:
        # 次の座標が範囲外の場合はスキップ
        if (next_y < 0) or (next_x < 0) or (next_y >= H) or (next_x >= W):
            continue
        # すでに探索済みの場合はスキップ
        if search_map[next_y, next_x]:
            continue
        # フェロモンのある座標の場合、再帰的に探索を行う
        if isPheromone(ant_map, next_y, next_x):
            if isreachable(ant_map, search_map, next_y, next_x, H, W):
                return True

    return False

if __name__ == '__main__':
    H, W = map(int, input().rstrip().split())

    # 入力の制約条件のバリデーションチェック
    if H < 3 or H > 100 or W < 3 or W > 100:
        print('Invalid input: H and W should be between 3 and 100.')
        exit()

    ant_map = []
    for _ in range(H):
        s = input().rstrip()

        # 入力の制約条件のバリデーションチェック
        if len(s) != W or not all(ch == '.' or ch == '#' for ch in s):
            print('Invalid input: Each S_i should be a string of length W containing only "." or "#".')
            exit()

        ant_map.append(list(s))
    ant_map = np.array(ant_map)

    N = int(input())

    # 入力の制約条件のバリデーションチェック
    if N < 1 or N > 10:
        print('Invalid input: N should be between 1 and 10.')
        exit()

    feed_list = [list(map(int, input().split())) for _ in range(N)]

    # feed_list の各要素の範囲チェック
    for i in range(N):
        y, x = feed_list[i]
        if y < 1 or y > H or x < 1 or x > W:
            print('Invalid input: y_k and x_k should be between 1 and H, 1 and W respectively.')
            exit()

    cannot = False
    for i in range(N):
        # 餌の座標がフェロモンのある座標でない場合は到達不可能と判定
        if ant_map[feed_list[i][0] - 1, feed_list[i][1] - 1] != '#':
            cannot = True
            print('NO')
            break

        search_map = np.array([[False for _ in range(W)] for _ in range(H)])
        # 到達可能かどうかを判定
        if not isreachable(ant_map, search_map, feed_list[i][0] - 1, feed_list[i][1] - 1, H, W):
            cannot = True
            print('NO')
            break

    if not cannot:
        print('YES')
'''
まず、isPheromone関数は、指定された座標がフェロモンのある座標かどうかを判定します。ant_mapという2次元配列でアリの巣と餌の情報を保持しており、座標の値が'#'ならフェロモンがあることを意味し、それ以外ならフェロモンがないことを示します。
次に、isreachable関数は、再帰的な探索を行い、目的地までの到達可能性を判定します。feed_yとfeed_xは現在の座標を表します。関数内では、現在の座標が目的地に到達しているかを確認し、到達していればTrueを返します。
そうでなければ、現在の座標から上下左右の座標に移動し、再帰的に探索を行います。探索済みの座標はsearch_mapという2次元配列で管理され、Trueがセットされている座標は再度探索しないようになっています。
メインの処理部分では、まず入力からアリの巣と餌の情報を受け取り、制約条件のバリデーションチェックを行います。アリの巣と餌の情報はant_mapという2次元配列に格納されます。
次に、餌の数と座標のリストを受け取り、それぞれの座標が制約条件に適合しているかをチェックします。
その後、餌の座標がフェロモンのある座標でない場合や、餌からアリの巣まで到達できない場合にはNOを出力し、それ以外の場合はYESを出力します。
このように、制約条件のチェックや再帰的な探索を行いながら、アリが餌まで移動できるかどうかを判定するプログラムとなっています。
'''

# B070 駒の到達範囲 ※入力例2でNG
def count_reachable_cells(N, H, W, K):
    # dpテーブルの初期化
    dp = [[[0] * (K + 1) for _ in range(N)] for _ in range(N)]
    dp[H-1][W-1][0] = 1

    # 上下左右および斜め方向への移動量
    dx = [0, 0, 1, -1]
    dy = [1, -1, 0, 0]

    # マスの移動をK回まで繰り返す
    for k in range(1, K + 1):
        for i in range(N):
            for j in range(N):
                for d in range(4):
                    nx, ny = i + dx[d], j + dy[d]
                    if 0 <= nx < N and 0 <= ny < N:
                        dp[i][j][k] += dp[nx][ny][k-1]
                
                # 斜め方向への移動
                for d in range(4):
                    nx, ny = i + dx[d], j + dy[d]
                    while 0 <= nx < N and 0 <= ny < N:
                        dp[i][j][k] += dp[nx][ny][k-1]
                        nx += dx[d]
                        ny += dy[d]

    # 到達可能なマスの数の合計を計算
    total = sum(dp[i][j][K] for i in range(N) for j in range(N))

    return total

# 入力を受け取る
N, H, W, K = map(int, input().split())

# 相異なるマスの数を計算
result = count_reachable_cells(N, H, W, K)

# 結果を出力
print(result)

--------------------------------------------- B071　※欠番 ◆
# B071 ダンベルトレーニング　※テストケース通過せず　80点　境界値で不一致
# utf-8
import itertools

def find_nearest_weight(N, weights, M):
    nearest_weight = float('inf')  # Mに最も近い重さを表す変数を無限大で初期化

    # おもりの組み合わせをすべて試す
    for r in range(1, N+1):
        combinations = itertools.combinations(weights, r)  # おもりの組み合わせを生成

        for combination in combinations:
            total_weight = sum(combination)  # 組み合わせの合計重さ

            # バーの両端の重さが等しくなる条件を満たす場合、nearest_weightを更新する
            if total_weight % 2 == 0 and total_weight <= M and abs(M - total_weight) < abs(M - nearest_weight):
                nearest_weight = total_weight

    if nearest_weight == float('inf'):  # 条件を満たす組み合わせが存在しない場合
        return 0
    else:
        return nearest_weight

# 入力を受け取る
N, M = map(int, input().split())

# バリデーションチェック
if not (1 <= N <= 10):
    print("Nの値が範囲外です")
    exit()
if not (1 <= M <= 100):
    print("Mの値が範囲外です")
    exit()

weights = []
for _ in range(N):
    weight = int(input())
    if not (1 <= weight <= 10):
        print("おもりの重さが範囲外です")
        exit()
    weights.append(weight)

nearest = find_nearest_weight(N, weights, M)
print(nearest)

# B072 反転スイッチ
# utf-8
def toggle_screen(screen_size, pattern_size, pattern, num_switches, switches):
    # 画面の初期化
    screen = [['_' for _ in range(screen_size[1])] for _ in range(screen_size[0])]

    # スイッチを押す回数だけ繰り返す
    for _ in range(num_switches):
        # パターンの行ごとに繰り返す
        for i in range(pattern_size[0]):
            # パターンの列ごとに繰り返す
            for j in range(pattern_size[1]):
                # 画面の範囲内かをチェック
                if 0 <= i < screen_size[0] and 0 <= j < screen_size[1]:
                    # パターンが '#' の場合は反転させる
                    if pattern[i][j] == '#':
                        # スイッチの座標を基準にして画面の状態を反転させる
                        screen[i + switches[_][1] - 1][j + switches[_][0] - 1] = '#' if screen[i + switches[_][1] - 1][j + switches[_][0] - 1] == '_' else '_'

    return screen

# 入力の読み込み
# 画面の縦の大きさ H、横の大きさ W
H, W = map(int, input().split())
# パターンの縦の大きさ N、横の大きさ M
N, M = map(int, input().split())

pattern = []
for _ in range(N):
    pattern.append(list(input()))
    
# スイッチを押す回数 Q
Q = int(input())
switches = []
# スイッチを押す回数だけ繰り返す
for _ in range(Q):
    # スイッチの対応するパターンの左上の x 座標 x_k、y 座標 y_k 
    switches.append(list(map(int, input().split())))

# 画面の状態を計算
result = toggle_screen((H, W), (N, M), pattern, Q, switches)

# 結果の出力
for row in result:
    print(''.join(row))
'''
toggle_screen 関数は、画面の状態を反転させる処理を行います。引数として、画面のサイズ screen_size、パターンのサイズ pattern_size、パターンの反転模様 pattern、スイッチの回数 num_switches、スイッチの座標情報 switches を受け取ります。
screen は二次元リストとして初期化され、画面のサイズに応じて全ての要素が '_'（白色）で埋められます。
スイッチを押す回数だけ繰り返すループがあります。各スイッチの回数に対して、以下の処理が行われます。
パターンの行ごとに繰り返すループがあります。
パターンの列ごとに繰り返すループがあります。
画面の範囲内かをチェックします。行番号 i と列番号 j が画面の範囲内にあるかを確認します。
パターンが '#' の場合は、スイッチの座標情報を基準にして画面の状態を反転させます。スイッチの座標情報 switches[_] の x 座標 switches[_][0] と y 座標 switches[_][1] を使用して、対応する画面上の座標を計算し、その位置の要素を反転させます。
toggle_screen 関数は最終的に、スイッチを押した後の画面の状態 screen を返します。
入力の読み込みが行われます。まず、画面の縦と横のサイズを H と W に読み込みます。
パターンの縦と横のサイズを N と M に読み込みます。
パターンの反転模様を読み込み、二次元リストとして pattern に格納します。
スイッチの回数を Q に読み込みます。
スイッチの座標情報を読み込み、リストとして switches に格納します。
toggle_screen 関数を呼び出し、最終的な画面の状態を result に格納します。
最終的な画面の状態を出力します。各行を結合して一つの文字列にし、それを行ごとに出力します。

これにより、与えられた入力に基づいてスイッチの押し操作をシミュレートし、最終的な画面の状態を出力するプログラムが実行されます。
'''

# B073 イルミネーションの調査
# utf-8　
"""
回答方針
(1) 各木に備えつけられた電球の数のリストを用意
(2) 調査区間毎の辞書を用意
(3) (2)を一つずつ取り出して、電球追加後の値に(1)を更新
(4) (3)を出力
"""

def is_valid_integer(value, lower, upper):
    return lower <= value <= upper

# NとMの入力チェック
N, average = map(int, input().split())
if not is_valid_integer(N, 1, 1000) or not is_valid_integer(average, 1, 100):
    print("Invalid input for N or M.")
    exit(1)

# 木の数と電球の数の入力チェック
areaArray = list(map(int, input().split()))
if len(areaArray) != N or not all(is_valid_integer(A, 1, 100) for A in areaArray):
    print("Invalid input for A_i.")
    exit(1)

# Qの入力チェック
Q = int(input())
if not is_valid_integer(Q, 1, 1000):
    print("Invalid input for Q.")
    exit(1)

researchArea = []
# 各調査区間の入力チェック
for _ in range(Q):
    S_i, E_i = map(int, input().split())
    if not (is_valid_integer(S_i, 1, N) and is_valid_integer(E_i, S_i, N)):
        print("Invalid input for S_i or E_i.")
        exit(1)
    research = {"start": S_i-1, "end": E_i-1, "range": (E_i - S_i) + 1}
    researchArea.append(research)

# (3) (2)を一つずつ取り出して、電球追加後の値に(1)を更新
# 手順
# 1. researchAreaのstart,endのリストを取り出して平均の電球の数の平均値を取得
# 2. average-1 をする。
# 3. 2.がマイナス値でない場合、区間の電球の数を追加
for research in researchArea:
    areas = areaArray[research["start"]: research["start"] + research["range"]]
    score = sum(areas) // research["range"]
    diff = average - score
    if diff > 0:
        for i in range(research["start"], research["end"] + 1):
            areaArray[i] += diff

# 回答結果を出力
print(" ".join(map(str, areaArray)))
'''
このコードは、与えられた並木道の情報と調査区間の情報に基づいて、電球の数を更新するプログラムです。以下でコードの概要を説明します。
まず、is_valid_integerという関数が定義されています。この関数は、ある値が指定された範囲内にあるかどうかを確認するために使用されます。
次に、NとMを入力として受け取ります。Nは並木道に並ぶ木の本数を表し、Mは区間の電球の平均個数が上回らなければならない数です。
これらの値が正しい範囲内にあるかどうかをチェックし、無効な入力の場合はエラーメッセージを表示してプログラムを終了します。
その後、並木道の情報を表す整数のリストareaArrayを入力として受け取ります。このリストは、各木にいくつの電球が装飾されているかを表します。
リストの長さがNであり、各要素が1から100の範囲内にあるかどうかを確認します。無効な入力の場合はエラーメッセージを表示してプログラムを終了します。
次に、電球の数を調べたい区間の数を表す整数Qを入力として受け取ります。Qは後続のQ行の入力を読み取るために使用されます。Qが1から1000の範囲内にあるかどうかを確認し、無効な入力の場合はエラーメッセージを表示してプログラムを終了します。
続いて、Q行の入力を処理します。各行には、電球の数を調べたい区間の始点と終点が半角スペースで区切られています。始点と終点が1からNの範囲内にあり、始点が終点以下であることを確認します。
無効な入力の場合はエラーメッセージを表示してプログラムを終了します。有効な入力の場合は、調査区間を表す辞書を作成し、リストresearchAreaに追加します。
これで入力処理が完了し、調査区間の情報を元に電球の数を更新します。各調査区間について、区間の木の数を取得し、その平均値を計算します。
平均値と指定された平均個数(M)との差分を計算し、正の値であれば区間の電球の数を更新します。
最後に、更新された電球の数をスペース区切りの文字列として出力します。
'''

# B074 コメントの順序
# utf-8
def calculate_comment_popularity(comment_id, comments):
    """
    特定のコメントの注目度を計算する関数
    """
    comment = comments[comment_id]
    likes = comment["likes"]
    replies = comment["replies"]

    popularity = likes
    for reply_id in replies:
        popularity += calculate_comment_popularity(reply_id, comments)

    return popularity


def find_most_popular_comment(comments):
    """
    最も注目度の高いコメントのIDを見つける関数
    """
    max_popularity = -1
    most_popular_comment_id = None

    for comment_id in comments:
        popularity = calculate_comment_popularity(comment_id, comments)
        if popularity > max_popularity or (popularity == max_popularity and comment_id < most_popular_comment_id):
            max_popularity = popularity
            most_popular_comment_id = comment_id

    return most_popular_comment_id


# 入力の読み込み
N = int(input())
comments = {}

for _ in range(N):
    comment_info = input().split()
    comment_id = int(comment_info[0])
    parent_id = comment_info[1]
    likes = int(comment_info[2])

    if parent_id == "None":
        parent_id = None
    else:
        parent_id = int(parent_id)

    comments[comment_id] = {
        "parent_id": parent_id,
        "likes": likes,
        "replies": []
    }

# 子コメントのリストを親コメントに追加する
for comment_id, comment in comments.items():
    parent_id = comment["parent_id"]
    if parent_id is not None:
        parent_comment = comments[parent_id]
        parent_comment["replies"].append(comment_id)

# 注目度の一番高いコメントのIDを求める
most_popular_comment_id = find_most_popular_comment(comments)

# 結果の出力
print(most_popular_comment_id)
'''
calculate_comment_popularity 関数は、特定のコメントの注目度を再帰的に計算するための関数です。与えられたコメントIDに対応するコメントの「いいね」数を取得し、それに対して返信コメントの注目度の合計を再帰的に計算して注目度を求めます。
find_most_popular_comment 関数は、与えられたコメントリストから最も注目度の高いコメントのIDを見つけるための関数です。各コメントの注目度を計算し、最大の注目度を持つコメントのIDを返します。注目度が同じ場合は、IDが最小のコメントを選択します。
入力を読み込み、コメント情報を辞書形式で保持します。コメントID、親コメントID、いいね数を取得し、コメント辞書に追加します。親コメントがある場合は、子コメントのリストを親コメントの辞書に追加します。
最も注目度の高いコメントのIDを求め、結果を出力します。
'''

# B075 商品の表示
# utf-8
def calculate_score(N, M, products):
    scores = []  # スコアを保持するリスト

    # スコア計算
    for i in range(N):
        score = 0
        ranks = []  # 各指標の順位を保持するリスト
        for j in range(M):
            rank = 1
            for k in range(N):
                if products[k][j] > products[i][j]:
                    rank += 1
            ranks.append(rank)
        for j in range(M):
            score += N - ranks[j] + 1
        scores.append((i + 1, score))  # 商品番号とスコアの組を追加

    # スコアの高い順にソート
    scores.sort(key=lambda x: x[1], reverse=True)

    # 結果の出力
    for score in scores:
        print(score[0])

# 入力の読み込み
N, M = map(int, input().split())  # 表示する商品の数を表す整数 N、商品の指標の数を表す整数 M
products = []
for _ in range(N):
    product = list(map(int, input().split()))  # i番目の商品の j 番目の指標の値
    products.append(product)

# スコア計算と結果の出力
calculate_score(N, M, products)
'''
calculate_scoreという関数を定義します。この関数は、商品のスコアを計算するための処理を行います。scoresという空のリストを用意して、スコアを保持します。
指定されたルールに基づいて、商品のスコアを計算します。まず、商品の数だけループします。内部のループでは、各指標ごとに順位を計算し、ranksリストに順位を追加します。次に、各指標の順位を使用してスコアを計算し、scoresリストに商品番号とスコアの組を追加します。
計算されたスコアを高い順にソートします。sortメソッドを使用して、スコアを基準にリストを降順に並び替えます。
ソートされたスコアを順番に取り出し、商品番号を出力します。入力値を読み込みます。
まず、map関数とsplitメソッドを使用して、商品の数を表す整数Nと商品の指標の数を表す整数Mを取得します。次に、商品の指標の値を入力として受け取り、それを二重リストとしてproductsリストに追加します。
calculate_score関数を呼び出して、スコアの計算と結果の出力を行います。
'''

# B076 パン屋さん
# utf-8
# N（パンの種類数）とQ（クエリの数）を読み込む
N, Q = map(int, input().split())

# NとQのバリデーションチェック
assert 1 <= N <= 30, "Nが無効です"
assert 1 <= Q <= 50, "Qが無効です"

# パンの価格と在庫数のリストを初期化する
prices = []  # パンの価格リスト
stock = []  # パンの在庫数リスト

# パンの価格と在庫数を読み込む
for _ in range(N):
    # 各パンの種類ごとに価格と在庫数を読み込む
    price, quantity = map(int, input().split())

    # 価格と在庫数のバリデーションチェック
    assert 1 <= price <= 500, "価格が無効です"
    assert 0 <= quantity <= 20, "在庫数が無効です"

    # 価格と在庫数をそれぞれのリストに追加する
    prices.append(price)
    stock.append(quantity)

# 結果のリストを初期化する
results = []

# クエリを処理する
for _ in range(Q):
    # クエリの種類とパンの個数を読み込む
    query, *quantities = input().split()

    # クエリの種類のバリデーションチェック
    assert query in ["bake", "buy"], "クエリの種類が無効です"

    # パンの個数を整数に変換する
    quantities = list(map(int, quantities))

    # パンの個数のバリデーションチェック
    assert all(0 <= q <= 1000 for q in quantities), "パンの個数が無効です"

    # "bake" クエリの処理
    if query == "bake":
        # 各パンの種類ごとに在庫数を増やす
        for i in range(N):
            stock[i] += quantities[i]

    # "buy" クエリの処理
    elif query == "buy":
        # 合計金額を初期化する
        total_cost = 0

        # 全てのパンを購入できるかを示すフラグを初期化する
        can_buy = True

        # 在庫の確認と合計金額の計算を行う
        for i in range(N):
            # 現在のパンの種類の在庫が購入個数に対して十分かチェックする
            if stock[i] >= quantities[i]:
                # 在庫数を減らし、金額を計算する
                stock[i] -= quantities[i]
                total_cost += prices[i] * quantities[i]
            else:
                # 在庫が不足している場合はフラグをFalseにする
                can_buy = False
                break

        # 結果を結果のリストに追加する
        if can_buy:
            results.append(total_cost)
        else:
            results.append(-1)

# 結果を出力する
for result in results:
    print(result)
'''
最初に、パンの種類数を表す整数 N とクエリの個数を表す整数 Q を入力します。このとき、N の値が 1 以上 30 以下であり、Q の値が 1 以上 50 以下であることをバリデーションチェックします。
パンの値段と在庫数を表す整数 a_i, b_i を N 回繰り返し入力します。各パラメータの値が以下の条件を満たしていることをバリデーションチェックします:
a_i の値が 1 以上 500 以下であること
b_i の値が 0 以上 20 以下であること
結果を格納するリスト results を初期化します。
クエリを Q 回繰り返し入力します。各クエリは以下の形式で与えられます:
"bake" クエリの場合: bake 0 c_{i, 1} c_{i, 2} ... c_{i, N}
"buy" クエリの場合: buy c_{i, 1} c_{i, 2} ... c_{i, N}
このとき、クエリの種類が "bake" または "buy" のいずれかであることをバリデーションチェックし、各パンの個数 c_{i, j} の値が 0 以上 1000 以下であることをバリデーションチェックします。
クエリの種類に応じて処理を行います:
"bake" クエリの場合: 各パンの在庫数を c_{i, j} だけ増やします。
"buy" クエリの場合: 各パンの在庫数と購入可能性をチェックし、在庫が足りる場合は購入に必要な合計金額を計算し、在庫数を減らします。在庫が足りない場合はエラーとして -1 を結果リストに追加します。
結果リストの値を順に出力します。
'''

# B077 チケットの売り場
# utf-8
# 入力の読み込み
N, M = map(int, input().split())
processing_times = []
for _ in range(N):
    t = int(input())
    if 1 <= t <= 1000:
        processing_times.append(t)
    else:
        print("処理時間の値は1以上1,000以下である必要があります。")
        exit()

# カウンターの数と人数の制約条件をチェック
if not (1 <= N <= 1000):
    print("カウンターの数は1以上1,000以下である必要があります。")
    exit()
if not (N <= M <= 10000):
    print("並んでいる人数はカウンターの数以上であり、10,000以下である必要があります。")
    exit()

# カウンターの処理時間でソート
processing_times.sort()

# カウンターの処理終了時刻を保持する配列
counters = [0] * N

# シミュレーションの実行
time = 0
for i in range(M):
    min_counter = 0
    for j in range(1, N):
        if counters[j] < counters[min_counter]:
            min_counter = j
    counters[min_counter] += processing_times[min_counter]
    time = max(time, counters[min_counter])

# 出力
print(time)
'''
最初に、入力の読み込みを行います。
NとMを半角スペース区切りで受け取り、それぞれカウンターの数と並んでいる人数を表します。
その後、N個の処理時間を入力として受け取り、processing_timesリストに格納します。
この際、各処理時間が1以上1,000以下の範囲に収まっているかどうかをバリデーションチェックします。
カウンターの数と人数の制約条件をチェックします。
Nが1以上1,000以下であるかをチェックします。そうでない場合、エラーメッセージを表示してプログラムを終了します。
MがN以上かつ10,000以下であるかをチェックします。そうでない場合、エラーメッセージを表示してプログラムを終了します。
カウンターの処理時間を昇順にソートします。
カウンターの処理終了時刻を保持するためのcountersリストを作成し、初期値を0に設定します。
シミュレーションを実行します。

M回のループで、順番に人がカウンターに並びます。
空いているカウンターの中で、最も早く処理が終わるカウンターを選びます。
選ばれたカウンターの処理終了時刻を更新します。
カウンターの処理終了時刻をもとに、全員がチケットを買い終わるまでの最終的な時間を計算します。
計算された時間を出力します。
'''

# B078 動画視聴スケジュール　※テストケース通過せず
# utf-8
import sys

def calculate_max_videos(vacation_end, broadcast_schedule):
    total_time = vacation_end
    max_videos = 0

    for start, duration in broadcast_schedule:
        total_time -= duration

        if total_time >= 0:
            max_videos += 1
        else:
            break

    return max_videos

# 標準入力から入力を読み込む
def read_input():
    lines = sys.stdin.readlines()
    N = int(lines[0])
    broadcast_schedule = []

    for line in lines[1:]:
        start, duration = map(int, line.split())
        broadcast_schedule.append((start, duration))

    vacation_end = broadcast_schedule[-1][0] + broadcast_schedule[-1][1]

    return vacation_end, broadcast_schedule

# 入力の読み込みと結果の出力
def main():
    vacation_end, broadcast_schedule = read_input()
    max_videos = calculate_max_videos(vacation_end, broadcast_schedule)
    print(max_videos)

if __name__ == '__main__':
    main()

# B079 相性チェック
# utf-8
def calculate_compatibility(name1, name2):
    # 1. 名前を小文字に変換し、アルファベットの数値に変換する
    nums1 = [ord(c) - ord('a') + 1 for c in name1]
    nums2 = [ord(c) - ord('a') + 1 for c in name2]

    # 2. 数列を作成する
    def create_sequence(nums):
        while len(nums) > 1:
            new_nums = []
            for i in range(len(nums) - 1):
                new_nums.append((nums[i] + nums[i+1]) % 101)
            nums = new_nums
            if nums[0] > 101:
                nums[0] -= 101
        return nums[0]

    # 3. 2通りの相性を計算し、大きい方を返す
    compatibility1 = create_sequence(nums1 + nums2)
    compatibility2 = create_sequence(nums2 + nums1)
    return max(compatibility1, compatibility2)

# 入力を受け取る
s, t = input().strip().split()

# 相性を計算する
compatibility = calculate_compatibility(s, t)

# 結果を出力
print(compatibility)
'''
calculate_compatibility関数は、2つの名前を受け取り、相性を計算します。
名前を小文字に変換し、アルファベットの数値に変換します。アルファベット"a"は1、"b"は2、...、"z"は26と対応付けられます。
数列を作成します。隣り合う2つの数を足し合わせて新しい数列を作成します。ただし、要素の値が101を超えた場合は101を引きます。この手順を繰り返し、数列の要素数が1になるまで行います。
2通りの相性を計算し、大きい方を返します。1つ目の名前を前にして計算する場合と、2つ目の名前を前にして計算する場合の2通りの相性を求め、大きい方の結果を採用します。
'''
# B080 みんなでスゴロク　※入力例全てでNG
# utf-8
class SugorokuGame:
    def __init__(self, N, M, K, move_effects, coin_effects, dice_results):
        self.N = N
        self.M = M
        self.K = K
        self.move_effects = move_effects
        self.coin_effects = coin_effects
        self.dice_results = dice_results
        self.players = [0] * M

    def simulate_sugoroku(self):
        for i in range(self.K):
            for j in range(self.M):
                dice_result = self.dice_results[i][j]
                self.players[j] += dice_result

                if self.players[j] >= self.N - 1:
                    self.players[j] = self.N - 1

                new_position = self.players[j]
                move_effect = 0

                if new_position > 0 and new_position < self.N - 1:
                    move_effect = self.move_effects[new_position - 1]

                if move_effect > 0:
                    self.players[j] += move_effect
                elif move_effect < 0:
                    self.players[j] = max(0, self.players[j] + move_effect)

        max_coins = max(self.players)
        winner = self.players.index(max_coins) + 1

        return winner, max_coins


def main():
    N, M, K = map(int, input().split())
    move_effects = []
    coin_effects = []
    dice_results = []

    for _ in range(N - 2):
        b, c = map(int, input().split())
        move_effects.append(b)
        coin_effects.append(c)

    for _ in range(K):
        dice_results.append(list(map(int, input().split())))

    game = SugorokuGame(N, M, K, move_effects, coin_effects, dice_results)
    winner, max_coins = game.simulate_sugoroku()
    print(winner, max_coins)


if __name__ == "__main__":
    main()
--------------------------------------------- B081　※欠番 ◆
# B081 花壇のロープ
# utf-8
def count_ropes(H, W, field):
    """
    花壇を過不足なく囲うために必要なロープの本数を数える関数

    Args:
        H (int): 地図の縦幅
        W (int): 地図の横幅
        field (List[List[str]]): 地図の情報を格納した2次元リスト

    Returns:
        int: ロープの本数
    """
    total_ropes = 0

    for i in range(H):
        for j in range(W):
            if field[i][j] == '#':
                if i == 0 or field[i - 1][j] == '.':
                    total_ropes += 1
                if i == H - 1 or field[i + 1][j] == '.':
                    total_ropes += 1
                if j == 0 or field[i][j - 1] == '.':
                    total_ropes += 1
                if j == W - 1 or field[i][j + 1] == '.':
                    total_ropes += 1

    return total_ropes

# 入力の読み込み
H, W = map(int, input().split())

# 地図の初期化
field = []
for _ in range(H):
    row = input()
    field.append(row)

# ロープの本数を数える
ropes = count_ropes(H, W, field)

# 結果を出力
print(ropes)
'''
まず count_ropes 関数が定義されています。この関数は、花壇を過不足なく囲うために必要なロープの本数を数えるために使用されます。
count_ropes 関数は、以下の引数を受け取ります：

H：地図の縦幅を表す整数
W：地図の横幅を表す整数
field：地図の情報を格納した2次元リスト
関数内部では、2重のループを使用して地図を走査します。各地点の文字が花壇を表す # であれば、その周囲をチェックします。
花壇の上側が存在しない場合や、上側が花壇ではない場合、現在の地点にロープが必要です。同様に、下側、左側、右側についても同様のチェックを行い、ロープの本数を適切にカウントします。
全ての地点をチェックし終えた後、合計のロープの本数を返します。
プログラムの残りの部分では、入力を受け取り、地図の情報を適切なデータ構造で格納します。そして、count_ropes 関数を呼び出し、結果を出力します。
'''

# B082 休暇の取り方
# utf-8
def calculate_longest_continuous_days(schedule, M):
    # スケジュール内の「出勤」日数をカウントする
    w_M = schedule.count("work")
    index = 0
    count = w_M - M + 1
    ansArr = []

    # スケジュールを繰り返し処理し、最長の連続休暇日数を見つける
    for _ in range(count):
        editArr, index = edit_arr(schedule.copy(), M, w_M, index)
        ans = count_arr(editArr)
        ansArr.append(ans)

    return max(ansArr)


def edit_arr(schedule, M, w_M, index):
    # スケジュール内の「出勤」日のインデックスを見つける
    workDays = [i for i, day in enumerate(schedule) if day == "work"]

    # スケジュールを編集し、「出勤」日を「休み」日に変更する
    for i in range(M):
        if i + index < len(workDays):
            schedule[workDays[i + index]] = "off"

    index += 1
    return schedule, index


def count_arr(editArr):
    ans = 0
    count = 0
    arr_last_index = len(editArr) - 1

    # 編集されたスケジュールで最も長い連続休暇日数をカウントする
    for i, shift in enumerate(editArr):
        if shift == "off":
            count += 1
            if i == arr_last_index and ans <= count:
                ans = count
        else:
            ans = max(ans, count)
            count = 0

    return ans


N, M = map(int, input().split())
schedule = []

# 入力からスケジュールを読み取る
for _ in range(N):
    schedule.append(input().strip())

result = calculate_longest_continuous_days(schedule, M)
print(result)
'''
このコードは、与えられたスケジュールと有給休暇の日数を利用して、最も長い連続休暇日数を計算するものです。
まず、calculate_longest_continuous_days関数は、スケジュールと有給休暇の日数を引数として受け取ります。この関数では、以下の処理が行われます。
スケジュール内の「出勤」日数をカウントします。これは、schedule.count("work")によって行われます。
indexを初期化し、有給休暇を利用して作成できる連続休暇日数の回数を計算します。具体的には、w_M - M + 1となります。
連続休暇日数の結果を保持するためのリストansArrを初期化します。
次に、連続休暇日数を計算するためのループが行われます。ループは、先ほど計算した回数分だけ繰り返されます。
edit_arr関数を呼び出し、スケジュールを編集します。この関数では、スケジュールのコピー、有給休暇の日数、出勤日数、および現在のindexを引数として受け取ります。
edit_arr関数では、まずスケジュール内の「出勤」日のインデックスを見つけます。これはリスト内包表記を使用して行われます。
スケジュールを編集し、「出勤」日を「休み」日に変更します。これはforループを使用して行われます。ただし、インデックスが範囲外にならないようにチェックしてから変更します。
indexをインクリメントして次の連続休暇日数の作成に備えます。
スケジュールの編集が完了したら、count_arr関数を呼び出して連続休暇日数をカウントします。
count_arr関数では、編集されたスケジュールを受け取り、最も長い連続休暇日数を計算します。具体的には、連続している「休み」日のカウントを行い、最大の連続休暇日数を保持します。
ループが終了したら、ansArrに計算結果を追加します。
最終的に、ansArrの中から最大の値を取得し、それが最も長い連続休暇日数となります。
最後に、メインの処理が行われます。入力からスケジュールを読み取り、calculate_longest_continuous_days関数を呼び出して最長の連続休暇日数を計算し、結果を出力します。
'''

# B083 宝の地図
# utf-8
N = int(input())  # 線分の本数を取得
s = []  # 線分の情報を格納するリスト
yoko = []  # 横方向の線分を格納するリスト
tate = []  # 縦方向の線分を格納するリスト
ans = float('inf')  # 面積の最小値を初期化

# 線分の情報を入力
for _ in range(N):
    a, b, c, d = map(int, input().split())
    s.append([a, b, c, d])

# 横方向と縦方向に線分を分類
for senn in s:
    if senn[1] == senn[3]:
        yoko.append(senn)
    else:
        tate.append(senn)

# 最小面積の長方形を探索
for i in range(len(yoko) - 1):
    tate_temp = []  # 縦方向の線分の一時的な格納リスト
    for tate_seg in tate:
        if yoko[i][0] <= tate_seg[0] <= yoko[i][2] and tate_seg[1] <= yoko[i][1] <= tate_seg[3]:
            tate_temp.append(tate_seg)

    if len(tate_temp) < 2:
        continue

    for j in range(len(yoko)):
        if j == i:
            continue

        for k in range(len(tate_temp) - 1):
            if yoko[j][0] <= tate_temp[k][0] <= yoko[j][2] and tate_temp[k][1] <= yoko[j][1] <= tate_temp[k][3]:
                for l in range(len(tate_temp)):
                    if l == k:
                        continue

                    if yoko[j][0] <= tate_temp[l][0] <= yoko[j][2] and tate_temp[l][1] <= yoko[j][1] <= tate_temp[l][3]:
                        a = max(tate_temp[l][0], tate_temp[k][0]) - min(tate_temp[l][0], tate_temp[k][0])
                        b = max(yoko[j][1], yoko[i][1]) - min(yoko[j][1], yoko[i][1])
                        area = a * b

                        if area < ans:
                            ans = area

print(ans)  # 最小面積を出力
'''
最初に、線分の本数を表す整数Nを入力します。
次に、N個の線分の情報を入力します。各線分は4つの整数a, b, c, dで表されます。これらの整数は線分の両端点の座標を表し、(a, b)と(c, d)が線分の端点です。
入力された線分を横方向の線分と縦方向の線分に分類します。線分のy座標が同じ場合は横方向の線分とし、それ以外の場合は縦方向の線分とします。
面積の最小値を表す変数ansを無限大で初期化します。
横方向の線分と縦方向の線分を組み合わせて長方形を作り、最小の面積を求めます。
横方向の線分を順番に取り出し、それに対応する縦方向の線分を探します。
縦方向の線分は、横方向の線分の範囲内にあり、かつy座標も範囲内にある必要があります。
縦方向の線分が2本以上存在する場合、他の横方向の線分との組み合わせも考えます。
3つの線分で作られる長方形の面積を計算し、最小の面積であればansを更新します。
最終的に求められた最小面積を出力します。
与えられた線分を組み合わせて長方形を作り、その中で面積が最小となる長方形を見つけるアルゴリズムを実装しています。
'''

# B084 オススメのお店
# utf-8
def recommend_restaurants(N, M, K, my_ratings, user_ratings):
    similar_users = []

    # 類似したユーザーを見つける
    for i in range(M):
        count = 0
        for j in range(N):
            # 自分の評価が3であり、ユーザーの評価も3の場合、好みが似ていると判断
            if my_ratings[j] == 3 and user_ratings[i][j] == 3:
                count += 1
        if count >= K:
            # 好みが似ているユーザーのインデックスを保存
            similar_users.append(i + 1)

    recommended_restaurants = []

    # 推薦されたお店を見つける
    for j in range(N):
        if my_ratings[j] == 0:
            for user in similar_users:
                # 好みが似ているユーザーが評価したお店が3の場合、お店を推薦
                if user_ratings[user - 1][j] == 3:
                    recommended_restaurants.append(j + 1)
                    break

    return recommended_restaurants


# 入力値の取得
N, M, K = map(int, input().split())
my_ratings = list(map(int, input().split()))
user_ratings = []
for _ in range(M):
    user_ratings.append(list(map(int, input().split())))

# お店の推薦
recommendations = recommend_restaurants(N, M, K, my_ratings, user_ratings)

# 推薦されたお店の出力
if recommendations:
    print(" ".join(map(str, recommendations)))
else:
    print("no")
'''
このコードは、与えられた評価データを解析し、好みが似ているユーザーが評価したお店を推薦するシンプルなアルゴリズムを実装しています。

まず、recommend_restaurants 関数は、お店の推薦を行うための主要なロジックが含まれています。
similar_users という空のリストを作成します。このリストは、好みが似ていると判断されたユーザーのインデックスを保持します。
入力データのユーザーごとにループします。
内側のループでは、自分の評価とユーザーの評価を比較し、好みが似ていると判断される基準数 K を満たすかどうかをカウントします。
基準数 K を満たす場合は、そのユーザーを similar_users に追加します。
recommended_restaurants という空のリストを作成します。このリストは、推薦されたお店のインデックスを保持します。
自分が評価していないお店でループします。
好みが似ていると判断されたユーザーごとにループします。
ユーザーが評価したお店の評価が高い（3）場合、そのお店を recommended_restaurants に追加します。
メインのプログラム部分では、入力値を受け取ります。
N、M、K は、それぞれお店の数、ユーザーの数、好みが似ていると言える基準の数を表します。
my_ratings は、自分のお店の評価リストを表します。
user_ratings は、各ユーザーのお店の評価リストを2次元配列として表します。
その後、recommend_restaurants 関数を呼び出し、お店の推薦を行います。推薦されたお店のリストを recommendations に保存します。
最後に、推薦されたお店の出力を行います。推薦されたお店がある場合は、リストの要素を文字列に変換してスペース区切りで出力します。推薦されたお店がない場合は、"no" を出力します。
'''

# B085 宝探しの手順
# utf-8
def calculate_distance(P):
    # １つ目の方法での距離の計算
    num = 0
    x, y = 0, 0

    while x != P:
        y += 1
        num += y
        x += y
        if x == P:
            break
        y += 1
        x -= y
        num += y

    # ２つ目の方法での距離の計算
    num2 = 0
    x, y, i, j = 0, 0, 1, 0

    while not (x <= P and P <= 0):
        num2 += y
        y = i - x
        x = i
        if x >= P and P >= 0:
            break
        num2 += y
        y = i + x
        x = -i
        j = i
        i *= 2

    y = abs(P) + j
    num2 += y

    return num, num2


# 座標Pの入力
P = int(input())

# 距離の計算
distance_1, distance_2 = calculate_distance(P)

# 結果の出力
print(distance_1, distance_2)
'''
calculate_distance関数は、座標Pに対して距離を計算するための関数です。まず、１つ目の方法での距離を計算します。
num変数は距離の合計を表します。xは現在の位置を表し、yは移動する距離を表します。
最初のwhileループでは、現在位置がPと等しくなるまで以下の処理を繰り返します。
yを1増やし、numに加算します。
xにyを加え、現在位置を更新します。
もしxがPと等しければ、ループを抜けます。
yを1増やし、xからyを減じ、現在位置を更新します。
numにyを加算します。
このようにして、１つ目の方法での距離を計算します。
次に、２つ目の方法での距離を計算します。
num2変数は２つ目の方法での距離の合計を表します。xは現在の位置を、yは移動する距離を表します。また、iは２のべき乗の値を保持し、jは直前のiの値を保持します。
２つ目のwhileループでは、以下の条件を満たす間、以下の処理を繰り返します。
num2にyを加算します。
yにi - xを代入し、次の移動距離を計算します。
xにiを代入し、現在位置を更新します。
もしxがP以上であり、かつPが0以上であれば、ループを抜けます。
num2にyを加算します。
yにi + xを代入し、次の移動距離を計算します。
xに-iを代入し、現在位置を更新します。
jにiを代入し、直前のiの値を保持します。
iを2倍にします。
ループを抜けた後、まだ移動していない距離を計算します。yには、abs(P)の絶対値を加算し、現在位置からの距離を計算します。最後に、この距離をnum2に加算します。
最後に、calculate_distance関数から計算結果を返します。まず座標Pを入力として受け取ります。次に、calculate_distance関数を呼び出し、１つ目と２つ目の方法での距離を計算します。最後に、計算結果を出力します。
'''

# B086 公平な分割
# utf-8
# ケーキのサイズを入力
H, W = map(int, input().split())
# ケーキの状態を入力
cake = [input() for _ in range(H)]

# スコアを計算する関数
def calculate_score(c):
    # イチゴの数を数える
    strawberries = sum(row.count('@') for row in c)
    # スコアを計算して返す
    return len(c) * len(c[0]) + strawberries ** 2

# 最小の不公平度と座標を保持する変数を初期化
min_unfairness = float('inf')
best_coordinates = []

# 全ての可能な座標の組み合わせを試す
for y in range(1, H):
    for x in range(1, W):
        # ケーキを4つの領域に分割
        upper_left = [row[:x] for row in cake[:y]]
        upper_right = [row[x:] for row in cake[:y]]
        lower_left = [row[:x] for row in cake[y:]]
        lower_right = [row[x:] for row in cake[y:]]

        # 分割したケーキごとにスコアを計算
        cakes = [upper_left, upper_right, lower_left, lower_right]
        scores = [calculate_score(c) for c in cakes]

        # 最大スコアと最小スコアの差が最小の不公平度を更新
        unfairness = max(scores) - min(scores)
        if unfairness < min_unfairness:
            min_unfairness = unfairness
            best_coordinates = [y, x]
        elif unfairness == min_unfairness:
            # 不公平度が同じ場合は座標の比較で最適な座標を更新
            if y < best_coordinates[0] or (y == best_coordinates[0] and x < best_coordinates[1]):
                best_coordinates = [y, x]

# 結果を出力
print(best_coordinates[0], best_coordinates[1])
'''
以下の手順でケーキを分割し、最も不公平度が低い切り分け方を求めるものです。

最初に、ケーキの高さ H と幅 W を入力します。
次に、H 行のケーキの状態を入力します。各行は W 文字の文字列で、'#' は生クリームを表し、'@' はイチゴを表します。
不公平度を計算するための関数 calculate_score を定義します。この関数では、ケーキの面積にイチゴの個数の二乗を加えた値を返します。
不公平度と座標を保持するための変数 min_unfairness と best_coordinates を初期化します。min_unfairness は最小の不公平度を表し、初期値として無限大を設定します。
全ての可能な座標の組み合わせについて、以下の手順を実行します。
y 座標を 1 から H-1 まで、x 座標を 1 から W-1 まで順に試します。
ケーキを上左、上右、下左、下右の 4 つの領域に分割します。これにより、4 つのケーキが得られます。
分割したケーキごとにスコアを計算します。スコアは関数 calculate_score を使用して、ケーキの面積にイチゴの個数の二乗を加えた値です。
4 つのケーキのスコアの最大値と最小値の差を不公平度とします。
不公平度が min_unfairness よりも小さい場合、不公平度を更新し、その座標を best_coordinates とします。不公平度が同じ場合は、より小さい座標が選択されるようにします。
最も不公平度が低い切り分け方として選ばれた座標を出力します。
'''

# B087 隠された数
# utf-8
def find_max_number(h, w, k, grid):
    max_number = -1

    # 上から下に連続する数字を並べた場合の最大値を探す
    for i in range(h):
        for j in range(w - k + 1):
            number = int(grid[i][j:j+k])
            max_number = max(max_number, number)

    # 左から右に連続する数字を並べた場合の最大値を探す
    for i in range(w):
        for j in range(h - k + 1):
            number = int(''.join(grid[x][i] for x in range(j, j+k)))
            max_number = max(max_number, number)

    return max_number

# 入力を受け取る
h, w, k = map(int, input().split())
grid = [input() for _ in range(h)]

# 最大値を求める
result = find_max_number(h, w, k, grid)

# 結果を出力
print(result)
'''
このプログラムは、与えられたマス目の情報を解析して条件に当てはまる数の最大値を見つけるためのものです。
最初に、与えられたマス目の情報を受け取ります。h, w, k = map(int, input().split())の部分では、1行目から高さを表すh、幅を表すw、そして探す数の桁数を表すkを取得しています。マス目の情報は、次の行でgridというリストに格納されます。gridはh行の文字列からなるリストです。
次に、find_max_numberという関数を定義します。この関数は、与えられたマス目の情報と条件の桁数kに基づいて、最大値を探します。
関数内部では、max_numberという変数を初期化し、-1で設定します。これは探索中に見つかる数の最大値を保持するための変数です。
最初のループでは、上から下に連続する数字を並べた場合の最大値を探します。for i in range(h)とfor j in range(w - k + 1)の2つのループを使用して、マス目を走査します。grid[i][j:j+k]は、i行目のj番目からk桁分の部分文字列を取得する操作です。これを整数に変換し、numberという変数に代入します。そして、max_numberとnumberを比較して、より大きい方をmax_numberに更新します。
2番目のループでは、左から右に連続する数字を並べた場合の最大値を探します。for i in range(w)とfor j in range(h - k + 1)の2つのループを使用して、マス目を走査します。内側のループでは、指定された桁数kに対して、各行の対応する位置からの文字を取得し、それらを連結して整数に変換します。同様に、max_numberとnumberを比較して、より大きい方をmax_numberに更新します。
最後に、find_max_number関数の結果をresultに代入し、結果を出力します。出力されるのは条件に当てはまる数の最大値です。
このプログラムを使えば、与えられたマス目の情報から条件に当てはまる数の最大値を見つけることができます。
'''

# B088 ロボットのデバッグ
# utf-8
H, W = map(int, input().split())  # 迷路の縦の長さと横の長さを取得

muki = 1  # 進行方向の初期値 (0: 上, 1: 右, 2: 下, 3: 左)
x, y = 0, 0  # 現在位置の初期値 (左上隅)
turn = 0  # 進行方向変更のカウント
s = []  # 迷路の情報を格納するリスト

def func():
    global turn, muki
    if turn >= 2:  # 進行方向変更が2回以上行われた場合
        return False
    else:
        muki = (muki + turn + 1) % 4  # 進行方向を変更
        turn += 1  # 進行方向変更のカウントを増やす
    return True

for h in range(H):
    s.append(list(input()))  # 迷路の情報を取得し、リストに追加

while True:
    if muki == 1:
        # 進行方向が右を向いている場合
        if x == W - 1:
            # 右に進むことができず、進行方向変更が必要な場合
            if not func():
                break
        elif s[y][x + 1] == '.':
            # 右に進むことができる場合
            s[y][x] = '#'  # 現在位置を壁に変更
            x += 1  # 右に移動
            turn = 0  # 進行方向変更のカウントをリセット
        elif s[y][x + 1] == '#':
            # 右に進むことができず、進行方向変更が必要な場合
            if not func():
                break
    elif muki == 2:
        # 進行方向が下を向いている場合
        if y == H - 1:
            # 下に進むことができず、進行方向変更が必要な場合
            if not func():
                break
        elif s[y + 1][x] == '.':
            # 下に進むことができる場合
            s[y][x] = '#'  # 現在位置を壁に変更
            y += 1  # 下に移動
            turn = 0  # 進行方向変更のカウントをリセット
        elif s[y + 1][x] == '#':
            # 下に進むことができず、進行方向変更が必要な場合
            if not func():
                break
    elif muki == 3:
        # 進行方向が左を向いている場合
        if x == 0:
            # 左に進むことができず、進行方向変更が必要な場合
            if not func():
                break
        elif s[y][x - 1] == '.':
            # 左に進むことができる場合
            s[y][x] = '#'  # 現在位置を壁に変更
            x -= 1  # 左に移動
            turn = 0  # 進行方向変更のカウントをリセット
        elif s[y][x - 1] == '#':
            # 左に進むことができず、進行方向変更が必要な場合
            if not func():
                break
    elif muki == 0:
        # 進行方向が上を向いている場合
        if y == 0:
            # 上に進むことができず、進行方向変更が必要な場合
            if not func():
                break
        if s[y - 1][x] == '.':
            # 上に進むことができる場合
            s[y][x] = '#'  # 現在位置を壁に変更
            y -= 1  # 上に移動
            turn = 0  # 進行方向変更のカウントをリセット
        elif s[y - 1][x] == '#':
            # 上に進むことができず、進行方向変更が必要な場合
            if not func():
                break

print(x, y) # ロボットの停止座標
'''
このコードは、与えられた迷路内をロボットが移動しながら特定の位置を求めるものです。
まず、入力から迷路の縦の長さと横の長さを取得します（H, W = map(int, input().split())）。次に、進行方向（muki）、現在位置（x, y）、進行方向変更の回数（turn）を初期化し、迷路の情報をリストsに格納します。
その後、以下のループが実行されます。

mukiが1の場合（右を向いている場合）：
もし現在位置が右端であり、かつ進行方向変更が必要な場合は、func関数を呼び出して進行方向を変更します。
もし現在位置の右が通路である場合は、現在位置を壁に変更し、右に移動し、進行方向変更の回数をリセットします。
もし現在位置の右が壁である場合は、func関数を呼び出して進行方向を変更します。
mukiが2の場合（下を向いている場合）：
もし現在位置が下端であり、かつ進行方向変更が必要な場合は、func関数を呼び出して進行方向を変更します。
もし現在位置の下が通路である場合は、現在位置を壁に変更し、下に移動し、進行方向変更の回数をリセットします。
もし現在位置の下が壁である場合は、func関数を呼び出して進行方向を変更します。
mukiが3の場合（左を向いている場合）：
もし現在位置が左端であり、かつ進行方向変更が必要な場合は、func関数を呼び出して進行方向を変更します。
もし現在位置の左が通路である場合は、現在位置を壁に変更し、左に移動し、進行方向変更の回数をリセットします。
もし現在位置の左が壁である場合は、func関数を呼び出して進行方向を変更します。
mukiが0の場合（上を向いている場合）：
もし現在位置が上端であり、かつ進行方向変更が必要な場合は、func関数を呼び出して進行方向を変更します。
もし現在位置の上が通路である場合は、現在位置を壁に変更し、上に移動し、進行方向変更の回数をリセットします。
もし現在位置の上が壁である場合は、func関数を呼び出して進行方向を変更します。
最後に、ロボットの最終位置（x, y）を出力します。

このコードでは、ロボットが通路を進みながら壁にぶつかるまで移動し続け、進行方向を変更しながら特定の位置を求める仕組みです。
'''

# B089 秘密の言葉
# utf-8
# NとMの値を取得
N, M = map(int, input().split())

# 文字盤の入力を受け取る
board = []
for _ in range(N):
    row = list(input().rstrip())
    board.append(row)

# 単語リストの入力を受け取る
words = []
for _ in range(M):
    word = input().rstrip()
    words.append(word)

# 各単語の先頭文字の位置を探索して出力
for word in words:
    for i in range(N):
        for j in range(N):
            if board[i][j] == word[0]:  # 先頭文字が一致する場所を探す
                flag = True
                for k in range(1, len(word)):
                    if i + k >= N or j + k >= N or board[i + k][j + k] != word[k]:
                        flag = False
                        break
                if flag:
                    # 単語の先頭文字の位置を出力
                    print(j + 1, i + 1)
                    break  # 単語が見つかったら探索を終了する
'''
最初に、入力から文字盤のサイズNと単語の個数Mを取得します。次に、N行の文字盤を入力します。文字盤は2次元リストとして表現されます。
続いて、M個の単語を入力します。単語はリストに格納されます。単語リストの各単語について、文字盤上での先頭文字の位置を探索します。
先頭文字が一致する場所を見つけたら、その位置を出力します。単語が見つかったら、それ以上の探索は行わずに次の単語に進みます。
このコードは、文字盤と単語のリストを受け取り、単語の先頭文字の位置を特定するものです。
'''

# B090 選挙の議席　※入力例1,2でNG
# utf-8
def distribute_seats(N, K, votes):
    seats = [0] * N  # 各政党の議席数を初期化

    # ドント式による議席の割り振り
    for i in range(1, K + 1):
        max_votes_index = max(range(N), key=lambda j: votes[j] // i)  # 得票数を割ることで小さくなった値の最大の政党を選択
        seats[max_votes_index] += 1  # 選ばれた政党に議席を割り振る

    return seats

# 入力を受け取る
N, K = map(int, input().split())
votes = []
for _ in range(N):
    votes.append(int(input()))

# 議席の配分を計算
seats = distribute_seats(N, K, votes)

# 結果を出力
for seat in seats:
    print(seat)

--------------------------------------------- B091　※欠番 ◆
# B091 山頂を探せ
# B092 セーブポイント
# B093 SNSの検索機能
# B094 ◆
# B095 カラオケ大会
# B096 ビンゴゲーム
# B096(2) 爆弾の大爆発
# B097 カウンター席
# B098 バズの検出
# B099 台風の接近
# B100 計算の遅延
--------------------------------------------- B101　※欠番 ◆
# B101 ◆
# B102 膨張と収縮
# B103 ◆
# B104 データのクレンジング
# B105 マッピングゲーム
# B106 席替えの席決め
# B107 カードシャッフル
# B108 観覧車の稼働状況
# B109 映画館の席の予約
# B110 解像度の向上
--------------------------------------------- B111　※欠番 ◆
# B111 天秤のつりあい
# B112 くじの作成
# B113 2のべき連結ゲーム
# B114 PAIZA運動会
# B115 アナグラムパズル
# B116 プレゼント交換
# B117 回る教習車
# B118 背の順
# B119 投網
# B120 ◆
--------------------------------------------- B121　※欠番 ◆
# B121 床の模様替え
# B122 うわさ
# B123 ビットゲーム
# B124 名前が似ている友達
# B125 工場のボトルネック
# B126 ダンスパーティー
# B127 ◆
# B128 簡易的二次元バーコード
# B129 n毛作
# B130 ブロック挿入
--------------------------------------------- B131　※欠番 ◆
# B131 運賃計算
# B131(2) 復号の処理
# B132
# B133
# B134
# B135
# B136
# B137
# B138
# B139
# B140
-----------------------------------------------B141　※欠番◆
