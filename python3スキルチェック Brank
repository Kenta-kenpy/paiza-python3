※欠番が存在する理由につきましては、出題自体を公開終了した問題が欠番となっております。

--------------------------------------------- B001　※欠番 ◆
# B001 ◆
# B002 ◆
# B003 ◆
# B004 ログファイルの抽出
# utf-8
def isValidIp(m, c):
    ret = False
    if m == "*" or m == c:
        ret = True
    elif m[0] == "[":
        a = m.split("-")
        ss = int(a[0].replace("[", ""))
        ee = int(a[1].replace("]", ""))
        if ss <= int(c) <= ee:
            ret = True
    return ret

def main():
    # IPアドレスを読み込む
    mip = input().strip().split(".")
    
    # ログの数を読み込む
    n = int(input())
    
    # ログを1行ずつ読み込み、IPアドレスをチェックする
    for i in range(n):
        s = input().strip().split(" ")
        tip = s[0].split(".")
        if mip[0] == tip[0] and \
           mip[1] == tip[1] and \
           isValidIp(mip[2], tip[2]) and \
           isValidIp(mip[3], tip[3]):
            print(s[0] + " " + s[3][1:] + " " + s[6])

if __name__ == '__main__':
    main()
'''
1 標準入力からIPアドレスとログの数を取得し、IPアドレスを「.」で分割してリストに格納する
2 ログの数だけ繰り返し、1行ずつログを取得する
3 取得したログのIPアドレスを「.」で分割してリストに格納する
4 IPアドレスの1〜3オクテットが一致し、4オクテットが以下の条件を満たす場合に、ログの情報を出力する
　・IPアドレスの4オクテットが、IPアドレスの4オクテットと完全一致する場合
　・IPアドレスの4オクテットが、ワイルドカード「*」の場合
　・IPアドレスの4オクテットが、範囲指定の場合（「[」と「]」で囲まれた範囲内の数値のみ許可される）
具体的には、以下のような関数を定義して使用しています。
isValidIp(m, c)
　・引数mが「*」またはcと完全一致する場合はTrueを返す
　・引数mが範囲指定の場合は、引数cが範囲内にある場合はTrueを返す
このコードは、ログのIPアドレスが与えられたIPアドレスにマッチするかどうかを判定する処理を行っており、与えられたIPアドレスがワイルドカードや範囲指定を含んでいる場合にも対応しています。
'''

# B005 ◆　
# B006 ダーツゲーム
# utf-8
# 標準入力からの値の取得
import sys
input_line = sys.stdin.read()
input_list = input_line.split()

# 初期値の設定
o_y = float(input_list[0])
s = float(input_list[1])
theta = float(input_list[2])
x = float(input_list[3])
y = float(input_list[4])
a = float(input_list[5])

# 矢が当たるかどうかの判定
import math
g = 9.8
rad = math.radians(theta)
t = x / (s * math.cos(rad))
y2 = o_y + s * math.sin(rad) * t - (g * t ** 2) / 2
if y - a / 2 <= y2 <= y + a / 2:
    # 当たった場合、的の中心からの距離を出力
    dist = abs(y2 - y)
    print("Hit {:.1f}".format(round(dist, 1)))
else:
    # 当たらなかった場合、Missを出力
    print("Miss")
'''
以下の手順で矢が的に当たるかどうかを判定し、当たった場合には的の中心からの距離を出力します。
まず、sys.stdin.read()で標準入力から値を読み込み、split()でスペース区切りの文字列をリストに変換します。
次に、リストから必要な値を取り出し、float()で数値に変換します。
これで、矢の初期値点の高さ o_y、初速 s、角度 theta、的までの距離 x、的の高さ y、的の大きさ a がそれぞれ変数に格納されました。

矢が当たるかどうかの判定には、以下の計算式を使用します。
y2 = o_y + s * sin(rad) * t - (g * t^2) / 2
ここで、radはthetaをラジアンに変換したもの、tは矢が的に当たるまでの時間です。この式は、矢の初期値点から投げた瞬間の高さ o_y に、矢が的に当たるまでに到達する高さを足し合わせたものを計算し、的の高さ y ± 的の大きさ a の範囲内にあるかどうかを判定します。

具体的には、以下のように計算します。
import math

# 重力加速度
g = 9.8

# 角度をラジアンに変換
rad = math.radians(theta)

# 矢が的に当たるまでの時間
t = x / (s * math.cos(rad))

# 矢が的に当たるときの高さ
y2 = o_y + s * math.sin(rad) * t - (g * t ** 2) / 2

矢が当たるかどうかを判定する部分では、まず重力加速度を9.8[m/s^2]として、投射角度θに対しての水平方向と鉛直方向の初速度を求めます。そして、投射角度θと初速度sを用いて、到達時間tを求めます。tを用いて、矢の到達位置y2を計算します。その後、的の位置yから、的の半径a/2の範囲内に矢の到達位置y2があるかどうかを判定しています。
当たった場合は、的の中心からの距離を求めています。このとき、求めた距離を絶対値をとっているのは、矢が的の上側に当たった場合でも、的の中心からの距離を正しく求めるためです。また、四捨五入して小数点第1位までの数値を出力するには、Pythonの組み込み関数であるround()関数を使います。
当たらなかった場合は、"Miss"を出力しています。
'''

# B007 ◆
# B008 ◆
# B009 カンファレンスのタイムテーブル作成
# utf-8
# 分を時刻表記に変換する関数　m分をhh:mm形式の文字列に変換する関数
def m2h(m):
    hour = m // 60 % 24  # 24時間制での時間を算出
    minute = m % 60  # 分を算出
    return f'{hour:02}:{minute:02}'  # hh:mm形式の文字列に変換して返す

# 時刻表記を分に変換する関数　hh:mm形式の文字列をm分に変換する関数
def h2m(h):
    hour, minute = map(int, h.split(':'))  # : を区切り文字として文字列を分割して、時と分に分ける
    return hour * 60 + minute  # 時を分に変換して分と合算し、分単位で返す

# 各プレゼンテーションの開始・終了時刻を計算する関数　スケジュールの時間計算を行う関数
def presentation_time(start_time, duration):
    global rest   # お昼休憩のフラグ　# グローバル変数 rest を参照するため、global宣言
    noon = h2m('12:00')  # 12:00を分単位に変換して、お昼の時間として取得
    end_time = start_time + duration  # 終了時刻を算出
    if not rest and noon < end_time:  # お昼休憩が必要かどうかを判定　# 休憩をとっておらず、終了時刻がお昼を過ぎている場合
        start_time += 60 - 10  # お昼休憩をとるために開始時刻をずらす　# お昼休憩を含む1時間の空きを作るために10分引いた時間に移動
        end_time = start_time + duration  # 新しい終了時刻を再度算出
        rest = True  # 休憩を取ったことをフラグに設定
    return start_time, end_time  # スケジュールの開始時間と終了時間を返す

n = int(input())  # # プレゼンテーションスケジュールの個数を入力

start_time = h2m('10:00')  # 最初のプレゼンテーションの開始時刻を10:00として、分単位に変換して取得

rest = False  # お昼休憩をとっていないことをフラグに設定　お昼休憩のフラグを初期化
for _ in range(n):  # スケジュールの個数だけ繰り返し処理を実行
    name, duration = input().split()  # スケジュール名と時間を入力として受け取る
    start_time, end_time = presentation_time(start_time, int(duration))  # スケジュールの開始時間と終了時間を計算
    print(f'{m2h(start_time)} - {m2h(end_time)} {name}')  # スケジュールの時間と名前を出力
    start_time = end_time + 10 # 休憩時間10分を加算して次のプレゼンテーションの開始時刻を計算する
'''
m2h() 関数
この関数は、分単位の時間を時:分の形式の文字列に変換するためのものです。
入力された分を60で割った余りが分の値、60で割った商を24で割った余りが時の値として取得します。
最後に、f-string を使って、"時:分" の形式で文字列を生成し、それを返します。

h2m() 関数
この関数は、時:分の形式の文字列を分単位の時間に変換するためのものです。
split() 関数を使って、文字列を ":" で分割し、時と分の値を取得します。
時を60で掛けたものに分を足し合わせて、分単位の時間を計算し、それを返します。

presentation_time() 関数
この関数は、スピーカーのプレゼンテーションの開始時間と終了時間を計算するためのものです。
引数として、スピーカーのプレゼンテーションの開始時間と時間の長さを受け取ります。
global キーワードを使って、rest 変数をグローバル変数として宣言します。
noon 変数には、12:00の分単位の時間を代入します。
end_time 変数には、プレゼンテーションの終了時間を代入します。
rest 変数が False かつ noon より end_time が後の場合、つまり、プレゼンテーションがお昼休憩をまたいでいる場合、開始時間にお昼休憩の10分を足した時間から再スタートし、終了時間を再計算します。
最後に、開始時間と終了時間を返します。

それ以降のメイン部分
まず、n = int(input())で発表する人数nを受け取ります。
次に、発表が始まる開始時間を表す変数start_timeに、10:00の時間をh2m('10:00')を使って分単位で代入します。
そして、restフラグをFalseで初期化します。これは、お昼休憩のチェックのために使用されます。
forループを使って、各発表の時間を処理します。forループの中で、name, duration = input().split()で発表者の名前nameと発表時間durationを受け取ります。このdurationは単位が分であり、整数型であることに注意してください。
次に、presentation_time(start_time, int(duration))を呼び出して、発表の終了時刻を計算し、その時間を人間が読みやすい形式で出力します。presentation_time関数は、start_timeと発表時間durationを引数として受け取り、終了時間のタイムスタンプ（分単位）を返します。
また、restフラグがFalseである場合は、終了時間が12:00を超える場合に、お昼休憩の時間（10分）を追加します。noon = h2m('12:00')で、12:00の時間を分単位で取得します。そして、noonよりも終了時間が後である場合に、start_time += 60 - 10で、お昼休憩を考慮した新しい開始時間を計算します。最後に、restフラグをTrueに設定します。
各発表が終わった後、start_timeにend_time + 10を代入して、次の発表の開始時間を計算します。この+ 10は、前の発表の終了時間と次の発表の開始時間の間に10分の休憩時間が必要であることを示しています。
'''

# B010 サッカーのオフサイド判定
# utf-8
def team_lineup(players, reverse=False):
    if reverse:
        players = list(map(lambda x:-x, players))
    return zip(range(1, 12), players)

def is_offside(x_player, x_passer, x_offside_line):
    return x_passer < x_offside_line < x_player

def get_offside_players(offence_team, diffence_team, x_passer, x_offside_line):
    offside_players = []
    for idx, x_p in enumerate(offence_team):
        if is_offside(x_p, x_passer, x_offside_line):
            offside_players.append(idx+1)
    return offside_players

def get_offside_line(diffence_team):
    return sorted(diffence_team, reverse=True)[1]

def get_opponent(name):
    return 'A' if name == 'B' else 'B'

# main
offence_name, passer = input().split()
team = {}
team['A'] = list(map(int, input().split()))
team['B'] = list(map(int, input().split()))

if offence_name == 'B':
    for t in team:
        team[t] = list(map(lambda x:-x, team[t]))

diffence_name = get_opponent(offence_name)
offence_team = team[offence_name]
diffence_team = team[diffence_name]

x_offside_line = get_offside_line(diffence_team)
x_passer = int(offence_team[int(passer)-1])

offside_players = get_offside_players(offence_team, diffence_team, x_passer, x_offside_line)

if offside_players:
    for p in offside_players:
        print(p)
else:
    print('None')
'''
与えられたサッカーの試合状況に対して、次のパスを受け取るとオフサイドと判定される選手の背番号を小さいものから順に1行ずつ出力するものです。
まず、input()関数を使って標準入力から入力を受け取ります。1行目では攻撃するチームの名前(offence_name)と、パスを受け取る選手の背番号(passer)をスペース区切りで受け取り、
2行目と3行目ではそれぞれ攻撃するチームの選手の背番号(team_a_numbers, team_b_numbers)をスペース区切りで受け取ります。
次に、攻撃するチームと守備するチームの背番号をリストで保持します。if文で、offence_nameが'B'の場合、攻撃するチームと守備するチームの背番号を反転させます。
この処理によって、攻撃するチームが必ずAチームになるようにしています。
次に、守備するチームの最後尾から2番目の背番号を取得します。この背番号より前に攻撃するチームの選手がいる場合、オフサイドの判定が行われます。
最後に、攻撃するチームの選手の中でオフサイドとなる選手の背番号を出力します。オフサイドとなる選手がいない場合には、"None"を出力します。
このコードのポイントは、オフサイド判定を行うis_offside関数にあります。この関数は、与えられた選手の背番号(x_player)、パスを出した選手の背番号(x_passer)、
そして守備するチームのオフサイドラインの背番号(x_offside_line)を受け取り、オフサイド判定を行います。
オフサイド判定は、パスを出した選手より前方に守備するチームのオフサイドラインと、パスを受けた選手が存在する場合に成立します。
'''

--------------------------------------------- B011　※欠番 ◆
# B011 名刺バインダー管理
# utf-8
n, m = map(int, input().split())

# m番目の名刺が含まれるページを計算する
page = (m - 1) // (n * 2) + 1

# そのページの最後の名刺番号と最初の名刺番号を計算する
last_card_num = page * n * 2
first_card_num = last_card_num - (n * 2 - 1)

# m番目の名刺が表面か裏面かによって、裏側の名刺の番号を計算する
if m <= (first_card_num + n - 1):
    back_card_num = last_card_num - (m - first_card_num)
else:
    back_card_num = first_card_num + (last_card_num - m)

print(back_card_num)
'''
1行目では、入力された文字列をスペースで分割し、それぞれ整数型に変換して、nとmに代入しています。
2行目では、m番目の名刺が属するページ数を求めています。m-1をn*2で割り、+1をしているのは、pythonで整数を割った場合、小数点以下が切り捨てられるためです。
また、m-1をする理由は、1番目の名刺が0ページ目にあるとみなすためです。3行目では、pageページに含まれる最後の名刺の番号を計算しています。pageページには、n2枚の名刺があるため、pmaxにn2をかけ、その後page-1をかけます。
それに1を足すのは、1ページ目が0番目のページであるとしているためです。4行目では、pageページに含まれる最初の名刺の番号を計算しています。pminには、pmaxからn*2-1を引いた数が入ります。
この式は、pageページの最初の名刺の番号がpage-1ページの最後の名刺の番号に1を足したものであることから導かれます。
5行目では、m番目の名刺の裏面にある名刺の番号を計算しています。mは、pageページの中で何番目の名刺なのかを計算します。pageページの最初の名刺の番号から、m番目の名刺の番号を引いたものが、m番目の名刺の裏面にある名刺の番号になります。
'''

# B012 ◆
# B013 ◆
# B014 3Dプリンタ
# utf-8
X,Y,Z=list(map(int,input().split()))
m=[['.' for j in range(Y)] for i in range(Z)]
for k in range(Z):
    for i in range(X):
        n=input()
        for j in range(Y):
            if n[j]=='#':
                m[k][j]='#'
    l=input()
for i in reversed(range(Z)):
    l=map(str,m[i])
    s=''.join(l)
    print(s)
'''
入力されたX,Y,Zに対して、Z枚のX行Y列のマス目を作成しています。マス目は、二次元リストで表現されています。
そして、入力されたマス目の状態を、マス目に反映させます。
最後に、マス目を反転させ、反転したマス目を出力します。
ここで、マス目の反転は、reversed(range(Z))を使用して、Zから0までの範囲を逆順に取得していることで実現されています。
また、map(str, m[i])を使用して、マス目を文字列に変換し、join()関数でつなげて、横一列の文字列として出力しています。
'''

# B015 7セグメントディスプレイ（デジタル表示の数字）
# utf-8
class SevenSegmentDisplay:
    def __init__(self, first_number, second_number):
        """
        セブンセグメントディスプレイの表示状態を管理するクラス

        Parameters:
            first_number (list): 1つ目の数字のセグメント表示
            second_number (list): 2つ目の数字のセグメント表示
        """
        self.seven_segment = [
            [1, 1, 1, 1, 1, 1, 0],
            [0, 1, 1, 0, 0, 0, 0],
            [1, 1, 0, 1, 1, 0, 1],
            [1, 1, 1, 1, 0, 0, 1],
            [0, 1, 1, 0, 0, 1, 1],
            [1, 0, 1, 1, 0, 1, 1],
            [1, 0, 1, 1, 1, 1, 1],
            [1, 1, 1, 0, 0, 1, 0],
            [1, 1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 0, 1, 1]
        ]
        self.number = [first_number, second_number]
        self.display_state = []

        self.check_display()

    def check_display(self):
        """
        セグメント表示の状態をチェックし、表示状態を設定する関数
        """
        if self.is_valid_display(self.number):
            self.display_state.append("Yes")
        else:
            self.display_state.append("No")

        # 数字の対称移動をチェック
        symmetry_check = [list(self.number[0]), list(self.number[1])]
        if self.is_valid_display(self.symmetry_move(symmetry_check)):
            self.display_state.append("Yes")
        else:
            self.display_state.append("No")

        # 数字の回転移動をチェック
        rotate_check = [list(self.number[0]), list(self.number[1])]
        if self.is_valid_display(self.rotate_move(rotate_check)):
            self.display_state.append("Yes")
        else:
            self.display_state.append("No")

    def symmetry_move(self, change_number):
        """
        数字の対称移動を行う関数

        Parameters:
            change_number (list): 移動する数字のリスト

        Returns:
            list: 移動後の数字のリスト
        """
        change_number[0][0], change_number[1][0] = change_number[1][0], change_number[0][0]  # a1-b1の入れ替え
        change_number[0][1], change_number[1][5] = change_number[1][5], change_number[0][1]  # a2-b6, a6-b2の入れ替え
        change_number[0][5], change_number[1][1] = change_number[1][1], change_number[0][5]
        change_number[0][6], change_number[1][6] = change_number[1][6], change_number[0][6]  # a7-b7の入れ替え
        change_number[0][2], change_number[1][4] = change_number[1][4], change_number[0][2]  # a3-b5, a5-b3の入れ替え
        change_number[0][4], change_number[1][2] = change_number[1][2], change_number[0][4]
        change_number[0][3], change_number[1][3] = change_number[1][3], change_number[0][3]  # a4-b4の入れ替え
        return change_number

    def rotate_move(self, change_number):
        """
        数字の回転移動を行う関数

        Parameters:
            change_number (list): 移動する数字のリスト

        Returns:
            list: 移動後の数字のリスト
        """
        change_number[0][0], change_number[1][3] = change_number[1][3], change_number[0][0]  # a1-b4の入れ替え
        change_number[0][1], change_number[1][4] = change_number[1][4], change_number[0][1]  # a2-b5, a6-b3の入れ替え
        change_number[0][5], change_number[1][2] = change_number[1][2], change_number[0][5]
        change_number[0][6], change_number[1][6] = change_number[1][6], change_number[0][6]  # a7-b7の入れ替え
        change_number[0][2], change_number[1][5] = change_number[1][5], change_number[0][2]  # a3-b6, a5-b2の入れ替え
        change_number[0][4], change_number[1][1] = change_number[1][1], change_number[0][4]
        change_number[0][3], change_number[1][0] = change_number[1][0], change_number[0][3]  # a4-b1の入れ替え
        return change_number

    def is_valid_display(self, check_number):
        """
        セグメント表示が正しいかどうかをチェックする関数

        Parameters:
            check_number (list): チェックする数字のリスト

        Returns:
            bool: セグメント表示が正しい場合はTrue、そうでない場合はFalse
        """
        checker = 0

        for segment in self.seven_segment:
            if self.check_display_number(segment, check_number[0]):
                checker += 1
            if self.check_display_number(segment, check_number[1]):
                checker += 1

        return checker == 2

    def check_display_number(self, number1, number2):
        """
        2つの数字が一致しているかどうかをチェックする関数

        Parameters:
            number1 (list): 数字1のセグメント表示
            number2 (list): 数字2のセグメント表示

        Returns:
            bool: 2つの数字が一致している場合はTrue、そうでない場合はFalse
        """
        return number1 == number2

    def print_display_state(self):
        """
        表示状態を出力する関数
        """
        for state in self.display_state:
            print(state)

def main():
    """
    メイン関数
    """
    # 入力の読み込み
    first_line = input().split()
    second_line = input().split()

    # 文字列を整数のリストに変換
    first_number = [int(x) for x in first_line]
    second_number = [int(x) for x in second_line]

    # SevenSegmentDisplayクラスのインスタンスを作成し、結果を出力
    display = SevenSegmentDisplay(first_number, second_number)
    display.print_display_state()

if __name__ == "__main__":
    main()
'''
このコードは、セブンセグメントディスプレイの表示状態を管理する SevenSegmentDisplay クラスと、それを使用して入力された数字の表示状態をチェックする main 関数から構成されています。
SevenSegmentDisplay クラスは、コンストラクタ __init__ を持ちます。このコンストラクタでは、セブンセグメントの各セグメントの状態を表す二次元リスト seven_segment を定義し、与えられた1つ目の数字と2つ目の数字の表示状態を保持するリスト number を初期化します。
また、結果を格納するリスト display_state も初期化されます。
check_display メソッドでは、与えられた数字の表示状態が正しいかどうかをチェックします。まず、与えられた数字自体が正しい表示かどうかを is_valid_display メソッドでチェックし、結果を display_state リストに追加します。
次に、与えられた数字の対称移動と回転移動を行い、それぞれの移動後の表示状態もチェックし、結果を display_state リストに追加します。
symmetry_move メソッドと rotate_move メソッドは、数字の対称移動と回転移動を行うためのメソッドです。これらのメソッドは、与えられた数字の表示状態を変更します。
is_valid_display メソッドは、与えられた数字の表示状態が正しいかどうかを判定するためのメソッドです。check_display_number メソッドを使用して、与えられた数字の各セグメントとセブンセグメントの状態を比較し、一致するセグメントの数をカウントします。
カウントされた数が2であれば、正しい表示と判定されます。print_display_state メソッドは、結果を表示するためのメソッドです。display_state リストに格納された結果を順に表示します。
main 関数では、入力を受け取り、文字列を整数のリストに変換して SevenSegmentDisplay クラスのインスタンスを作成します。その後、print_display_state メソッドを呼び出して結果を表示します。
以上が、このコードの概要と各部の役割の解説です。このコードは、与えられた数字のセブンセグメント表示が正しいかどうかをチェックし、さまざまな移動パターンも考慮して結果を表示する機能を持っています。
'''

# B016 ここはどこ？
# utf-8
def get_final_position(w, h, x, y, moves):
    for move in moves:
        direction, steps = move
        if direction == "U":
            y = (y + steps) % h  # 上への移動
        elif direction == "D":
            y = (y - steps) % h  # 下への移動
        elif direction == "L":
            x = (x - steps) % w  # 左への移動
        elif direction == "R":
            x = (x + steps) % w  # 右への移動

    return x, y

# 入力を受け取る
w, h, n = map(int, input().split())  # マップの横幅 w、縦幅 h、移動ログの個数 n を受け取る
x, y = map(int, input().split())  # 初期位置 x, y を受け取る
move_logs = []
for _ in range(n):
    direction, steps = input().split()  # 移動ログの情報を受け取る
    move_logs.append((direction, int(steps)))  # 移動ログをリストに追加

# 最終位置を計算
final_position = get_final_position(w, h, x, y, move_logs)

# 結果を出力
print(final_position[0], final_position[1])  # 最終位置を出力
'''
与えられたマップの情報と移動ログを処理し、キャラクターの最終位置を計算して表示するものです。
まず、get_final_position 関数は、マップの情報と移動ログを受け取り、キャラクターの最終位置を計算する役割を担っています。
移動ログの情報を1つずつ取り出し、指定された方向とステップ数に基づいてキャラクターの位置を更新します。また、マップの端に達した場合は巡回するように設定されています。最終的な位置は (x, y) の形式で返されます。
次に、入力を受け取ります。input().split() を使用して、マップの横幅 w、縦幅 h、移動ログの個数 n、初期位置 x、y を入力から読み取ります。
移動ログはループを使用して、n 回分だけ読み取り、方向とステップ数の情報をタプルとして move_logs リストに追加します。
最後に、get_final_position 関数を呼び出し、計算された最終位置を final_position に代入します。最終位置の横座標と縦座標を final_position[0] と final_position[1] から取り出し、表示します。
'''

# B017 手役の強さ(花札)
# utf-8
class StrongestMeans:
    def __init__(self, cards):
        self.cards = cards
        self.countOfCard = {}

    def getMeans(self):
        self.countCard()

        means = ""
        max_count = max(self.countOfCard.values())
        if max_count == 1:
            means = "NoPair"
        elif max_count == 2:
            means = "TwoPair" if len(self.countOfCard) == 2 else "OnePair"
        elif max_count == 3:
            means = "ThreeCard"
        elif max_count == 4:
            means = "FourCard"

        return means

    def countCard(self):
        for card in self.cards:
            if card == "*":
                self.plusAllKindCardOne()
            else:
                self.plusSpecifiedCardOne(card)

    def plusAllKindCardOne(self):
        cards = set(self.cards)
        for card in cards:
            if card != "*":
                self.plusSpecifiedCardOne(card)

    def plusSpecifiedCardOne(self, card):
        self.countOfCard[card] = self.countOfCard.get(card, 0) + 1

cards = input().strip()
strongMeans = StrongestMeans(list(cards))
print(strongMeans.getMeans())
'''
このコードは、入力のフォーマットに合わせてカードの入力を受け取り、StrongestMeansクラスのインスタンスを作成して、getMeansメソッドを呼び出し、結果を表示しています。
注意点：
カードの入力は、スペースで区切られた4つの文字列として受け取ります。
input().strip()を使って末尾の改行文字を除去します。
入力の最後には余分な文字や空行が含まれていないことを確認してください。
このコードを使用して、与えられた入力に基づいて最高の手役を判定し、出力することができます。

まず、StrongestMeansという名前のクラスが定義されています。このクラスは、カードの集合から手役の強さを判定するためのメソッドを提供します。
__init__メソッドは、cardsという引数を受け取り、インスタンスの初期化を行います。cardsは入力されたカードのリストです。countOfCardはカードの出現回数を格納するための辞書です。
getMeansメソッドは手役の強さを返します。まず、countCardメソッドを呼び出してカードの出現回数を数えます。
次に、countOfCard辞書の値の中で最大の数を取得します。その最大数に応じて手役を判定し、meansに結果を格納します。

countCardメソッドは、カードの出現回数を数えるためのメソッドです。self.cardsの各カードについて、cardとして処理します。
もしcardがワイルドカード "*" ならば、plusAllKindCardOneメソッドを呼び出します。
そうでない場合は、plusSpecifiedCardOneメソッドを呼び出して指定されたカードの出現回数を増やします。

plusAllKindCardOneメソッドは、ワイルドカード "*" の場合に他のすべてのカードの出現回数を増やすためのメソッドです。
self.cardsのユニークな要素を取得し、それぞれのカードについて処理します。
'''

# B018 ◆
# B019 グレースケールの画像の縮小
# utf-8
def shrink_image(N, K, pixels):
    # N/K × N/Kの画像を作成
    new_N = N // K
    new_pixels = [[0] * new_N for _ in range(new_N)]

    # 各ブロックの平均値を計算
    for r in range(new_N):
        for c in range(new_N):
            block_sum = 0
            for i in range(r * K, (r + 1) * K):
                for j in range(c * K, (c + 1) * K):
                    block_sum += pixels[i][j]
            average = block_sum // (K * K)
            new_pixels[r][c] = average

    return new_pixels

# 入力を受け取る
N, K = map(int, input().split())
pixels = []
for _ in range(N):
    row = list(map(int, input().split()))
    pixels.append(row)

# 画像を縮小
result = shrink_image(N, K, pixels)

# 結果を出力
for row in result:
    print(*row)
'''
shrink_image(N, K, pixels) 関数は、元の画像を指定されたブロックサイズで縮小するための関数です。関数は以下の手順で動作します。

元の画像のサイズ N とブロックサイズ K を受け取ります。
新しい画像のサイズ new_N を計算します。new_N は N を K で割った商です。
新しい画像を表現するための二次元リスト new_pixels を作成します。サイズは new_N × new_N です。
各ブロックの平均値を計算し、新しい画像のピクセル値として new_pixels に格納します。
最終的に new_pixels を返します。
メインのプログラムでは、以下の手順で処理が行われます。

元の画像のサイズ N とブロックサイズ K を入力します。
N 行のピクセル値を受け取り、二次元リスト pixels に格納します。
shrink_image(N, K, pixels) 関数を呼び出して、画像を縮小します。結果は result に格納されます。
result を出力します。
'''

# B020 ネットサーフィン
# utf-8
n = int(input())  # クエリの数を取得
queries = []  # クエリを保持するリスト
history = ["blank page"]  # ページの履歴を保持するリスト

# クエリを入力してリストに追加
for _ in range(n):
    queries.append(input())

# 各クエリを処理
for query in queries:
    if query == "use the back button":
        if len(history) > 1:
            history.pop()  # 直前のページを履歴から削除
        print(history[-1])  # 現在のページを出力
    else:
        page_name = query[6:]  # ページ名を取得
        history.append(page_name)  # ページを履歴に追加
        print(page_name)  # ページ名を出力

print()  # 最後の改行を出力
'''
このコードでは、まずクエリの数を取得し、その後のクエリをリストに追加します。それぞれのクエリに対して以下の処理を行います。

"use the back button" の場合:

履歴が1つ以上存在する場合は、直前のページを履歴から削除します。
現在のページを出力します。
"go to [page_name]" の場合:

ページ名を取得し、履歴に追加します。
ページ名を出力します。
最後に改行を出力します。

この修正により、最初のページが "blank page" であること、"use the back button" の場合でも "blank page" 以外の指定されたページを開くこと、各テストケースでの出力例が要件を満たすようになります。

修正後のコードでは、入力例に対する出力例も要件を満たすようになります。それぞれのクエリに対して適切なページを開き、履歴を保持しながら出力しています。
'''
--------------------------------------------- B021　※欠番 ◆
# B021 ◆
# B022 ◆
# B023 マッチ棒パズル
# utf-8
def get_another(a, b):
    for i in range(len(a)):
        a[i] = b[i]
    return a


def set_number(number):
    number[0][0] = "69"
    number[0][1] = "8"
    number[0][2] = ""

    number[1][0] = ""
    number[1][1] = "7"
    number[1][2] = ""

    number[2][0] = "3"
    number[2][1] = ""
    number[2][2] = ""

    number[3][0] = "25"
    number[3][1] = "9"
    number[3][2] = ""

    number[4][0] = ""
    number[4][1] = ""
    number[4][2] = ""

    number[5][0] = "3"
    number[5][1] = "69"
    number[5][2] = ""

    number[6][0] = "09"
    number[6][1] = "8"
    number[6][2] = "5"

    number[7][0] = ""
    number[7][1] = ""
    number[7][2] = "1"

    number[8][0] = ""
    number[8][1] = ""
    number[8][2] = "069"

    number[9][0] = "06"
    number[9][1] = "8"
    number[9][2] = "35"

    return number


def main():
    charS = input().strip()
    result = []

    number = [["" for _ in range(3)] for _ in range(10)]
    number = set_number(number)

    temp = list(charS)
    temp = get_another(temp, list(charS))
    for i in range(len(charS)):
        for j in range(3):
            point = int(charS[i])

            for k in range(len(number[point][j])):
                if j == 0:
                    temp[i] = number[point][0][k]
                    output = "".join(temp)
                    result.append(output)
                    temp = get_another(temp, list(charS))
                elif j == 1:
                    for l in range(i + 1, len(charS)):
                        point2 = int(charS[l])
                        for m in range(len(number[point2][2])):
                            temp[i] = number[point][1][k]
                            temp[l] = number[point2][2][m]
                            output = "".join(temp)
                            result.append(output)
                            temp = get_another(temp, list(charS))
                else:
                    for l in range(i + 1, len(charS)):
                        point2 = int(charS[l])
                        for m in range(len(number[point2][1])):
                            temp[i] = number[point][2][k]
                            temp[l] = number[point2][1][m]
                            output = "".join(temp)
                            result.append(output)
                            temp = get_another(temp, list(charS))

    result.sort()

    if len(result) == 0:
        print("none")
    else:
        for i in range(len(result)):
            print(result[i])
main()
'''
get_another(a, b) 関数:
リスト a をリスト b の要素で上書きする関数です。
a と b の要素数は同じである必要があります。
set_number(number) 関数:
number という2次元リストを引数として受け取り、特定のパターンで要素を初期化します。
この関数は number リストを返します。
main() 関数:
・プログラムのエントリーポイントとなる関数です。
・入力文字列 charS を受け取り、結果のリスト result を初期化します。
・2次元リスト number を set_number() 関数で初期化します。
・charS の各文字を処理するループを開始します。
・charS の各文字について、3つのパターン (j の値) に対してループを開始します。
・パターンごとに、数字の置換を行い、結果を result リストに追加します。
・最後に result をソートし、結果を出力します。

このコードのアルゴリズムは、与えられた文字列 charS の各文字に対して、異なるパターンで数字の置換を行い、結果を生成しています。
これにより、全ての可能な置換パターンを網羅的に生成することができます。最終的な結果は辞書順にソートされています。
ただし、このコードでは一部の箇所で冗長な処理が行われており、効率的ではないと言えます。特に、リストのコピー (temp = get_another(temp, list(charS))) や結果のリストに要素を追加する際のループ処理が、改善の余地があります。
'''

# B024 格子を円で切り取る　※数学的アプローチが必要
# utf-8
import math # mathモジュールをインポートして円周率の計算や平方根の計算を行います。

while True: # 無限ループを開始
    try: # 入力を試みます。もし例外が発生した場合、exceptブロックに移動します。
        r = float(input()) # 半径 r の値を浮動小数点数として入力します。
        if r <= 0: # もし r が0以下の場合、無効な入力値として扱い、エラーメッセージを表示して次のループに移ります。
            print("Invalid input: r must be a positive number.")
            continue
        total = 0 # 格子点の合計数を初期化します。
        n = math.ceil(r) # r の値を切り上げて最も近い整数 n にします。これは最小の正方形の一辺の長さとなります。
        for i in range(n + 1): # 0から n までの範囲でループ
            if r * r - i * i < 0: # もし r * r - i * i が0より小さい場合、円の内部にないのでスキップします。
                continue
            total += math.ceil(math.sqrt(r * r - i * i)) # 円の内部にある格子点の数を計算し、それを total に加算します。
        print(total * 4) # 計算された格子点の合計数に4を乗算して出力します。
    except (ValueError, EOFError): # 入力時に ValueError や EOFError の例外が発生した場合、ループを終了します。
        break
'''
このコードでは、入力された半径 r をもとに最小の正方形内の格子点の数を求め、さらに円の内部にある格子点の数を計算しています。
最終的に、格子点の数に4を乗算して出力します。なお、無効な入力や入力の終了（EOF）に対しても適切に処理しているため、例外が発生しても安全に終了できます。
'''

# B025 うさぎジャンプ
# utf-8
# N, M, Kの入力を受け取る
N, M, K = map(int, input().split())

# 各うさぎの現在の位置をリストに格納する
s = [int(input()) for _ in range(M)]

# しげみの状態を管理するリストを作成する（初期値は0）
grass = [0] * N

# 各うさぎの初期位置をしげみのリストに反映する
for i in s:
    grass[i - 1] = i

# Kセットのジャンプを行う
for _ in range(K):
    for j in range(M):
        # うさぎがジャンプ先として選ぶしげみの番号（% nを行うことで範囲内に収める）
        grass_num = s[j] % N
        # ジャンプ先が他のうさぎに占拠されている場合、空いているしげみを探す
        while grass[grass_num] != 0:
            grass_num = (grass_num + 1) % N
        # ジャンプ元のしげみからうさぎを移動させる
        grass[grass_num] = grass[s[j] - 1]
        grass[s[j] - 1] = 0
        # うさぎの位置情報を更新する
        s[j] = grass_num + 1

# 各うさぎの最終位置を出力する
for i in s:
    print(i)
'''
標準入力からN、M、Kの値を受け取ります。それぞれ、しげみの数N、うさぎの数M、ジャンプ回数Kを表します。
うさぎの現在位置をリストsに格納しています。range(m)でうさぎの数M回ループし、int(input())によって各うさぎの位置を受け取ります。
しげみの状態を管理するためのリストgrassを作成、初期値は全て0です。次のループでは、リストsに格納されている各うさぎの位置情報を、リストgrassに反映させています。
各うさぎの位置-1のインデックスに対応する要素にうさぎの番号を代入しています。Kセットのジャンプを行っています。
外側のループはK回ループします。内側のループでは、各うさぎに対してジャンプ処理を行います。
grass_numはうさぎがジャンプ先として選ぶしげみの番号です。s[j] % nによって範囲内に収められます。
grass[grass_num] != 0は、ジャンプ先のしげみが他のうさぎに占拠されているかどうかを判定しています。もし占拠されている場合、次の空いているしげみを探すためにgrass_numを1ずつ増やしていきます。whileループを抜けた時点で、grass_numには空いているしげみの番号が格納されます。
ジャンプ元のしげみからうさぎを移動させるために、grass[grass_num]にジャンプ元のうさぎの番号を代入し、ジャンプ元のしげみを空にします。
最後に、うさぎの位置情報を更新するためにs[j]にgrass_num + 1を代入します。+ 1はインデックスと番号の差を調整するためです。
'''

# B026 自動販売機
# utf-8
class VendingMachine:
    def __init__(self, coin_in_machine):
        self.coin_in_machine = coin_in_machine

    def sell_result(self, customers):
        for customer in customers:
            arr_customer = customer.split(" ")

            # お客様が購入した商品の価格及び入れた各コインの枚数
            product_price = int(arr_customer[0])
            use_coin = {
                500: int(arr_customer[1]),
                100: int(arr_customer[2]),
                50: int(arr_customer[3]),
                10: int(arr_customer[4])
            }

            change_coin = {
                500: 0,
                100: 0,
                50: 0,
                10: 0
            }

            # お釣り
            change = [500 * use_coin[500] + 100 * use_coin[100] + 50 * use_coin[50] + 10 * use_coin[10] - product_price]
            tmp_change = change[0]

            for coin, coin_number in self.coin_in_machine.items():
                self.change(coin, coin_number, change, change_coin)

            message = ""
            if self.check_if_pass(change_coin, tmp_change):

                # 自動販売機内部コインの変化
                for coin, coin_number in self.coin_in_machine.items():
                    self.coin_in_machine[coin] = coin_number + use_coin[coin] - change_coin[coin]

                # 出力
                k = 0
                for coin, count in change_coin.items():
                    message += str(count)
                    if k == len(change_coin) - 1:
                        break
                    message += " "
                    k += 1

            else:
                message += "impossible"
            print(message)

    def change(self, coin, coin_number, change, change_coin):
        # お釣りの残りがcoin以下の場合は計算不要なので処理を終了する
        if change[0] < coin:
            return
        for num in range(coin_number, -1, -1):
            price = change[0] - num * coin
            # 残りのお釣りがcoinを使ってprice円支払える場合
            if price >= 0:
                change[0] -= num * coin
                change_coin[coin] = num
                return

    def check_if_pass(self, change_coin, tmp_change):
        # 50円玉と10円玉の合計が100円以上の場合は条件を満たさない
        if change_coin[50] * 50 + change_coin[10] * 10 >= 100:
            return False
        for coin, coin_number in self.coin_in_machine.items():
            # 自動販売機内のコインの枚数を超える場合は条件を満たさない
            if change_coin[coin] > coin_number:
                return False
        # お釣りの合計金額がtmp_change円と一致しない場合は条件を満たさない
        if change_coin[500] * 500 + change_coin[100] * 100 + change_coin[50] * 50 + change_coin[10] * 10 != tmp_change:
            return False
        return True


# 入力値の読み込み
info = input().strip()
arr_info = info.split(" ")

coin_in_machine = {
    500: int(arr_info[0]),
    100: int(arr_info[1]),
    50: int(arr_info[2]),
    10: int(arr_info[3])
}

count_of_customer = int(input().strip())
customers = []
for _ in range(count_of_customer):
    customers.append(input().strip())

# 自動販売機オブジェクトの作成と売り上げ結果の表示
vending_machine = VendingMachine(coin_in_machine)
vending_machine.sell_result(customers)
'''
VendingMachine クラス:
coin_in_machine インスタンス変数: 自動販売機内の各コインの枚数を格納する辞書です。
__init__ メソッド: coin_in_machine 辞書を受け取り、インスタンス変数に設定します。
sell_result メソッド: 複数の顧客の購入情報を受け取り、結果を表示します。
change メソッド: お釣りの計算を行います。指定されたコインで支払い可能な最大枚数を計算し、お釣りと使用したコインの枚数を更新します。
check_if_pass メソッド: お釣りの条件をチェックし、条件を満たすかどうかを判定します。

入力の読み込み:
最初の入力は自動販売機内のコインの枚数を表す文字列です。空白で区切られた各要素は、500円、100円、50円、10円のコインの枚数を表します。
2番目の入力は顧客の数を表す整数です。
続く入力は各顧客の購入情報を表す文字列です。空白で区切られた各要素は、商品の価格、500円、100円、50円、10円のコインの枚数を表します。

自動販売機オブジェクトの作成と売り上げ結果の出力:
入力から得られた情報をもとに、VendingMachine オブジェクトを作成します。
sell_result メソッドを呼び出し、顧客ごとの売り上げ結果を出力します。
'''

# B027 ◆
# B028 チャット記録
# utf-8
# 入力を取得
n, g, m = list(map(int, input().split()))
# グループの情報を取得
k = [list(map(int, input().split())) for i in range(g)]
# 各社員の画面に表示されるメッセージを格納するリストを初期化
N = [[] for i in range(n)]
# メッセージの数だけループ
for i in range(m):
    # メッセージの情報を入力し、送信者、受信者の種類、ターゲット、内容を取得
    s = input().split()
    sender = int(s[0])
    recipient_type = int(s[1])
    target = int(s[2])
    content = s[3:]
    
    # 受信者の種類が0の場合、送信者と受信者の両方の画面にメッセージを追加
    if recipient_type == 0 and sender != target:
        N[sender-1] += content
        N[target-1] += content
    
    # 受信者の種類が1の場合、対象のグループに所属するすべての社員の画面にメッセージを追加
    if recipient_type == 1:
        group_members = k[target-1][1:]  # グループのメンバーを取得
        for member in group_members:
            N[member-1] += content
    
# 各社員の画面に表示されるメッセージを出力
for i in range(n-1):
    print('\n'.join(N[i]))
    print('--')
print('\n'.join(N[-1]))
'''
このコードは、与えられた入力に基づいてメッセージのやり取りをシミュレーションし、各社員の画面に表示されるメッセージを出力します。
まず、社員数 n、グループ数 g、メッセージ数 m を入力します。次に、各グループの情報を入力し、グループに所属する社員のリストを作成します。
その後、メッセージの数だけループを回し、各メッセージに対して以下の処理を行います。
メッセージの情報を入力し、送信者と受信者の種類、ターゲット、内容を取得します。
受信者の種類が 0 の場合、送信者と受信者の両方の画面にメッセージを追加します。
受信者の種類が 1 の場合、対象のグループに所属するすべての社員の画面にメッセージを追加します。
最後に、各社員の画面に表示されるメッセージを出力します。各社員の画面ごとに、メッセージを改行区切りで表示し、最後にハイフンで区切ります。
'''

# B029 地価の予想
# utf-8
import math

def main():
    # 地点Aの座標を入力
    x, y = map(int, input().split())
    # k-近傍法のパラメータkを入力
    k = int(input())
    # 既知の地点の総数Nを入力
    N = int(input())

    info = []
    # 既知の地点の座標と価格を入力し、距離を計算してinfoリストに追加
    for _ in range(N):
        xi, yi, pi = map(int, input().split())
        distance = math.sqrt((x - xi) ** 2 + (y - yi) ** 2)
        info.append([xi, yi, pi, distance])

    # 距離を基準にinfoリストをソート
    info.sort(key=lambda x: x[3])

    # k個の地点の価格の合計を計算
    sum_price = sum(info[i][2] for i in range(int(k)))
    # 平均地価を求め、四捨五入して結果とする
    result = int(sum_price / k) + int((sum_price / k * 10) % 10) // 5

    # 結果を出力
    print(result)

if __name__ == "__main__":
    main()
'''
このコードは、与えられた地点Aと既知の地点の座標と価格を利用して、k-近傍法に基づいた地価の予測を行います。
main関数では、まず地点Aの座標を入力します。x, y = map(int, input().split())の部分で、空白区切りの入力を整数として受け取っています。
次に、k-近傍法のパラメータkと既知の地点の総数Nを入力します。k = int(input())とN = int(input())の部分で、整数の入力を受け取ります。
その後、infoリストを用意し、N回のループで既知の地点の座標と価格を入力し、距離を計算してinfoリストに追加しています。
xi, yi, pi = map(int, input().split())の部分で、空白区切りの入力を整数として受け取り、distance = math.sqrt((x - xi) ** 2 + (y - yi) ** 2)の部分で地点Aからの距離を計算しています。
その後、infoリストを距離を基準にソートします。info.sort(key=lambda x: x[3])の部分で、lambda関数を用いて要素の3番目（距離）を基準にソートしています。
次に、k個の地点の価格の合計を計算します。sum_price = sum(info[i][2] for i in range(int(k)))の部分で、リスト内包表記を用いてk個の地点の価格を合計しています。
最後に、平均地価を求めて四捨五入し、結果を出力します。result = int(sum_price / k) + int((sum_price / k * 10) % 10) // 5の部分で、合計をkで割った商と剰余を用いて四捨五入を行っています。
'''

# B030 氷のダンジョン
# utf-8
# ダンジョンの縦と横の長さを取得
H, W = map(int, input().split())

# ダンジョンの情報を取得
maze = []
for _ in range(H):
    row = input()
    maze.append(row)

# 最初の座標を取得し、0-indexedに変換
s_y, s_x = map(int, input().split())
s_x -= 1
s_y -= 1

# 移動回数を取得
N = int(input())

# 各移動の方向を取得
direction = []
for _ in range(N):
    d = input()
    direction.append(d)

check = True
for i in range(N):
    if direction[i] == 'U':
        # 上方向に移動
        while check:
            if s_x - 1 >= 0:
                if maze[s_x - 1][s_y] == '.':
                    s_x -= 1
                    break
                elif maze[s_x - 1][s_y] == '#':
                    s_x -= 1
            else:
                break
    elif direction[i] == 'D':
        # 下方向に移動
        while check:
            if s_x + 1 < H:
                if maze[s_x + 1][s_y] == '.':
                    s_x += 1
                    break
                elif maze[s_x + 1][s_y] == '#':
                    s_x += 1
            else:
                break
    elif direction[i] == 'L':
        # 左方向に移動
        while check:
            if s_y - 1 >= 0:
                if maze[s_x][s_y - 1] == '.':
                    s_y -= 1
                    break
                elif maze[s_x][s_y - 1] == '#':
                    s_y -= 1
            else:
                break
    elif direction[i] == 'R':
        # 右方向に移動
        while check:
            if s_y + 1 < W:
                if maze[s_x][s_y + 1] == '.':
                    s_y += 1
                    break
                elif maze[s_x][s_y + 1] == '#':
                    s_y += 1
            else:
                break

# 1-indexedに戻して最終的な座標を出力
s_x += 1
s_y += 1
print(s_y, s_x)
'''
１．ダンジョンの情報を入力として受け取ります。
　　最初に、縦の長さと横の長さを表す H と W を取得します。
　　続いて、H 行分の文字列を入力として受け取り、ダンジョンの情報を表す2次元リスト maze に格納します。
２．最初の座標と移動回数を入力として受け取ります。
　　s_y と s_x に最初の座標を格納します。ここで、座標は 1-indexed で与えられているため、0-indexed に変換します。
　　移動回数 N を取得します。
３．各移動の方向を入力として受け取ります。
　　N 回分の移動の方向を取得し、リスト direction に格納します。
４．移動のシミュレーションを行います。
　　N 回の移動を順番に処理します。
　　移動の方向に応じて、現在の座標を更新します。
　　上下左右の移動先がダンジョンの範囲内であり、移動先が土の床である場合にのみ移動します。
５．最終的な座標を出力します。
　　1-indexed の座標に戻し、最終的な座標を出力します。
このコードは、入力されたダンジョンの情報に基づいて指定された移動回数だけ移動し、最終的な座標を出力するシミュレーションのアルゴリズムです。ダンジョンの範囲や床の種類を判定しながら移動を行っています。
'''
--------------------------------------------- B031　※欠番 ◆
# B031 コインのウラとオモテ
# utf-8
def count_black_coins(N, s):
    board = list(s)  # 入力文字列をリストに変換してボードとして扱う
    black_count = board.count('b')  # 最初の黒コインの数を数える

    flipped = True  # 反転が行われたかどうかを表すフラグ
    while flipped:
        flipped = False  # 初期値は反転が行われなかったとする
        i = 0
        while i < N:
            if board[i] == 'b':  # 黒コインの場合
                j = i
                while j < N and board[j] == 'b':
                    j += 1
                if i > 0 and j < N and 'w' not in board[i:j]:
                    # 黒コインが白コインを挟めない場合、反転させる
                    for k in range(i, j):
                        board[k] = 'w'
                    flipped = True  # 反転が行われたのでフラグを立てる
            elif board[i] == 'w':  # 白コインの場合
                j = i
                while j < N and board[j] == 'w':
                    j += 1
                if i > 0 and j < N and 'b' not in board[i:j]:
                    # 白コインが黒コインを挟めない場合、反転させる
                    for k in range(i, j):
                        board[k] = 'b'
                    flipped = True  # 反転が行われたのでフラグを立てる
            i = j

    black_count = board.count('b')  # 最終的な黒コインの数を数える
    return black_count

# 入力の読み込み
N = int(input())
s = input().rstrip()

# 黒コインの個数の計算
result = count_black_coins(N, s)

# 結果の出力
print(result)
'''
まず、count_black_coinsという関数が定義されています。この関数は、引数としてボードの横の長さを表すNとゲーム開始時のコインの並びを表す文字列sを受け取り、最終的な黒コインの数を返します。
関数内では、boardというリストを作成し、sを文字ごとに分割して格納します。また、最初の黒コインの数を数えるための変数black_countを用意します。
flippedというフラグ変数をTrueで初期化します。この変数は、反転が行われたかどうかを示す役割を果たします。
次に、whileループが開始されます。ループ内では、まずflippedをFalseに設定します。これは、反転が行われなかった場合のデフォルトの状態です。
次に、インデックスiを初期化し、iがNより小さい間ループを繰り返します。ループ内では、以下の処理が行われます。

board[i]が黒コインの場合：
jをiとし、jがN以下かつboard[j]が黒コインである間ループを繰り返します。つまり、連続する黒コインの範囲を見つけます。
もしiより前に白コインがなく、jより後に白コインがない場合、つまり黒コインが白コインを挟めない状態であれば、その範囲のコインを反転させます。具体的には、board[i:j]の要素をすべて白コインに置き換えます。
反転が行われた場合、flippedをTrueに設定します。

board[i]が白コインの場合：
jをiとし、jがN以下かつboard[j]が白コインである間ループを繰り返します。つまり、連続する白コインの範囲を見つけます。
もしiより前に黒コインがなく、jより後に黒コインがない場合、つまり白コインが黒コインを挟めない状態であれば、その範囲のコインを反転させます。具体的には、board[i:j]の要素をすべて黒コインに置き換えます。
反転が行われた場合、flippedをTrueに設定します。
iをjの値に更新します。

ループの最後で、もしflippedがTrueのままであれば、まだ反転が行われる可能性があるため、再度の反転処理を行います。これは、連続するコインの範囲に対しての反転を繰り返し行うためです。
最後に、最終的なボードの状態で黒コインの数を数え、その結果をblack_countとして返します。
メインの処理では、入力を受け取り、count_black_coins関数を呼び出して最終的な黒コインの数を計算し、結果を出力します。
'''

# B032 デジタル計算機
# utf-8
class Abacus:
    def __init__(self, width):
        self.width = width

    def get_number(self):
        numbers = []
        # そろばんの状態を入力
        for _ in range(8):
            pearls = input().strip()
            numbers.append(list(pearls))
        
        result = ''
        # 列ごとに珠の移動をシミュレーション
        for pearls in zip(*numbers):
            tmp = 0
            for position, pearl in enumerate(pearls):
                if position < 2:
                    if position == 1 and pearl == '*':
                        tmp += 5  # 上の桁で2つ目の珠が存在し、'*' の場合は5を加算
                    continue
                if position == 2:
                    continue # 3つ目の位置は無視して次の位置へ進む
                if position > 2:
                    if pearl == '|':
                        break   # '|' が現れた場合は珠の移動が終了し、ループから抜ける
                    tmp += 1    # '|' が出現するまで、珠の移動回数をカウント
            result += str(tmp)  # 珠の移動回数を結果に追加

        return int(result.rjust(self.width, '0')) # 結果を指定の桁数に合わせてゼロで左詰めし、整数として返す

    def get_result(self, number):
        result = [['*' if i != 2 else '=' for _ in range(self.width)] for i in range(8)]
        # そろばんの初期状態を生成
        number = str(number).rjust(self.width, '0')
 
        # 数字をそろばんの状態に変換
        for i, digit in enumerate(number):
            digit = int(digit)
            if digit < 5:
                result[0][i] = '*'  # 上の桁の珠
                result[1][i] = '|'  # 下の桁の珠
            else:
                result[0][i] = '|'  # 上の桁の珠

            number = str(digit - 5) if digit >= 5 else str(digit)
            # 数字が5以上の場合は珠を1つ上に移動させた後の数字
            # 数字が5未満の場合は珠を移動させずそのままの数字
            # 条件が真の場合、珠を1つ上に移動させた後の数字を表す文字列に変換しています。
            # 条件が偽の場合、珠を移動させず、元の数字のままとなります。
            # 下の桁の珠を配置
            for j in range(3, 8):
                if j - 3 == int(number):
                    result[j][i] = '|'  # 下の桁の珠

        # 結果を表示
        for row in result:
            print(''.join(row))


W = int(input())  # そろばんの長さを入力
abacus = Abacus(W)
A = abacus.get_number()  # 数字 A のそろばんを取得
B = abacus.get_number()  # 数字 B のそろばんを取得
abacus.get_result(A + B)  # A + B のそろばんを表示
'''
Abacus クラスのコンストラクタで、そろばんの幅（桁数）を受け取り、インスタンス変数 width に設定します。
get_number メソッドは、そろばんの状態を入力として受け取り、その状態に対応する数値を返します。
入力されたそろばんの状態は、8行分の文字列として受け取ります。各行は桁ごとの珠の状態を表しています。それぞれの珠は '*' または '|' のいずれかです。
列ごとに珠の移動をシミュレーションし、数値に変換しています。具体的な処理は以下の通りです。

position と pearl には珠の位置と状態が順番に渡されます。
position が 0 または 1 の場合、2つ目の珠の位置であることを判定しています。
もし pearl が '*' の場合、上の桁で2つ目の珠が存在することを意味し、結果に 5 を加算します。
position が 2 の場合、3つ目の位置であることを判定して無視します。
position が 2 より大きい場合、下の桁の位置であることを意味します。
もし pearl が '|' の場合、珠の移動が終了し、ループから抜けます。
それ以外の場合、珠の移動回数を 1 加算します。
最終的に、結果を文字列 result に追加し、指定の桁数に合わせて左詰めし、整数として返します。

get_result メソッドは、数値をそろばんの状態に変換して表示します。
まず、数値 number を文字列に変換し、指定の桁数に合わせて左詰めします。
それぞれの桁の数字をそろばんの状態に変換して result に格納します。具体的な処理は以下の通りです。

i と digit には桁のインデックスと数字が順番に渡されます。
digit を整数に変換し、その値に応じて上の桁と下の桁の珠の状態を設定します。
もし digit が 5 未満の場合、上の桁の珠に '*' を、下の桁の珠に '|' を設定します。
もし digit が 5 以上の場合、上の桁の珠に '|' を設定します。
digit を 5 を引いた値に変換し、その結果を number に再代入します。これにより、次の桁の珠の配置に移ります。
下の桁の珠の位置 j が、j - 3 と number の値が一致する場合、下の桁の珠に '|' を設定します。
最終的に、結果のそろばんの状態を表示します。
'''

# B033 テーブルジェネレーター
# utf-8
def generate_table(headers, data):
    # 各列の最大幅を計算
    column_widths = [max(len(header), max(len(str(row[i])) for row in data)) for i, header in enumerate(headers)]

    # ヘッダー行を生成
    header_row = "| " + " | ".join(header.ljust(width) for header, width in zip(headers, column_widths)) + " |"

    # 区切り行を生成
    separator_row = "|-" + "-|-".join("-" * width for width in column_widths) + "-|"

    # データ行を生成
    data_rows = ""
    for row in data:
        data_row = "| " + " | ".join(str(cell).ljust(width) for cell, width in zip(row, column_widths)) + " |\n"
        data_rows += data_row

    # テーブルを結合して返す
    table = header_row + "\n" + separator_row + "\n" + data_rows
    return table

def generate_output(headers, data):
    # テーブルを生成
    table = generate_table(headers, data)
    # 改行と余分な空白を削除して出力用文字列を作成
    output = ""
    output += table.strip() + "\n"

    return output

# 入力の取得
W = int(input())
headers = input().split()
H = int(input())
data = [input().split() for _ in range(H)]

# テーブルの生成と出力
output = generate_output(headers, data)
print(output)
'''
generate_table(headers, data)関数は、与えられた見出しとデータから表を生成するための関数です。まず、各列の最大幅を計算します。
その後、ヘッダー行、区切り行、データ行を生成し、それらを結合してテーブルを作成します。最終的に、生成したテーブルを返します。
generate_output(headers, data)関数は、generate_table()関数を呼び出してテーブルを生成し、出力用の文字列を作成します。
テーブルの前後に余分な空白がないようにし、最終的な出力用文字列を返します。
入力部分では、まず見出しの個数 W を取得し、次に見出しのリスト headers を取得します。
続いて、データ行の行数 H を取得し、H 行分のデータをリストとして取得します。
最後に、generate_output()関数を呼び出してテーブルを生成し、出力します。
'''

# B034 ロボットの歩行実験
# utf-8
# 入力値の読み込み
sp_x, sp_y = map(int, input().split())  # 初期位置
move_forward, move_right, move_backward, move_left = map(int, input().split())  # 移動量
mCN = int(input())  # 移動コマンドの数
move_command = [list(map(str, input().split())) for _ in range(mCN)]  # 移動コマンド

current_state = 0
# 0 : F (前進)
# 1 : R (右に移動)
# 2 : B (後退)
# 3 : L (左に移動)

for i in range(mCN):
    if move_command[i][0] == 'm':  # 移動コマンド
        if move_command[i][1] == 'F':  # 前進
            if current_state == 0:
                sp_y += move_forward
            elif current_state == 1:
                sp_x += move_forward
            elif current_state == 2:
                sp_y -= move_forward
            elif current_state == 3:
                sp_x -= move_forward
        elif move_command[i][1] == 'R':  # 右に移動
            if current_state == 0:
                sp_x += move_right
            elif current_state == 1:
                sp_y -= move_right
            elif current_state == 2:
                sp_x -= move_right
            elif current_state == 3:
                sp_y += move_right
        elif move_command[i][1] == 'B':  # 後退
            if current_state == 0:
                sp_y -= move_backward
            elif current_state == 1:
                sp_x -= move_backward
            elif current_state == 2:
                sp_y += move_backward
            elif current_state == 3:
                sp_x += move_backward
        elif move_command[i][1] == 'L':  # 左に移動
            if current_state == 0:
                sp_x -= move_left
            elif current_state == 1:
                sp_y += move_left
            elif current_state == 2:
                sp_x += move_left
            elif current_state == 3:
                sp_y -= move_left
    elif move_command[i][0] == 't':  # 回転コマンド
        if move_command[i][1] == 'R':  # 右に回転
            current_state = (current_state + 1) % 4
        elif move_command[i][1] == 'B':  # 後ろ向きに回転
            current_state = (current_state + 2) % 4
        elif move_command[i][1] == 'L':  # 左に回転
            current_state = current_state - 1
            if current_state == -1:
                current_state = 3

    # 座標の範囲を制限
    if sp_x < -1000:
        sp_x = -1000
    elif sp_x > 1000:
        sp_x = 1000
    if sp_y < -1000:
        sp_y = -1000
    elif sp_y > 1000:
        sp_y = 1000

# 結果を出力
print(sp_x, sp_y)
'''
与えられた入力に基づいてロボットの移動をシミュレートし、最終的な座標を出力するものです。以下、コードの解説をします。

最初に、初期位置と移動量、移動コマンドの数を入力します。
次に、移動コマンドを入力します。移動コマンドは、移動（'m'）か回転（'t'）のどちらかであり、移動の場合は方向（'F', 'R', 'B', 'L'）も指定されます。
ロボットの現在の状態を表す変数 current_state を初期化します。0は前進（F）、1は右に移動（R）、2は後退（B）、3は左に移動（L）を表します。
移動コマンドの数だけループを実行します。
ループ内では、移動コマンドが移動の場合と回転の場合に分かれます。
移動の場合は、現在の状態に応じて座標を更新します。例えば、前進の場合は現在の状態に応じて sp_x や sp_y を増減させます。
回転の場合は、現在の状態を変更します。右回転（R）の場合は現在の状態に1を加え、後ろ向きに回転（B）の場合は2を加えます。左回転（L）の場合は現在の状態から1を引きますが、-1になる場合は3に戻します。
移動後に、座標の範囲を制限します。sp_x や sp_y が範囲外（-1000未満または1000を超える）の場合は、最小値または最大値に制限します。
最後に、最終的な座標 sp_x と sp_y を出力します。
このコードは、与えられた移動コマンドに従ってロボットを移動させ、最終的な座標を制限しながら計算します。移動と回転の操作を適切に行い、最終的な座標を正確に計算できるようになっています。
'''

# B035 ジョギングランキング
# utf-8
# 部員数 N、ジョギング記録数 M、上位人数 T を入力として受け取る
N, M, T = map(int, input().split())

# 前月のジョギング成績を格納するリスト
post_mon = []

# 前月のジョギング成績を受け取り、リストに追加する
for _ in range(N):
    post_mon.append(input().split())

# 今月のジョギング記録を格納するリスト
this_mon = []

# 今月のジョギング記録を受け取り、リストに追加する
for _ in range(M):
    this_mon.append(input().split())

# リストを距離の降順にソートする関数
def range_sort(lst):
    lst.sort(key=lambda x: (-int(x[1]), x[0]))
    return lst

# 前月のジョギング成績をソートする
post_mon = range_sort(post_mon)

# 上位のジョギング記録を取得する
top_post = post_mon[:T]

# 今月のジョギング記録の合計を計算し、名前と合計距離を格納するリスト
this_mon_sum = []

# 今月のジョギング記録の合計を計算する
for name in set(record[1] for record in this_mon):
    total_distance = sum(int(record[2]) for record in this_mon if record[1] == name)
    this_mon_sum.append([name, str(total_distance)])

# 前月のジョギング成績と今月のジョギング記録の合計を結合し、ソートする
this_mon_sum += [[name, '0'] for name in set(record[0] for record in post_mon) - set(record[0] for record in this_mon_sum)]
this_mon_sum = range_sort(this_mon_sum)

# 上位のジョギング記録を取得する
top_this = this_mon_sum[:T]

# 変動を判定し、結果を追加する
for i in range(T):
    if top_this[i][0] == top_post[i][0]:
        top_this[i].append("same")
    elif any(top_this[i][0] == record[0] for record in top_post[i + 1:]):
        top_this[i].append("up")
    elif any(top_this[i][0] == record[0] for record in top_post[:i]):
        top_this[i].append("down")
    else:
        top_this[i].append("new")

# 結果を出力する
for record in top_this:
    print(" ".join(record))
'''
まず、与えられた入力を受け取ります。N, M, T = map(int, input().split())を使って、整数値の N, M, T を取得します。
次に、post_monというリストに前月のジョギング成績を格納します。post_mon = [input().split() for _ in range(N)]の部分で、N 回のループを実行して、各行から名前と距離を受け取って post_mon リストに追加しています。
同様に、this_monというリストに今月のジョギング記録を格納します。this_mon = [input().split() for _ in range(M)]の部分で、M 回のループを実行して、各行から日付、名前、距離を受け取って this_mon リストに追加しています。
次に、range_sort関数を使って post_mon リストと this_mon_sum リストをソートします。range_sort関数は与えられたリストを距離の降順にソートし、距離が同じ場合は名前の辞書順でソートする関数です。
その後、上位のジョギング記録を top_post リストと top_this リストに格納します。top_post リストは post_mon リストの上位 T 件の記録を格納し、top_this リストは this_mon_sum リストの上位 T 件の記録を格納します。
top_post リストと top_this リストを比較し、各記録の変動を判定します。結果を top_this リストの各要素の3番目の要素に追加します。
最後に、top_this リストを出力します。各要素の名前、距離、変動結果がスペース区切りで表示されます。
'''

# B036 大統領選挙
# utf-8
def calculate_winner(candidate_num, candidates, voter_num, voter_preferences):
    voted_candidates = [0] * (candidate_num + 1)  # 候補者ごとの得票数を保持するリスト
    repub_vote = 0  # 共和党候補の得票数
    demo_vote = 0  # 民主党候補の得票数

    # 最初の投票
    for preferences in voter_preferences:
        for check in range(2):
            for candidate in preferences:
                if candidates[candidate] == check:
                    voted_candidates[candidate] += 1  # 候補者の得票数をインクリメント
                    break

    # 最初の投票結果
    repub = max((c for c in range(1, candidate_num + 1) if candidates[c] == 0), key=lambda x: voted_candidates[x])
    demo = max((c for c in range(1, candidate_num + 1) if candidates[c] == 1), key=lambda x: voted_candidates[x])

    # 最後の投票
    for preferences in voter_preferences:
        for candidate in preferences:
            if candidate == repub:
                repub_vote += 1
                break
            elif candidate == demo:
                demo_vote += 1
                break

    # 結果の出力
    if repub_vote > demo_vote:
        return repub
    else:
        return demo

# 入力
candidate_num = int(input())  # 候補者数の入力
candidates = [0] * (candidate_num + 1)  # 候補者の所属パーティーを保持するリスト
for i in range(1, candidate_num + 1):
    if input() == "Republican":
        candidates[i] = 0
    else:
        candidates[i] = 1

voter_num = int(input())  # 投票者数の入力
voter_preferences = []  # 投票者の選好順位を保持するリスト
for _ in range(voter_num):
    preferences = list(map(int, input().split()))  # 投票者の選好順位をリストとして入力
    voter_preferences.append(preferences)

# 勝者の計算
winner = calculate_winner(candidate_num, candidates, voter_num, voter_preferences)

# 結果の出力
print(winner)
'''
calculate_winner 関数は、候補者数、候補者の所属パーティー、投票者数、投票者の選好順位を受け取り、最終的な勝者を計算する関数です。共和党候補と民主党候補の得票数を数えて、最終的な勝者を決定します。
入力値を受け取ります。まず、候補者数と候補者の所属パーティーを入力し、その後、投票者数と各投票者の選好順位を入力します。
calculate_winner 関数を使用して最終的な勝者を計算し、結果を出力します。
このコードでは、最初の投票で各候補者の得票数をカウントし、その結果から共和党候補と民主党候補を決定します。その後、最後の投票で選好順位に基づいて得票数をカウントし、最終的な勝者を決定します。最終的な勝者の候補者番号が返され、結果が出力されます。
'''

# B037 幸運な1年
# utf-8
def get_lucky_day(M, D, a, b, m):
    w, x, y, z = 0, 0, 0, 0
    d = {}
    date = '{:0=2}'.format(M) + '{:0=2}'.format(D)
    datenum = set(date)
    
    # 日付の桁数と出現回数をカウント
    for i in datenum:
        d[i] = date.count(i)
    
    for i in range(10000):
        flag = True
        w = (a[0] * w + b[0]) % m[0]
        x = (a[1] * x + b[1]) % m[1]
        y = (a[2] * y + b[2]) % m[2]
        z = (a[3] * z + b[3]) % m[3]
        date2 = str(w % 10) + str(x % 10) + str(y % 10) + str(z % 10)
        
        # カードの数字と日付を比較
        for key in d:
            if key not in date2:
                flag = False
                break
            if date2.count(key) != d[key]:
                flag = False
                break
        
        if flag:
            return i + 1
    
    return -1

# 入力値の取得
M, D = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
m = list(map(int, input().split()))

# 幸運な日を取得
result = get_lucky_day(M, D, a, b, m)
print(result)
'''
get_lucky_day 関数は、引数として今日の日付 (M, D)、カードのパラメータ (a, b, m) を受け取り、幸運な日になるために必要なカードの引き直し回数を計算します。
変数 w, x, y, z はカードの擬似乱数を表すための変数で、初期値は 0 です。
辞書 d は日付の桁数と出現回数を保持します。桁数と出現回数の対応は、日付を文字列に変換してカウントします。
次に、10,000 回までのループを実行します。
フラグ flag は幸運な日になるかどうかを示す変数で、初期値は True です。
カードの擬似乱数を生成し、それぞれのカードの数字を 10 で割った余りを取得して date2 に格納します。
date2 と辞書 d を比較して、カードの数字が日付を作るために必要な条件を満たしているかどうかを判定します。条件を満たさない場合、flag を False に設定します。
もし flag が True のままであれば、ループ回数に 1 を加えた値を返します。これが幸運になるために必要なカードの引き直し回数です。
もしループが終了しても幸運な日になる条件を満たすカードの引き直し回数が見つからない場合、-1 を返します。
最後に、入力値を受け取り、get_lucky_day 関数を呼び出して結果を出力します。
'''

# B038 つるかめ算
# utf-8
# 入力を受け取る
a, b, c, d = map(int, input().split())

# パイザ鶴とパイザ亀の匹数を格納するリスト
matched = [0, 0]

# 推定のためのループ
for i in range(1, b):
    # パイザ鶴とパイザ亀の足の本数の合計を計算
    tmp_feet = i * c + (b - i) * d
    
    # 推定の結果が与えられた足の本数と一致する場合
    if tmp_feet == a:
        # 既に一意の結果が得られている場合は「miss」として終了
        if matched != [0, 0]:
            matched = [0, 0]
            break
        # 一意の結果が得られていない場合は推定結果を格納
        else:
            matched = [i, b - i]

# 結果の出力
if matched != [0, 0]:
    print(matched[0], matched[1])
else:
    print('miss')
'''
最初に入力を受け取ります。a, b, c, d = map(int, input().split()) の行では、スペース区切りの入力を受け取り、それぞれの値を整数として変数 a, b, c, d に代入しています。
推定結果を格納するための変数 matched を [0, 0] で初期化します。この変数は、一意の結果が得られたかどうかを管理するために使用します。
ループを使って、推定を行います。for i in range(1, b) の行では、1から b-1 までの数値を順番に変数 i に代入しながらループを回します。
ループ内では、仮の結果を計算しています。tmp_feet = i * c + (b - i) * d の行では、仮の結果として、i 匹のパイザ鶴の足の本数と (b - i) 匹のパイザ亀の足の本数の合計を計算しています。
仮の結果が与えられた足の本数と一致する場合、一意の結果が得られるかどうかを判定します。if tmp_feet == a: の行では、仮の結果が与えられた足の本数と一致するかを確認しています。
もし一意の結果がまだ得られていない場合、推定結果を matched 変数に格納します。matched = [i, b - i] の行では、i 匹のパイザ鶴と (b - i) 匹のパイザ亀を推定したことを表す結果を格納しています。
ループが終了した後、最終的な結果を出力します。if matched != [0, 0]: の行では、一意の結果が得られたかどうかを判定しています。もし一意の結果が得られた場合、パイザ鶴とパイザ亀の匹数を出力します。それ以外の場合は、"miss" を出力します。
このコードは、与えられた足の本数と頭の個数の合計から、パイザ鶴とパイザ亀の匹数を推定するための処理を行っています。ループを使用して可能な組み合わせを試し、一意の結果が得られるかどうかを判定しています。
'''

# B039 雨上がりの道
# utf-8
class UnionFind:
    def __init__(self, n):
        self.parent = [i for i in range(n)]  # 各要素の親を格納するリスト
        self.rank = [0] * n  # 各要素のランク（深さ）を格納するリスト

    def find(self, x):
        if self.parent[x] != x:  # 親が自身でない場合、再帰的に親をたどる
            self.parent[x] = self.find(self.parent[x])  # 親を根に直接設定し、経路圧縮を行う
        return self.parent[x]  # 根を返す

    def union(self, x, y):
        root_x = self.find(x)  # xの根を取得
        root_y = self.find(y)  # yの根を取得

        if root_x != root_y:  # 異なる根を持つ場合のみ結合処理を行う
            if self.rank[root_x] < self.rank[root_y]:  # root_xのランクが小さい場合
                self.parent[root_x] = root_y  # root_xの親をroot_yに設定
            elif self.rank[root_x] > self.rank[root_y]:  # root_yのランクが小さい場合
                self.parent[root_y] = root_x  # root_yの親をroot_xに設定
            else:
                self.parent[root_y] = root_x  # root_yの親をroot_xに設定
                self.rank[root_x] += 1  # root_xのランクを増加させる


def check_overlap(rect1, rect2):
    # 2つの長方形が重なっているかを判定する関数
    x_overlap = (rect1[0][0] <= rect2[1][0]) and (rect1[1][0] >= rect2[0][0])
    y_overlap = (rect1[0][1] <= rect2[1][1]) and (rect1[1][1] >= rect2[0][1])
    return x_overlap and y_overlap


def find_accessible_puddles(n, s, puddles):
    uf = UnionFind(n)  # UnionFindオブジェクトを初期化

    for i in range(n):
        for j in range(i + 1, n):
            if check_overlap(puddles[i], puddles[j]):  # 水たまりが重なっている場合
                uf.union(i, j)  # 水たまりを結合

    accessible_puddles = []  # アメンボが入ることのできる水たまりのリスト
    root = uf.find(s - 1)  # アメンボがいる水たまりの根を取得

    for i in range(n):
        if uf.find(i) == root:  # 同じ根に属する水たまりはアメンボが入れる
            accessible_puddles.append(i + 1)  # 水たまりの番号をリストに追加

    return accessible_puddles


# 入力値の読み込み
n = int(input())  # 水たまりの個数
s = int(input())  # アメンボがいる水たまりの番号

puddles = []
for _ in range(n):
    x, y, a, b = map(int, input().split())
    puddles.append(((x, y), (a, b)))  # 水たまりの座標をタプルとしてリストに追加

accessible_puddles = find_accessible_puddles(n, s, puddles)  # アメンボが入れる水たまりを求める

for puddle in accessible_puddles:
    print(puddle)  # 結果を出力
'''
ここでは、Union-Find法による解法のコード例の解説を行います。
まず、UnionFindクラスを定義しています。このクラスは、Union-Findデータ構造を表現するためのものです。
__init__メソッドでは、要素の数を指定してUnionFindオブジェクトを初期化します。parentリストは各要素の親を表し、最初は自身を親として初期化します。rankリストは各要素のランク（深さ）を表し、最初はすべて0で初期化します。
findメソッドは、指定された要素の親を再帰的に辿り、根（ルート）の要素を返します。また、途中で辿った要素の親を根に直接設定することで経路圧縮を行っています。これにより、次回以降のfind操作の際に効率的に根を特定することができます。
unionメソッドは、2つの要素を結合します。まず、それぞれの要素の根（ルート）を取得し、異なる根を持つ場合にのみ結合処理を行います。結合時には、ランク（深さ）を考慮して低いランクの木を高いランクの木に結合し、木のバランスを保ちます。
次に、find_accessible_puddles関数では、与えられた水たまりの情報を基にアメンボが入ることのできる水たまりを特定します。
まず、UnionFindオブジェクトを初期化します。その後、2重ループを使ってすべての水たまりの組み合わせをチェックします。check_overlap関数を利用して重なっているかを判定し、重なっている場合はそれらの水たまりを結合します。
結合処理が終わった後、アメンボがいる水たまりのルートを取得します（s - 1で指定）。そのルートに属する水たまりがアメンボが入ることのできる水たまりとなります。最後に、結果を出力します。
この解法では、Union-Findデータ構造を使って水たまりの重なりを効率的に判定し、アメンボが入ることのできる水たまりを特定しています。Union-Find法は連結性の管理に優れたデータ構造であり、効率的なグループ化が可能です。これにより、問題の制約条件に合わせた高速な解法を実現しています。
'''

# B040 たのしい暗号解読
# 入力値の取得
lines = []
while True:
    try:
        line = input()
        lines.append(line)
    except EOFError:
        break

# 回答方針
# [1] 必要な値を変数/配列化する。置換回数(count), 暗号文(codeText), 暗号ルール(codeRule), アルファベット(alphabet)
# [2] 暗号文を一文字ずつ置換ルールと比較。暗号文文字 = 暗号ルールとなる時の、置換ルールの文字列順を取得
# [3] [2]で取得した番号のアルファベット文字列を取得する。
# [4] [2][3]を暗号文の文字列回数分繰り返す
# [5] [2][3][4]の処理を置換回数(count)回、繰り返す。
# [5]で得られた文字列を表示する

alphabet = "abcdefghijklmnopqrstuvwxyz"
count, codeRule = lines[0].split()
count = int(count)
codeText = lines[1].strip()
decryption = ''

for c in range(count):
    for char in codeText:
        if char == ' ':
            decryption += ' '
            continue
        for n in range(len(codeRule)):
            if char == codeRule[n]:
                decryption += alphabet[n]
    codeText = decryption
    decryption = ''

print(codeText)
'''
最初に、入力を受け取るための処理が行われています。input()関数を使って一行ずつ入力を読み込み、linesリストに格納しています。EOFError例外が発生するまで繰り返します。
次に、アルファベットの文字列や復号に必要な変数を初期化しています。alphabet変数にはアルファベットの文字列が格納されています。count変数には置換回数が、codeRule変数には置換のルールが格納されます。countは整数に変換しています。また、codeText変数には暗号文が格納されます。strip()関数を使って行末の改行文字を削除しています。decryption変数は復号結果を格納するための空の文字列です。
指定された回数だけ復号処理を繰り返します。外側のループはcount回繰り返されます。内側のループでは、暗号文の各文字を一つずつ処理します。文字がスペースの場合は、スペースを復号結果に追加し、次の文字の処理へ進みます。それ以外の場合は、暗号ルールを順番に比較し、一致するルールの位置に対応するアルファベットを復号結果に追加します。
内側のループが終わった後、codeTextを更新して復号結果を反映します。そして、decryptionを空の文字列にリセットします。
最後に、復号された結果を出力します。
このコードでは、与えられた置換回数と置換ルールを使って暗号文を復号する処理が行われます。指定された回数だけ復号処理が繰り返され、最終的な復号結果が出力されます。
'''
--------------------------------------------- B041　※欠番 ◆
# B041 繰り返し模様
# utf-8
K = int(input())  # 繰り返し手順の回数を取得
N = int(input())  # 最初の正方形の辺の長さを取得
s = [list(input()) for _ in range(N)]  # 初期状態の模様を取得

for m in range(K):
    s1 = []  # 新しい模様を生成するためのリスト

    for i in range(N):
        for j in range(N):
            if s[i][j] == '.':
                if j == 0:
                    # 白色の場合は、同じ大きさの白い正方形を生成
                    for k in range(N):
                        s1.append(['.'] * N)
                elif j > 0:
                    # 白色の場合は、同じ大きさの白い正方形を追加
                    for k in range(N):
                        s1[i * N + k][len(s1[i * N + k]):len(s1[i * N + k])] = ['.'] * N
            else:
                if j == 0:
                    # 青色の場合は、元の模様をそのまま追加
                    for k in range(N):
                        s1.append(s[k][:])
                elif j > 0:
                    # 青色の場合は、元の模様を追加
                    for k in range(N):
                        s1[i * N + k][len(s1[i * N + k]):len(s1[i * N + k])] = s[k]

    N *= N  # 新しい模様の辺の長さを更新
    s = s1[:]  # 新しい模様で元の模様を上書き

for row in s1:
    print("".join(row))  # 生成された最終的な模様を出力
'''
入力値の受け取り:
K = int(input()): 繰り返し手順の回数を整数として受け取ります。
N = int(input()): 最初の正方形の辺の長さを整数として受け取ります。
s = [list(input()) for _ in range(N)]: N行の文字列を受け取り、それぞれの文字列をリストに変換して二次元リスト s に格納します。これにより、初期状態の模様が表現されます。

模様の生成と更新のループ:
for m in range(K):: K回の繰り返しを行います。各繰り返しでは、新しい模様が生成されて元の模様と入れ替わります。
s1 = []: 新しい模様を生成するための空のリスト s1 を作成します。

新しい模様の生成:
2重ループを使用して、元の模様を基に新しい模様を生成します。
if s[i][j] == '.':: もし現在の正方形が白色であれば、同じ大きさの白い正方形で置き換えます。
else:: もし現在の正方形が青色であれば、元の模様をそのまま追加します。

新しい模様の更新:
N *= N: 新しい模様の辺の長さを更新します。元の辺の長さの N 倍になります。
s = s1[:]: 生成された新しい模様で元の模様を上書きします。
最終的な模様の出力:

for row in s1: print("".join(row)): 生成された最終的な模様を出力します。各行の文字列を結合して表示します。
このコードは、与えられた繰り返し手順に基づいて模様を生成し、最終的な模様を出力します。初期状態の模様に対して、白色の正方形は同じ大きさの白い正方形で置き換えられ、青色の正方形は元の模様に置き換えられます。
この操作を指定された回数繰り返すことで、最終的な模様が生成されます。
'''

# B042 横入りするネコ
# utf-8
def check_cat(cat_num, M, cat_info, eat_time_info, cat_line):
    # 猫の順番を組み合わせて全パターンを調べる再帰関数
    if len(cat_line) == cat_num:
        cat_M = check_M(cat_num, cat_info, cat_line)
        if cat_M <= M:
            eat_time = check_eat_time(cat_num, cat_info, cat_line)
            eat_time_info.add(eat_time)
    else:
        for i in range(cat_num):
            if i + 1 not in cat_line:
                new_cat_line = cat_line.copy()
                new_cat_line.append(i + 1)
                check_cat(cat_num, M, cat_info, eat_time_info, new_cat_line)


def check_M(cat_num, cat_info, cat_line):
    # 各猫の不満度の合計を計算する関数
    cat_M = [0] * cat_num
    cat_line_info = [0] * cat_num
    sum_cat_M = 0

    for index, value in enumerate(cat_line):
        cat_line_info[index] = value

    for i in range(1, cat_num):
        for j in range(i):
            if cat_line_info[i] < cat_line_info[j]:
                cat_M[cat_line_info[i] - 1] += 1

    for i in range(cat_num):
        sum_cat_M += cat_M[i] * cat_info[i][1]

    return sum_cat_M


def check_eat_time(cat_num, cat_info, cat_line):
    # 各猫の食事時間の合計を計算する関数
    eat_time = 0
    eat_time_sum = 0
    cat_line_info = [0] * cat_num

    for index, value in enumerate(cat_line):
        cat_line_info[index] = value

    for i in range(cat_num):
        eat_time += eat_time_sum + cat_info[cat_line_info[i] - 1][0]
        eat_time_sum += cat_info[cat_line_info[i] - 1][0]

    return eat_time


cat_num, M = map(int, input().split())

cat_info = []
for _ in range(cat_num):
    cat_info.append(list(map(int, input().split())))

eat_time_info = set()
cat_line = []

check_cat(cat_num, M, cat_info, eat_time_info, cat_line)

min_eat_time = min(eat_time_info)

print(min_eat_time)
'''
check_cat関数:
引数:
cat_num: 猫の数
M: 許容される不満度の合計
cat_info: 猫の情報を格納した2次元リスト
eat_time_info: 結果として得られる食事時間の集合
cat_line: 現在の猫の順番のリスト
再帰的に全ての猫の順番の組み合わせをチェックし、条件を満たす場合に食事時間を計算して集合に追加します。
まだ順番が割り当てられていない猫に対して順番を割り当てて再帰呼び出しを行います。

check_M関数:
引数:
cat_num: 猫の数
cat_info: 猫の情報を格納した2次元リスト
cat_line: 現在の猫の順番のリスト
各猫の不満度の合計を計算して返します。
猫の順番が入れ替わった場合、その猫より前にいる猫の不満度を増やします。

check_eat_time関数:
引数:
cat_num: 猫の数
cat_info: 猫の情報を格納した2次元リスト
cat_line: 現在の猫の順番のリスト
各猫の食事時間の合計を計算して返します。
猫の順番に従って、各猫の食事時間を計算し合計します。

メイン部分:
ユーザーからの入力を受け取り、cat_numとMに代入します。
cat_infoリストを作成し、猫の情報を格納します。
結果の食事時間を格納するための集合eat_time_infoと、現在の猫の順番を格納するためのリストcat_lineを初期化します。
check_cat関数を呼び出して、全ての猫の順番の組み合わせをチェックします。
得られた食事時間の集合eat_time_infoから最小値を取得し、結果を出力します。
このコードは、猫の順番の組み合わせを全て試す方法を用いて最適解を求める力まで持っています。
ただし、猫の数が増えると組み合わせの数が爆発的に増えるため、実行時間が長くなる可能性があります。
より効率的なアルゴリズムを検討する必要があるかもしれません。
'''

# B043 ねずみ小僧
# utf-8
# 町の大きさを入力
H, W = map(int, input().split())

# ねずみ小僧の初期位置を入力
h0, w0 = map(int, input().split())

# 町の各家の状態を入力
houses = [list(input().strip()) for _ in range(H)]

# ねずみ小僧の初期設定
axis = 1  # 初期方向は北を示す
num = 1  # 移動回数の初期値
x, y = h0 - 1, w0 - 1  # 座標の初期値（0-indexedに変換）

# ねずみ小僧の移動ループ
while num <= 2000 and 0 <= x < H and 0 <= y < W:
    num += 1
    
    # 現在の座標の家の状態に応じて行動を決定
    if houses[x][y] == '.':  # 庶民の家の場合
        houses[x][y] = '*'  # 富豪の家に変更
        if axis == 1:  # 北を向いている場合
            axis = 2  # 東に方向転換
            y += 1
        elif axis == 2:  # 東を向いている場合
            axis = 3  # 南に方向転換
            x += 1
        elif axis == 3:  # 南を向いている場合
            axis = 4  # 西に方向転換
            y -= 1
        elif axis == 4:  # 西を向いている場合
            axis = 1  # 北に方向転換
            x -= 1
    else:  # 富豪の家の場合
        houses[x][y] = '.'  # 庶民の家に変更
        if axis == 1:  # 北を向いている場合
            axis = 4  # 西に方向転換
            y -= 1
        elif axis == 2:  # 東を向いている場合
            axis = 1  # 北に方向転換
            x -= 1
        elif axis == 3:  # 南を向いている場合
            axis = 2  # 東に方向転換
            y += 1
        elif axis == 4:  # 西を向いている場合
            axis = 3  # 南に方向転換
            x += 1

# 町の最終状態を出力
for row in houses:
    print("".join(row))
'''
最初の部分では、入力値を受け取り、必要な変数を初期化しています。

hとwには町の大きさが格納されます。
xとyにはねずみ小僧の初期位置が格納されます。
sは町の状態を表す二次元リストです。
axisはねずみ小僧の向いている方向を表す変数で、初期値は1です（北を意味します）。
numはねずみ小僧の移動回数を表す変数で、初期値は1です。
xとyは座標のインデックスとして使用されるため、1から0始まりのインデックスに変換しています。

while文からはねずみ小僧の移動ループです。ループは以下の条件を満たす間、繰り返されます:

numが2000以下であり、ねずみ小僧が町の範囲内にいること。
xが0以上h未満、yが0以上w未満であること。
ループ内の処理は次のようになっています:

s[x][y]が'.'（庶民の家）の場合、その家を'*'（富豪の家）に変えます。
ねずみ小僧の向き(axis)に応じて、座標を更新します。向きが1の場合、y座標を増やし、向きが2の場合、x座標を増やします。向きが3の場合、y座標を減らし、向きが4の場合、x座標を減らします。
s[x][y]が'*'（富豪の家）の場合、その家を'.'（庶民の家）に変えます。
ねずみ小僧の向き(axis)に応じて、座標を更新します。向きが1の場合、y座標を減らし、向きが2の場合、x座標を減らします。向きが3の場合、y座標を増やし、向きが4の場合、x座標を増やします。
移動が終了すると、ねずみ小僧が通過した後の町の状態が得られます。

最後の部分では、町の状態を出力しています。二次元リストsの各行を文字列に変換し、改行なしで出力します。
'''

# B044 爆弾ゲーム
# utf-8
def is_enemy_defeated(H, W, board):
    # 盤面の初期化と敵の数のカウント
    num_enemies = 0
    for row in board:
        num_enemies += row.count('X')

    # 爆弾が爆発した際の敵の倒れる範囲を計算する関数
    def explode_bomb(r, c, power):
        nonlocal num_enemies
        if power == 0:
            return
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            for i in range(1, power + 1):
                nr, nc = r + i * dr, c + i * dc
                if 0 <= nr < H and 0 <= nc < W:
                    if board[nr][nc] == 'X':
                        num_enemies -= 1
                        board[nr][nc] = '.'
                    elif board[nr][nc] == '#':
                        break
                else:
                    break

    # 盤面の爆弾を探索し、爆発させる
    for r in range(H):
        for c in range(W):
            if board[r][c].isnumeric():
                power = int(board[r][c])
                explode_bomb(r, c, power)

    # 全ての爆弾が爆発した後に敵が残っているか判定
    if num_enemies == 0:
        return "YES"
    else:
        return "NO"


# 入力の読み込み
H, W = map(int, input().split())
board = []

# 盤面の読み込みと周囲を壁で囲む
board.append(['#'] * (W + 2))
for _ in range(H):
    row = list(input().strip())
    row.insert(0, '#')
    row.append('#')
    board.append(row)
board.append(['#'] * (W + 2))

# 判定結果の出力
result = is_enemy_defeated(H, W, board)
print(result)
'''
まず、is_enemy_defeated 関数を定義します。この関数は盤面の縦幅 H、横幅 W、および盤面の情報 board を受け取ります。
関数内部では、敵の数をカウントするための変数 num_enemies を初期化します。そして、board 内の各行を走査し、'X' の出現回数を数えて num_enemies に加算します。
次に、explode_bomb 関数を定義します。この関数は爆弾の位置と火力を受け取り、爆発した際の敵の倒れる範囲を計算します。
関数内部では、爆発の方向を表すベクトル (dr, dc) を定義し、それを用いて爆発範囲を走査します。具体的には、爆発の中心から 1 から power までの距離を順に増やしながら、範囲内にあるマスをチェックします。
マスが範囲内にあり、敵 'X' であれば num_enemies を減算し、そのマスを '.' (空マス) に変更します。マスが壁 '#' であれば、それ以上の範囲へは進めず、ループを抜けます。
最後に、全ての爆弾が爆発した後に敵が残っているかを判定します。num_enemies の値が 0 であれば、全ての敵が倒されたことを意味し、"YES" を返します。そうでなければ、残っている敵がいることを意味し、"NO" を返します。
メインの処理の後、盤面の情報を受け取ります。入力の読み込み部分では、最初に盤面の縦幅 H と横幅 W を読み込みます。そして、次に盤面の情報を board に格納していきます。
board の各行を読み込む際に、行の前後に壁 '#' を追加して、盤面の周囲を壁で囲むようにします。
最後に、is_enemy_defeated 関数を呼び出して判定結果を得て、それを出力します。
以上が修正版のプログラムの解説です。このプログラムは、与えられた盤面の全ての爆弾を同時に爆発させた際に敵が全滅するかどうかを判定します。
'''

# B045 計算ドリル
# utf-8
import random

# 入力を取得し、足し算の問題数と引き算の問題数を設定する
setting = input()
set_data = setting.split()
plus = int(set_data[0])
minus = int(set_data[1])

problems = []  # 問題を格納するリスト

# 足し算の問題を生成
while len(problems) < plus:
    left = random.randint(0, 99)  # 0から99までのランダムな左辺を生成
    right = random.randint(0, 99 - left)  # 左辺以下の範囲でランダムな右辺を生成
    problem = f"{left} + {right} ="  # 問題文を作成
    if problem not in problems:  # 重複しない問題文の場合にリストに追加
        problems.append(problem)

# 引き算の問題を生成
while len(problems) < plus + minus:
    left = random.randint(0, 99)  # 0から99までのランダムな被減数を生成
    right = random.randint(0, left)  # 被減数以下の範囲でランダムな減数を生成
    problem = f"{left} - {right} ="  # 問題文を作成
    if problem not in problems:  # 重複しない問題文の場合にリストに追加
        problems.append(problem)

random.shuffle(problems)  # 問題の順序をランダムにシャッフル

# 問題を出力
for problem in problems:
    print(problem)
'''
このコードでは、random モジュールを使用してランダムな数値を生成しています。足し算の問題を生成する際には、0から99までのランダムな左辺と、左辺以下の範囲でランダムな右辺を生成し、問題文を作成しています。
同様に、引き算の問題を生成する際には、0から99までのランダムな被減数と、被減数以下の範囲でランダムな減数を生成して問題文を作成しています。
問題文の重複を防ぐため、生成した問題文が既にリストに存在するかをチェックしています。存在しない場合にのみリストに追加されます。
最後に、random.shuffle() 関数を使用して問題の順序をランダムにシャッフルしています。最終的に生成された問題は、for ループを使用して一つずつ出力されます。
このコードによって、与えられた条件を満たし、効率的かつランダムな問題のドリルが生成されます。
'''

# B046 街の距離
# utf-8
import math

class B046:
    def __init__(self, rounds):
        # 同心円の数
        self.rounds = int(rounds)
        # 現在位置の同心円番号
        self.now_around = None
        # 現在位置の方角
        self.now_direction = None
        # 目的地の同心円番号
        self.purpose_around = None
        # 目的地の方角
        self.purpose_direction = None
        # 最短距離
        self.distance = None

    def set_now_position_info(self, info):
        # 現在位置の同心円番号と方角を設定
        self.now_around, self.now_direction = info.split()

    def set_purpose_position_info(self, info):
        # 目的地の同心円番号と方角を設定
        self.purpose_around, self.purpose_direction = info.split()

    def calculation_shortest_distance(self):
        # 方向の組み合わせパターン
        check_direction = self.now_direction + self.purpose_direction
        one_line_direction = ["NS", "SN", "WE", "EW", "NN", "SS", "WW", "EE"]

        if check_direction in one_line_direction:
            if self.now_direction == self.purpose_direction:
                # 同じ直線上にいる場合は、直線距離のみ
                self.distance = abs(int(self.now_around) - int(self.purpose_around)) * 100
            else:
                # 直線上にいる場合は、同心円同士の距離を加算
                self.distance = (int(self.now_around) + int(self.purpose_around)) * 100
        else:
            if int(self.now_around) < int(self.purpose_around):
                # 短い方向に半周し、直線距離を加算
                self.distance = abs(int(self.now_around) - int(self.purpose_around)) * 100 + math.pi * 100 * int(self.now_around) / 2
            elif int(self.now_around) > int(self.purpose_around):
                # 短い方向に半周し、直線距離を加算
                self.distance = abs(int(self.now_around) - int(self.purpose_around)) * 100 + math.pi * 100 * int(self.purpose_around) / 2
            else:
                # 同心円上の同じ位置にいる場合は、半周距離のみ
                self.distance = math.pi * 100 * int(self.purpose_around) / 2

        return self.distance

N = input().strip()  # 同心円の数を入力
B046 = B046(N)  # B046クラスのインスタンスを生成
B046.set_now_position_info(input().strip())  # 現在位置情報を入力
B046.set_purpose_position_info(input().strip())  # 目的地情報を入力
B046.calculation_shortest_distance()  # 最短距離を計算
print("{:.9f}".format(B046.distance))  # 最短距離を表示
'''
このコードは、同心円状の道路が配置された環境で、現在位置と目的地の情報から最短距離を計算しています。
B046 クラスは、最短距離の計算と情報の設定を行うためのメソッドを提供します。インスタンス化された B046 オブジェクトを使用して、現在位置情報と目的地情報を設定し、最短距離を計算します。
set_now_position_info メソッドは、現在位置情報を設定します。文字列として渡された情報を分割して、現在の同心円位置と方角を設定します。
set_purpose_position_info メソッドは、目的地情報を設定します。文字列として渡された情報を分割して、目的地の同心円位置と方角を設定します。
calculation_shortest_distance メソッドは、現在位置と目的地から最短距離を計算します。まず、現在位置と目的地の方角の組み合わせをチェックし、直線上に位置する場合と曲線上に位置する場合で処理を分岐します。最短距離を計算して distance 属性に代入します。
メインの処理部分では、入力から同心円の数、現在位置情報、目的地情報を受け取り、B046 クラスのインスタンスを生成し、必要な情報を設定します。最後に最短距離を計算して表示します。
'''

# B047 ホームポジション
# utf-8
def check_habit(key_input):
    result_habit = 0
    keyboard = [['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'],
                ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', '0'],
                ['z', 'x', 'c', 'v', 'b', 'n', 'm', '0', '0', '0']]

    def check_true_key(char):
        # タイプするキーが左手のキーか右手のキーかをチェックする関数
        # 右手のキーなら1、左手のキーなら2を返す
        for i in range(3):
            for j in range(5, 10):
                if char == keyboard[i][j]:
                    return 1  # 右手のキー
        return 2  # 左手のキー

    def check_near(cur_get, post_get):
        """
        タイプするキーが直前に打ったキーの隣接するキーかをチェックする関数

        Args:
            cur_get (str): タイプするキー
            post_get (str): 直前に打ったキー

        Returns:
            bool: タイプするキーが直前に打ったキーの隣接するキーならTrue、そうでなければFalseを返す
        """
        x, y = -1, -1
        for i in range(len(keyboard)):
            for j in range(len(keyboard[0])):
                if keyboard[i][j] == cur_get:
                    x, y = i, j
                    break
            if x > -1 or y > -1:
                break

        if x > 0:
            if keyboard[x - 1][y] == post_get:
                return True
        if x + 1 < len(keyboard):
            if keyboard[x + 1][y] == post_get:
                return True
        if y > 0:
            if keyboard[x][y - 1] == post_get:
                return True
        if y + 1 < len(keyboard[0]):
            if keyboard[x][y + 1] == post_get:
                return True
        if keyboard[x][y] == post_get:
            return True

        return False

    check = 0
    prev_key = '0'

    for cur_key in key_input:
        if check == 1:  # 左手
            if check_near(cur_key, prev_key):
                if check_true_key(cur_key) == 1:  # 右手のキー
                    result_habit += 1
            else:
                check = 0
        elif check == 2:  # 右手
            if check_near(cur_key, prev_key):
                if check_true_key(cur_key) == 2:  # 左手のキー
                    result_habit += 1
            else:
                check = 0
        elif prev_key != '0':
            if (cur_key == 'y' and prev_key == 't') or \
               (cur_key == 'h' and prev_key == 'g') or \
               (cur_key == 'n' and prev_key == 'b'):
                result_habit += 1
                check = 1  # 左手
            elif (cur_key == 't' and prev_key == 'y') or \
                 (cur_key == 'g' and prev_key == 'h') or \
                 (cur_key == 'b' and prev_key == 'n'):
                result_habit += 1
                check = 2  # 右手
        prev_key = cur_key

    return result_habit


if __name__ == "__main__":
    key_input = input().strip()

    result = check_habit(key_input)
    print(result)
'''
関数 check_habit の定義と、キーボードの配置を表す二次元リスト keyboard の初期化を行っています。
関数 check_true_key は、与えられたキーが左手のキーか右手のキーかを判定する関数です。キーボードの配置を参照し、右手のキーなら1を、左手のキーなら2を返します。
関数 check_near は、与えられたキーが直前に打ったキーの隣接するキーかを判定する関数です。キーボードの配置を参照し、タイプするキーが直前に打ったキーの隣接するキーなら True を、そうでなければ False を返します。
メインの処理は、与えられた文字列 key_input を順番に処理しながら、タイピングの癖によって違う手でタイプする回数を数える部分です。

変数 check は、現在どの手でタイピングしているかを表します。0 は初期状態（どちらの手でもない）を表します。
変数 prev_key は、直前に打ったキーを保持します。初期値は '0' としています。
文字列 key_input の各文字に対してループを実行します。
check の値に応じて、適切な手でキーをタイプしているか判定します。
check が 1 の場合は左手でタイピングしている状態を表し、check_near 関数を使って隣接するキーかどうかをチェックします。
もし隣接するキーであり、かつ check_true_key 関数が右手のキーを示す場合、癖によって違う手でタイプしていると判断し、result_habit をインクリメントします。
check が 2 の場合は右手でタイピングしている状態を表し、同様の判定を行います。
check の値が 0 の場合は、直前のキーとの組み合わせによる手の切り替えの可能性を判定します。
最後に、処理が終わった後の result_habit の値を返しています。
メインの処理の下に、キーボード入力を受け取り、check_habit 関数を呼び出して結果を表示する部分を記述します。
'''

# B048 理想のビンゴ
# utf-8
N, M = map(int, input().split())
bingo_card = []  # ビンゴカードの盤面を格納するリスト
bingo_count = 0  # ビンゴ数をカウントする変数

# ビンゴカードの盤面を入力として受け取り、リストに格納する
for _ in range(N):
    row = list(map(int, input().split()))
    bingo_card.append(row)

# M-1回の数字の呼び出しを処理する
for _ in range(M - 1):
    called_number = int(input())
    for i in range(N):
        for j in range(N):
            if called_number == bingo_card[i][j]:
                bingo_card[i][j] = 0  # 呼び出された数字を0に置き換える

# 行のビンゴをチェック
for i in range(N):
    if bingo_card[i].count(0) == N:
        bingo_count += 1

columns = []  # 列ごとの数字を格納するリスト
for i in range(N):
    column = []
    for j in range(N):
        column.append(bingo_card[j][i])
    columns.append(column)
    if column.count(0) == N:
        bingo_count += 1

diagonal = []  # 対角線の数字を格納するリスト
for i in range(N):
    diagonal.append(bingo_card[i][i])

reverse_diagonal = []  # 逆対角線の数字を格納するリスト
for i in range(1, N + 1):
    reverse_diagonal.append(bingo_card[-i][i - 1])

lines = [diagonal, reverse_diagonal]  # 対角線と逆対角線をまとめたリスト

# 対角線と逆対角線のビンゴをチェック
for line in lines:
    if line.count(0) == N:
        bingo_count += 1

extra_numbers = []  # ビンゴの候補となる数字を格納するリスト

# ビンゴの候補となる数字を抽出
for i in range(N):
    if bingo_card[i].count(0) == N - 1:
        for j in range(N):
            if bingo_card[i][j] != 0:
                extra_numbers.append(bingo_card[i][j])

for i in range(N):
    if columns[i].count(0) == N - 1:
        for j in range(N):
            if columns[i][j] != 0:
                extra_numbers.append(columns[i][j])

for line in lines:
    if line.count(0) == N - 1:
        for j in range(N):
            if line[j] != 0:
                extra_numbers.append(line[j])

frequency = []  # ビンゴの候補数字の出現回数を格納するリスト

# ビンゴの候補数字の出現回数を計算し、最大のビンゴ数を更新
if len(extra_numbers) > 0:
    for i in range(len(extra_numbers)):
        frequency.append(extra_numbers.count(extra_numbers[i]))
    bingo_count += max(frequency)

print(bingo_count)  # 最大のビンゴ数を出力
'''
入力の受け取りと初期化:
N, M = map(int, input().split()): ビンゴカードのサイズと呼び出し回数を受け取ります。
bingo_card = []: ビンゴカードの盤面を格納するための空のリストを作成します。
bingo_count = 0: ビンゴ数をカウントする変数を初期化します。

ビンゴカードの入力と数字の呼び出し処理:
for _ in range(N): ...: ビンゴカードの盤面を入力として受け取り、リスト bingo_card に格納します。
for _ in range(M - 1): ...: 呼び出された数字を処理し、ビンゴカード上の該当する数字を0に置き換えます。

行・列・対角線のビンゴをチェック:
行のビンゴをチェックし、ビンゴ数をカウントします。
列ごとの数字を格納するリスト columns を作成し、列のビンゴをチェックし、ビンゴ数をカウントします。
対角線と逆対角線の数字を格納するリスト diagonal と reverse_diagonal を作成し、対角線と逆対角線のビンゴをチェックし、ビンゴ数をカウントします。

追加のビンゴの候補数字を抽出:
ビンゴの候補となる数字を格納するリスト extra_numbers を作成し、行・列・対角線・逆対角線のビンゴの候補数字を抽出します。

追加のビンゴ数の計算:
ビンゴの候補数字が存在する場合、その出現回数を計算し、最大のビンゴ数を更新します。

結果の出力:
最大のビンゴ数を出力します。
このコードでは、ビンゴカードの盤面と呼び出された数字を処理し、行・列・対角線・逆対角線のビンゴをチェックして最大のビンゴ数を求めるアルゴリズムが実装されています。ビンゴ数の計算は、ビンゴの候補数字が存在する場合にのみ行われます。最終的な結果は、最大のビンゴ数が出力されます。
'''

# B049 ◆
# B050 有効なチケット
# utf-8
# 入力の受け取りと制約のチェック
N = int(input())  # チケットの枚数
if not 1 <= N <= 100:
    raise ValueError("Nの値が制約を満たしていません")

S = input()  # 暗号チケットの指定された文字列
if not 1 <= len(S) <= 10 or not S.islower():
    raise ValueError("Sの値が制約を満たしていません")

valid_tickets = []
for _ in range(N):
    T = input()  # チケットに書かれた文字列
    if not 1 <= len(T) <= 20 or not T.islower():
        raise ValueError("Tの値が制約を満たしていません")
    
    if S in T:  # SがTに含まれる場合は有効
        valid_tickets.append("valid")
    elif any(S in T[:i] + T[i+1:] for i in range(len(T))):  # Tから1文字を削除してSが含まれる場合は有効
        valid_tickets.append("valid")
    else:  # 上記の条件に該当しない場合は無効
        valid_tickets.append("invalid")

# 有効/無効なチケットを出力
for ticket in valid_tickets:
    print(ticket)
'''
入力の受け取りと制約のチェック

N = int(input()): チケットの枚数を整数として受け取ります。
S = input(): 暗号チケットの指定された文字列を受け取ります。
制約を満たしていない場合は、ValueErrorを発生させます。
有効なチケットの判定

valid_tickets = []: 有効なチケットを格納するリストを初期化します。
for _ in range(N):: チケットの枚数分だけループを行います。
T = input(): チケットに書かれた文字列を受け取ります。
if S in T:: もし指定された文字列 S がチケット文字列 T に含まれる場合は、有効なチケットとして判定します。
elif any(S in T[:i] + T[i+1:] for i in range(len(T))):: それ以外の場合、チケット文字列 T から1文字ずつ削除した文字列に指定された文字列 S が含まれるかどうかを判定します。任意のインデックス i に対して、T[:i] + T[i+1:] で T の i 番目の文字を削除した文字列が得られます。
valid_tickets.append("valid"): 上記のいずれかの条件に該当する場合は、有効なチケットとしてリストに追加します。
else: valid_tickets.append("invalid"): 上記の条件に該当しない場合は、無効なチケットとしてリストに追加します。
有効/無効なチケットの出力

for ticket in valid_tickets: print(ticket): 有効/無効なチケットのリストを出力します。
'''
--------------------------------------------- B051　※欠番 ◆
# B051 ◆
# B052 積もる粒子
# utf-8
def simulate_landscape(H, W, N, particles):
    landscape = [[0] * W for _ in range(H)]
    
    def is_valid_position(x, y):
        return 0 <= x < W and 0 <= y < H
    
    def get_lowest_neighbor(x, y):
        lowest_height = landscape[y][x]
        lowest_position = (x, y)
        
        # Check north neighbor
        if is_valid_position(x, y - 1) and landscape[y - 1][x] < lowest_height:
            lowest_height = landscape[y - 1][x]
            lowest_position = (x, y - 1)
        
        # Check east neighbor
        if is_valid_position(x + 1, y) and landscape[y][x + 1] < lowest_height:
            lowest_height = landscape[y][x + 1]
            lowest_position = (x + 1, y)
        
        # Check south neighbor
        if is_valid_position(x, y + 1) and landscape[y + 1][x] < lowest_height:
            lowest_height = landscape[y + 1][x]
            lowest_position = (x, y + 1)
        
        # Check west neighbor
        if is_valid_position(x - 1, y) and landscape[y][x - 1] < lowest_height:
            lowest_height = landscape[y][x - 1]
            lowest_position = (x - 1, y)
        
        return lowest_position
    
    for x, y in particles:
        while True:
            lowest_neighbor = get_lowest_neighbor(x, y)
            if lowest_neighbor == (x, y):
                landscape[y][x] += 1
                break
            else:
                x, y = lowest_neighbor
    
    return landscape

# 入力を受け取る
H, W, N = map(int, input().split())
particles = []
for _ in range(N):
    x, y = map(int, input().split())
    particles.append((x - 1, y - 1))  # 座標を0-indexedに変換

# 地形をシミュレーションして結果を出力
result = simulate_landscape(H, W, N, particles)
for row in result:
    print(" ".join(map(str, row)))
'''
simulate_landscape 関数は、地形をシミュレーションし、最終的な地形を表す二次元リスト landscape を作成します。初期状態では全ての要素が 0 で初期化されます。
is_valid_position 関数は、指定された座標がマップ内に存在するかどうかを判定します。x が 0 以上 W 未満であり、y が 0 以上 H 未満であれば有効な座標と判定します。
get_lowest_neighbor 関数は、指定された座標 (x, y) の隣接地点のうち、最も低い高さを持つ地点を求めます。まず、(x, y) の高さを lowest_height として初期化し、(x, y) 自体を lowest_position に設定します。その後、順番に北、東、南、西の順で隣接地点をチェックし、最も低い高さを持つ地点が見つかれば lowest_height と lowest_position を更新します。
メインの処理部分では、各粒子に対してシミュレーションを行います。粒子の座標 (x, y) を受け取り、隣接地点のうち最も低い地点を lowest_neighbor として取得します。もし lowest_neighbor が (x, y) 自体であれば、その地点に粒子が固定されるため、landscape[y][x] の高さを 1 増やしてループを抜けます。そうでなければ、lowest_neighbor の座標を新たな (x, y) として更新し、再度隣接地点をチェックします。
最後に、関数から最終的な地形の状態を表す二次元リスト landscape を返します。
メイン部分では、入力を受け取り、粒子の座標をリスト particles に格納しています。その後、simulate_landscape 関数を呼び出し、結果を出力します。
このコードは、指定された条件に基づいて地形をシミュレーションするためのものです。入力例に対して実行すると、最終的な地形の状態が出力されます。
'''

# B053 表の自動作成
# utf-8
import numpy as np

# 行数と列数を入力から取得
H, W = input().rstrip().split(' ')

# 表を格納するためのnumpy配列を作成し、初期値を0で初期化
table = np.zeros((2, int(W)))

# オートフィルを適用する必要がある残りの行数と列数を計算
row_left = int(H) - 2
col_left = int(W) - 2

# 2行目から始まる各行について、入力を受け取り、オートフィルを適用して行を完成させる
for h in range(2):
    retu = input().rstrip().split(' ')
    retu = np.array(retu)
    retu = retu.astype(np.int64)
    
    # 行の初項と公差を計算
    sa = retu[1] - retu[0]
    
    # オートフィルを適用して行を完成させる
    for i in range(int(W) - col_left, int(W)):
        retu = np.append(retu, retu[i - 1] + sa)
    
    # 行を表に格納
    table[h, :] = retu

# 2行目以降の行について、前の行との差からオートフィルを適用して行を完成させる
div = table[1] - table[0]
for j in range(int(H) - row_left, int(H)):
    table = np.vstack([table, table[j - 1] + div])

# 最終的な表をリスト形式に変換し、各要素をスペース区切りで出力
table = list(table)
for i in range(int(H)):
    for j in range(int(W)):
        if j == int(W) - 1:
            print(int(table[i][j]), end='')
        else:
            print(int(table[i][j]), end=' ')
    print()
'''
最初に、入力から表のサイズである行数と列数を取得します。表を格納するためのnumpy配列を作成し、初期値として全ての要素を0で初期化します。
行数と列数から、オートフィルを適用する必要がある残りの行数と列数を計算します。2行目から始まる各行について、入力を受け取り、その数列の初項と公差を計算します。そして、オートフィルを適用して行を完成させます。
2行目以降の行について、前の行との差からオートフィルを適用して行を完成させます。最終的な表をリスト形式に変換し、各要素をスペース区切りで出力します。
'''

# B054 不思議な足し算
# utf-8
# 入力の読み込み
s1, s2 = input().split()
s1 = list(s1)
s2 = list(s2)

# 文字列を数値に変換
for i in range(len(s1)):
    if s1[i] == "A":
        s1[i] = '0'
    elif s1[i] == "B":
        s1[i] = '1'
    elif s1[i] == "C":
        s1[i] = "2"
    elif s1[i] == "D":
        s1[i] = "3"
    else:
        s1[i] = "4"

for i in range(len(s2)):
    if s2[i] == "A":
        s2[i] = '0'
    elif s2[i] == "B":
        s2[i] = '1'
    elif s2[i] == "C":
        s2[i] = "2"
    elif s2[i] == "D":
        s2[i] = "3"
    else:
        s2[i] = "4"

# 数値に変換
s1 = int(''.join(map(str, s1)))
s2 = int(''.join(map(str, s2)))

# 5進数から10進数への変換と足し算
ss1 = int(str(s1), 5)
ss2 = int(str(s2), 5)
b = ss1 + ss2

# 10進数から5進数への変換
def base5int(value):
    if int(value / 5):
        return base5int(int(value / 5)) + str(value % 5)
    return str(value % 5)

d = base5int(b)
d = list(d)

# 数値を文字列に変換
for i in range(len(d)):
    if d[i] == "0":
        d[i] = 'A'
    elif d[i] == "1":
        d[i] = 'B'
    elif d[i] == "2":
        d[i] = "C"
    elif d[i] == "3":
        d[i] = "D"
    else:
        d[i] = "E"

# 結果の出力
print(''.join(map(str, d)))
'''
入力文字列 s1 と s2 をスペースで分割して読み込みます。その後、文字列をリストに変換します。
文字列リスト内の各文字を適切な数値に変換します。"A" から "E" までの文字はそれぞれ "0" から "4" の数値に対応しています。
文字列リストを結合し、int() を使用して整数に変換します。それぞれの数値を 5 進数から 10 進数に変換し、足し合わせます。
base5int() 関数を使用して、10 進数の数値 b を 5 進数に逆変換します。変換後の数値をリストに変換し、最後に文字列リストを結合して PAIZA 表記の数値を得ます。最終結果を出力します。
'''

# B055 ◆
# B056 リズムゲームの分析
# utf-8
def check_sharp_pattern(N, sharp, v):
    # "#" のパターンが正しいかをチェックする関数
    # sharp 列目が "+" であり、他の列が "-" であるかを確認する
    for j in range(N):
        if v[j] != ('+' if sharp == j else '-'):
            return False
    return True

def calculate_max_combo(N, M, data):
    max_combo = 0
    prev = False
    prev_sharp = False
    combo = 0
    for i in range(M):
        d = list(data[i][0])  # 譜面データ
        p = list(data[i][1])  # プレイデータ

        sharp = -1
        for j in range(N):
            if d[j] == '#':
                sharp = j
                break

        if sharp >= 0:
            # "#" のパターンの場合
            if check_sharp_pattern(N, sharp, p):
                if prev:
                    combo += 1
                elif not prev_sharp:
                    combo = 1
                    prev = True
                if max_combo < combo:
                    max_combo = combo
            else:
                prev = False
            prev_sharp = True
        else:
            # "#" のパターンでない場合
            if d == p:
                if prev:
                    combo += 1
                else:
                    combo = 1
                    prev = True
                if max_combo < combo:
                    max_combo = combo
            else:
                prev = False
            prev_sharp = False

    return max_combo

# 入力の読み込み
N, M = map(int, input().split())
data = []
for _ in range(M):
    line = input().split()
    data.append((line[0], line[1]))

# 最大コンボ数の計算
max_combo = calculate_max_combo(N, M, data)

# 結果の出力
print(max_combo)
'''
check_sharp_pattern 関数
sharp 列目が "+" であり、他の列が "-" であるかを確認する関数です。
引数としてボタンの数 N、sharp 列目のインデックス、譜面データのリスト v を受け取ります。
v の各要素をチェックし、sharp 列目の要素が "+" であり、他の列の要素が "-" であるかを確認します。
正しいパターンであれば True を、そうでなければ False を返します。

calculate_max_combo 関数
最大コンボ数を計算する関数です。
引数としてボタンの数 N、タイミングの数 M、ログデータのリスト data を受け取ります。
変数 max_combo に最大コンボ数を格納するための初期値 0 を設定します。
変数 prev は直前のタイミングでコンボが続いているかを示すフラグで、初期値は False です。
変数 prev_sharp は直前のタイミングで "#" のパターンが出現したかを示すフラグで、初期値も False です。
ループを通じて各タイミングを処理し、最大コンボ数を更新していきます。
data の各要素に対して、譜面データとプレイデータを取得します。
譜面データに "#" が含まれるかを確認し、含まれる場合と含まれない場合で処理を分岐します。
"#" のパターンの場合は、check_sharp_pattern 関数を用いて正しいパターンであるかをチェックします。
正しいパターンであればコンボ数を更新し、最大コンボ数を更新します。
"#" のパターンでない場合は、譜面データとプレイデータを比較し、一致していればコンボ数を更新し、最大コンボ数を更新します。
各タイミングの処理が終わったら最大コンボ数を返します。

入力の読み込み
最初にボタンの数 N とタイミングの数 M を入力から読み込みます。
その後、M 行分のループを行い、ログデータを読み込みます。
calculate_max_combo 関数の呼び出しと結果の出力
calculate_max_combo 関数を呼び出し、ボタンの数 N、タイミングの数 M、ログデータのリストを渡します。
返された最大コンボ数を出力します。
'''

# B057 回転寿司
# utf-8
def round_ring(ring):
    # 寿司の位置リストを一つ回転させる関数
    return [ring[-1]] + ring[:-1]

def eat(sushi_ring, eating_map, n):
    # 指定された位置の客が寿司を食べるかどうかを判定する関数
    if eating_map[n] > 0:
        # まだ寿司を食べ終えていない場合、残りの時間を1秒減らす
        eating_map[n] -= 1
    elif sushi_ring[n] == 1:
        # 寿司が存在しており、まだ食べていない場合、寿司を取り、食べるまでの時間を10秒に設定する
        eating_map[n] = 10 - 1
        sushi_ring[n] = 0
        
    return sushi_ring, eating_map

# 入力を受け取る
round_time, customer_num, sushi_num = map(int, input().split())
customer_pos = list(map(int, input().split()))
sushi_pos = list(map(int, input().split()))

# 各客の座席位置を表すリストを作成する
customer_ring = [1 if i in customer_pos else 0 for i in range(round_time)]
# 寿司の位置を表すリストを作成する
sushi_ring = [1 if i in sushi_pos else 0 for i in range(round_time)]

# 各客が寿司を食べるかどうかの情報を保持するリスト
eating_map = [0] * round_time

time = 0
while sum(sushi_ring) > 0 or sum(eating_map) > 0:
    # 各客の位置をチェックし、寿司を食べるかどうかを判定する
    for n in customer_pos:
        sushi_ring, eating_map = eat(sushi_ring, eating_map, n) 
    # 寿司の位置を一周させる
    sushi_ring = round_ring(sushi_ring)
    time += 1

# 全ての寿司が完食されるまでの時間を出力する
print(time)
'''
このプログラムは、与えられた入力に基づいて回転寿司店の状況をシミュレートし、全ての寿司が完食されるまでの時間を計算します。
まず、与えられた入力を解析します。round_time はレーンの一周にかかる時間であり、customer_num は客席の数、sushi_num は時刻0における寿司の数を表しています。また、customer_pos は各客の座席位置を、sushi_pos は時刻0における各寿司の位置を表しています。
次に、客のいる席と寿司の位置を表すリストを作成します。customer_ring リストは、客がいる位置には1を、それ以外の位置には0を持つリストです。sushi_ring リストも同様に、寿司がある位置には1を、それ以外の位置には0を持つリストです。
次に、各客が寿司を食べるかどうかを判定します。eating_map リストは、各位置に対して寿司を食べるまでの残り時間を保持するリストです。初期値として、全ての位置の残り時間を0に設定します。
そして、ループを開始して寿司の流れをシミュレートします。ループの条件は、まだ流れている寿司が存在するか、または誰かがまだ寿司を食べている場合にループを継続します。
各客の位置に対して、eat() 関数を呼び出して寿司を食べるかどうかを判定します。eat() 関数は、指定された位置 n の客が寿司を食べるかどうかを判定します。もし eating_map[n] が0より大きい場合、その客はまだ寿司を食べ終えていないため、残りの時間を1秒減らします。それ以外の場合、寿司が存在しており、まだ食べていないため、寿司を取り、食べるまでの時間を10秒に設定します。
ループの最後で、寿司の位置を一周させるために round_ring() 関数を呼び出します。
round_ring() 関数は、寿司の位置リストを一つ回転させます。最後に、ループが終了したときの時間を出力します。これにより、全ての寿司が完食されるまでの時間が表示されます。
'''

# B058 ◆
# B059 占領区域
# utf-8
def calculate_occupation(H, W, N, countries):
    # マップの初期化
    map = [['?' for _ in range(W)] for _ in range(H)]

    # 各国の占領区域を計算
    for i in range(N):
        a, x, y = countries[i]
        x, y = x - 1, y - 1  # 座標を0-indexedに変換
        map[y][x] = a

    # 各土地からの最短距離を計算し、占領国を更新
    for y in range(H):
        for x in range(W):
            if map[y][x] != '?':
                continue
            min_distance = float('inf')
            occupying_country = ''
            for i in range(N):
                a, cx, cy = countries[i]
                cx, cy = cx - 1, cy - 1  # 座標を0-indexedに変換
                distance = abs(cx - x) + abs(cy - y)
                if distance < min_distance:
                    min_distance = distance
                    occupying_country = a
                elif distance == min_distance:
                    occupying_country = '?'  # 距離が同じ場合は境界上の土地
            map[y][x] = occupying_country

    # 結果の出力
    for row in map:
        print(''.join(row))


# 入力の読み込み
H, W, N = map(int, input().split())
countries = []
for _ in range(N):
    # 各国の情報を読み込む
    a, x, y = input().split()
    countries.append((a, int(x), int(y)))

# 占領区域の計算と出力
calculate_occupation(H, W, N, countries)
'''
このプログラムは、ストラテジーゲームのマップ上で各国の占領している区域を計算し、表示するためのものです。
calculate_occupation 関数を定義します。この関数は、マップの高さ H、幅 W、国の数 N、各国の情報 countries を受け取り、占領区域を計算します。
マップの初期化を行います。map という二次元リストを作成し、マップの全ての要素を '?' で初期化します。
各国の占領区域を計算します。countries リストに格納された各国の情報を取り出し、座標を0-indexedに変換してマップ上の対応する位置に占領国の頭文字をセットします。
各土地からの最短距離を計算し、占領国を更新します。マップ上の各土地について、まだ占領国がセットされていない土地に対して、各国の首都との距離を計算します。
最も距離が近い国を占領国として設定し、距離が同じ場合は境界上の土地として '?' をセットします。
最終的な占領区域を出力します。マップの各行を連結して表示し、各土地がどの国に占領されているかを表示します。
メインの処理として、入力を読み込んでマップの情報を取得し、calculate_occupation 関数を呼び出して占領区域の計算と表示を行います。
'''

# B060 サイコロころがし
# utf-8
N, H, W = list(map(int, input().split()))  # 入力値を取得
sy, sx = list(map(int, input().split()))  # 初期位置を取得
s = input()  # 移動方法を取得
ij = [[0 for i in range(W)] for j in range(H)]  # 旗のマス目の初期化

class Roll:
    def __init__(self, sx, sy):
        self.sx, self.sy, self.stamp, self.u, self.d, self.l, self.r, self.t = sx, sy, 6, 2, 5, 3, 4, 1
    '''
        # サイコロの初期位置と面の初期値を設定する
    self.sx, self.sy = sx, sy  # サイコロの現在位置のx座標とy座標
    self.stamp = 6  # サイコロの現在の面の値
    self.u = 2  # サイコロの上面の値
    self.d = 5  # サイコロの下面の値
    self.l = 3  # サイコロの左面の値
    self.r = 4  # サイコロの右面の値
    self.t = 1  # サイコロの手前面の値
    '''

    def up(self):
        self.sy -= 1
        tmp = self.t
        self.t = self.d
        self.d = self.stamp
        self.stamp = self.u
        self.u = tmp
        return self.stamp

    def down(self):
        self.sy += 1
        tmp = self.t
        self.t = self.u
        self.u = self.stamp
        self.stamp = self.d
        self.d = tmp
        return self.stamp

    def left(self):
        self.sx -= 1
        tmp = self.t
        self.t = self.r
        self.r = self.stamp
        self.stamp = self.l
        self.l = tmp
        return self.stamp

    def right(self):
        self.sx += 1
        tmp = self.t
        self.t = self.l
        self.l = self.stamp
        self.stamp = self.r
        self.r = tmp
        return self.stamp

dice = Roll(sx, sy)  # サイコロを作成し初期位置を設定
ij[sy - 1][sx - 1] = dice.stamp  # 初期位置のマスにサイコロの目の値を設定
for i in s:
    if i == 'U':
        ij[dice.sy - 1][dice.sx - 1] = dice.up()  # 上方向に移動し、そのマスにサイコロの目の値を設定
    if i == 'D':
        ij[dice.sy - 1][dice.sx - 1] = dice.down()  # 下方向に移動し、そのマスにサイコロの目の値を設定
    if i == 'L':
        ij[dice.sy - 1][dice.sx - 1] = dice.left()  # 左方向に移動し、そのマスにサイコロの目の値を設定
    if i == 'R':
        ij[dice.sy - 1][dice.sx - 1] = dice.right()  # 右方向に移動し、そのマスにサイコロの目の値を設定

# 旗のマス目を出力
for i in ij:
    rs = [str(n) for n in i]
    print(" ".join(rs))
'''
まず、入力から回転する回数N、旗のマス目の縦の大きさH、旗のマス目の横の大きさWが取得されます。また、最初にサイコロを置く位置の行syと列sxも取得されます。
その後、文字列sが取得され、これはサイコロの移動方法を表しています。具体的には、"U"は上方向、"D"は下方向、"L"は左方向、"R"は右方向の移動を示します。
次に、H行W列の二次元リストijが作成されます。このリストは、旗の各マスの色を表します。初期状態ではすべてのマスが0（白色）で初期化されます。
そして、Rollクラスが定義されます。このクラスはサイコロの動作を管理します。サイコロの現在位置と各面の値を保持します。
クラスには、上方向への移動を表すupメソッド、下方向への移動を表すdownメソッド、左方向への移動を表すleftメソッド、右方向への移動を表すrightメソッドが定義されています。
これらのメソッドは、サイコロの位置と面の値を適切に変更し、移動後の面の値を返します。
Rollクラスのインスタンスdiceが作成され、初期位置であるsy行sx列のマスにサイコロの面の値（stamp）が設定されます。
その後、文字列sを順に処理し、各移動に応じてサイコロを移動させます。移動方法に従ってサイコロの位置と面の値が変更され、ijリストの対応するマスに面の値が記録されます。
最後に、ijリストの各行を順に出力します。各行はスペースで区切られた数字のシーケンスとなり、それぞれの数字は旗の各マスの色を表します。この出力によって、シミュレーション後の旗のデザインが表示されます。
'''
--------------------------------------------- B061　※欠番 ◆
# B061 福袋詰め
# utf-8
import itertools

def count_lucky_bags(S, N, values):
    '''
    福袋に詰める商品の組み合わせの数を計算する関数

    Parameters:
        S (int): 福袋に詰める商品の価値の合計の最小値
        N (int): 福袋に詰める候補となる商品の数
        values (list): 商品の価値を表す整数のリスト

    Returns:
        int: 福袋に詰める商品の組み合わせの数
    '''
    count = 0
    # 商品の個数で組み合わせを生成
    for i in range(1, N+1):
        for combination in itertools.combinations(values, i):
            # 組み合わせの値の合計がS以上であるかを確認
            if sum(combination) >= S:
                valid = True
                for j in combination:
                    # 商品を1つ取り除いた場合の値の合計がS未満であるかを確認
                    if sum(combination) - j >= S:
                        valid = False
                        break
                if valid:
                    count += 1

    return count

# 入力の受け取り
S = int(input())
N = int(input())
values = [int(input()) for _ in range(N)]

# 福袋の詰め方の組み合わせの数を計算
result = count_lucky_bags(S, N, values)

# 結果の出力
print(result)
'''
福袋に詰める商品の組み合わせの数を計算するための関数 count_lucky_bags が定義されています。
この関数は、以下の手順で組み合わせの数を計算します。
count_lucky_bags 関数の引数として、福袋に詰める商品の価値の合計の最小値 S、福袋に詰める候補となる商品の数 N、および商品の価値を表す整数のリスト values が与えられます。
初期化: 組み合わせの数をカウントするための変数 count を0で初期化します。
商品の個数ごとの組み合わせ生成: for ループを使用して、商品の個数ごとに組み合わせを生成します。range(1, N+1) の範囲でループし、1つからN個の商品を含む組み合わせを生成します。
組み合わせの条件判定: itertools.combinations を使用して、与えられた商品リスト values から i 個の商品を選んだ組み合わせを生成します。生成された組み合わせの値の合計が S 以上であるかを確認します。
条件を満たす組み合わせの特定: 組み合わせの値の合計が S 以上の場合、さらに個別の商品を1つずつ取り除いた場合の組み合わせの値の合計が S 未満であるかを確認します。この確認を行い、条件を満たす組み合わせを特定します。
条件を満たす組み合わせのカウント: 条件を満たす組み合わせが特定された場合、カウンター変数 count をインクリメントします。
結果の返却: ループが終了したら、最終的な count の値を返します。
コードの最後では、入力の受け取り、count_lucky_bags 関数の呼び出し、結果の出力が行われています。
'''

# B062 部屋掃除ロボット
# utf-8
N = int(input())  # 掃除する時間
H, W = map(int, input().split())  # 部屋の縦と横のマスの数

s = []  # 部屋の状態を格納するリスト
for _ in range(H):
    s.append(input())  # 部屋の各行の状態をリストに追加

h, w = 0, 0  # ロボットの現在位置 (初期位置は左上)
d = 0  # 掃除したマスの数
c = 'right'  # ロボットの進行方向

for _ in range(N):
    if c == 'right':
        if s[h][w] == '#':  # 現在位置が汚れている場合
            d += 1  # マスを掃除する
        s[h] = s[h][:w] + '*' + s[h][w+1:]  # マスの状態を掃除済みに更新
        if w < W-1 and s[h][w+1] != '*':  # 右に進める場合
            w += 1  # 右に進む
        elif h < H-1 and s[h+1][w] != '*':  # 下に進める場合
            c = 'down'  # 進行方向を変更して下に進む
            h += 1
        else:
            break  # 進める方向がない場合は終了
    elif c == 'down':
        # 以下同様の処理をコメント追加しながら繰り返す
        if s[h][w] == '#':
            d += 1
        s[h] = s[h][:w] + '*' + s[h][w+1:]
        if h < H-1 and s[h+1][w] != '*':
            h += 1
        elif w > 0 and s[h][w-1] != '*':
            c = 'left'
            w -= 1
        else:
            break
    elif c == 'left':
        if s[h][w] == '#':
            d += 1
        s[h] = s[h][:w] + '*' + s[h][w+1:]
        if w > 0 and s[h][w-1] != '*':
            w -= 1
        elif h > 0 and s[h-1][w] != '*':
            c = 'up'
            h -= 1
        else:
            break
    elif c == 'up':
        if s[h][w] == '#':
            d += 1
        s[h] = s[h][:w] + '*' + s[h][w+1:]
        if h > 0 and s[h-1][w] != '*':
            h -= 1
        elif w < W-1 and s[h][w+1] != '*':
            c = 'right'
            w += 1
        else:
            break

print(d)  # 掃除したマスの数を出力
'''
掃除ロボットが指定された時間内に部屋のマスを掃除する機能を実装しています。
最初に、入力から掃除する時間を表す整数 N、部屋の縦と横のマスの数を表す整数 H と W を受け取ります。次に、部屋の状態を示す文字列を入力として受け取り、それをリスト s に格納します。
掃除ロボットの初期位置は部屋の左上のマスであり、ロボットの現在位置を h と w の変数で追跡します。また、掃除したマスの数を表す変数 d を初期化し、ロボットの進行方向を表す変数 c を初期値 'right' で設定します。
次に、指定された時間 N の回数だけ以下の処理を繰り返します。
まず、現在の進行方向が 'right' の場合を考えます。現在位置が汚れている場合、d をインクリメントしてマスを掃除します。その後、現在位置を掃除済みに更新します。次に、右に進むことができる場合は w をインクリメントします。もし右に進めない場合は、下に進むことができるかを確認し、できる場合は進行方向を 'down' に変更して h をインクリメントします。右にも下にも進めない場合は、掃除を終了します。
同様の手順で、進行方向が 'down'、'left'、'up' の場合についても処理を行います。進行方向ごとに、現在位置が汚れている場合は d をインクリメントし、現在位置を掃除済みに更新します。進行方向に応じて次のマスに進むかを判断し、進める場合は位置を更新します。進めない場合は、掃除を終了します。
最後に、掃除したマスの数 d を出力します。
'''

# B063 支払う枚数とお釣りの枚数
# utf-8
# 支払いとお釣りに使う硬貨の合計枚数を計算する関数
def coin_count(pay):
    coins = [500, 100, 50, 10, 5, 1]
    coin_count = 0
    while pay:
        for coin in coins:
            coin_count += pay // coin  # 硬貨の枚数を加算
            pay -= pay // coin * coin  # 支払った金額を引く
    return coin_count

price = int(input())

# 最小の支払いとお釣りの枚数を保持する変数
min_pay = 21

# 各硬貨の枚数の組み合わせをループで試す
for y500 in range(3):
    for y100 in range(5):
        for y50 in range(2):
            for y10 in range(5):
                for y5 in range(2):
                    for y1 in range(5):
                        pay = y500 * 500 + y100 * 100 + y50 * 50 + y10 * 10 + y5 * 5 + y1 * 1
                        if pay >= price:  # 支払い金額が与えられた金額以上である場合のみ計算
                            pay_count = y500 + y100 + y50 + y10 + y5 + y1
                            charge_count = coin_count(pay - price)
                            min_pay = min(pay_count + charge_count, min_pay)  # 最小枚数を更新

print(min_pay)
'''
支払いとお釣りに使用する硬貨の合計枚数を最小化するための方法を求めるものです。
まず、coin_count関数は、与えられた金額を支払うために必要な硬貨の合計枚数を計算します。この関数では、与えられた金額を大きい硬貨から順に割り算していき、必要な枚数を加算します。その後、支払いに使用した硬貨の額を引いていきます。この操作を繰り返すことで、最小の硬貨枚数を計算します。
メインのプログラムでは、与えられた金額を支払うための硬貨の組み合わせをすべて試します。各硬貨の枚数をループで変化させながら、金額を計算します。ただし、支払い金額が与えられた金額以上である場合にのみ計算を行います。
計算した支払いとお釣りの硬貨の合計枚数を、現在の最小枚数と比較し、より小さい場合は最小枚数を更新します。
最後に、最小枚数を出力します。
'''

# B064 うずを探せ
# utf-8
import copy

H, W = map(int, input().split())
s = [list(input()) for _ in range(H)]

# 入力値のバリデーションチェック
if not (1 <= H <= 10) or not (1 <= W <= 10):
    print("縦と横のサイズは1以上10以下である必要があります。")
    exit()

for row in s:
    if len(row) != W or any(direction not in "RLUD" for direction in row):
        print("入力が正しくありません。各行は長さWの文字列で、R, L, U, Dのみが使用できます。")
        exit()

x, y, ans = 0, 0, 0
s1 = copy.deepcopy(s)

for h in range(H):
    for w in range(W):
        ss = s[h][w]
        if ss == '*':
            continue
        s[h][w] = '*'
        # スタート地点の範囲チェック
        if (h == 0 and ss == 'U') or (w == 0 and ss == 'L') or (h == H-1 and ss == 'D') or (w == W-1 and ss == 'R'):
            continue
        x = h
        y = w
        for i in range(H * W):
            # 移動先の座標の範囲チェック
            if not (0 <= x < H) or not (0 <= y < W):
                break
            if ss == 'U':
                x -= 1
            elif ss == 'L':
                y -= 1
            elif ss == 'D':
                x += 1
            elif ss == 'R':
                y += 1
            ss = s[x][y]
            s[x][y] = '*'
            if x == h and y == w:
                ans += 1
                s1 = copy.deepcopy(s)
                break
            if ss == '*':
                s = copy.deepcopy(s1)
                break

print(ans)
'''
与えられた天気図のグリッド上で渦の個数を求める
最初に、入力された縦幅と横幅を取得します。また、天気図の状態を表す文字列のリスト s を作成します。
入力値のバリデーションチェックを行います。縦幅と横幅が1以上10以下であること、および各行が長さWの文字列であり、文字は'R', 'L', 'U', 'D'のいずれかであることを確認します。
変数 x, y, ans を初期化します。x, y は現在の位置を表す変数で、ans は渦の個数を数えるための変数です。
天気図の状態を保持するリスト s1 を作成します。このリストは、渦の探索中に一時的な変更を保持するために使用されます。
全てのマスを順番に探索します。二重のループを使用し、各マスについて以下の処理を行います。
マスの風向きを取得し、変数 ss に代入します。
もしマスがすでに探索済みであればスキップし、探索を続けます。
マスを探索済みとしてマークします。
スタート地点の範囲チェックを行い、範囲外であればスキップし、次のマスへ移動します。
スタート地点を設定し、渦の探索を開始します。
一周するまで渦を辿り、マスを探索済みとしてマークします。一周した場合は、渦の個数 ans をインクリメントし、s1 を現在の天気図の状態に更新します。
一周せずにすでに探索済みのマスに到達した場合、探索を終了します。
最終的な渦の個数 ans を出力します。
'''

# B065 小さなライフゲーム
# utf-8
def mass_change(left, right):
    # マスの左右の組み合わせに応じてキーを返す
    left_right = left + right
    if left_right == "--":
        return 0  # 左右が "-" の場合、キーは0
    elif left_right == "-+":
        return 1  # 左が "-" で右が "+" の場合、キーは1
    elif left_right == "+-":
        return 2  # 左が "+" で右が "-" の場合、キーは2
    elif left_right == "++":
        return 3  # 左右が "+" の場合、キーは3

def mass_game(mass_arr, rule_arr):
    # マスゲームの実行
    result_arr = []
    for i in range(10):
        if i == 0:
            left = mass_arr[9]  # 左隣のマスの値
            right = mass_arr[i + 1]  # 右隣のマスの値
        elif i == 9:
            left = mass_arr[i - 1]  # 左隣のマスの値
            right = mass_arr[0]  # 右隣のマスの値
        else:
            left = mass_arr[i - 1]  # 左隣のマスの値
            right = mass_arr[i + 1]  # 右隣のマスの値

        key = mass_change(left, right)  # マスの左右の組み合わせに応じてキーを取得
        ans = rule_arr[key]  # キーに対応するルールを取得
        result_arr.append(ans)  # 結果を配列に追加

    return result_arr

# 入力の読み込み
S, T = input().split()
mass_arr = list(S)  # 初期盤面のマス配列
rule_arr = list(T)  # 更新ルールの配列
result_arr = mass_arr  # マスゲームの結果の配列
ans = "NO"  # 初期値はNO

# マス配列、ルール配列を1024回ループしてゲームを実行
for _ in range(1024):
    result_arr = mass_game(result_arr, rule_arr)
    if result_arr == mass_arr:
        ans = "YES"  # 初期盤面に戻った場合はYESとする
        break

# 結果の出力
print(ans)
'''
与えられた初期盤面と更新ルールに基づいてミニライフゲームを実行し、初期盤面に戻るかどうかを判定するプログラムです。
まず、入力から初期盤面の文字列 S と更新ルールの文字列 T を読み込みます。それぞれをマス配列 mass_arr とルール配列 rule_arr に変換します。
また、マスゲームの結果を保持するための配列 result_arr を初期盤面と同じに設定します。そして、初期値として判定結果の文字列 ans を "NO" とします。
次に、1024回のループを実行します。ループ内では、mass_game 関数を使用してマスゲームの結果を計算し、結果を result_arr に更新します。その後、result_arr が初期盤面と一致するかを確認します。
一致した場合は、ans を "YES" に変更し、ループを抜けます。
最後に、最終的な判定結果を出力します。

関数 mass_change は、与えられた左隣と右隣のマスの値に応じて、適切なキーを返します。
キーは以下のように対応しています：
左右が "-" の場合はキーが0
左が "-" で右が "+" の場合はキーが1
左が "+" で右が "-" の場合はキーが2
左右が "+" の場合はキーが3
関数 mass_game は、与えられたマス配列とルール配列に基づいてマスゲームの結果を計算します。
各マスに対して、左隣と右隣のマスの値を取得し、mass_change 関数でキーを求めます。キーに対応するルールをルール配列から取得し、結果配列に追加します。最終的に結果配列を返します。
'''

# B066 色のパズル
# utf-8
import itertools
import copy

X, N, M = list(map(int, input().split()))
c, cc = [], []
p = [[] for i in range(X)]

# パズルの状態とピースの情報を入力
for i in range(N):
    c.append(list(input()))

for i in range(X):
    for j in range(M):
        p[i].append(list(input()))
    p[i] = sum(p[i], [])

# パズルのピースの配置を整形
nm = N // M  # パズルの一辺がピース何個分か
for i in range(nm ** 2):
    ccc = []
    for j in range(M):
        ccc.append(c[i // nm * M + j][i % nm * M:i % nm * M + M])
    cc.append(ccc)

pp = [[] for i in range(X)]
for i in range(X):
    for j in range(M):
        pp[i].append(p[i][j * M:j * M + M])

# 各ピースをチェック
for i in range(X):
    flag = False
    # ピースと完成図の合うものを探す
    for j in range(nm ** 2):
        if pp[i] == cc[j]:
            print(j // nm * M + 1, j % nm * M + 1, 0)  # 回転なしで合致した場合
            flag = True
            break
    # もし見つかったら、次のピースに移る
    if flag:
        continue
    # ピースの回転
    ppp = [[' ' for i in range(M)] for j in range(M)]
    p4 = pp[i]
    # ピースを最大3回転させる
    for n in range(3):
        for k in range(M):
            for m in range(M):
                ppp[m][M - 1 - k] = p4[k][m]
        # ピースを回転させた後、合うものを探している。
        for j in range(nm ** 2):
            if ppp == cc[j]:
                print(j // nm * M + 1, j % nm * M + 1, n + 1)  # 回転後に合致した場合
                flag = True
                break
        if flag:
            break
        p4 = copy.deepcopy(ppp)
    if not flag:
        print(-1)  # 合致するピースが見つからなかった場合
'''
このプログラムは、与えられたピースとパズルの状態から、パズルのピースを組み合わせて完成形を作り出すための解法を提供します。
最初に、itertoolsモジュールとcopyモジュールをインポートします。これらのモジュールは、組み合わせの生成とオブジェクトのコピーを行うために使用されます。
ピースの個数を表す整数X、パズルの大きさを表す整数N、ピースの大きさを表す整数Mを入力します。
パズルの状態を表すリストcとピースの情報を格納するリストpを初期化します。
パズルの状態を入力し、リストcに格納します。
各ピースの情報を入力し、リストpに格納します。また、ピースを1次元のリストに変換しています。
パズルのピースの配置を整形し、リストccに格納します。これにより、パズルの一辺がMマスのピース何個分かを正確に表現することができます。
ピースの情報を整形し、リストppに格納します。これにより、各ピースをM x Mの2次元リストとして表現することができます。
各ピースを順番にチェックします。
ピースと完成図の合致を探し、見つかった場合はその位置と回転回数を出力します。合致するピースが見つかった場合、flagフラグを立ててループを抜けます。
もし合致するピースが見つからなかった場合、ピースを最大3回転させながら再度合致を探します。
合致するピースが見つかった場合は、その位置と回転回数を出力し、flagフラグを立ててループを抜けます。
もし合致するピースが見つからなかった場合、-1を出力します。
'''

# B067 タスクの管理
# utf-8
schelde_input = []
N = 0
while not (1 <= N <= 100):
    N = int(input())  # タスクの数を入力

condition_ness_day = []  # タスクの必要日数を格納するリスト
condition_start_day = []  # タスクの開始日を格納するリスト
condition_end_day = []  # タスクの終了日を格納するリスト

# タスクの入力を受け取り、条件を満たすものをリストに追加する
for _ in range(N):
    i_n = input().split(' ')
    i_n = list(map(int, i_n))
    if (i_n[2] >= i_n[1]) and (i_n[0] <= (i_n[2] - i_n[1] + 1)):
        schelde_input.append(i_n)

is_check = True

# 各タスクの必要日数、開始日、終了日をリストに分割して格納する
for n in schelde_input:
    condition_ness_day.append(n[0])
    condition_start_day.append(n[1])
    condition_end_day.append(n[2])

# タスクを終了日までに完了できるか判定する
if sum(condition_ness_day) <= (max(condition_end_day) - min(condition_start_day) + 1):
    if (condition_start_day[-1] + sum(condition_ness_day) <= condition_end_day[-1]):
        is_check = True
    else:
        is_check = False
else:
    is_check = False

# 結果を出力する
if is_check:
    print("YES")
else:
    print("NO")
'''
タスクの数と各タスクの情報を入力として受け取り、それらの条件を満たすかどうかを判定します。
最初に、タスクの数を入力します。この値は1以上100以下でなければなりません。
次に、タスクの数だけタスクの情報を入力します。各タスクの情報は必要日数、開始日、終了日の順で半角スペース区切りで与えられます。
入力されたタスクの情報が条件を満たすかどうかを判定します。条件は以下の通りです。
タスクの開始日が終了日以下であること
タスクの必要日数が終了日 - 開始日 + 1以下であること
全てのタスクの情報が条件を満たす場合、タスクを終了日までに完了できるかどうかを判定します。
タスクの必要日数の合計が、最後のタスクの終了日 - 最初のタスクの開始日 + 1以下であること
タスクの開始日と必要日数の合計が最後のタスクの終了日以下であること
最終的な結果を出力します。タスクを終了日までに完了できる場合は「YES」を、できない場合は「NO」を出力します。
'''

# B068 チョコの分割
# utf-8
def check(allSugarList):
    """
    与えられたチョコレートの糖度リストが条件1を満たすかをチェックする関数

    Parameters:
        allSugarList (list): チョコレートの糖度リスト

    Returns:
        bool: 条件1を満たす場合はTrue、そうでない場合はFalse
    """
    result = []
    for i in allSugarList:
        if sum(i) % 2 == 0:
            result.append(True)
        else:
            result.append(False)

    if False in result:
        return False
    else:
        return True


def check2(allSugarList):
    """
    与えられたチョコレートの糖度リストが条件2を満たすかをチェックする関数

    Parameters:
        allSugarList (list): チョコレートの糖度リスト

    Returns:
        bool: 条件2を満たす場合はTrue、そうでない場合はFalse
    """
    result = []
    for i in allSugarList:
        if sum(i) % 2 == 0:
            wa = 0
            for j in i:
                wa += j
                if wa == sum(i) // 2:
                    result.append(True)
        if True not in result:
            result.append(False)
    if False in result:
        return False
    else:
        return True


# チョコレートの行数と列数を取得
h, w = map(int, input().split())
allSugarList = []

# チョコレートのかけらの糖度を入力し、リストに追加
for i in range(h):
    result = []
    sugarList = list(map(int, input().split()))
    allSugarList.append(sugarList)

# 2つの条件を満たすかをチェックし、結果に応じて出力
if check(allSugarList) and check2(allSugarList):
    print("Yes")
    for i in allSugarList:
        result = []
        wa = sum(i) // 2
        for j in range(w):
            if wa != 0:
                wa -= i[j]
                result.append("A")
            else:
                result.append("B")
        print("".join(result))
else:
    print("No")
'''
まず、check関数は、与えられたチョコレートの糖度リストが条件1を満たすかどうかをチェックする関数です。
条件1は、「それぞれの行ごとに、アリスとボブが得る糖度の和が等しくなるようにチョコを分ける」というものです。check関数は、糖度リストの各行の糖度の和が偶数であればTrueを、奇数であればFalseを返します。
次に、check2関数は、与えられたチョコレートの糖度リストが条件2を満たすかどうかをチェックする関数です。条件2は、「それぞれの行ごとに、左端から連続したかけらをアリスがもらい、残りはボブがもらう」というものです。
check2関数は、糖度リストの各行に対して、左端から順にかけらの糖度を足していき、アリスがもらうかけらの糖度の和がその行の糖度の和の半分になるかどうかをチェックします。
条件を満たす場合はTrueを、満たさない場合はFalseを返します。
メインの処理部分では、まずチョコレートの行数と列数を入力として受け取ります。その後、糖度リストを入力として受け取り、allSugarListに格納します。
次に、check関数とcheck2関数を使って、与えられたチョコレートが2つの条件を満たすかどうかを判定します。条件を満たす場合は"Yes"を出力し、各行に対してアリスとボブがもらうかけらを割り当てます。
アリスがもらうかけらは左端から連続していき、残りはボブがもらうようにします。条件を満たさない場合は"No"を出力します。
'''
    
# B069 蟻の餌探し
# utf-8
import numpy as np
import sys

sys.setrecursionlimit(10**6)

def isPheromone(ant_map, y, x):
    # 指定された座標がフェロモンのある座標かどうかを判定
    if ant_map[y, x] != '#':
        return False
    else:
        return True

def isreachable(ant_map, search_map, feed_y, feed_x, H, W):
    # 目的地に到達可能かどうかを判定する再帰関数
    if (feed_y == 0) and (feed_x == 0):
        return True

    search_map[feed_y, feed_x] = True

    directions = [(feed_y - 1, feed_x), (feed_y, feed_x - 1), (feed_y + 1, feed_x), (feed_y, feed_x + 1)]
    for next_y, next_x in directions:
        # 次の座標が範囲外の場合はスキップ
        if (next_y < 0) or (next_x < 0) or (next_y >= H) or (next_x >= W):
            continue
        # すでに探索済みの場合はスキップ
        if search_map[next_y, next_x]:
            continue
        # フェロモンのある座標の場合、再帰的に探索を行う
        if isPheromone(ant_map, next_y, next_x):
            if isreachable(ant_map, search_map, next_y, next_x, H, W):
                return True

    return False

if __name__ == '__main__':
    H, W = map(int, input().rstrip().split())

    # 入力の制約条件のバリデーションチェック
    if H < 3 or H > 100 or W < 3 or W > 100:
        print('Invalid input: H and W should be between 3 and 100.')
        exit()

    ant_map = []
    for _ in range(H):
        s = input().rstrip()

        # 入力の制約条件のバリデーションチェック
        if len(s) != W or not all(ch == '.' or ch == '#' for ch in s):
            print('Invalid input: Each S_i should be a string of length W containing only "." or "#".')
            exit()

        ant_map.append(list(s))
    ant_map = np.array(ant_map)

    N = int(input())

    # 入力の制約条件のバリデーションチェック
    if N < 1 or N > 10:
        print('Invalid input: N should be between 1 and 10.')
        exit()

    feed_list = [list(map(int, input().split())) for _ in range(N)]

    # feed_list の各要素の範囲チェック
    for i in range(N):
        y, x = feed_list[i]
        if y < 1 or y > H or x < 1 or x > W:
            print('Invalid input: y_k and x_k should be between 1 and H, 1 and W respectively.')
            exit()

    cannot = False
    for i in range(N):
        # 餌の座標がフェロモンのある座標でない場合は到達不可能と判定
        if ant_map[feed_list[i][0] - 1, feed_list[i][1] - 1] != '#':
            cannot = True
            print('NO')
            break

        search_map = np.array([[False for _ in range(W)] for _ in range(H)])
        # 到達可能かどうかを判定
        if not isreachable(ant_map, search_map, feed_list[i][0] - 1, feed_list[i][1] - 1, H, W):
            cannot = True
            print('NO')
            break

    if not cannot:
        print('YES')
'''
まず、isPheromone関数は、指定された座標がフェロモンのある座標かどうかを判定します。ant_mapという2次元配列でアリの巣と餌の情報を保持しており、座標の値が'#'ならフェロモンがあることを意味し、それ以外ならフェロモンがないことを示します。
次に、isreachable関数は、再帰的な探索を行い、目的地までの到達可能性を判定します。feed_yとfeed_xは現在の座標を表します。関数内では、現在の座標が目的地に到達しているかを確認し、到達していればTrueを返します。
そうでなければ、現在の座標から上下左右の座標に移動し、再帰的に探索を行います。探索済みの座標はsearch_mapという2次元配列で管理され、Trueがセットされている座標は再度探索しないようになっています。
メインの処理部分では、まず入力からアリの巣と餌の情報を受け取り、制約条件のバリデーションチェックを行います。アリの巣と餌の情報はant_mapという2次元配列に格納されます。
次に、餌の数と座標のリストを受け取り、それぞれの座標が制約条件に適合しているかをチェックします。
その後、餌の座標がフェロモンのある座標でない場合や、餌からアリの巣まで到達できない場合にはNOを出力し、それ以外の場合はYESを出力します。
このように、制約条件のチェックや再帰的な探索を行いながら、アリが餌まで移動できるかどうかを判定するプログラムとなっています。
'''

# B070 駒の到達範囲
# utf-8
N, H, W, K = map(int, input().split())

# プロットの初期化
plot = [[0 for _ in range(N)] for _ in range(N)]

# 計算済みの結果を保持するための辞書
memo = {}

# 王を配置する関数
def King(h, w, k):
    plot[h - 1][w - 1] = 1  # 現在の位置に王を配置
    if h > 1:
        plot[h - 2][w - 1] = 1  # 現在の位置の上にクイーンを配置
        queen(h - 1, w, k - 1)  # 残りのクイーンを再帰的に配置
    if w > 1:
        plot[h - 1][w - 2] = 1  # 現在の位置の左にクイーンを配置
        queen(h, w - 1, k - 1)  # 残りのクイーンを再帰的に配置
    if w < N:
        plot[h - 1][w] = 1  # 現在の位置の右にクイーンを配置
        queen(h, w + 1, k - 1)  # 残りのクイーンを再帰的に配置
    if h < N:
        plot[h][w - 1] = 1  # 現在の位置の下にクイーンを配置
        queen(h + 1, w, k - 1)  # 残りのクイーンを再帰的に配置

# ビショップを配置する関数
def Bishop(h, w, k):
    num = 1
    while h - num >= 1 and w - num >= 1:
        plot[h - 1 - num][w - 1 - num] = 1  # 左上の斜めの位置にクイーンを配置
        queen(h - num, w - num, k - 1)  # 残りのクイーンを再帰的に配置
        num += 1
    num = 1
    while h - num >= 1 and w + num <= N:
        plot[h - 1 - num][w - 1 + num] = 1  # 右上の斜めの位置にクイーンを配置
        queen(h - num, w + num, k - 1)  # 残りのクイーンを再帰的に配置
        num += 1
    num = 1
    while h + num <= N and w - num >= 1:
        plot[h - 1 + num][w - 1 - num] = 1  # 左下の斜めの位置にクイーンを配置
        queen(h + num, w - num, k - 1)  # 残りのクイーンを再帰的に配置
        num += 1
    num = 1
    while h + num <= N and w + num <= N:
        plot[h - 1 + num][w - 1 + num] = 1  # 右下の斜めの位置にクイーンを配置
        queen(h + num, w + num, k - 1)  # 残りのクイーンを再帰的に配置
        num += 1

# クイーンを配置する関数
def queen(h, w, k):
    if k <= 0:
        return
    # memo 辞書から計算済みの結果を取得
    if (h, w, k) in memo:
        plot[h - 1][w - 1] = memo[(h, w, k)]
        return
    King(h, w, k)  # 指定された位置に王を配置
    Bishop(h, w, k)  # 指定された位置にビショップを配置
    # 計算結果を memo 辞書に保存
    memo[(h, w, k)] = plot[h - 1][w - 1]

# クイーンの配置を開始
queen(H, W, K)

# クイーンの数をカウント
ans = 0
for i in plot:
    ans += sum(i)

print(ans)
'''
与えられた問題に対してメモ化という最適化手法を適用しています。以下に、コードの解説を行います。
最初に、入力として与えられる変数 N, H, W, K を取得します。これらの変数は、クイーンの配置に関する情報を表しています。
plot という二次元リストを初期化します。このリストは、クイーンが配置される盤面を表現しています。初期状態では、全てのマスは 0 で初期化されています。
memo という空の辞書を初期化します。この辞書は、計算済みの結果を保持するために使用されます。
King 関数は、王を配置するための関数です。与えられた位置に王を配置し、その周囲にクイーンを再帰的に配置します。
Bishop 関数は、ビショップを配置するための関数です。与えられた位置から斜め方向にクイーンを配置し、その周囲にクイーンを再帰的に配置します。
queen 関数は、クイーンを配置するための関数です。与えられた位置に王とビショップを配置し、その周囲にクイーンを再帰的に配置します。また、メモ化を行うために memo 辞書を参照し、同じ引数の組み合わせが現れた場合には事前に計算済みの結果を取得します。
queen 関数を呼び出して、クイーンの配置を開始します。
最後に、配置されたクイーンの数をカウントして結果を出力します。
この改善版のコードでは、メモ化を用いることで、同じ引数の組み合わせに対する計算結果を再利用することができます。これにより、再計算を避けることができ、処理速度の改善が期待できます。
'''
--------------------------------------------- B071　※欠番 ◆
# B071 ダンベルトレーニング
# utf-8
import sys
from itertools import combinations

def main():
    input = sys.stdin.read
    data = input().strip().split()
    
    # おもりの数と目標重さを読み取る
    N = int(data[0])
    M = int(data[1])
    
    # 各おもりの重さをリストに格納する
    weights = list(map(int, data[2:2 + N]))

    closest_weight = 0

    # すべての可能な部分集合の組み合わせを試す
    for r in range(1, N + 1):
        for combo in combinations(weights, r):
            total_weight = sum(combo)
            # 合計重さが偶数の場合のみ検討
            if total_weight % 2 == 0:
                half_weight = total_weight // 2
                # 左右に分けて重さが等しくなるか確認
                if can_partition(combo, half_weight):
                    # 合計重さがM以下なら更新
                    if total_weight <= M:
                        closest_weight = max(closest_weight, total_weight)

    # 最も近い重さを出力
    print(closest_weight)

def can_partition(weights, target):
    # 動的計画法で部分和問題を解く
    dp = [False] * (target + 1)
    dp[0] = True  # 初期状態: 0kgは常に達成可能

    for weight in weights:
        # 現在の重さから逆順にチェック
        for j in range(target, weight - 1, -1):
            dp[j] = dp[j] or dp[j - weight]

    return dp[target]

if __name__ == "__main__":
    main()
'''
入力の読み取り:
標準入力からデータを読み取って、最初の2つの値をおもりの数 N と目標重さ M に、それ以降の値を各おもりの重さのリスト weights に格納します。
全ての部分集合の組み合わせを試す:
combinations を使って、おもりの全ての部分集合を生成します。
部分集合の合計重さ total_weight が偶数の場合にのみチェックします。
部分集合の重さが等しいか確認する:
can_partition 関数を使って、左右に分けて重さが等しくなるかを確認します。
M kg 以下で最もM kgに近い重量を見つける:
total_weight が M kg 以下であれば、closest_weight を更新します。
動的計画法による部分和問題の解決:
can_partition 関数では、動的計画法を用いて、与えられた部分集合が特定の重さに分割可能かどうかを確認します。
'''

# B072 反転スイッチ
# utf-8
def toggle_screen(screen_size, pattern_size, pattern, num_switches, switches):
    # 画面の初期化
    screen = [['_' for _ in range(screen_size[1])] for _ in range(screen_size[0])]

    # スイッチを押す回数だけ繰り返す
    for _ in range(num_switches):
        # パターンの行ごとに繰り返す
        for i in range(pattern_size[0]):
            # パターンの列ごとに繰り返す
            for j in range(pattern_size[1]):
                # 画面の範囲内かをチェック
                if 0 <= i < screen_size[0] and 0 <= j < screen_size[1]:
                    # パターンが '#' の場合は反転させる
                    if pattern[i][j] == '#':
                        # スイッチの座標を基準にして画面の状態を反転させる
                        screen[i + switches[_][1] - 1][j + switches[_][0] - 1] = '#' if screen[i + switches[_][1] - 1][j + switches[_][0] - 1] == '_' else '_'

    return screen

# 入力の読み込み
# 画面の縦の大きさ H、横の大きさ W
H, W = map(int, input().split())
# パターンの縦の大きさ N、横の大きさ M
N, M = map(int, input().split())

pattern = []
for _ in range(N):
    pattern.append(list(input()))
    
# スイッチを押す回数 Q
Q = int(input())
switches = []
# スイッチを押す回数だけ繰り返す
for _ in range(Q):
    # スイッチの対応するパターンの左上の x 座標 x_k、y 座標 y_k 
    switches.append(list(map(int, input().split())))

# 画面の状態を計算
result = toggle_screen((H, W), (N, M), pattern, Q, switches)

# 結果の出力
for row in result:
    print(''.join(row))
'''
toggle_screen 関数は、画面の状態を反転させる処理を行います。引数として、画面のサイズ screen_size、パターンのサイズ pattern_size、パターンの反転模様 pattern、スイッチの回数 num_switches、スイッチの座標情報 switches を受け取ります。
screen は二次元リストとして初期化され、画面のサイズに応じて全ての要素が '_'（白色）で埋められます。
スイッチを押す回数だけ繰り返すループがあります。各スイッチの回数に対して、以下の処理が行われます。
パターンの行ごとに繰り返すループがあります。
パターンの列ごとに繰り返すループがあります。
画面の範囲内かをチェックします。行番号 i と列番号 j が画面の範囲内にあるかを確認します。
パターンが '#' の場合は、スイッチの座標情報を基準にして画面の状態を反転させます。スイッチの座標情報 switches[_] の x 座標 switches[_][0] と y 座標 switches[_][1] を使用して、対応する画面上の座標を計算し、その位置の要素を反転させます。
toggle_screen 関数は最終的に、スイッチを押した後の画面の状態 screen を返します。
入力の読み込みが行われます。まず、画面の縦と横のサイズを H と W に読み込みます。
パターンの縦と横のサイズを N と M に読み込みます。
パターンの反転模様を読み込み、二次元リストとして pattern に格納します。
スイッチの回数を Q に読み込みます。
スイッチの座標情報を読み込み、リストとして switches に格納します。
toggle_screen 関数を呼び出し、最終的な画面の状態を result に格納します。
最終的な画面の状態を出力します。各行を結合して一つの文字列にし、それを行ごとに出力します。

これにより、与えられた入力に基づいてスイッチの押し操作をシミュレートし、最終的な画面の状態を出力するプログラムが実行されます。
'''

# B073 イルミネーションの調査
# utf-8　
"""
回答方針
(1) 各木に備えつけられた電球の数のリストを用意
(2) 調査区間毎の辞書を用意
(3) (2)を一つずつ取り出して、電球追加後の値に(1)を更新
(4) (3)を出力
"""

def is_valid_integer(value, lower, upper):
    return lower <= value <= upper

# NとMの入力チェック
N, average = map(int, input().split())
if not is_valid_integer(N, 1, 1000) or not is_valid_integer(average, 1, 100):
    print("Invalid input for N or M.")
    exit(1)

# 木の数と電球の数の入力チェック
areaArray = list(map(int, input().split()))
if len(areaArray) != N or not all(is_valid_integer(A, 1, 100) for A in areaArray):
    print("Invalid input for A_i.")
    exit(1)

# Qの入力チェック
Q = int(input())
if not is_valid_integer(Q, 1, 1000):
    print("Invalid input for Q.")
    exit(1)

researchArea = []
# 各調査区間の入力チェック
for _ in range(Q):
    S_i, E_i = map(int, input().split())
    if not (is_valid_integer(S_i, 1, N) and is_valid_integer(E_i, S_i, N)):
        print("Invalid input for S_i or E_i.")
        exit(1)
    research = {"start": S_i-1, "end": E_i-1, "range": (E_i - S_i) + 1}
    researchArea.append(research)

# (3) (2)を一つずつ取り出して、電球追加後の値に(1)を更新
# 手順
# 1. researchAreaのstart,endのリストを取り出して平均の電球の数の平均値を取得
# 2. average-1 をする。
# 3. 2.がマイナス値でない場合、区間の電球の数を追加
for research in researchArea:
    areas = areaArray[research["start"]: research["start"] + research["range"]]
    score = sum(areas) // research["range"]
    diff = average - score
    if diff > 0:
        for i in range(research["start"], research["end"] + 1):
            areaArray[i] += diff

# 回答結果を出力
print(" ".join(map(str, areaArray)))
'''
このコードは、与えられた並木道の情報と調査区間の情報に基づいて、電球の数を更新するプログラムです。以下でコードの概要を説明します。
まず、is_valid_integerという関数が定義されています。この関数は、ある値が指定された範囲内にあるかどうかを確認するために使用されます。
次に、NとMを入力として受け取ります。Nは並木道に並ぶ木の本数を表し、Mは区間の電球の平均個数が上回らなければならない数です。
これらの値が正しい範囲内にあるかどうかをチェックし、無効な入力の場合はエラーメッセージを表示してプログラムを終了します。
その後、並木道の情報を表す整数のリストareaArrayを入力として受け取ります。このリストは、各木にいくつの電球が装飾されているかを表します。
リストの長さがNであり、各要素が1から100の範囲内にあるかどうかを確認します。無効な入力の場合はエラーメッセージを表示してプログラムを終了します。
次に、電球の数を調べたい区間の数を表す整数Qを入力として受け取ります。Qは後続のQ行の入力を読み取るために使用されます。Qが1から1000の範囲内にあるかどうかを確認し、無効な入力の場合はエラーメッセージを表示してプログラムを終了します。
続いて、Q行の入力を処理します。各行には、電球の数を調べたい区間の始点と終点が半角スペースで区切られています。始点と終点が1からNの範囲内にあり、始点が終点以下であることを確認します。
無効な入力の場合はエラーメッセージを表示してプログラムを終了します。有効な入力の場合は、調査区間を表す辞書を作成し、リストresearchAreaに追加します。
これで入力処理が完了し、調査区間の情報を元に電球の数を更新します。各調査区間について、区間の木の数を取得し、その平均値を計算します。
平均値と指定された平均個数(M)との差分を計算し、正の値であれば区間の電球の数を更新します。
最後に、更新された電球の数をスペース区切りの文字列として出力します。
'''

# B074 コメントの順序
# utf-8
def calculate_comment_popularity(comment_id, comments):
    """
    特定のコメントの注目度を計算する関数
    """
    comment = comments[comment_id]
    likes = comment["likes"]
    replies = comment["replies"]

    popularity = likes
    for reply_id in replies:
        popularity += calculate_comment_popularity(reply_id, comments)

    return popularity


def find_most_popular_comment(comments):
    """
    最も注目度の高いコメントのIDを見つける関数
    """
    max_popularity = -1
    most_popular_comment_id = None

    for comment_id in comments:
        popularity = calculate_comment_popularity(comment_id, comments)
        if popularity > max_popularity or (popularity == max_popularity and comment_id < most_popular_comment_id):
            max_popularity = popularity
            most_popular_comment_id = comment_id

    return most_popular_comment_id


# 入力の読み込み
N = int(input())
comments = {}

for _ in range(N):
    comment_info = input().split()
    comment_id = int(comment_info[0])
    parent_id = comment_info[1]
    likes = int(comment_info[2])

    if parent_id == "None":
        parent_id = None
    else:
        parent_id = int(parent_id)

    comments[comment_id] = {
        "parent_id": parent_id,
        "likes": likes,
        "replies": []
    }

# 子コメントのリストを親コメントに追加する
for comment_id, comment in comments.items():
    parent_id = comment["parent_id"]
    if parent_id is not None:
        parent_comment = comments[parent_id]
        parent_comment["replies"].append(comment_id)

# 注目度の一番高いコメントのIDを求める
most_popular_comment_id = find_most_popular_comment(comments)

# 結果の出力
print(most_popular_comment_id)
'''
calculate_comment_popularity 関数は、特定のコメントの注目度を再帰的に計算するための関数です。与えられたコメントIDに対応するコメントの「いいね」数を取得し、それに対して返信コメントの注目度の合計を再帰的に計算して注目度を求めます。
find_most_popular_comment 関数は、与えられたコメントリストから最も注目度の高いコメントのIDを見つけるための関数です。各コメントの注目度を計算し、最大の注目度を持つコメントのIDを返します。注目度が同じ場合は、IDが最小のコメントを選択します。
入力を読み込み、コメント情報を辞書形式で保持します。コメントID、親コメントID、いいね数を取得し、コメント辞書に追加します。親コメントがある場合は、子コメントのリストを親コメントの辞書に追加します。
最も注目度の高いコメントのIDを求め、結果を出力します。
'''

# B075 商品の表示
# utf-8
def calculate_score(N, M, products):
    scores = []  # スコアを保持するリスト

    # スコア計算
    for i in range(N):
        score = 0
        ranks = []  # 各指標の順位を保持するリスト
        for j in range(M):
            rank = 1
            for k in range(N):
                if products[k][j] > products[i][j]:
                    rank += 1
            ranks.append(rank)
        for j in range(M):
            score += N - ranks[j] + 1
        scores.append((i + 1, score))  # 商品番号とスコアの組を追加

    # スコアの高い順にソート
    scores.sort(key=lambda x: x[1], reverse=True)

    # 結果の出力
    for score in scores:
        print(score[0])

# 入力の読み込み
N, M = map(int, input().split())  # 表示する商品の数を表す整数 N、商品の指標の数を表す整数 M
products = []
for _ in range(N):
    product = list(map(int, input().split()))  # i番目の商品の j 番目の指標の値
    products.append(product)

# スコア計算と結果の出力
calculate_score(N, M, products)
'''
calculate_scoreという関数を定義します。この関数は、商品のスコアを計算するための処理を行います。scoresという空のリストを用意して、スコアを保持します。
指定されたルールに基づいて、商品のスコアを計算します。まず、商品の数だけループします。内部のループでは、各指標ごとに順位を計算し、ranksリストに順位を追加します。次に、各指標の順位を使用してスコアを計算し、scoresリストに商品番号とスコアの組を追加します。
計算されたスコアを高い順にソートします。sortメソッドを使用して、スコアを基準にリストを降順に並び替えます。
ソートされたスコアを順番に取り出し、商品番号を出力します。入力値を読み込みます。
まず、map関数とsplitメソッドを使用して、商品の数を表す整数Nと商品の指標の数を表す整数Mを取得します。次に、商品の指標の値を入力として受け取り、それを二重リストとしてproductsリストに追加します。
calculate_score関数を呼び出して、スコアの計算と結果の出力を行います。
'''

# B076 パン屋さん
# utf-8
# N（パンの種類数）とQ（クエリの数）を読み込む
N, Q = map(int, input().split())

# NとQのバリデーションチェック
assert 1 <= N <= 30, "Nが無効です"
assert 1 <= Q <= 50, "Qが無効です"

# パンの価格と在庫数のリストを初期化する
prices = []  # パンの価格リスト
stock = []  # パンの在庫数リスト

# パンの価格と在庫数を読み込む
for _ in range(N):
    # 各パンの種類ごとに価格と在庫数を読み込む
    price, quantity = map(int, input().split())

    # 価格と在庫数のバリデーションチェック
    assert 1 <= price <= 500, "価格が無効です"
    assert 0 <= quantity <= 20, "在庫数が無効です"

    # 価格と在庫数をそれぞれのリストに追加する
    prices.append(price)
    stock.append(quantity)

# 結果のリストを初期化する
results = []

# クエリを処理する
for _ in range(Q):
    # クエリの種類とパンの個数を読み込む
    query, *quantities = input().split()

    # クエリの種類のバリデーションチェック
    assert query in ["bake", "buy"], "クエリの種類が無効です"

    # パンの個数を整数に変換する
    quantities = list(map(int, quantities))

    # パンの個数のバリデーションチェック
    assert all(0 <= q <= 1000 for q in quantities), "パンの個数が無効です"

    # "bake" クエリの処理
    if query == "bake":
        # 各パンの種類ごとに在庫数を増やす
        for i in range(N):
            stock[i] += quantities[i]

    # "buy" クエリの処理
    elif query == "buy":
        # 合計金額を初期化する
        total_cost = 0

        # 全てのパンを購入できるかを示すフラグを初期化する
        can_buy = True

        # 在庫の確認と合計金額の計算を行う
        for i in range(N):
            # 現在のパンの種類の在庫が購入個数に対して十分かチェックする
            if stock[i] >= quantities[i]:
                # 在庫数を減らし、金額を計算する
                stock[i] -= quantities[i]
                total_cost += prices[i] * quantities[i]
            else:
                # 在庫が不足している場合はフラグをFalseにする
                can_buy = False
                break

        # 結果を結果のリストに追加する
        if can_buy:
            results.append(total_cost)
        else:
            results.append(-1)

# 結果を出力する
for result in results:
    print(result)
'''
最初に、パンの種類数を表す整数 N とクエリの個数を表す整数 Q を入力します。このとき、N の値が 1 以上 30 以下であり、Q の値が 1 以上 50 以下であることをバリデーションチェックします。
パンの値段と在庫数を表す整数 a_i, b_i を N 回繰り返し入力します。各パラメータの値が以下の条件を満たしていることをバリデーションチェックします:
a_i の値が 1 以上 500 以下であること
b_i の値が 0 以上 20 以下であること
結果を格納するリスト results を初期化します。
クエリを Q 回繰り返し入力します。各クエリは以下の形式で与えられます:
"bake" クエリの場合: bake 0 c_{i, 1} c_{i, 2} ... c_{i, N}
"buy" クエリの場合: buy c_{i, 1} c_{i, 2} ... c_{i, N}
このとき、クエリの種類が "bake" または "buy" のいずれかであることをバリデーションチェックし、各パンの個数 c_{i, j} の値が 0 以上 1000 以下であることをバリデーションチェックします。
クエリの種類に応じて処理を行います:
"bake" クエリの場合: 各パンの在庫数を c_{i, j} だけ増やします。
"buy" クエリの場合: 各パンの在庫数と購入可能性をチェックし、在庫が足りる場合は購入に必要な合計金額を計算し、在庫数を減らします。在庫が足りない場合はエラーとして -1 を結果リストに追加します。
結果リストの値を順に出力します。
'''

# B077 チケットの売り場
# utf-8
# 入力の読み込み
N, M = map(int, input().split())
processing_times = []
for _ in range(N):
    t = int(input())
    if 1 <= t <= 1000:
        processing_times.append(t)
    else:
        print("処理時間の値は1以上1,000以下である必要があります。")
        exit()

# カウンターの数と人数の制約条件をチェック
if not (1 <= N <= 1000):
    print("カウンターの数は1以上1,000以下である必要があります。")
    exit()
if not (N <= M <= 10000):
    print("並んでいる人数はカウンターの数以上であり、10,000以下である必要があります。")
    exit()

# カウンターの処理時間でソート
processing_times.sort()

# カウンターの処理終了時刻を保持する配列
counters = [0] * N

# シミュレーションの実行
time = 0
for i in range(M):
    min_counter = 0
    for j in range(1, N):
        if counters[j] < counters[min_counter]:
            min_counter = j
    counters[min_counter] += processing_times[min_counter]
    time = max(time, counters[min_counter])

# 出力
print(time)
'''
最初に、入力の読み込みを行います。
NとMを半角スペース区切りで受け取り、それぞれカウンターの数と並んでいる人数を表します。
その後、N個の処理時間を入力として受け取り、processing_timesリストに格納します。
この際、各処理時間が1以上1,000以下の範囲に収まっているかどうかをバリデーションチェックします。
カウンターの数と人数の制約条件をチェックします。
Nが1以上1,000以下であるかをチェックします。そうでない場合、エラーメッセージを表示してプログラムを終了します。
MがN以上かつ10,000以下であるかをチェックします。そうでない場合、エラーメッセージを表示してプログラムを終了します。
カウンターの処理時間を昇順にソートします。
カウンターの処理終了時刻を保持するためのcountersリストを作成し、初期値を0に設定します。
シミュレーションを実行します。

M回のループで、順番に人がカウンターに並びます。
空いているカウンターの中で、最も早く処理が終わるカウンターを選びます。
選ばれたカウンターの処理終了時刻を更新します。
カウンターの処理終了時刻をもとに、全員がチケットを買い終わるまでの最終的な時間を計算します。
計算された時間を出力します。
'''

# B078 動画視聴スケジュール
# utf-8
def count_maximum_videos(N, videos):
    # 動画を終了時間でソート
    videos.sort(key=lambda x: x[0] + x[1])

    count = 1  # 視聴できる動画の数を初期化
    end_time = videos[0][0] + videos[0][1]  # 最初の動画の終了時間

    for i in range(1, N):
        start_time, duration = videos[i]

        # 前の動画の終了時間と次の動画の開始時間が被らない場合、視聴できる動画の数を増やす
        if end_time < start_time:
            count += 1
            end_time = start_time + duration

    return count

# 入力を受け取る
N = int(input())
videos = []
for _ in range(N):
    start_time, duration = map(int, input().split())
    videos.append((start_time, duration))

# 最大の動画数を求める
result = count_maximum_videos(N, videos)

# 結果を出力
print(result)
'''
このコードは、与えられた動画の情報を使って最大の視聴可能な動画数を計算するための関数 count_maximum_videos と、それを呼び出して結果を出力する部分から構成されています。
まず、関数 count_maximum_videos 内では以下の手順で最大の動画数を計算しています：
videos リストを動画の終了時間でソートします。これにより、視聴中の動画と次の動画との間に被りがないようになります。
count 変数を 1 で初期化し、最初の動画は必ず視聴できるとします。
end_time 変数には最初の動画の終了時間を格納します。これにより、次の動画の開始時間と比較することで、動画の被りがないかどうかを判定します。
for ループを使用して、2 番目の動画から最後の動画までの間で処理を行います。各動画に対して以下の処理を行います：
start_time 変数には現在の動画の開始時間を格納します。
duration 変数には現在の動画の長さを格納します。
end_time と start_time を比較して、動画の被りがないかどうかを判定します。もし被りがない場合、count をインクリメントし、end_time を次の動画の終了時間に更新します。
ループが終了した時点で、count の値が最大の視聴可能な動画数となります。
その後、与えられた入力を受け取り、動画の数 N と各動画の開始時間と長さを格納したリスト videos を作成します。
最後に、関数 count_maximum_videos を呼び出して最大の動画数を計算し、結果を出力します。
'''

# B079 相性チェック
# utf-8
def calculate_compatibility(name1, name2):
    # 1. 名前を小文字に変換し、アルファベットの数値に変換する
    nums1 = [ord(c) - ord('a') + 1 for c in name1]
    nums2 = [ord(c) - ord('a') + 1 for c in name2]

    # 2. 数列を作成する
    def create_sequence(nums):
        while len(nums) > 1:
            new_nums = []
            for i in range(len(nums) - 1):
                new_nums.append((nums[i] + nums[i+1]) % 101)
            nums = new_nums
            if nums[0] > 101:
                nums[0] -= 101
        return nums[0]

    # 3. 2通りの相性を計算し、大きい方を返す
    compatibility1 = create_sequence(nums1 + nums2)
    compatibility2 = create_sequence(nums2 + nums1)
    return max(compatibility1, compatibility2)

# 入力を受け取る
s, t = input().strip().split()

# 相性を計算する
compatibility = calculate_compatibility(s, t)

# 結果を出力
print(compatibility)
'''
calculate_compatibility関数は、2つの名前を受け取り、相性を計算します。
名前を小文字に変換し、アルファベットの数値に変換します。アルファベット"a"は1、"b"は2、...、"z"は26と対応付けられます。
数列を作成します。隣り合う2つの数を足し合わせて新しい数列を作成します。ただし、要素の値が101を超えた場合は101を引きます。この手順を繰り返し、数列の要素数が1になるまで行います。
2通りの相性を計算し、大きい方を返します。1つ目の名前を前にして計算する場合と、2つ目の名前を前にして計算する場合の2通りの相性を求め、大きい方の結果を採用します。
'''
# B080 みんなでスゴロク
# utf-8
class Player:
    c_award = 3
    goal_pos = 0
    
    def __init__(self, sugoroku, position=0, coin=0, award=0):
        """
        プレイヤーの初期化を行うメソッド
        
        Parameters:
            sugoroku (list): スゴロクの道の情報を格納したリスト
            position (int): プレイヤーの初期位置 (デフォルトは0)
            coin (int): プレイヤーの初期コイン数 (デフォルトは0)
            award (int): プレイヤーの初期受賞コイン数 (デフォルトは0)
        """
        self.sugoroku = sugoroku
        self.position = position
        self.coin = coin
        self.award = award
        Player.goal_pos = len(sugoroku) - 1
    
    def move(self, roll):
        """
        プレイヤーをサイコロの目の分だけ進めるメソッド
        
        Parameters:
            roll (int): サイコロの目の数
        """
        pos = max(min(self.position + roll, Player.goal_pos), 0)
        self.set_award(pos)
        self.position = pos
    
    def set_award(self, pos):
        """
        ゴールに到達した場合に受賞コインを設定するメソッド
        
        Parameters:
            pos (int): 現在の位置
        """
        if pos == Player.goal_pos and self.award == 0:
            self.award = Player.c_award
            Player.c_award = max(Player.c_award-1, 0)
    
    def get_award(self, roll):
        """
        受賞コインを得るメソッド
        
        Parameters:
            roll (int): サイコロの目の数
        """
        self.coin += self.award * roll
    
    def get_coin(self, amount):
        """
        コインを増減させるメソッド
        
        Parameters:
            amount (int): 増減するコインの数
        """
        self.coin = max(self.coin + amount, 0)


class Square:
    def __init__(self, extend=0, coin=0):
        """
        スゴロクのマスの情報を初期化するメソッド
        
        Parameters:
            extend (int): マスの進む数
            coin (int): マスで得られるコイン数
        """
        self.extend = extend
        self.coin = coin


class Sugoroku:
    def __init__(self, road):
        """
        スゴロクの道を初期化するクラス
        
        Parameters:
            road (list): マスの情報を格納したリスト
        """
        self.road = road
        self.start = 0
        self.goal = len(road)


# 入力を受け取る
N, M, K = map(int, input().split())
'''
スゴロクのマスの数を表す整数 N, プレイヤーの人数を表す M と各プレイヤーがサイコロを振る回数を表す整数 K
'''

road_map = [Square()]  # start
for _ in range(N-2):
    extend, coin = map(int, input().split())
    road_map.append(Square(extend, coin))
road_map.append(Square())  # goal

player = [Player(road_map) for _ in range(M)]

for _ in range(K):
    roll = list(map(int, input().split()))
    for i in range(M):
        p, r = player[i], roll[i]
        p.get_award(r)
        p.move(r)  # ダイスの目分進む
        s = road_map[p.position]
        p.get_coin(s.coin)
        p.move(s.extend)

get_coin = [p.coin for p in player]
max_coin = max(get_coin)
winner = get_coin.index(max_coin) + 1
print(winner, max_coin)
'''
与えられたスゴロクの道の情報とプレイヤーの行動に基づいて、最終的な勝者の番号とコインの枚数を求めるプログラムです。
まず、Player クラスはプレイヤーの情報を管理するためのクラスです。インスタンス変数として、スゴロクの道の情報 sugoroku、現在の位置 position、所持しているコインの枚数 coin、受賞コインの枚数 award を持ちます。Player クラスの goal_pos は全プレイヤーで共有するゴールの位置を表しています。
Player クラスの move メソッドは、与えられたサイコロの目の数に基づいてプレイヤーを移動します。現在の位置にサイコロの目の数を加えて新しい位置を計算し、ゴールを超える場合はゴールの位置に修正します。また、位置に応じて受賞コインを設定するための set_award メソッドもあります。
Player クラスの get_award メソッドは、与えられたサイコロの目の数に基づいて受賞コインを獲得します。受賞コインの数にサイコロの目の数を掛けて現在のコインに加えます。
Player クラスの get_coin メソッドは、与えられたコインの数を現在のコインに加えます。ただし、コインが負の値にならないように注意しています。
次に、Square クラスはスゴロクのマスの情報を管理するためのクラスです。インスタンス変数として、進むマスの数 extend と獲得できるコインの枚数 coin を持ちます。
Sugoroku クラスはスゴロクの道全体を管理するためのクラスです。インスタンス変数として、道の情報を格納したリスト road、スタートの位置 start、ゴールの位置 goal を持ちます。
プログラムの実行部分では、まず入力からスゴロクのマスの数を表す整数 N、プレイヤーの人数を表す整数 M、各プレイヤーがサイコロを振る回数を表す整数 K を受け取ります。
次に、スゴロクの道の情報を入力として受け取り、Square オブジェクトを生成し、リスト road_map に格納します。スタートとゴールのマスも含めて生成します。
その後、プレイヤーの人数分だけ Player オブジェクトを生成し、リスト player に格納します。
最後に、サイコロの目の数を受け取りながら、各プレイヤーの行動を順番に実行します。受賞コインの獲得、移動、マス効果によるコインの獲得などが行われます。
全ての行動が終了した後、各プレイヤーの現在のコイン数を取得し、最もコイン数の多いプレイヤーを勝者として選びます。その勝者の番号とコイン数を出力します。
'''
--------------------------------------------- B081　※欠番 ◆
# B081 花壇のロープ
# utf-8
def count_ropes(H, W, field):
    """
    花壇を過不足なく囲うために必要なロープの本数を数える関数

    Args:
        H (int): 地図の縦幅
        W (int): 地図の横幅
        field (List[List[str]]): 地図の情報を格納した2次元リスト

    Returns:
        int: ロープの本数
    """
    total_ropes = 0

    for i in range(H):
        for j in range(W):
            if field[i][j] == '#':
                if i == 0 or field[i - 1][j] == '.':
                    total_ropes += 1
                if i == H - 1 or field[i + 1][j] == '.':
                    total_ropes += 1
                if j == 0 or field[i][j - 1] == '.':
                    total_ropes += 1
                if j == W - 1 or field[i][j + 1] == '.':
                    total_ropes += 1

    return total_ropes

# 入力の読み込み
H, W = map(int, input().split())

# 地図の初期化
field = []
for _ in range(H):
    row = input()
    field.append(row)

# ロープの本数を数える
ropes = count_ropes(H, W, field)

# 結果を出力
print(ropes)
'''
まず count_ropes 関数が定義されています。この関数は、花壇を過不足なく囲うために必要なロープの本数を数えるために使用されます。
count_ropes 関数は、以下の引数を受け取ります：

H：地図の縦幅を表す整数
W：地図の横幅を表す整数
field：地図の情報を格納した2次元リスト
関数内部では、2重のループを使用して地図を走査します。各地点の文字が花壇を表す # であれば、その周囲をチェックします。
花壇の上側が存在しない場合や、上側が花壇ではない場合、現在の地点にロープが必要です。同様に、下側、左側、右側についても同様のチェックを行い、ロープの本数を適切にカウントします。
全ての地点をチェックし終えた後、合計のロープの本数を返します。
プログラムの残りの部分では、入力を受け取り、地図の情報を適切なデータ構造で格納します。そして、count_ropes 関数を呼び出し、結果を出力します。
'''

# B082 休暇の取り方
# utf-8
def calculate_longest_continuous_days(schedule, M):
    # スケジュール内の「出勤」日数をカウントする
    w_M = schedule.count("work")
    index = 0
    count = w_M - M + 1
    ansArr = []

    # スケジュールを繰り返し処理し、最長の連続休暇日数を見つける
    for _ in range(count):
        editArr, index = edit_arr(schedule.copy(), M, w_M, index)
        ans = count_arr(editArr)
        ansArr.append(ans)

    return max(ansArr)


def edit_arr(schedule, M, w_M, index):
    # スケジュール内の「出勤」日のインデックスを見つける
    workDays = [i for i, day in enumerate(schedule) if day == "work"]

    # スケジュールを編集し、「出勤」日を「休み」日に変更する
    for i in range(M):
        if i + index < len(workDays):
            schedule[workDays[i + index]] = "off"

    index += 1
    return schedule, index


def count_arr(editArr):
    ans = 0
    count = 0
    arr_last_index = len(editArr) - 1

    # 編集されたスケジュールで最も長い連続休暇日数をカウントする
    for i, shift in enumerate(editArr):
        if shift == "off":
            count += 1
            if i == arr_last_index and ans <= count:
                ans = count
        else:
            ans = max(ans, count)
            count = 0

    return ans


N, M = map(int, input().split())
schedule = []

# 入力からスケジュールを読み取る
for _ in range(N):
    schedule.append(input().strip())

result = calculate_longest_continuous_days(schedule, M)
print(result)
'''
このコードは、与えられたスケジュールと有給休暇の日数を利用して、最も長い連続休暇日数を計算するものです。
まず、calculate_longest_continuous_days関数は、スケジュールと有給休暇の日数を引数として受け取ります。この関数では、以下の処理が行われます。
スケジュール内の「出勤」日数をカウントします。これは、schedule.count("work")によって行われます。
indexを初期化し、有給休暇を利用して作成できる連続休暇日数の回数を計算します。具体的には、w_M - M + 1となります。
連続休暇日数の結果を保持するためのリストansArrを初期化します。
次に、連続休暇日数を計算するためのループが行われます。ループは、先ほど計算した回数分だけ繰り返されます。
edit_arr関数を呼び出し、スケジュールを編集します。この関数では、スケジュールのコピー、有給休暇の日数、出勤日数、および現在のindexを引数として受け取ります。
edit_arr関数では、まずスケジュール内の「出勤」日のインデックスを見つけます。これはリスト内包表記を使用して行われます。
スケジュールを編集し、「出勤」日を「休み」日に変更します。これはforループを使用して行われます。ただし、インデックスが範囲外にならないようにチェックしてから変更します。
indexをインクリメントして次の連続休暇日数の作成に備えます。
スケジュールの編集が完了したら、count_arr関数を呼び出して連続休暇日数をカウントします。
count_arr関数では、編集されたスケジュールを受け取り、最も長い連続休暇日数を計算します。具体的には、連続している「休み」日のカウントを行い、最大の連続休暇日数を保持します。
ループが終了したら、ansArrに計算結果を追加します。
最終的に、ansArrの中から最大の値を取得し、それが最も長い連続休暇日数となります。
最後に、メインの処理が行われます。入力からスケジュールを読み取り、calculate_longest_continuous_days関数を呼び出して最長の連続休暇日数を計算し、結果を出力します。
'''

# B083 宝の地図
# utf-8
N = int(input())  # 線分の本数を取得
s = []  # 線分の情報を格納するリスト
yoko = []  # 横方向の線分を格納するリスト
tate = []  # 縦方向の線分を格納するリスト
ans = float('inf')  # 面積の最小値を初期化

# 線分の情報を入力
for _ in range(N):
    a, b, c, d = map(int, input().split())
    s.append([a, b, c, d])

# 横方向と縦方向に線分を分類
for senn in s:
    if senn[1] == senn[3]:
        yoko.append(senn)
    else:
        tate.append(senn)

# 最小面積の長方形を探索
for i in range(len(yoko) - 1):
    tate_temp = []  # 縦方向の線分の一時的な格納リスト
    for tate_seg in tate:
        if yoko[i][0] <= tate_seg[0] <= yoko[i][2] and tate_seg[1] <= yoko[i][1] <= tate_seg[3]:
            tate_temp.append(tate_seg)

    if len(tate_temp) < 2:
        continue

    for j in range(len(yoko)):
        if j == i:
            continue

        for k in range(len(tate_temp) - 1):
            if yoko[j][0] <= tate_temp[k][0] <= yoko[j][2] and tate_temp[k][1] <= yoko[j][1] <= tate_temp[k][3]:
                for l in range(len(tate_temp)):
                    if l == k:
                        continue

                    if yoko[j][0] <= tate_temp[l][0] <= yoko[j][2] and tate_temp[l][1] <= yoko[j][1] <= tate_temp[l][3]:
                        a = max(tate_temp[l][0], tate_temp[k][0]) - min(tate_temp[l][0], tate_temp[k][0])
                        b = max(yoko[j][1], yoko[i][1]) - min(yoko[j][1], yoko[i][1])
                        area = a * b

                        if area < ans:
                            ans = area

print(ans)  # 最小面積を出力
'''
最初に、線分の本数を表す整数Nを入力します。
次に、N個の線分の情報を入力します。各線分は4つの整数a, b, c, dで表されます。これらの整数は線分の両端点の座標を表し、(a, b)と(c, d)が線分の端点です。
入力された線分を横方向の線分と縦方向の線分に分類します。線分のy座標が同じ場合は横方向の線分とし、それ以外の場合は縦方向の線分とします。
面積の最小値を表す変数ansを無限大で初期化します。
横方向の線分と縦方向の線分を組み合わせて長方形を作り、最小の面積を求めます。
横方向の線分を順番に取り出し、それに対応する縦方向の線分を探します。
縦方向の線分は、横方向の線分の範囲内にあり、かつy座標も範囲内にある必要があります。
縦方向の線分が2本以上存在する場合、他の横方向の線分との組み合わせも考えます。
3つの線分で作られる長方形の面積を計算し、最小の面積であればansを更新します。
最終的に求められた最小面積を出力します。
与えられた線分を組み合わせて長方形を作り、その中で面積が最小となる長方形を見つけるアルゴリズムを実装しています。
'''

# B084 オススメのお店
# utf-8
def recommend_restaurants(N, M, K, my_ratings, user_ratings):
    similar_users = []

    # 類似したユーザーを見つける
    for i in range(M):
        count = 0
        for j in range(N):
            # 自分の評価が3であり、ユーザーの評価も3の場合、好みが似ていると判断
            if my_ratings[j] == 3 and user_ratings[i][j] == 3:
                count += 1
        if count >= K:
            # 好みが似ているユーザーのインデックスを保存
            similar_users.append(i + 1)

    recommended_restaurants = []

    # 推薦されたお店を見つける
    for j in range(N):
        if my_ratings[j] == 0:
            for user in similar_users:
                # 好みが似ているユーザーが評価したお店が3の場合、お店を推薦
                if user_ratings[user - 1][j] == 3:
                    recommended_restaurants.append(j + 1)
                    break

    return recommended_restaurants


# 入力値の取得
N, M, K = map(int, input().split())
my_ratings = list(map(int, input().split()))
user_ratings = []
for _ in range(M):
    user_ratings.append(list(map(int, input().split())))

# お店の推薦
recommendations = recommend_restaurants(N, M, K, my_ratings, user_ratings)

# 推薦されたお店の出力
if recommendations:
    print(" ".join(map(str, recommendations)))
else:
    print("no")
'''
このコードは、与えられた評価データを解析し、好みが似ているユーザーが評価したお店を推薦するシンプルなアルゴリズムを実装しています。

まず、recommend_restaurants 関数は、お店の推薦を行うための主要なロジックが含まれています。
similar_users という空のリストを作成します。このリストは、好みが似ていると判断されたユーザーのインデックスを保持します。
入力データのユーザーごとにループします。
内側のループでは、自分の評価とユーザーの評価を比較し、好みが似ていると判断される基準数 K を満たすかどうかをカウントします。
基準数 K を満たす場合は、そのユーザーを similar_users に追加します。
recommended_restaurants という空のリストを作成します。このリストは、推薦されたお店のインデックスを保持します。
自分が評価していないお店でループします。
好みが似ていると判断されたユーザーごとにループします。
ユーザーが評価したお店の評価が高い（3）場合、そのお店を recommended_restaurants に追加します。
メインのプログラム部分では、入力値を受け取ります。
N、M、K は、それぞれお店の数、ユーザーの数、好みが似ていると言える基準の数を表します。
my_ratings は、自分のお店の評価リストを表します。
user_ratings は、各ユーザーのお店の評価リストを2次元配列として表します。
その後、recommend_restaurants 関数を呼び出し、お店の推薦を行います。推薦されたお店のリストを recommendations に保存します。
最後に、推薦されたお店の出力を行います。推薦されたお店がある場合は、リストの要素を文字列に変換してスペース区切りで出力します。推薦されたお店がない場合は、"no" を出力します。
'''

# B085 宝探しの手順
# utf-8
def calculate_distance(P):
    # １つ目の方法での距離の計算
    num = 0
    x, y = 0, 0

    while x != P:
        y += 1
        num += y
        x += y
        if x == P:
            break
        y += 1
        x -= y
        num += y

    # ２つ目の方法での距離の計算
    num2 = 0
    x, y, i, j = 0, 0, 1, 0

    while not (x <= P and P <= 0):
        num2 += y
        y = i - x
        x = i
        if x >= P and P >= 0:
            break
        num2 += y
        y = i + x
        x = -i
        j = i
        i *= 2

    y = abs(P) + j
    num2 += y

    return num, num2


# 座標Pの入力
P = int(input())

# 距離の計算
distance_1, distance_2 = calculate_distance(P)

# 結果の出力
print(distance_1, distance_2)
'''
calculate_distance関数は、座標Pに対して距離を計算するための関数です。まず、１つ目の方法での距離を計算します。
num変数は距離の合計を表します。xは現在の位置を表し、yは移動する距離を表します。
最初のwhileループでは、現在位置がPと等しくなるまで以下の処理を繰り返します。
yを1増やし、numに加算します。
xにyを加え、現在位置を更新します。
もしxがPと等しければ、ループを抜けます。
yを1増やし、xからyを減じ、現在位置を更新します。
numにyを加算します。
このようにして、１つ目の方法での距離を計算します。
次に、２つ目の方法での距離を計算します。
num2変数は２つ目の方法での距離の合計を表します。xは現在の位置を、yは移動する距離を表します。また、iは２のべき乗の値を保持し、jは直前のiの値を保持します。
２つ目のwhileループでは、以下の条件を満たす間、以下の処理を繰り返します。
num2にyを加算します。
yにi - xを代入し、次の移動距離を計算します。
xにiを代入し、現在位置を更新します。
もしxがP以上であり、かつPが0以上であれば、ループを抜けます。
num2にyを加算します。
yにi + xを代入し、次の移動距離を計算します。
xに-iを代入し、現在位置を更新します。
jにiを代入し、直前のiの値を保持します。
iを2倍にします。
ループを抜けた後、まだ移動していない距離を計算します。yには、abs(P)の絶対値を加算し、現在位置からの距離を計算します。最後に、この距離をnum2に加算します。
最後に、calculate_distance関数から計算結果を返します。まず座標Pを入力として受け取ります。次に、calculate_distance関数を呼び出し、１つ目と２つ目の方法での距離を計算します。最後に、計算結果を出力します。
'''

# B086 公平な分割
# utf-8
# ケーキのサイズを入力
H, W = map(int, input().split())
# ケーキの状態を入力
cake = [input() for _ in range(H)]

# スコアを計算する関数
def calculate_score(c):
    # イチゴの数を数える
    strawberries = sum(row.count('@') for row in c)
    # スコアを計算して返す
    return len(c) * len(c[0]) + strawberries ** 2

# 最小の不公平度と座標を保持する変数を初期化
min_unfairness = float('inf')
best_coordinates = []

# 全ての可能な座標の組み合わせを試す
for y in range(1, H):
    for x in range(1, W):
        # ケーキを4つの領域に分割
        upper_left = [row[:x] for row in cake[:y]]
        upper_right = [row[x:] for row in cake[:y]]
        lower_left = [row[:x] for row in cake[y:]]
        lower_right = [row[x:] for row in cake[y:]]

        # 分割したケーキごとにスコアを計算
        cakes = [upper_left, upper_right, lower_left, lower_right]
        scores = [calculate_score(c) for c in cakes]

        # 最大スコアと最小スコアの差が最小の不公平度を更新
        unfairness = max(scores) - min(scores)
        if unfairness < min_unfairness:
            min_unfairness = unfairness
            best_coordinates = [y, x]
        elif unfairness == min_unfairness:
            # 不公平度が同じ場合は座標の比較で最適な座標を更新
            if y < best_coordinates[0] or (y == best_coordinates[0] and x < best_coordinates[1]):
                best_coordinates = [y, x]

# 結果を出力
print(best_coordinates[0], best_coordinates[1])
'''
以下の手順でケーキを分割し、最も不公平度が低い切り分け方を求めるものです。

最初に、ケーキの高さ H と幅 W を入力します。
次に、H 行のケーキの状態を入力します。各行は W 文字の文字列で、'#' は生クリームを表し、'@' はイチゴを表します。
不公平度を計算するための関数 calculate_score を定義します。この関数では、ケーキの面積にイチゴの個数の二乗を加えた値を返します。
不公平度と座標を保持するための変数 min_unfairness と best_coordinates を初期化します。min_unfairness は最小の不公平度を表し、初期値として無限大を設定します。
全ての可能な座標の組み合わせについて、以下の手順を実行します。
y 座標を 1 から H-1 まで、x 座標を 1 から W-1 まで順に試します。
ケーキを上左、上右、下左、下右の 4 つの領域に分割します。これにより、4 つのケーキが得られます。
分割したケーキごとにスコアを計算します。スコアは関数 calculate_score を使用して、ケーキの面積にイチゴの個数の二乗を加えた値です。
4 つのケーキのスコアの最大値と最小値の差を不公平度とします。
不公平度が min_unfairness よりも小さい場合、不公平度を更新し、その座標を best_coordinates とします。不公平度が同じ場合は、より小さい座標が選択されるようにします。
最も不公平度が低い切り分け方として選ばれた座標を出力します。
'''

# B087 隠された数
# utf-8
def find_max_number(h, w, k, grid):
    max_number = -1

    # 上から下に連続する数字を並べた場合の最大値を探す
    for i in range(h):
        for j in range(w - k + 1):
            number = int(grid[i][j:j+k])
            max_number = max(max_number, number)

    # 左から右に連続する数字を並べた場合の最大値を探す
    for i in range(w):
        for j in range(h - k + 1):
            number = int(''.join(grid[x][i] for x in range(j, j+k)))
            max_number = max(max_number, number)

    return max_number

# 入力を受け取る
h, w, k = map(int, input().split())
grid = [input() for _ in range(h)]

# 最大値を求める
result = find_max_number(h, w, k, grid)

# 結果を出力
print(result)
'''
このプログラムは、与えられたマス目の情報を解析して条件に当てはまる数の最大値を見つけるためのものです。
最初に、与えられたマス目の情報を受け取ります。h, w, k = map(int, input().split())の部分では、1行目から高さを表すh、幅を表すw、そして探す数の桁数を表すkを取得しています。マス目の情報は、次の行でgridというリストに格納されます。gridはh行の文字列からなるリストです。
次に、find_max_numberという関数を定義します。この関数は、与えられたマス目の情報と条件の桁数kに基づいて、最大値を探します。
関数内部では、max_numberという変数を初期化し、-1で設定します。これは探索中に見つかる数の最大値を保持するための変数です。
最初のループでは、上から下に連続する数字を並べた場合の最大値を探します。for i in range(h)とfor j in range(w - k + 1)の2つのループを使用して、マス目を走査します。grid[i][j:j+k]は、i行目のj番目からk桁分の部分文字列を取得する操作です。これを整数に変換し、numberという変数に代入します。そして、max_numberとnumberを比較して、より大きい方をmax_numberに更新します。
2番目のループでは、左から右に連続する数字を並べた場合の最大値を探します。for i in range(w)とfor j in range(h - k + 1)の2つのループを使用して、マス目を走査します。内側のループでは、指定された桁数kに対して、各行の対応する位置からの文字を取得し、それらを連結して整数に変換します。同様に、max_numberとnumberを比較して、より大きい方をmax_numberに更新します。
最後に、find_max_number関数の結果をresultに代入し、結果を出力します。出力されるのは条件に当てはまる数の最大値です。
このプログラムを使えば、与えられたマス目の情報から条件に当てはまる数の最大値を見つけることができます。
'''

# B088 ロボットのデバッグ
# utf-8
H, W = map(int, input().split())  # 迷路の縦の長さと横の長さを取得

muki = 1  # 進行方向の初期値 (0: 上, 1: 右, 2: 下, 3: 左)
x, y = 0, 0  # 現在位置の初期値 (左上隅)
turn = 0  # 進行方向変更のカウント
s = []  # 迷路の情報を格納するリスト

def func():
    global turn, muki
    if turn >= 2:  # 進行方向変更が2回以上行われた場合
        return False
    else:
        muki = (muki + turn + 1) % 4  # 進行方向を変更
        turn += 1  # 進行方向変更のカウントを増やす
    return True

for h in range(H):
    s.append(list(input()))  # 迷路の情報を取得し、リストに追加

while True:
    if muki == 1:
        # 進行方向が右を向いている場合
        if x == W - 1:
            # 右に進むことができず、進行方向変更が必要な場合
            if not func():
                break
        elif s[y][x + 1] == '.':
            # 右に進むことができる場合
            s[y][x] = '#'  # 現在位置を壁に変更
            x += 1  # 右に移動
            turn = 0  # 進行方向変更のカウントをリセット
        elif s[y][x + 1] == '#':
            # 右に進むことができず、進行方向変更が必要な場合
            if not func():
                break
    elif muki == 2:
        # 進行方向が下を向いている場合
        if y == H - 1:
            # 下に進むことができず、進行方向変更が必要な場合
            if not func():
                break
        elif s[y + 1][x] == '.':
            # 下に進むことができる場合
            s[y][x] = '#'  # 現在位置を壁に変更
            y += 1  # 下に移動
            turn = 0  # 進行方向変更のカウントをリセット
        elif s[y + 1][x] == '#':
            # 下に進むことができず、進行方向変更が必要な場合
            if not func():
                break
    elif muki == 3:
        # 進行方向が左を向いている場合
        if x == 0:
            # 左に進むことができず、進行方向変更が必要な場合
            if not func():
                break
        elif s[y][x - 1] == '.':
            # 左に進むことができる場合
            s[y][x] = '#'  # 現在位置を壁に変更
            x -= 1  # 左に移動
            turn = 0  # 進行方向変更のカウントをリセット
        elif s[y][x - 1] == '#':
            # 左に進むことができず、進行方向変更が必要な場合
            if not func():
                break
    elif muki == 0:
        # 進行方向が上を向いている場合
        if y == 0:
            # 上に進むことができず、進行方向変更が必要な場合
            if not func():
                break
        if s[y - 1][x] == '.':
            # 上に進むことができる場合
            s[y][x] = '#'  # 現在位置を壁に変更
            y -= 1  # 上に移動
            turn = 0  # 進行方向変更のカウントをリセット
        elif s[y - 1][x] == '#':
            # 上に進むことができず、進行方向変更が必要な場合
            if not func():
                break

print(x, y) # ロボットの停止座標
'''
このコードは、与えられた迷路内をロボットが移動しながら特定の位置を求めるものです。
まず、入力から迷路の縦の長さと横の長さを取得します（H, W = map(int, input().split())）。次に、進行方向（muki）、現在位置（x, y）、進行方向変更の回数（turn）を初期化し、迷路の情報をリストsに格納します。
その後、以下のループが実行されます。

mukiが1の場合（右を向いている場合）：
もし現在位置が右端であり、かつ進行方向変更が必要な場合は、func関数を呼び出して進行方向を変更します。
もし現在位置の右が通路である場合は、現在位置を壁に変更し、右に移動し、進行方向変更の回数をリセットします。
もし現在位置の右が壁である場合は、func関数を呼び出して進行方向を変更します。
mukiが2の場合（下を向いている場合）：
もし現在位置が下端であり、かつ進行方向変更が必要な場合は、func関数を呼び出して進行方向を変更します。
もし現在位置の下が通路である場合は、現在位置を壁に変更し、下に移動し、進行方向変更の回数をリセットします。
もし現在位置の下が壁である場合は、func関数を呼び出して進行方向を変更します。
mukiが3の場合（左を向いている場合）：
もし現在位置が左端であり、かつ進行方向変更が必要な場合は、func関数を呼び出して進行方向を変更します。
もし現在位置の左が通路である場合は、現在位置を壁に変更し、左に移動し、進行方向変更の回数をリセットします。
もし現在位置の左が壁である場合は、func関数を呼び出して進行方向を変更します。
mukiが0の場合（上を向いている場合）：
もし現在位置が上端であり、かつ進行方向変更が必要な場合は、func関数を呼び出して進行方向を変更します。
もし現在位置の上が通路である場合は、現在位置を壁に変更し、上に移動し、進行方向変更の回数をリセットします。
もし現在位置の上が壁である場合は、func関数を呼び出して進行方向を変更します。
最後に、ロボットの最終位置（x, y）を出力します。

このコードでは、ロボットが通路を進みながら壁にぶつかるまで移動し続け、進行方向を変更しながら特定の位置を求める仕組みです。
'''

# B089 秘密の言葉
# utf-8
# NとMの値を取得
N, M = map(int, input().split())

# 文字盤の入力を受け取る
board = []
for _ in range(N):
    row = list(input().rstrip())
    board.append(row)

# 単語リストの入力を受け取る
words = []
for _ in range(M):
    word = input().rstrip()
    words.append(word)

# 各単語の先頭文字の位置を探索して出力
for word in words:
    for i in range(N):
        for j in range(N):
            if board[i][j] == word[0]:  # 先頭文字が一致する場所を探す
                flag = True
                for k in range(1, len(word)):
                    if i + k >= N or j + k >= N or board[i + k][j + k] != word[k]:
                        flag = False
                        break
                if flag:
                    # 単語の先頭文字の位置を出力
                    print(j + 1, i + 1)
                    break  # 単語が見つかったら探索を終了する
'''
最初に、入力から文字盤のサイズNと単語の個数Mを取得します。次に、N行の文字盤を入力します。文字盤は2次元リストとして表現されます。
続いて、M個の単語を入力します。単語はリストに格納されます。単語リストの各単語について、文字盤上での先頭文字の位置を探索します。
先頭文字が一致する場所を見つけたら、その位置を出力します。単語が見つかったら、それ以上の探索は行わずに次の単語に進みます。
このコードは、文字盤と単語のリストを受け取り、単語の先頭文字の位置を特定するものです。
'''

# B090 選挙の議席（ドント方式選挙）
# utf-8
def distribute_seats(votes, K):
    parties = list(range(1, len(votes) + 1))  # 政党の番号（1からNまで）をリスト化
    seats = [0] * len(votes)  # 各政党の議席数を格納するリスト

    for _ in range(K):
        # 得票数を割り算し、商の大きい順に政党をソート
        parties.sort(key=lambda x: votes[x-1] // (seats[x-1] + 1), reverse=True)

        # 最大の商を持つ政党に議席を配分
        seats[parties[0]-1] += 1

    return seats

# 入力を受け取る
N, K = map(int, input().split())  # 政党の数と議席の数

votes = []  # 政党ごとの得票数を格納するリスト
for _ in range(N):
    votes.append(int(input()))

# 各政党の議席数を計算
result = distribute_seats(votes, K)

# 結果を出力
for seats in result:
    print(seats)
'''
指定された得票数と議席数に基づいて、ドント方式選挙における各政党の議席数を計算するプログラムです。
distribute_seats関数は、得票数と議席数を受け取り、各政党の議席数を計算します。partiesリストには政党の番号（1からNまで）が格納され、seatsリストには各政党の議席数が初期化されます。
ループをK回繰り返し、得票数を割り算して商の大きい順に政党をソートします。lambda関数を使用して、割り算の結果を比較し、partiesリストをソートします。
最大の商を持つ政党に議席を配分します。seatsリストの該当政党の要素に1を加算します。
seatsリストを最終的な結果として返します。
メインのコード部分では、入力を受け取り、各政党の得票数をリストに格納します。そして、distribute_seats関数を呼び出して各政党の議席数を計算し、結果を出力します。
'''
--------------------------------------------- B091　※欠番 ◆
# B091 山頂を探せ
# utf-8
N = int(input())  # 地図の大きさを表す整数 N を入力
h = []  # 標高データを格納するリスト
y = []  # 山頂の標高を格納するリスト

# 標高データを入力し、周囲にダミーの標高 0 を追加する
for _ in range(N):
    row = list(map(int, input().split()))  # スペース区切りで標高データを入力
    h.append(row)

for i in range(N):
    h[i].insert(0, 0)  # 各行の先頭にダミーの標高 0 を追加
    h[i].append(0)  # 各行の末尾にダミーの標高 0 を追加

h.insert(0, [0] * (N + 2))  # 最初の行にダミーの標高 0 の行を追加
h.append([0] * (N + 2))  # 最後の行にダミーの標高 0 の行を追加

# 山頂を見つけて高い順に標高を保存する
for k in range(1, N + 1):
    for j in range(1, N + 1):
        x = h[k][j]
        if x > h[k - 1][j] and x > h[k + 1][j] and x > h[k][j - 1] and x > h[k][j + 1]:
            y.append(x)

y.sort(reverse=True)  # 標高を高い順に並び替える
for i in y:
    print(i)  # 山頂の標高を出力
'''
最初に、地図の大きさを表す整数 N を入力します。
h という空のリストを作成します。このリストは、各マスの標高データを格納するために使用します。
N 回のループを実行して、各行の標高データを入力します。split() を使ってスペース区切りの入力値を整数に変換し、row というリストとして追加します。
各行の先頭と末尾にダミーの標高 0 を追加します。これにより、地図の外側のマスの標高を 0 として扱います。
ダミーの行を最初と最後に追加することで、地図の上下の境界も考慮できるようにします。
y という空のリストを作成します。このリストは、山頂の標高を格納するために使用します。
k と j の2重ループを使用して、各マスの標高をチェックします。
現在のマスの標高 x が、上下左右のマスの標高よりも高い場合、それは山頂と見なされます。
この場合、y リストに標高を追加します。y リストを高い順に並び替えます。
y リスト内の各標高を順に出力します。与えられた地図の中から山頂を見つけて、その標高を高い順に出力することができるようになります。
'''

# B092 セーブポイント
# utf-8
def find_nearest_save_point(map):
    rows = len(map)  # マップの行数を取得
    cols = len(map[0])  # マップの列数を取得
    current_position = None  # 現在地の座標を初期化
    save_points = []  # セーブポイントの座標と番号を保存するリスト

    # マップ上の現在地とセーブポイントを探す
    for i in range(rows):
        for j in range(cols):
            if map[i][j] == 'N':
                current_position = (i, j)  # 現在地の座標を保存
            elif map[i][j].isdigit():
                save_points.append((int(map[i][j]), i, j))  # セーブポイントの座標と番号を保存

    # 現在地からの距離を計算し、最も近いセーブポイントを求める
    distances = []
    for save_point in save_points:
        distance = abs(save_point[1] - current_position[0]) + abs(save_point[2] - current_position[1])
        distances.append((save_point[0], distance))  # セーブポイントの番号と距離を保存

    # 距離が最小のセーブポイントを求める
    min_distance = min(distances, key=lambda x: x[1])
    nearest_save_points = [save_point[0] for save_point in distances if save_point[1] == min_distance[1]]
    nearest_save_points.sort()  # セーブポイント番号を昇順にソート

    return nearest_save_points

# マップの入力
H, W, K = map(int, input().split())  # マップの高さ、幅、セーブポイントの数を取得
map = []
for _ in range(H):
    row = input()  # マップの各行を入力
    map.append(row)  # マップをリストに追加

# 結果の出力
result = find_nearest_save_point(map)  # 最も近いセーブポイントを求める
print(len(result))  # 最も近いセーブポイントの数を出力
for save_point in result:
    print(save_point)  # 各セーブポイントの番号を出力
'''
与えられたマップ上で現在地から最も近いセーブポイントを見つけるためのプログラムです。
まず、find_nearest_save_point関数では、マップの情報を受け取ります。マップは二次元リストとして表現され、各要素は文字列で構成されています。関数内では、マップの行数と列数を取得し、現在地とセーブポイントの座標を保存するための変数を初期化します。
次に、二重ループを使用してマップを走査します。マップ上で現在地を示す"N"の位置を見つけると、その座標をcurrent_position変数に保存します。また、数字のセーブポイントの位置を見つけると、その座標と番号をsave_pointsリストに保存します。
現在地から各セーブポイントまでの距離を計算するため、distancesリストを作成します。セーブポイントごとに、現在地とのマンハッタン距離を計算し、セーブポイントの番号と距離の組をdistancesリストに追加します。
距離が最小のセーブポイントを見つけるため、min関数を使用してdistancesリストを距離の要素で比較します。最小距離を持つ要素を取得し、その距離をmin_distance変数に保存します。
最後に、最も近いセーブポイントの番号を昇順にソートし、nearest_save_pointsリストに保存します。
メインの処理では、マップの情報を入力し、find_nearest_save_point関数を呼び出して最も近いセーブポイントを求めます。結果を出力する際は、最も近いセーブポイントの数を先に出力し、その後に各セーブポイントの番号を表示します。
このように、コード全体ではマップの情報を解析し、現在地から最も近いセーブポイントを見つけるための処理が行われます。
'''

# B093 SNSの検索機能
# utf-8
# 投稿クラスの定義
class Post:
    def __init__(self, id, length, content, year, month, day):
        self.id = id  # 投稿ID
        self.length = length  # つぶやきの長さ
        self.content = content  # つぶやきの内容
        self.year = year  # 投稿の年
        self.month = month  # 投稿の月
        self.day = day  # 投稿の日

    def contains_keyword(self, keywords):
        # キーワードがつぶやきに含まれているかをチェックするメソッド
        for keyword in keywords:
            if keyword in self.content:
                return True
        return False

    def __lt__(self, other):
        # ソートのために比較演算子 __lt__ をオーバーライド
        # 投稿日時が早い順にソートする
        if self.year != other.year:
            return self.year < other.year
        if self.month != other.month:
            return self.month < other.month
        if self.day != other.day:
            return self.day < other.day

        # 投稿日時が同じ場合は投稿IDの小さい順にソートする
        return self.id < other.id


# N, Mを入力
N, M = map(int, input().split())

# 投稿情報を格納するリスト
posts = []
for i in range(N):
    # 投稿の長さと内容を入力
    c, s = input().split()
    # 投稿日時を入力
    year, month, day = map(int, input().split())
    # 投稿オブジェクトを作成し、リストに追加
    post = Post(i + 1, int(c), s, year, month, day)
    posts.append(post)

# キーワードを格納するリスト
keywords = []
for _ in range(M):
    # キーワードの長さとキーワードを入力
    e, k = input().split()
    keywords.append(k)

# キーワードを含む投稿を抽出する
filtered_posts = []
for post in posts:
    if post.contains_keyword(keywords):
        filtered_posts.append(post)

# 投稿をソートする
filtered_posts.sort()

# 結果を出力
if not filtered_posts:
    print("None")
else:
    for post in filtered_posts:
        print(post.id)
'''
Post クラスの定義：投稿情報を格納するためのクラスです。投稿ID、つぶやきの長さ、内容、投稿日時を保持し、キーワードの有無をチェックするメソッドも提供しています。
NとMの入力：投稿の数Nとキーワードの数Mを入力します。
投稿情報の入力：N回のループで、投稿の長さと内容、投稿日時を入力し、Post オブジェクトを作成してリストに追加します。
キーワードの入力：M回のループで、キーワードを入力し、キーワードを格納するリストに追加します。
キーワードを含む投稿の抽出：投稿リストを走査し、キーワードを含む投稿を抽出し、別のリストに格納します。
投稿のソート：抽出された投稿を投稿日時の昇順と投稿IDの昇順でソートします。
結果の出力：ソートされた投稿リストが空の場合は"None"を出力し、そうでない場合は各投稿のIDを出力します。
'''

# B094 ◆

# B095 カラオケ大会
# utf-8
# 歌う人数と課題曲の長さを受け取る
N, M = map(int, input().split())

# 正解の音程を格納するリスト
arr_interval = []
for _ in range(M):
    arr_interval.append(int(input()))

# 歌唱者の得点を格納するリスト
result = []

# 歌唱者ごとに得点を計算する
for _ in range(N):
    # 採点方法は100点からの減点方式
    score = 100
    
    for j in range(M):
        # 正解の音程
        a = arr_interval[j]
        # 歌唱者の音程
        b = int(input())
        
        # "小節の正しい音程" と "歌唱者音程" の差分
        interval_diff = abs(b - a)
        
        """
        判定条件
        ・誤差 5 Hz 以内なら減点しない
        ・上記に当てはまらず、誤差 10 Hz 以内なら 1 点減点
        ・上記に当てはまらず、誤差 20 Hz 以内なら 2 点減点
        ・上記に当てはまらず、誤差 30 Hz 以内なら 3 点減点
        ・上記に当てはまらない場合、5 点減点
        """
        if interval_diff <= 5:
            continue
        elif interval_diff <= 10:
            score -= 1
        elif interval_diff <= 20:
            score -= 2
        elif interval_diff <= 30:
            score -= 3
        else:
            score -= 5

    # 減点方式で 0 点を下回らせないための処理
    score = max(score, 0)
    result.append(score)

# N 人のうちの最高得点を出力する
highest_score = max(result)
print(highest_score)
'''
このコードは、解の音程と歌唱者の音程を比較し、減点方式で得点を計算し、歌唱者の中で最高得点を持つ人の得点が出力されます。
最初に、歌う人数と課題曲の長さを受け取ります。NとMにはそれぞれ整数として値が代入されます。
正解の音程を格納するリスト arr_interval を作成します。課題曲の各小節の正しい音程を順番に入力し、リストに追加します。
歌唱者ごとの得点を計算し、結果を格納するリスト result を作成します。
歌唱者ごとに得点を計算するためのループを行います。ループの中で、各小節の正解の音程と歌唱者の音程の差分を計算し、得点を減点方式で計算します。
得点リスト result から最高得点を求め、最終的な結果を出力します。
'''

# B096 ビンゴゲーム
# utf-8
def main():
    # 入力
    N = int(input())  # Nを入力
    s = [[0] * 4 for _ in range(4)]  # 4x4の二次元リストを作成し、0で初期化
    for i in range(4):
        s[i] = list(map(int, input().split()))  # 4行の数字を入力してsに格納

    p = []
    for _ in range(N):
        p.append(int(input()))  # N個の数字を入力してpに格納

    # すでに選ばれている数字を"-1"に置き換える
    for i in range(N):
        for j in range(4):
            for k in range(4):
                if s[j][k] == p[i]:
                    s[j][k] = -1
                    break

    # リーチチェック
    # 縦を確認
    height = [[0] * 4 for _ in range(2)]  # 高さを格納する二次元リストを作成し、0で初期化
    # 横を確認
    row = [[0] * 4 for _ in range(2)]  # 行を格納する二次元リストを作成し、0で初期化
    # 右下方向斜めを確認
    right_down = [[0] * 1 for _ in range(2)]  # 右下方向斜めを格納する二次元リストを作成し、0で初期化
    # 左下方向斜めを確認
    left_down = [[0] * 1 for _ in range(2)]  # 左下方向斜めを格納する二次元リストを作成し、0で初期化
    answer = -1

    # 縦を確認
    for i in range(4):
        for j in range(4):
            if s[j][i] == -1:
                height[0][i] += 1  # -1の数をカウント
            else:
                height[1][i] = s[j][i]  # -1以外の数字を保存
        if height[0][i] == 3:  # 3つの数字が-1の場合
            answer = height[1][i]  # リーチとなる数字を保存
            break

    # 横を確認
    if answer == -1:
        for i in range(4):
            for j in range(4):
                if s[i][j] == -1:
                    row[0][i] += 1  # -1の数をカウント
                else:
                    row[1][i] = s[i][j]  # -1以外の数字を保存
            if row[0][i] == 3:  # 3つの数字が-1の場合
                answer = row[1][i]  # リーチとなる数字を保存
                break

    # 右下方向斜めを確認
    if answer == -1:
        for i in range(4):
            if s[i][i] == -1:
                right_down[0][0] += 1  # -1の数をカウント
            else:
                right_down[1][0] = s[i][i]  # -1以外の数字を保存
        if right_down[0][0] == 3:  # 3つの数字が-1の場合
            answer = right_down[1][0]  # リーチとなる数字を保存

    # 左下方向斜めを確認
    if answer == -1:
        for i, j in zip(range(4), range(3, -1, -1)):
            if s[i][j] == -1:
                left_down[0][0] += 1  # -1の数をカウント
            else:
                left_down[1][0] = s[i][j]  # -1以外の数字を保存
        if left_down[0][0] == 3:  # 3つの数字が-1の場合
            answer = left_down[1][0]  # リーチとなる数字を保存

    if answer == -1:
        print("no")
    else:
        print(answer)


if __name__ == "__main__":
    main()
'''
このコードは、ビンゴのゲームをシミュレートしてリーチの状態をチェックするものです。
main()関数はプログラムのエントリーポイントです。ここから処理が始まります。
最初に、変数Nに整数値を入力します。これはリーチの数字の個数を表します。
sという2次元リストを作成し、4x4の盤面を表現します。初期値はすべて0です。
4行の入力があり、それぞれの行には4つの数字がスペース区切りで入力されます。これらの数字はビンゴの盤面を表します。
変数pはリーチの数字を格納するリストです。N回の入力があり、リーチの数字が入力されます。
リーチの数字がすでに選ばれている場合、その数字を盤面上の該当する位置に置き換えます。すでに選ばれている数字は-1として表現されます。
リーチチェックのための変数を初期化します。heightは縦方向、rowは横方向、right_downは右下方向の斜め、left_downは左下方向の斜めを表します。
それぞれのリストの最初の要素はリーチの数字が選ばれた回数を、2番目の要素はリーチの数字自体を格納します。
縦方向のリーチをチェックします。height[0]は-1の数をカウントし、height[1]は-1以外の数字を保存します。-1の数が3つになった場合、リーチとなる数字をanswerに保存します。
横方向のリーチをチェックします。row[0]は-1の数をカウントし、row[1]は-1以外の数字を保存します。-1の数が3つになった場合、リーチとなる数字をanswerに保存します。
右下方向の斜めのリーチをチェックします。right_down[0]は-1の数をカウントし、right_down[1]は-1以外の数字を保存します。-1の数が3つになった場合、リーチとなる数字をanswerに保存します。
左下方向の斜めのリーチをチェックします。left_down[0]は-1の数をカウントし、left_down[1]は-1以外の数字を保存します。-1の数が3つになった場合、リーチとなる数字をanswerに保存します。
最後に、answerの値をチェックして、リーチがある場合はその数字を出力し、リーチがない場合は"no"を出力します。
ビンゴの盤面からリーチの状態を判定し、結果を出力する仕組みになっています。
'''

# B096(2) 爆弾の大爆発
# utf-8
def count_explosion_cells(field):
    H = len(field)
    W = len(field[0])

    # 爆風が広がるマスの数をカウントする変数
    count = 0

    # 各行の爆弾の位置を記録するリスト
    row_bombs = [False] * H

    # 各列の爆弾の位置を記録するリスト
    col_bombs = [False] * W

    # 爆弾の位置を調べて記録する
    for i in range(H):
        for j in range(W):
            if field[i][j] == '#':
                row_bombs[i] = True
                col_bombs[j] = True

    # 爆風が広がるマスの数を計算する
    for i in range(H):
        for j in range(W):
            if row_bombs[i] or col_bombs[j]:
                count += 1

    return count


# 入力を受け取る
H, W = map(int, input().split())
field = [input() for _ in range(H)]

# 爆風が広がるマスの数を計算する
result = count_explosion_cells(field)

# 結果を出力する
print(result)
'''
与えられたフィールドの情報を解析し、爆風が広がるマスの数を計算するためのものです。
まず、count_explosion_cellsという関数を定義します。この関数は、フィールドの情報を受け取り、爆風が広がるマスの数を返します。
関数内で、まず与えられたフィールドの行数をH、列数をWとして取得します。
次に、countという変数を初期化し、爆風が広がるマスの数をカウントするための準備をします。
さらに、row_bombsとcol_bombsというリストを初期化します。これらのリストは、各行と各列に爆弾が存在するかどうかを記録します。初期値はすべてFalseです。
次に、二重のループを使ってフィールド上の各マスを調べ、爆弾の位置をrow_bombsとcol_bombsに記録します。もし爆弾がある場合、対応する行と列のフラグをTrueにします。
その後、再び二重のループを使って各マスを調べ、その行または列に爆弾がある場合には爆風が広がるため、countをインクリメントします。
最後に、countを返します。
メインの処理では、まず入力として与えられるフィールドの行数と列数を受け取ります。
次に、fieldというリストにフィールドの情報を行ごとに格納します。
そして、先ほど定義したcount_explosion_cells関数を呼び出し、結果をresultという変数に格納します。
最後に、resultを出力します。
このコードを実行すると、与えられたフィールドの中で爆風が広がるマスの数が計算され、出力されます。
'''

# B097 カウンター席
# utf-8
def ramen_shop_simulation():
    import sys
    input = sys.stdin.read
    data = input().strip().split()
    
    # カウンター席の数とグループの数を読み取る
    idx = 0
    N = int(data[idx])
    idx += 1
    M = int(data[idx])
    idx += 1
    
    groups = []
    
    # 各グループのデータを読み取る
    for _ in range(M):
        G_i = int(data[idx])
        idx += 1
        times = [int(data[idx + j]) for j in range(G_i)]
        idx += G_i
        groups.append((G_i, times))
    
    # 座席の初期化（-1 は空席を表す）
    seats = [-1] * N
    
    # 現在の時間
    current_time = 0
    
    # 各グループを処理する
    for G_i, times in groups:
        # 現在のグループに十分な空席が見つかるまで待つ
        while True:
            # G_i 連続する空席のセグメントを探す
            found = False
            for start in range(N - G_i + 1):
                if all(seats[start + i] == -1 for i in range(G_i)):
                    # グループをこれらの席に配置する
                    for i in range(G_i):
                        seats[start + i] = times[i] + current_time
                    found = True
                    break
            
            if found:
                break
            
            # 次のイベント（最短完食時間）まで時間を進める
            current_time = min([seat for seat in seats if seat != -1])
            # 現在の時間で完食した席を空席に戻す
            seats = [-1 if seat == current_time else seat for seat in seats]
    
    # 全てのグループが席に座った後、最大の完食時間を求める
    final_time = max(seats)
    
    print(final_time)

# この行はスクリプトを直接実行する際のテスト用です
if __name__ == "__main__":
    ramen_shop_simulation()
'''
入力の読み取り：input()で全体の入力を読み取り、データをスペースで分割します。
初期設定：座席の数とグループの数を読み取ります。各グループのデータをリストに格納します。
座席管理：座席の状況をリストで管理し、初期値はすべて-1（空席）とします。
グループ配置：各グループについて、連続する空席が見つかるまで時間を進めます。連続する空席が見つかったら、そのグループのメンバーの完食時間を設定します。
時間更新：全グループが座席に座った後、全員の退店時間（完食時間）を求め、その最大値を出力します。
sys.stdin.readで標準入力全体を一度に読み取り、スペースで分割してdataリストに格納します。このリストには、カウンター席の数、グループの数、各グループの人数とそのメンバーが完食するまでの時間が順番に含まれています。
dataリストから最初の2つの要素を取り出し、カウンター席の数Nとグループの数Mを取得します。idxは現在の読み取り位置を示すインデックスです。
グループごとに、人数G_iと各メンバーの完食時間を読み取ります。これらの情報はタプル(G_i, times)としてリストgroupsに格納されます。
カウンター席の状態をリストseatsで管理します。初期状態ではすべて-1とし、これは空席を示します。
シミュレーションの現在の時間をcurrent_timeとして初期化します。
各グループについて、全員が横並びで座れる連続した空席を探します。見つかった場合、そのグループの各メンバーの完食時間をseatsに記録します。もし見つからない場合、現在の時間を最短の完食時間に進め、該当する席を空席に戻します。
すべてのグループが座席に座った後、seatsリストの最大値（最も遅く完食する時間）を求めます。
最終的に、全員が完食するまでにかかった時間final_timeを出力します。
'''

# B098 バズの検出
# utf-8
# 発言ごとにT回、連続して配列の値を足し合わせてバズ判定を行う関数
def bazzCheck(commentArr, M, T, K):
    groupCounter = M - T + 1
    counter = 0
    for i_1 in range(groupCounter):
        ans = 0
        for i_2 in range(T):
            ans += commentArr[i_1 + i_2]
            if ans >= K:
                return ["yes", i_1 + i_2 + 1]
        counter += 1
    return ["no", 0]

# 入力を読み込む
N, M, T, K = map(int, input().split())
commentArrs = []
for _ in range(M):
    dataArr = list(map(int, input().split()))
    commentArrs.append(dataArr)

ansArrs = []
# 各発言に対してバズ判定を行う
for i in range(N):
    commentArr = [commentArrs[j][i] for j in range(M)]  # 各発言の配列を取得
    ansArrs.append(bazzCheck(commentArr, M, T, K))

# 結果を出力する
for ansArr in ansArrs:
    print(ansArr[0], ansArr[1])
'''
bazzCheck()関数は、与えられた発言の配列に対してバズ判定を行う関数です。発言ごとにT回、連続して配列の値を足し合わせて、その合計値がK以上になるかどうかを判定します。合計値がK以上になった場合は、"yes"とその発言の開始時間を返し、そうでなければ"no"と0を返します。
メインの処理は、以下のようになっています。
入力値を取得し、N, M, T, Kに代入します。
commentArrsという空のリストを作成します。
M回のループを実行し、各発言の配列を取得してcommentArrsに追加します。
ansArrsという空のリストを作成します。
N回のループを実行し、各発言に対してbazzCheck関数を適用し、結果をansArrsに追加します。
ansArrsの結果を出力します。
'''

# B099 台風の接近
# utf-8
# 回答方針
# (1) 各ルート毎の連想配列を作成...cf.[0:[0:100][1:200]...],]
# (2) ルート毎の降水量を足し合わせて、閾値(M)と比較
# (3) 閾値を超えない場合は、そのルート番号を配列で保持
# (4) (3)を空文字区切りで表示、一つもない場合は"wait"と出力

N, M = map(int, input().split())  # 地図のサイズ N, 通れない降水量 M を取得
calLists = []  # 各地区の降水量を格納するリスト
routeLists = []  # 各列の降水量を格納するリスト
ansLists = []  # 通ることができるルートの番号を格納するリスト

# 各地区の降水量を取得
for _ in range(N):
    routes = list(map(int, input().split()))
    calLists.append(routes)

# 各列の降水量を格納
for x in range(N):
    route = []
    for y in range(N):
        route.append(calLists[y][x])
    routeLists.append(route)

# ルート毎の降水量を、閾値(M)と比較
for x, routes in enumerate(routeLists):
    for y, route in enumerate(routes):
        if M <= route:  # 降水量が閾値を超えた場合、そのルートは通れない
            break
        elif y == len(routes) - 1:
            ansLists.append(x + 1)  # 降水量が閾値を超えなかった場合、通ることができるルート

# 通ることができるルートの番号を表示、一つもない場合は"wait"と出力
if not ansLists:
    print("wait")
else:
    print(" ".join(str(ans) for ans in ansLists))
'''
与えられた地図と降水量の情報を元に、会社へ通うことができるルートを見つけるプログラムです。
まず、入力から地図のサイズNと通れない降水量Mを受け取ります。その後、各地区の降水量を取得し、2次元リストcalListsに格納します。また、各列の降水量を保持するために、routeListsというリストも用意します。
次に、各列の降水量を取得してrouteListsに格納します。これにより、各列ごとに降水量を確認できるようになります。
その後、ルート毎の降水量を閾値Mと比較します。具体的には、2重のループを使用して各列の降水量を順に確認し、閾値Mを超えた場合はそのルートは通れないことになります。ルート毎に降水量を比較し、閾値を超えない場合はそのルート番号をansListsに追加します。
最後に、ansListsを出力します。もしansListsが空であれば、"wait"と出力します。それ以外の場合は、ansListsの要素を空文字区切りで結合して出力します。
'''

# B100 計算の遅延
# utf-8
# 入力の解析
N = int(input())
score_changes = []
for _ in range(N):
    t, d, s = map(int, input().split())
    score_changes.append((t, d, s))

Q = int(input())
queries = [int(input()) for _ in range(Q)]

# 指定した時刻における表示スコアと正確なスコアの差を計算する関数
def calculate_score_difference(target_time):
    display_score = 0  # 表示スコア
    exact_score = 0  # 正確なスコア
    for t, d, delta in score_changes:
        if t <= target_time:
            exact_score += delta
            if t + d <= target_time:
                display_score += delta
    difference = exact_score - display_score
    return difference

# 各質問に対してスコアの差を計算し、出力
for query in queries:
    difference = calculate_score_difference(query)
    print(difference)
'''
与えられたスコア変化のリストとクエリのリストに基づいて、指定された時刻における表示スコアと正確なスコアの差を計算します。
まず、入力を解析し、スコア変化のリスト score_changes とクエリのリスト queries を作成します。score_changes リストは、各スコア変化のタイムスタンプ t、遅延時間 d、スコア変化量 s をタプルとして保持します。
queries リストには、計算したいクエリの時刻が含まれます。次に、calculate_score_difference 関数を定義します。
この関数は、引数としてターゲットの時刻を受け取り、その時刻における表示スコアと正確なスコアの差を計算します。
初期値として display_score と exact_score をそれぞれ 0 で初期化します。score_changes リストを順に処理し、各スコア変化に対して以下の処理を行います。
もしスコア変化のタイムスタンプ t がターゲットの時刻以下であれば、正確なスコア exact_score にスコア変化量 s を加算します。
もしスコア変化のタイムスタンプ t に遅延時間 d を加えた時刻がターゲットの時刻以下であれば、表示スコア display_score にスコア変化量 s を加算します。
最後に、正確なスコアと表示スコアの差を計算し、その差を返します。
最後のループでは、各クエリに対して calculate_score_difference 関数を呼び出し、結果を出力します。
計算に遅延が含まれなくなり、スコアの加算も直接行われるため、正確なスコアと表示スコアの差をより迅速に計算できるようになりました。
'''
--------------------------------------------- B101　※欠番 ◆
# B101 ◆
# B102 膨張と収縮
# utf-8
def expand_shrink(DataArr, operation):
    H = len(DataArr)
    W = len(DataArr[0])
    
    def changePix(color, newDataArr, i, j):
        if i == 0:
            if j == 0:  # 左上隅
                newDataArr[i][j + 1] = color
                newDataArr[i + 1][j] = color
            elif j == W - 1:  # 右上隅
                newDataArr[i][j - 1] = color
                newDataArr[i + 1][j] = color
            else:  # １行目
                newDataArr[i][j - 1] = color
                newDataArr[i][j + 1] = color
                newDataArr[i + 1][j] = color
        elif i == H - 1:
            if j == 0:  # 左下隅
                newDataArr[i - 1][j] = color
                newDataArr[i][j + 1] = color
            elif j == W - 1:  # 右下隅
                newDataArr[i - 1][j] = color
                newDataArr[i][j - 1] = color
            else:  # 最終行
                newDataArr[i][j - 1] = color
                newDataArr[i - 1][j] = color
                newDataArr[i][j + 1] = color
        else:
            if j == 0:  # 左中隅
                newDataArr[i - 1][j] = color
                newDataArr[i][j + 1] = color
                newDataArr[i + 1][j] = color
            elif j == W - 1:  # 右中隅
                newDataArr[i - 1][j] = color
                newDataArr[i][j - 1] = color
                newDataArr[i + 1][j] = color
            else:  # 中行
                newDataArr[i - 1][j] = color
                newDataArr[i][j + 1] = color
                newDataArr[i + 1][j] = color
                newDataArr[i][j - 1] = color

    newDataArr = [row[:] for row in DataArr]
    for ope in operation:
        color = "#" if ope == "D" else "."
        for i in range(H):
            for j in range(W):
                if DataArr[i][j] == color:
                    changePix(color, newDataArr, i, j)
        DataArr = [row[:] for row in newDataArr]
    
    return DataArr


# 列毎の配列(DataArr),"operation"を配列化(opeArr)
H, W, N = map(int, input().split())

DataArr = []
for _ in range(H):
    row = list(input().strip())
    DataArr.append(row)

opeArr = list(input().strip())

# (2) operationを引数に膨張/縮小結果のDataArrを返す関数を実行
result = expand_shrink(DataArr, opeArr)

# (4) DataArrを画面に表示
for row in result:
    print("".join(row))
'''
このコードは、指定された解答方針に従って、与えられた配列DataArrと操作配列operationに対して膨張と縮小を行う関数expand_shrinkを定義しています。
まず、DataArrの行数をH、列数をWとして取得します。また、changePixという内部関数を定義しています。この関数は、指定された色colorと位置(i, j)に基づいて、ピクセルの変更を行います。
expand_shrink関数では、newDataArrという新しい配列を作成し、DataArrの初期値で初期化します。それぞれの操作opeについて、色colorを設定し、DataArrを走査して色が一致するピクセルの周囲のピクセルを変更します。その後、DataArrをnewDataArrの値で更新します。
最終的に、操作が終了した結果のDataArrを返します。
そして、主な処理部分では、入力値としてH、W、Nを取得します。次に、H行の配列データを入力し、opeArrに操作の配列を入力します。
そして、expand_shrink関数にDataArrとopeArrを渡して膨張と縮小を行い、結果をresultに格納します。最後に、resultを表示します。
このコードは、与えられた操作に従って配列を変更し、その結果を表示するものです。
'''

# B103 ◆
# B104 データのクレンジング
# utf-8
# 入力の読み込み
N, M = map(int, input().split())

# 設問ごとの回答データを取得
answers = []
for _ in range(N):
    answer = list(map(str, input().split()))
    answers.append(answer)

# クレンジングと平均値の計算
averages = []
for question_index in range(M):
    cleaned_responses = []
    for response in answers:
        try:
            value = int(response[question_index])
            if (0 <= value <= 100) or (value == 0 and len(response[question_index]) > 1):
                cleaned_responses.append(value)
        except ValueError:
            pass
    
    if len(cleaned_responses) == 0:
        average = 0
    else:
        average = int(sum(cleaned_responses) / len(cleaned_responses))
    
    averages.append(average)

# 結果の出力
for average in averages:
    print(average)
'''
最初に、回答者の数と設問の数を入力します。設問ごとの回答データを取得します。回答データは2次元リスト answers に格納されます。
クレンジングと平均値の計算を行います。各設問について以下の手順で処理します。
cleaned_responses リストを作成し、クレンジングされた回答を追加します。
回答が整数であり、0以上100以下の範囲に収まるか、または0であり、文字列の長さが1より大きい場合にクレンジングされた回答として扱います。
cleaned_responses リストが空の場合は、平均値を0とします。
cleaned_responses リストの要素の合計を計算し、要素数で割ることで平均値を求めます。
平均値を整数に変換して averages リストに追加します。
最後に、各設問の平均値を出力します。
'''

# B105 マッピングゲーム
# utf-8
data = list(map(int, input().split()))  # 入力を整数のリストとして取得 [ターン数, yサイズ, xサイズ]
turn_Count, ySize, xSize = data[0], data[1], data[2]
board_Size = [[False] * xSize for _ in range(ySize)]  # マス目の使用状況を管理する2次元配列
red_Have = [[False] * xSize for _ in range(ySize)]  # 赤プレイヤーが占有しているかどうかを管理する2次元配列
blue_Have = [[False] * xSize for _ in range(ySize)]  # 青プレイヤーが占有しているかどうかを管理する2次元配列
green_Have = [[False] * xSize for _ in range(ySize)]  # 緑プレイヤーが占有しているかどうかを管理する2次元配列
playersCount = 3
red_Count, blue_Count, green_Count = 0, 0, 0

def checkingColor(player, y, x):
    """
    プレイヤーがマスを占有しようとしたときの色のチェックを行う関数

    Args:
        player (int): プレイヤーの番号
        y (int): マスのy座標
        x (int): マスのx座標
    """
    if player == 0:
        if blue_Have[y][x]:  # 青プレイヤーが既に占有している場合
            blue_Have[y][x] = False
            green_Have[y][x] = True
        elif green_Have[y][x]:  # 緑プレイヤーが既に占有している場合
            green_Have[y][x] = False
            blue_Have[y][x] = True
        elif red_Have[y][x]:  # 赤プレイヤーが既に占有している場合
            return
    elif player == 1:
        if red_Have[y][x]:  # 赤プレイヤーが既に占有している場合
            red_Have[y][x] = False
            green_Have[y][x] = True
        elif green_Have[y][x]:  # 緑プレイヤーが既に占有している場合
            green_Have[y][x] = False
            red_Have[y][x] = True
        elif blue_Have[y][x]:  # 青プレイヤーが既に占有している場合
            return
    else:
        if red_Have[y][x]:  # 赤プレイヤーが既に占有している場合
            red_Have[y][x] = False
            blue_Have[y][x] = True
        elif blue_Have[y][x]:  # 青プレイヤーが既に占有している場合
            blue_Have[y][x] = False
            red_Have[y][x] = True
        elif green_Have[y][x]:  # 緑プレイヤーが既に占有している場合
            return

def putColor(player, xStart, yStart, mass):
    """
    プレイヤーが色を置く処理を行う関数

    Args:
        player (int): プレイヤーの番号
        xStart (int): 開始マスのx座標
        yStart (int): 開始マスのy座標
        mass (int): マスのサイズ
    """
    global red_Count, blue_Count, green_Count
    for i in range(yStart, yStart + mass):
        if i >= ySize:
            return
        for j in range(xStart, xStart + mass):
            if j >= xSize:
                break
            if board_Size[i][j]:  # すでにマスが使用されている場合
                checkingColor(player, i, j)
            else:
                board_Size[i][j] = True  # マスを使用済みにする
                if player == 0:
                    red_Have[i][j] = True  # 赤プレイヤーが占有
                elif player == 1:
                    blue_Have[i][j] = True  # 青プレイヤーが占有
                else:
                    green_Have[i][j] = True  # 緑プレイヤーが占有

# ターンごとのプレイヤーの入力を処理する
for _ in range(turn_Count):
    for i in range(playersCount):
        putData = list(map(int, input().split()))  # プレイヤーの入力を整数のリストとして取得 [x座標, y座標, マスのサイズ]
        x, y, massSize = putData[0], putData[1], putData[2]
        putColor(i, x, y, massSize)

# 各色の占有マス数をカウントする
for i in range(ySize):
    for j in range(xSize):
        if red_Have[i][j]:
            red_Count += 1  # 赤色の占有マス数をカウント
        elif blue_Have[i][j]:
            blue_Count += 1  # 青色の占有マス数をカウント
        elif green_Have[i][j]:
            green_Count += 1  # 緑色の占有マス数をカウント

print(f"{red_Count} {blue_Count} {green_Count}")
'''
最初に、ゲームの設定情報を入力します。ターン数、マップの縦サイズ、マップの横サイズを取得します。
ゲームの状態を管理するための配列や変数を初期化します。board_Sizeはマス目の使用状況を管理する2次元配列で、red_Have、blue_Have、green_Haveは各プレイヤーが占有しているかどうかを管理する2次元配列です。
ターン数だけループを実行し、各ターンでプレイヤーの入力を処理します。各プレイヤーの番号と、マスを占有するための情報（x座標、y座標、マスのサイズ）を入力として受け取ります。
putColor関数は、プレイヤーが色を置く処理を行います。指定された範囲のマスを占有するかどうかを判断します。マスがすでに使用されている場合は、checkingColor関数を呼び出して色のチェックを行います。
使用されていない場合は、マスを占有し、該当するプレイヤーの情報を更新します。ゲーム終了後、各色の占有マス数をカウントします。
2重のループを使用して、各マスの状態をチェックし、占有されている色に応じて対応する変数をインクリメントします。
最後に、赤、青、緑の占有マス数を表示します。
このコードは、マッピングゲームを実行し、最終的な占有マス数を計算するためのものです。各プレイヤーの入力を処理し、マスの状態を更新しています。
'''

# B106 席替えの席決め
# utf-8
# 生徒の座席を設定する関数
def set_seat(student_arr, col_arrs):
    for row, col_arr in enumerate(col_arrs):
        for student_no, seat_no in student_arr.items():
            for col, seat in enumerate(col_arr):
                if seat["seatNo"] == seat_no:
                    col_arrs[row][col]["student"] = student_no
                    break
    return col_arrs

# 座席を詰める関数
def pack_seat(col_arrs, H):
    for w, col_arr in enumerate(col_arrs):
        student_list = [seat["student"] for seat in col_arr]
        packed_students = [student for student in student_list if student != 0]
        for i in range(H):
            if i < len(packed_students):
                col_arrs[w][i]["student"] = int(packed_students[i])
            else:
                col_arrs[w][i]["student"] = 0
    return col_arrs

# 座席の配置を出力する関数
def answer(col_arrs, H, W):
    for row in range(H):
        answer = ""
        for col in range(W):
            answer += str(col_arrs[col][row]["student"]) + (" " if col != W - 1 else "")
        print(answer)

# 入力: H, W, N
H, W, N = map(int, input().split())

student_arr = {}
# 入力: 生徒の座席番号
for i in range(1, N + 1):
    student_arr[i] = int(input())

row_arrs = [[] for _ in range(H)]
index = 1
# 行の配列を作成
for h in range(H):
    for w in range(W):
        row_arrs[h].append({"seatNo": index, "student": 0})
        index += 1

col_arrs = [[] for _ in range(W)]
# 列の配列を作成
for row in range(W):
    index = row + 1
    for col in range(H):
        col_arrs[row].append({"seatNo": index, "student": 0})
        index += W

# 生徒の座席を設定
col_arrs = set_seat(student_arr, col_arrs)

# 座席を詰める
col_arrs = pack_seat(col_arrs, H)

# 座席の配置を出力
answer(col_arrs, H, W)
'''
最初の部分では、変数 H、W、N を入力として受け取ります。それぞれ、教室の行数、列数、生徒の数を表しています。
次に、生徒の座席番号を入力として受け取ります。student_arr という辞書型の変数に生徒の番号をキー、座席番号を値として格納しています。
row_arrs というリストを作成します。これは、教室の行ごとに座席の情報を格納するためのリストです。各行には、座席番号と生徒の番号を格納する辞書が含まれます。
col_arrs というリストも作成します。これは、教室の列ごとに座席の情報を格納するためのリストです。各列には、座席番号と生徒の番号を格納する辞書が含まれます。
set_seat 関数を使用して、生徒の座席を設定します。生徒の座席番号と教室の座席情報を比較し、一致する場合に生徒の番号を格納します。
pack_seat 関数を使用して、座席を詰めます。各列ごとに生徒の番号を詰めて配置し、前の列に空席がある場合に詰め込まれた生徒の位置を調整します。
最後に、answer 関数を使用して座席の配置を出力します。各行ごとに生徒の番号を表示し、列ごとにスペースで区切ります。
'''

# B107 カードシャッフル
# utf-8
# カードを束ごとにシャッフルする関数
def card_bundle(cards_arr, roup_count, remainder, last_key, M):
    right_counter = 0
    left_counter = last_key
    new_cards_arr = [None] * len(cards_arr)
    
    for i in range(roup_count):
        if remainder >= 1 and i == 0:
            # 最後のカードの束がM枚未満の場合の処理
            for i_s in range(remainder):
                new_cards_arr[i_s] = cards_arr[left_counter - (remainder - i_s)]
            
            left_counter -= remainder
            right_counter += remainder
        else:
            # 通常の束の処理
            for i_s in range(M):
                new_cards_arr[i_s + right_counter] = cards_arr[left_counter - (M - i_s)]
            
            left_counter -= M
            right_counter += M
    
    return new_cards_arr


# 入力値の受け取り
N, M, K = map(int, input().split())
remainder = N % M
roup_count = (N // M) + 1 if remainder >= 1 else N // M
cards_arr = list(range(1, N + 1))
last_key = len(cards_arr)

# カードのシャッフル
for _ in range(K):
    cards_arr = card_bundle(cards_arr, roup_count, remainder, last_key, M)

# シャッフル後の結果を出力
for card in cards_arr:
    print(card)
'''
このコードは、与えられたカードの枚数を指定されたセットの枚数で束に分け、指定された回数だけシャッフルした後のカードの順序を出力します。
card_bundle 関数:
カードを束ごとにシャッフルするための関数です。
引数として、シャッフル前のカードの配列 (cards_arr)、束の枚数 (roup_count)、最後の束の枚数 (remainder)、シャッフル前のカードの最後のインデックス (last_key)、束ごとの枚数 (M) を受け取ります。
シャッフル後のカードを格納する新しい配列 (new_cards_arr) を作成し、束ごとにシャッフル処理を行います。
最後のカードの束が M 枚未満の場合と通常の束の処理を分けて実行します。

入力値の受け取り:
N, M, K の値を入力から受け取ります。
N はカードの枚数、M は1セットあたりの枚数、K はシャッフルの回数を表します。

シャッフル処理の準備:
remainder 変数には、カードの枚数をセットごとに分けた際の余りが格納されます。
roup_count 変数には、束の枚数がセットごとに分けた際の総数が格納されます。
cards_arr は、1 から N までの連続した整数を要素とするリストで、シャッフル前のカードを表します。
last_key 変数には、cards_arr の最後の要素のインデックスが格納されます。

カードのシャッフル:
K 回のシャッフル処理を行います。
card_bundle 関数を呼び出し、現在の cards_arr を引数として渡します。
シャッフル後の結果を cards_arr に再代入します。

シャッフル後の結果の出力:
cards_arr の要素を順番に出力します。
各カードの数字を整数として1行ずつ出力します。
'''

# B108 観覧車の稼働状況
# utf-8
from collections import deque  # キューやスタックの操作に使用するデック（deque）をインポート
from dataclasses import dataclass  # オブジェクトのデータクラスを定義するためのimport文
from typing import List  # リスト型を使用するためのimport文

@dataclass
class Gondola:
    capacity: int  # ゴンドラの収容人数を表す整数
    ride_log: List[int]  # 乗車した人数のログを表すリスト
    idx: int  # ゴンドラのインデックスを表す整数

    def get_total_ride(self) -> int:
        return sum(self.ride_log)


def answer() -> None:
    # ゴンドラの数とグループの数を取得
    N, M = map(int, input().split())  # ゴンドラの数とグループの数を表す整数

    # ゴンドラの収容人数をリストとして取得
    A = [int(input()) for _ in range(N)]  # 各ゴンドラに乗車できる人数の制限を表す整数のリスト

    # グループの人数をリストとして取得
    B = [int(input()) for _ in range(M)]  # 各グループの人数を表す整数のリスト

    # ゴンドラのキューを初期化
    gondola_queue = deque([
        Gondola(capacity, [], idx+1)
        for idx, capacity in enumerate(A)
    ])

    # グループのキューを初期化
    group_queue = deque(B)

    while group_queue:
        group_size = group_queue.popleft()  # 待っているグループから人数を取り出す
        while group_size > 0:
            gondola = gondola_queue.popleft()  # 先頭のゴンドラを取り出す

            if gondola.capacity >= group_size:  # ゴンドラに乗れるだけの人数が残っている場合
                gondola.ride_log.append(group_size)  # ゴンドラに乗った人数をログに追加
                group_size = 0  # グループの残り人数を0にする
            else:  # ゴンドラに乗れるだけの人数が残っていない場合
                gondola.ride_log.append(gondola.capacity)  # ゴンドラに乗った人数をログに追加
                group_size -= gondola.capacity  # グループの残り人数から乗った人数を引く

            gondola_queue.append(gondola)  # ゴンドラをキューの末尾に追加

    # ゴンドラのキューを回転して最初のゴンドラを先頭にする
    while gondola_queue[0].idx != 1:
        gondola_queue.rotate(-1)

    # 各ゴンドラのトータルの乗車人数を出力
    for gondola in gondola_queue:
        print(gondola.get_total_ride())


if __name__ == "__main__":
    answer()
'''
ゴンドラの収容人数と待ちグループの人数を管理して、ゴンドラに乗車する人数を計算するプログラムです。
まず、Gondoraというデータクラスが定義されています。このクラスは、ゴンドラの収容人数(capacity)、乗車した人数のログ(ride_log)、およびゴンドラのインデックス(idx)を保持します。また、get_total_ride()メソッドを持ち、乗車した人数の合計を計算することができます。
answer関数は、ゴンドラの収容人数と待ちグループの人数を受け取り、各ゴンドラに乗車する人数を計算して出力します。
まず、与えられたゴンドラの収容人数とインデックスを使用して、初期状態のゴンドラのリストを作成します。また、待ちグループの人数を管理するためのキューを作成します。
次に、待ちグループのキューが空になるまで、以下の処理を繰り返します。

待ちグループのキューから一人分の人数を取り出します。
ゴンドラのリストから先頭のゴンドラを取り出します。
ゴンドラの収容人数が待ちグループの人数以上であれば、待ちグループの人数全員が乗車できます。その場合は、ゴンドラの乗車ログに乗車した人数を追加し、待ちグループの人数から乗車した人数を引きます。
ゴンドラの収容人数が待ちグループの人数より少ない場合、ゴンドラの収容人数分だけ乗車できます。その場合は、ゴンドラの乗車ログに収容人数を追加し、待ちグループの人数から収容人数を引きます。
ゴンドラを再度キューの末尾に追加します。
待ちグループのキューが空になった後は、ゴンドラのリストを再度並び替えます。これは、最初に取り出したゴンドラがゴンドラのリストの最後に来るようにするためです。

最後に、ゴンドラのリストを順番に処理し、各ゴンドラの乗車人数の合計を出力します。
'''

# B109 映画館の席の予約
# utf-8
# 入力から映画館の情報を取得
N, H, W, P, Q = map(int, input().split())

# 予約されていない席の情報を保持する2次元リストを作成
vacant = [[True for _ in range(W)] for _ in range(H)]

# 予約された席の情報を取得し、予約済みの座席をFalseに設定
for _ in range(N):
    p, q = map(int, input().split())
    vacant[p][q] = False

# 最も見やすい席とのマンハッタン距離の初期値を設定
mh = W + H

# 最も見やすい席とのマンハッタン距離が最小となる座席を探索し、その距離を更新
for i in range(H):
    for j in range(W):
        if vacant[i][j] and mh > abs(P - i) + abs(Q - j):
            mh = abs(P - i) + abs(Q - j)

# 最も見やすい席とのマンハッタン距離が最小の座席を保持するリストを初期化
seats = []

# 最も見やすい席とのマンハッタン距離が最小となる座席を抽出し、リストに追加
for i in range(H):
    for j in range(W):
        if vacant[i][j] and mh == abs(P - i) + abs(Q - j):
            seats.append((i, j))

# 最も見やすい席の座標を出力
for seat in seats:
    print(seat[0], seat[1])
'''
まず、最初の行では入力から映画館の情報を取得しています。Nは予約された席の数、Hは座席の縦の数、Wは座席の横の数、PとQは最も見やすい席の座標です。
次に、予約されていない席の情報を保持するための2次元リストvacantを作成します。最初はすべての席が予約されていない状態を表すTrueで初期化されます。
その後、N回のループで予約された席の情報を取得し、予約された座席をFalseに設定しています。
その後、最も見やすい席とのマンハッタン距離の初期値をW + Hと設定します。マンハッタン距離は座標間の縦方向と横方向の距離の合計を表します。
その後、2重のループを使用して、すべての座席を調べています。予約されていない座席でかつ最も見やすい席とのマンハッタン距離が現在の最小値より小さい場合、最小値を更新します。
最後に、再度2重のループを使用して、最も見やすい席とのマンハッタン距離が最小となる座席を抽出し、リストseatsに追加します。
最後のループでは、リストseatsに格納された最も見やすい席の座標を出力します。映画館の座席情報と予約情報に基づき、予約されていない席の中で最も映画を見やすい席の座標を効率的に見つけます。
'''

# B110 解像度の向上
# utf-8
import numpy as np

# ピクセル値を2で割る関数
def func(x):
    return int(x / 2)

# 入力から解像度を読み込む
H, W = map(int, input().split())

# 画像データを読み込む
ex1 = []
ex2 = []

# 画像1のデータを読み込み、2倍に複製して ex1 に格納
for count1 in range(H):
    box = list(map(int, input().split()))
    i = []
    for count2 in range(W):
        i.append(box[count2])
        i.append(box[count2])  # ピクセル値を2倍に複製
    ex1.append(i)
    ex1.append(i)  # 行も2倍に複製

# 画像2のデータを読み込み、2倍に複製して ex2 に格納
for count1 in range(H):
    box = list(map(int, input().split()))
    i = []
    for count2 in range(W):
        i.append(box[count2])
        i.append(box[count2])  # ピクセル値を2倍に複製
    ex2.append(i)
    ex2.append(i)  # 行も2倍に複製

# ピクセルの補間を行い、結果を出力
for count1 in range(len(ex1) - 1):
    # 対応するピクセル同士を足し合わせる
    a = np.array(ex1[count1 + 1][1:]) + np.array(ex2[count1][:-1])
    # ピクセル値を2で割って整数に変換
    ans = list(map(func, a))
    for count2 in range(len(ans)):
        if count2 == len(ans) - 1:
            print(ans[count2])  # 行末のピクセル値は改行
        else:
            print(ans[count2], end=" ")  # それ以外のピクセル値はスペースで区切って表示
'''
2つの画像（image1とimage2）を読み込み、これらの画像から新しい画像を生成するプログラムです。各画像は同じ解像度（H x W）を持っており、ピクセル値（0から255の整数）で表されます。
import numpy as np：NumPyライブラリをインポートして、数値計算を補助します。
def func(x):：ピクセル値を2で割る関数を定義しています。この関数は、後で新しい画像のピクセル値を計算する際に使用されます。
H, W = map(int, input().split())：入力から解像度（HとW）を読み込みます。解像度は、画像の縦と横のピクセル数を示します。
ex1 と ex2：2つの画像データを格納するためのリストです。これらのリストは、画像1（image1）と画像2（image2）のデータを2倍に複製して格納します。これは、新しい画像を生成する際にピクセルの対応を行うためです。
2つの画像データを読み込み、2倍に複製して ex1 と ex2 に格納します。各行のピクセル値を2倍に複製することで、新しい画像の解像度が2倍になります。
for count1 in range(len(ex1) - 1):：ex1 の長さ（行数）から1を引いた回数だけ、ピクセルの補間を行います。これにより、新しい画像のピクセル値が計算されます。
a = np.array(ex1[count1 + 1][1:]) + np.array(ex2[count1][:-1])：新しい画像の各ピクセルに対して、対応するピクセルの値を足し合わせます。np.array を使用して数値の配列を作成し、対応するピクセル同士を足し合わせています。
ans = list(map(func, a))：足し合わせた値を2で割り、小数点以下を切り捨てた整数に変換します。これにより、新しい画像の各ピクセルの値が得られます。
for count2 in range(len(ans)):：新しい画像の各ピクセルの値に対して、以下の処理を行います。
if count2 == len(ans) - 1:：行末のピクセルの場合、改行して次の行に移ります。
else:：それ以外のピクセルの場合、スペースで区切って表示します。これにより、新しい画像が指定された形式で出力されます。
このコードは、2つの画像を組み合わせて新しい画像を生成するための効率的な方法を実装しています。新しい画像のピクセル値は、元の2つの画像の対応する部分の平均値を取り、指定された条件に従って計算されます。
'''
--------------------------------------------- B111　※欠番 ◆
# B111 天秤のつりあい
# utf-8
def min_weight_difference(N, weights):
    total_sum = sum(weights)  # 分銅の総和を計算
    target_sum = total_sum // 2  # 目標の総和を総和の半分に設定

    dp = [False] * (target_sum + 1)  # 部分和の組み合わせを記録する配列を初期化
    dp[0] = True  # 総和が0の場合は部分和の組み合わせが存在するため、Trueとする

    # 動的計画法により部分和の組み合わせを求める
    for weight in weights:
        for i in range(target_sum, weight - 1, -1):
            dp[i] = dp[i] or dp[i - weight]

    k = target_sum
    while not dp[k]:
        k -= 1

    min_difference = total_sum - 2 * k  # 両皿の重さの差の最小値を計算
    return min_difference

# 入力の読み込み
N = int(input())  # 乗せる分銅の数
weights = list(map(int, input().split()))  # 分銅の重さのリスト

# 最小差を求めて出力
result = min_weight_difference(N, weights)
print(result)
'''
まず、min_weight_difference関数は与えられた分銅の重さから両皿の重さの差の最小値を計算するための関数です。
total_sum = sum(weights)
　分銅の重さのリスト weights の総和を計算し、total_sum に代入します。
target_sum = total_sum // 2
　total_sum の半分を target_sum として設定します。この値は、両皿の重さの合計の差の最小値を求める際に使用します。
dp = [False] * (target_sum + 1)
　長さが target_sum + 1 の配列 dp を作成し、初期値をすべて False とします。この配列は、部分和の組み合わせを記録するためのものです。
dp[0] = True
　dp の最初の要素を True にします。総和が0の場合は部分和の組み合わせが存在するため、True とします。
部分和の組み合わせを計算するためのループ処理
　for weight in weights: のループを使用して、分銅の重さを1つずつ取り出します。
　for i in range(target_sum, weight - 1, -1): のループを使用して、target_sum から weight まで逆順にループします。
　dp[i] = dp[i] or dp[i - weight] を実行し、現在の総和 i の部分和の組み合わせが存在するかどうかを判定します。
k の値を求める
　k = target_sum とし、while not dp[k]: のループを使用して dp の値が True となる最初の k を見つけます。
min_difference = total_sum - 2 * k
　total_sum から 2 * k を引いた値を計算し、min_difference に代入します。これは両皿の重さの差の最小値です。
min_difference を返して関数の実行を終了します。
その後、入力の読み込みや関数の呼び出し、結果の出力が行われます。
'''

# B112 ◆
# B113 2のべき連結ゲーム　（参考:2048ゲーム）
# utf-8
def main():
    import sys
    input = sys.stdin.read  # 標準入力からすべての入力を読み込む関数を定義
    data = input().split()  # 入力を空白で分割してリストに変換
    
    N = int(data[0])  # 最初の要素は数字の数
    A = [int(data[i]) for i in range(1, N + 1)]  # 続くN個の要素を整数に変換してリストに格納
    
    ans = [0] * N  # 出力用のリストを初期化
    list_nums = []  # 盤面の数を格納するリストを初期化
    
    list_nums.append(A[0])  # 最初の数を盤面に追加
    
    for i in range(1, N):  # 2つ目以降の数についてループ
        inserted = False  # 数が挿入されたかどうかを追跡するフラグ
        for x in range(len(list_nums)):  # 盤面のリストを走査
            if list_nums[x] <= A[i]:  # 挿入する数が現在の数以下なら
                list_nums.insert(x, A[i])  # 現在の数の前に挿入
                ans[i] = x  # 挿入位置を記録
                inserted = True  # 挿入フラグを立てる
                break  # 挿入が完了したのでループを抜ける
        if not inserted:  # もしどこにも挿入されなかったら
            list_nums.append(A[i])  # リストの末尾に追加
            ans[i] = len(list_nums) - 1  # 挿入位置を記録
        
        x = 1  # インデックスを1に設定
        while x < len(list_nums):  # リスト内の数をチェック
            if list_nums[x - 1] == list_nums[x]:  # 連続する同じ数があれば
                list_nums[x - 1] *= 2  # 前の数を2倍にする
                del list_nums[x]  # 現在の数をリストから削除
                x = 1  # インデックスをリセットして最初からチェック
            else:
                x += 1  # 次のインデックスに進む
    
    for num in ans:  # 出力用リストを走査
        print(num)  # 各挿入位置を出力

if __name__ == "__main__":
    main()  # main関数を呼び出してプログラムを実行
'''
このPythonコードは、与えられた問題の条件に従って、与えられた数値を16個のマスに挿入するプログラムです。
ここでは、与えられた数値は2の累乗の値であり、挿入される数値は左詰めされます。
まず、プログラムは標準入力からデータを読み取ります。このデータには、最初の行にマスに挿入されるべき数の総数が与えられ、続く各行に挿入される数値が記述されています。
次に、それぞれの数値がどの位置に挿入されるかを特定するためのアルゴリズムが適用されます。
アルゴリズムの中心的な部分は、数値を挿入する際のループです。このループでは、挿入する数値が盤面のどの位置に挿入されるかを決定し、それに応じて挿入位置を記録します。
挿入位置が決まった後、連続する同じ数値があればそれらを2倍にし、左詰めします。これにより、数値の連結が実現されます。
最後に、各数値が挿入される位置のインデックスを出力します。これにより、与えられた数値がどの位置に挿入されたかが示されます。
'''

# B114 PAIZA運動会　
# utf-8
def main():
    import sys
    input = sys.stdin.read
    data = input().strip().split("\n")
    
    # 入力の最初の行からNとKを取得
    N, K = map(int, data[0].split())
    
    # 各プレイヤーの記録を取得
    players = []
    for i in range(1, N + 1):
        records = list(map(int, data[i].split()))
        players.append((records, i))
    
    # 各プレイヤーの記録を比較するためにソートする
    # (記録は降順に並べ替え、その次にプレイヤー番号でソート)
    players.sort(key=lambda x: (sorted(x[0], reverse=True), x[1]), reverse=True)
    
    # 最も良い記録を持つプレイヤーの番号を取得する
    best_records = players[0][0]
    result = [players[0][1]]
    
    # 同順位のプレイヤーがいるかどうかを確認
    for i in range(1, N):
        if sorted(players[i][0], reverse=True) == sorted(best_records, reverse=True):
            result.append(players[i][1])
        else:
            break
    
    # プレイヤー番号を昇順にソートして出力
    result.sort()
    for r in result:
        print(r)

if __name__ == "__main__":
    main()
'''
このプログラムは、PAIZA小学校の運動会のジャンプ競技で、最も良い記録を出したプレイヤーを決定するためのものです。
標準入力からすべてのデータを読み込みます。入力されたデータを改行で分割してリストにします。
最初の行からプレイヤーの人数 N と試技の回数 K を取得します。
各プレイヤーの試技の記録をリストに格納します。
各行から試技の記録を取得し、それぞれプレイヤー番号と一緒にタプルとして players リストに追加します。
各プレイヤーの記録を降順に並べ替え、その次にプレイヤー番号でソートします。
sorted(x[0], reverse=True) で記録を降順に並べ替え、それをキーとしてソートします。
reverse=True によって、記録が大きい順に並べられます。
ソートされたリストの中で最も良い記録を持つプレイヤーの番号を取得します。
最初のプレイヤーの記録を best_records として保持し、番号を result リストに追加します。
他のプレイヤーの記録が best_records と同じかどうかを確認します。
同じ場合、そのプレイヤーの番号も result リストに追加します。1位となるプレイヤーの番号を昇順にソートし、出力します。
'''

# B115 アナグラムパズル
# 2つの単語の長さと文字の一致を判定する関数
def judge_match_word_pair(word_a, word_b):
    # 単語の長さが異なる場合、一致しない
    if len(word_a) != len(word_b):
        return 0
    # 単語の長さが同じ場合、文字の一致を判定
    if len(word_a) == len(word_b):
        for i in range(len(word_a)):
            # word_a[i]がword_bに存在するか判定
            match_position = word_b.find(word_a[i])
            if match_position == -1:
                return 0
            # word_a[i]が一致した場合、word_bから取り除く
            if match_position != -1:
                word_b = word_b[:match_position] + word_b[match_position + 1:]
        return 1

# 標準入力から値を取得する関数
def get_stdin():
    return input().strip()

# 単語の数を入力
word_num = int(get_stdin())

words = []
match_word_pair_num = 0

# 単語を入力し、リストに追加
for _ in range(word_num):
    words.append(get_stdin())

all_word_pair = []

# 単語のペアを生成
for i in range(word_num):
    for j in range(i, word_num):
        all_word_pair.append(words[i] + words[j])

# 全ての単語ペアに対して判定を行い、一致する数をカウント
for word_pair in all_word_pair:
    for word in words:
        match_word_pair_num += judge_match_word_pair(word_pair, word)

# 結果を出力
print(match_word_pair_num)
'''
与えられた単語のリストから異なる2つの単語を選び、それらを連結して別の単語を作ることができる組み合わせの数を求める問題です。
まず、標準入力から単語の数を取得し、その後の入力で単語のリストを受け取ります。
次に、全ての単語のペアを生成します。これは、単語リスト内の全ての単語の組み合わせを考えるため、2重のループを使用しています。
生成された単語のペアは、all_word_pairリストに追加されます。その後、全ての単語ペアに対して以下の処理を行います。
まず、単語リスト内の各単語と比較します。比較には、judge_match_word_pairという関数が使用されます。この関数では、2つの単語の長さが一致しているかを確認し、一致している場合は文字の一致を判定します。一致する場合は、match_word_pair_num変数をインクリメントします。
最後に、組み合わせの数であるmatch_word_pair_numを出力します。
'''

# B116 プレゼント交換
# utf-8
H, W, T = map(int, input().split())

# 男性と女性が持っているプレゼントの初期状態
men_gifts = [('M', i) for i in range(1, H+1)]
women_gifts = [('F', i) for i in range(1, W+1)]

# 男性と女性の初期座標
men_pos = [(i, 0) for i in range(1, H+1)]
women_pos = [(0, j) for j in range(1, W+1)]

for t in range(1, T+1):
    # 男性の時間tの座標
    men_t = t % (2 * W)
    if men_t > W:
        men_t = 2 * W - men_t
    men_pos = [(i, men_t) for i in range(1, H+1)]

    # 女性の時間tの座標
    women_t = t % (2 * H)
    if women_t > H:
        women_t = 2 * H - women_t
    women_pos = [(women_t, j) for j in range(1, W+1)]

    # それぞれの男女が同じ座標であればプレゼントを交換する
    for r in range(H):
        for c in range(W):
            if men_pos[r] == women_pos[c]:
                men_gifts[r], women_gifts[c] = women_gifts[c], men_gifts[r]

# 出力
for gift in men_gifts:
    print(gift[0], gift[1])
for gift in women_gifts:
    print(gift[0], gift[1])
'''
与えられた部屋の縦幅(H)、横幅(W)、および交換会の時刻(T)に対して、プレゼント交換が終わった後のプレゼントの元々の持ち主を計算して出力するPythonの実装です。
最初に、入力から部屋の縦幅(H)、横幅(W)、および交換会の時刻(T)を受け取ります。
男性と女性が持っているプレゼントの初期状態をリストで作成します。男性は'M'と数字のペア、女性は'F'と数字のペアのタプルで表されています。例えば、男性が2人であれば、men_gifts = [('M', 1), ('M', 2)]となります。
男性と女性の初期座標をリストで作成します。男性の初期座標は(i, 0)、女性の初期座標は(0, j)となります。
時刻tにおける男性と女性の座標を計算します。男性は速度1で東西に往復し続けるため、時間tにおける座標はt % (2 * W)となります。ここで、t % (2 * W)は0から2*W-1の範囲の値を取ります。男性の座標は(1, t % (2 * W))から(2, t % (2 * W))となるため、men_pos = [(i, t % (2 * W)) for i in range(1, H+1)]として計算されます。女性の座標も同様に計算します。
男性と女性の座標が同じ場合、プレゼントを交換します。具体的には、男性と女性の持ち物を入れ替えます。
交換が終了した後、男性と女性のプレゼントの元々の持ち主を出力します。
コードの内容は正確ですが、プレゼントの交換を行うループがT回分だけ行われる必要があります。そのため、交換を行うループ部分をT回分だけfor文で囲む必要があります。
'''

# B117 回る教習車
# utf-8
import sys

file = '/dev/stdin' if sys.platform == 'linux' else './input.txt'

# ファイルを読み込んで行ごとにリストに格納する
with open(file) as f:
    lines = f.read().strip().split('\n')

N = int(lines[0])  # 教習車の台数
nums = list(map(int, lines[1:]))  # 教習車の車番リスト

nums.reverse()  # 車番リストを逆順にする

count = 1  # カウント
result = 0  # 公道に出た教習車の数

while len(nums) != 1:
    pop = nums.pop()  # リストの末尾の要素を取り出す
    if N == pop:
        result += 1
    nums.insert(0, pop)  # 取り出した要素をリストの先頭に挿入

    if pop == count:  # カウントと取り出した要素が一致する場合
        count += 1
        nums.pop(0)  # リストの先頭の要素を削除

print(result)  # 公道に出た教習車の数を出力
'''
このコードは、教習車の台数と車番リストが与えられた場合に、最後に公道に出る教習車が公道に出るまでに教習所内のコースを何周する必要があるかを計算するものです。
まず、import sysを使ってsysモジュールをインポートし、プラットフォームに応じてファイルの読み込み方法を決定します。Linuxの場合は'/dev/stdin'、それ以外の場合は'./input.txt'となります。
次に、with open(file) as f:を使ってファイルを開き、行ごとにリストに格納します。
N = int(lines[0])によって、教習車の台数が取得されます。nums = list(map(int, lines[1:]))によって、教習車の車番リストが取得されます。
nums.reverse()を使って、車番リストを逆順にします。これにより、教習車の出発順序を公道に出る順序に変換します。
count = 1とresult = 0は、カウントと公道に出た教習車の数を追跡するための変数です。
ループ処理が行われます。リストの長さが1でない限り、以下の処理が繰り返されます。
pop = nums.pop()によって、リストの末尾の要素が取り出されます。この要素は、教習所内のコースを進んで公道に出ていく教習車を表します。
if N == pop:によって、取り出した要素が公道に出る最後の教習車であるかを判定します。もし最後の教習車であれば、resultの値が1増えます。
nums.insert(0, pop)によって、取り出した要素がリストの先頭に挿入されます。これにより、教習車がコースを回り続けることが表現されます。
if pop == count:によって、取り出した要素とカウントが一致するかを判定します。もし一致すれば、カウントを1増やし、リストの先頭の要素を削除します。これにより、教習車が公道に出たことを示します。
ループが終了した後、print(result)によって、公道に出た教習車の数が出力されます。
'''

# B118 背の順
# utf-8
def compare_students(a, b):
    if a[1] != b[1]:
        return a[1] - b[1]  # 背の高さで比較
    elif a[2] != b[2]:
        return b[2] - a[2]  # 誕生月の数字で比較
    else:
        return -1 if a[0] < b[0] else 1  # 名前の辞書順で比較

def sort_students(students):
    students.sort(key=lambda x: (x[1], -x[2], x[0]))  # 条件に従って並び替え

N = int(input())  # 生徒の人数
students = []
for _ in range(N):
    name, height, birth_month = input().split()
    height = int(height)
    birth_month = int(birth_month)
    students.append((name, height, birth_month))  # 生徒の情報をリストに追加

sort_students(students)  # 生徒リストを並び替え

for student in students:
    print(student[0])  # 生徒の名前を出力
'''
まず、入力から生徒の人数を取得します。次に、生徒の情報を受け取り、それぞれの生徒の名前、身長、誕生月をリストに格納します。このとき、身長と誕生月は整数に変換されます。
次に、定義したsort_students関数を使って、生徒リストを並び替えます。この関数では、以下の条件に従って生徒をソートします。
身長の昇順に並べる。
身長が同じ場合は、誕生月の降順に並べる。
身長と誕生月が同じ場合は、名前の辞書順に並べる。
最後に、並び替えた生徒リストを順番に出力します。ここでは、生徒の名前だけを出力しています。
このプログラムは、与えられた生徒の情報を条件に従って並び替え、最終的な並び順を出力するものです。
条件によって優先順位が決められ、ソートアルゴリズムに基づいて生徒リストを操作しています。
'''

# B119 投網
# utf-8
def catch_fish():
    # 入力から値を読み取る
    H, W = map(int, input().split())
    radar = [list(map(int, input().split())) for _ in range(H)]
    R, C = map(int, input().split())
    net = [list(input()) for _ in range(R)]

    max_fish = 0

    # 網を投げ入れる全ての位置を試す
    for i in range(H - R + 1):
        for j in range(W - C + 1):
            total_fish = 0

            # 網が重なる範囲内の魚の総数を計算する
            for r in range(R):
                for c in range(C):
                    if net[r][c] == '#':
                        total_fish += radar[i + r][j + c]

            # 最大の魚の総数を更新する
            max_fish = max(max_fish, total_fish)

    return max_fish

# 関数を呼び出して結果を出力
result = catch_fish()
print(result)
'''
catch_fish() 関数を定義します。この関数は入力から値を読み取り、問題を解決します。
H, W = map(int, input().split()) を使って、海域の縦幅 H と横幅 W を入力から読み取ります。
radar = [list(map(int, input().split())) for _ in range(H)] を使って、H 行分の海域の情報を入力から読み取り、2次元リスト radar に格納します。各行の値は整数のリストとなります。
R, C = map(int, input().split()) を使って、網の縦幅 R と横幅 C を入力から読み取ります。
net = [list(input()) for _ in range(R)] を使って、R 行分の網の情報を入力から読み取り、2次元リスト net に格納します。各行は文字列となり、'#' または '.' の文字からなります。
max_fish を初期化します。
ネストした2重ループを使用して、網を投げ入れる全ての位置を試します。ループ変数 i は行方向のオフセットを表し、ループ変数 j は列方向のオフセットを表します。このループにより、網が重なる可能性のある位置をすべて網の左上の位置として試すことができます。
ネストした2重ループを使用して、網が重なる範囲内の魚の総数を計算します。ループ変数 r は網の行方向のオフセットを表し、ループ変数 c は網の列方向のオフセットを表します。net[r][c] が '#' の場合、それに対応する位置の radar[i + r][j + c] の値を総数に加算します。
総数 total_fish を最大の魚の総数 max_fish と比較し、更新します。
最大の魚の総数 max_fish を返します。
result = catch_fish() を呼び出して、問題を解決し、結果を変数 result に格納します。
print(result) を使って、最終的な結果を出力します。
このコードは、指定された入力フォーマットに基づいて値を読み取り、問題を解決します。海域の情報と網の情報を繰り返し試しながら、最大の魚の総数を求めるアルゴリズムを実装しています。
'''

# B120 ◆
--------------------------------------------- B121　※欠番 ◆
# B121 床の模様替え
# utf-8
def rotate_floor(original_floor, r, c, s, d):
    n = len(original_floor)
    rotated_floor = [row[:] for row in original_floor]  # 回転後の床の初期化

    if d == 0:
        return rotated_floor  # 回転角度が 0 の場合は回転しない

    # 回転させる部分の床を一時的な行列にコピーする
    temp_floor = [[None] * s for _ in range(s)]
    for i in range(s):
        for j in range(s):
            temp_floor[i][j] = rotated_floor[r - 1 + i][c - 1 + j]

    # 回転後の床に要素をコピーする
    for i in range(s):
        for j in range(s):
            if d == 90:
                rotated_floor[r - 1 + j][c - 1 + s - i - 1] = temp_floor[i][j]  # 時計回りに 90 度回転
            elif d == 180:
                rotated_floor[r - 1 + s - i - 1][c - 1 + s - j - 1] = temp_floor[i][j]  # 時計回りに 180 度回転
            elif d == 270:
                rotated_floor[r - 1 + s - j - 1][c - 1 + i] = temp_floor[i][j]  # 時計回りに 270 度回転

    return rotated_floor

# タイルの情報の入力
n = int(input())
original_floor = []
for _ in range(n):
    row = list(map(int, input().split()))
    original_floor.append(row)

# 回転させる部分の床の情報の入力
r, c, s, d = map(int, input().split())

# 回転後の床の出力
rotated_floor = rotate_floor(original_floor, r, c, s, d)
for row in rotated_floor:
    print(*row)
'''
このプログラムは、与えられた入力に基づいて床のタイルを回転させるための関数 rotate_floor を定義し、その関数を使用して回転後の床を出力しています。
まず、rotate_floor 関数は、与えられた床の情報を元に回転後の床を計算します。関数の引数は次の通りです。
original_floor: 元の床の情報を表す2次元リストです。
r, c: 回転させる部分の床の左上の行と列のインデックスです。
s: 回転させる部分の床の大きさです。
d: 回転角度です。
関数の動作は以下の通りです。

元の床の情報を rotated_floor にコピーします。
回転角度 d が 0 の場合は、回転せずに rotated_floor をそのまま返します。
回転させる部分の床を一時的な行列 temp_floor にコピーします。
回転後の床に要素をコピーします。回転角度に応じて、一時的な行列から要素を取り出して回転後の床に配置します。
関数 rotate_floor の処理が完了したら、メインのプログラムでは以下の手順で入力を受け取り、回転後の床を出力しています。

最初に、床のタイルの情報を入力します。タイルの情報は2次元リスト original_floor に格納されます。
次に、回転させる部分の床の情報を入力します。左上の行と列のインデックスを表す r と c、部分の床の大きさを表す s、回転角度を表す d を受け取ります。
rotate_floor 関数を呼び出して、回転後の床を計算します。
回転後の床を出力します。
'''

# B122 うわさ
# utf-8
def propagate_rumors(city_map, initial_believers):
    """
    噂が伝播するまでの日数を計算する関数
    :param city_map: 市の地図を表す2次元リスト
    :param initial_believers: 初期の噂を信じる民家の座標のリスト
    :return: 噂が全民家に伝播するまでの日数または"No"
    """
    rows = len(city_map)
    cols = len(city_map[0])
    rumor_map = [[False for _ in range(cols)] for _ in range(rows)]

    # 初期の噂を信じる民家を設定
    for house in initial_believers:
        row, col = house
        rumor_map[row][col] = True

    days = 0

    while True:
        # 新たに噂を信じる民家の座標を保存するリスト
        new_believers = []

        for row in range(rows):
            for col in range(cols):
                # 既に噂を信じている民家はスキップ
                if rumor_map[row][col]:
                    continue

                # 隣接する民家の噂を確認
                neighbors = get_neighbors(row, col, rows, cols)
                neighbor_rumors = sum(rumor_map[r][c] for r, c in neighbors)

                # 噂を信じる条件を満たすか判定
                if (city_map[row][col] == "#" and neighbor_rumors >= 1) or (city_map[row][col] in ["1", "2"] and neighbor_rumors >= int(city_map[row][col])):
                    new_believers.append((row, col))

        # 新たに噂を信じる民家が存在しない場合、終了
        if len(new_believers) == 0:
            break

        # 新たに噂を信じる民家を更新
        for house in new_believers:
            row, col = house
            rumor_map[row][col] = True

        days += 1

    # 全民家が噂を信じる場合、日数を返す
    if all(all(row) for row in rumor_map):
        return days
    else:
        return "No"


def get_neighbors(row, col, rows, cols):
    """
    指定された座標の隣接する民家の座標を取得する関数
    :param row: 現在の行インデックス
    :param col: 現在の列インデックス
    :param rows: 市の地図の行数
    :param cols: 市の地図の列数
    :return: 隣接する民家の座標のリスト
    """
    neighbors = []
    if row > 0:
        neighbors.append((row - 1, col))
    if row < rows - 1:
        neighbors.append((row + 1, col))
    if col > 0:
        neighbors.append((row, col - 1))
    if col < cols - 1:
        neighbors.append((row, col + 1))
    return neighbors


# 入力の読み込み
H, W = map(int, input().split())
city_map = []
initial_believers = []

for _ in range(H):
    row = input().strip()
    city_map.append(list(row))
    for col in range(W):
        if row[col] == "#":
            initial_believers.append((_, col))

# プログラムの実行
result = propagate_rumors(city_map, initial_believers)

# 結果の出力
print(result)
'''
まず、propagate_rumors関数は、市の地図と初期の噂を信じる民家の座標を受け取り、噂が伝播するまでの日数を計算する関数です。関数内で使用される主な変数は以下の通りです。
rowsとcols: 市の地図の行数と列数を格納する変数です。
rumor_map: 各民家が噂を信じているかどうかを管理する2次元リストです。初期状態では全ての要素がFalse（噂を信じていない）となっています。
new_believers: 新たに噂を信じる民家の座標を格納するリストです。
days: 噂が伝播するまでの日数をカウントする変数です。
まず、初期の噂を信じる民家の座標をrumor_mapに反映させます。その後、噂の伝播が終了するまでループを繰り返します。

ループ内部では、各民家に対して以下の処理を行います。
既に噂を信じている民家はスキップします。
隣接する民家の噂を確認します。get_neighbors関数を使用して、指定された民家の上下左右の座標を取得します。
隣接する民家の中で噂を信じている民家の数を数えます。
噂を信じる条件を満たすか判定し、条件を満たす場合はnew_believersリストに座標を追加します。
全ての民家に対して処理が完了した後、new_believersリストが空であればループを終了します。空でなければ、new_believersリストに含まれる民家をrumor_mapに追加し、daysを1日増やします。

ループを抜けた後、rumor_mapが全ての要素がTrue（噂を信じている）であれば、daysを返します。そうでなければ、"No"を返します。
また、get_neighbors関数は指定された座標の上下左右の隣接する民家の座標を取得する関数です。
最後に、入力を受け取り、propagate_rumors関数を実行し、結果を出力します。
'''

# B123 ビットゲーム
# utf-8
def generate_new_hand(p, q, R):
    """
    手札の数字列pと山札の数字列qに基づいて新たな手札を生成する関数
    :param p: 手札の数字列
    :param q: 山札の数字列
    :param R: 命令
    :return: 新たな手札の数字列
    """
    p_prime = ""
    for i in range(len(p)):
        if R == 'a':
            # Rが'a'の場合、p[i]またはq[i]が'1'であれば'1'を生成し、それ以外は'0'を生成する
            if p[i] == '1' or q[i] == '1':
                p_prime += '1'
            else:
                p_prime += '0'
        elif R == 'b':
            # Rが'b'の場合、p[i]またはq[i]が'0'であれば'0'を生成し、それ以外は'1'を生成する
            if p[i] == '0' or q[i] == '0':
                p_prime += '0'
            else:
                p_prime += '1'
        elif R == 'c':
            # Rが'c'の場合、p[i]とq[i]が異なる数字であれば'1'を生成し、同じ数字であれば'0'を生成する
            if p[i] != q[i]:
                p_prime += '1'
            else:
                p_prime += '0'
    return p_prime

def main():
    # プレイヤー数と山札の枚数を取得
    N, M = map(int, input().split())

    # 各プレイヤーの初期手札を取得
    hands = []
    for _ in range(N):
        hand = input().split()
        hands.append(hand)

    # 山札の情報を取得
    deck = []
    for _ in range(M):
        card = input().split()
        deck.append(card)

    # ゲームの進行
    for card in deck:
        R = card[0]
        q = card[1:]
        for i in range(N):
            hands[i] = generate_new_hand(hands[i], q, R)

    # 最終的な手札を10進数に変換して比較
    max_value = -1
    winners = []
    for i in range(N):
        value = int(''.join(hands[i]), 2)
        if value > max_value:
            max_value = value
            winners = [i + 1]
        elif value == max_value:
            winners.append(i + 1)

    # 勝者を表示
    for winner in winners:
        print(winner)

if __name__ == '__main__':
    main()
'''
generate_new_hand(p, q, R) 関数:
手札の数字列 p と山札の数字列 q、命令 R に基づいて新たな手札を生成する関数です。
R の値に応じて、指定されたルールに基づいて新たな手札を生成します。

main() 関数:
プログラムのメイン関数です。
プレイヤー数と山札の枚数を取得し、各プレイヤーの初期手札と山札の情報を受け取ります。
ゲームの進行と最終的な勝者の判定を行います。

ゲームの進行:
山札の情報を1枚ずつ取り出し、各プレイヤーの手札を更新します。
generate_new_hand() 関数を呼び出して、各プレイヤーの手札を新たな手札で更新します。

最終的な勝者の判定:
各プレイヤーの手札を10進数に変換して比較し、最大の値を持つプレイヤーを勝者とします。
勝者のID番号を記録し、同じ最大値を持つ場合は複数の勝者がいる可能性があるため、全ての勝者のID番号を記録します。

勝者の表示:
最終的な勝者のID番号を順に表示します。
これにより、プレイヤー数と山札の情報を受け取り、ゲームを進行して最終的な勝者のID番号を出力するプログラムが実現されています。
'''

# B124 名前が似ている友達
# utf-8
def find_max_similarity(names):
    max_similarity = 0

    # すべての名前のペアの類似度を比較
    for i in range(len(names)):
        for j in range(i + 1, len(names)):
            similarity = calculate_similarity(names[i], names[j])
            max_similarity = max(max_similarity, similarity)

    return max_similarity

def calculate_similarity(name1, name2):
    # 最長の共通部分文字列を求める
    max_length = 0

    for i in range(len(name1)):
        for j in range(len(name2)):
            length = 0
            while i + length < len(name1) and j + length < len(name2) and name1[i + length] == name2[j + length]:
                length += 1
            max_length = max(max_length, length)

    return max_length

# 名前の個数を入力
N = int(input())

# 名前をリストとして入力
names = []
for _ in range(N):
    names.append(input())

# 類似度の最大値を求める
max_similarity = find_max_similarity(names)
print(max_similarity)
'''
このプログラムは、与えられた友達の名前のリストから、名前の類似度の最大値を求めるものです。
まず、find_max_similarity関数は、与えられた名前のリストを受け取り、類似度の最大値を求めます。この関数では、2重のループを使用して、すべての名前のペアの類似度を比較します。
外側のループでは、名前のリストの要素を1つずつ取り出し、内側のループでは、外側のループの要素の次の要素から末尾までの名前との類似度を計算します。類似度の最大値を更新していき、最終的な最大値を返します。
次に、calculate_similarity関数は、2つの名前を受け取り、最長の共通部分文字列の長さを計算します。この関数では、2重のループを使用して、2つの名前の文字列の各文字を順番に比較します。共通部分文字列が見つかった場合、長さを増やしていきます。
内側のループが終了した時点での最大の共通部分文字列の長さを返します。
メインの処理では、まず名前の個数を入力します。その後、名前のリストを受け取ります。最後に、find_max_similarity関数を呼び出し、類似度の最大値を求めて出力します。
このプログラムは、与えられた名前のリストに対して、類似度の最大値を計算する効率的な方法です。ただし、名前の数が増えると計算時間が増えるため、入力の名前の数が大きい場合は注意が必要です。
'''

# B125 工場のボトルネック
# utf-8
def find_bottleneck():
    import sys
    input = sys.stdin.read
    
    # 入力データを読み取り、スペースで分割
    data = input().split()
    
    # レーンの長さ L と作業記録の数 Q を取得
    L = int(data[0])
    Q = int(data[1])
    
    # 作業記録を格納するリスト
    tasks = []
    for i in range(Q):
        v_i = int(data[2 + 2 * i])
        t_i = int(data[2 + 2 * i + 1])
        tasks.append((v_i, t_i))
    
    # 商品の到着時間を計算して格納するリスト
    arrival_times = []
    for v, t in tasks:
        if v > 0:
            # 到着時間を計算
            arrival_time = t + L / v
            arrival_times.append((arrival_time, t))
    
    # 到着時間でソート
    arrival_times.sort()
    
    # 最大ボトルネック時間を記録する変数
    max_bottleneck = 0
    
    # 作業記録を処理
    for v, t in tasks:
        if v == 0:  # アームのパッキングタイミング
            pack_time = t
            # 到着した商品を順次処理
            while arrival_times and arrival_times[0][0] <= pack_time:
                arrival, start_time = arrival_times.pop(0)
                # 運搬開始からパッキング完了までの時間を計算
                bottleneck = pack_time - start_time
                # 最大ボトルネック時間を更新
                if bottleneck > max_bottleneck:
                    max_bottleneck = bottleneck
    
    # 最大ボトルネック時間を出力
    print(int(max_bottleneck))

# 標準入力からデータを受け取って実行
find_bottleneck()
'''
このプログラムは、工場で運搬ロボットによって運ばれる商品のボトルネック時間（運搬開始からパッキング完了までの最長時間）を求めるものです。
sys.stdin.readを使って標準入力からデータを一括で読み込みます。読み込んだデータをスペースで分割してdataリストに格納します。
dataリストの最初の2つの要素から、レーンの長さ L と作業記録の数 Q を取得します。
各作業記録を (速度, 時刻) のタプルとして tasks リストに格納します。
作業記録は、速度 v_i とその作業が開始された時刻 t_i のペアです。
商品がレーンの先頭に到達する時間を計算し、到着時間と運搬開始時間のペアを arrival_times リストに格納します。
到着時間は 運搬開始時刻 t + (レーンの長さ L / 速度 v) で計算されます。
到着時間を基準に arrival_times リストをソートします。これにより、先に到着した商品から順に処理できます。
max_bottleneck はボトルネック時間を記録する変数です。
作業記録を順に処理し、速度 v が 0 の場合はパッキングタイミングとみなします。
パッキングタイミング pack_time より前に到着した商品を順に処理し、各商品の運搬開始からパッキング完了までの時間（ボトルネック時間）を計算します。
計算したボトルネック時間が現時点での最大ボトルネック時間より大きければ、max_bottleneck を更新します。
最終的に最大ボトルネック時間を整数として出力します。
'''

# B126 ダンスパーティー
# utf-8
def cal_rank():
    vic_num = 1  # 同じ順位を持つ選手の数
    score = score_list[0][0]  # 現在の最高順位
    count = 1  # 選手を選び出した数
    for i in range(1, people_num):
        if score_list[i][0] == score:
            vic_num += 1
            count += 1
        elif vic_num < 3:
            vic_num += 1
            score = score_list[i][0]  # 新しい最高順位を設定
            count += 1
        else:
            break
    for i in range(count):
        score_list.pop(0)

# 入力を受け取る
people_num, song_num = list(map(int, input().split()))
score_list = []

# 各選手の順位データをリストに格納
for i in range(people_num):
    score_list.append([int(i) for i in list(input().split())])

# 平均順位を計算し、1位、2位、3位の数も計算
for i in range(people_num):
    score_list[i] = [sum(score_list[i]) / song_num, i, score_list[i].count(1) + score_list[i].count(2) + score_list[i].count(3)]

# 平均順位でソート
score_list.sort()

# cal_rank 関数を呼び出して最初の3人の選手を選び出す
cal_rank()

not_lose_count = 0  # 敗者復活戦に進出する選手の数

# 1位、2位、3位に入った選手がいればカウントする
for i in range(len(score_list)):
    if score_list[i][2] >= 1:
        not_lose_count += 1

# 結果を出力
print(not_lose_count)
'''
ダンス大会の審査員としての役割を果たすプログラムです。このプログラムは、ダンス大会の予選結果を入力として受け取り、敗者復活戦に進出する選手の数を計算します。以下に、コード全体の解説を行います：

cal_rank 関数:
この関数は、最初の3人の選手を選び出す役割を果たします。ダンスの順位データを処理し、最終的な順位が3位以内の選手を選び出します。
vic_num 変数は、同じ順位を持つ選手の数をカウントします。
score 変数は、現在の最高順位を追跡します。
count 変数は、選手を選び出した数を記録します。
ループを通じて、順位が変わるか、最初の3人の選手が選ばれるまで続けられます。
メイン部分:
最初に、選手の人数とダンスの曲数を読み取ります。
各選手の順位データを score_list リストに格納します。
各選手の平均順位と、1位、2位、3位の数を計算し、選手のデータを [平均順位, 選手番号, 1位・2位・3位の数] という形式に変換します。
score_list リストを平均順位でソートします。
cal_rank 関数を呼び出して、最初の3人の選手を選び出します。
敗者復活戦に進出する選手の数を計算:
not_lose_count 変数を使用して、敗者復活戦に進出する選手の数を計算します。1位、2位、3位に入った選手がいる場合、その数をカウントします。
結果の出力:
最終的に計算された not_lose_count の値を出力します。これは、敗者復活戦に進出する選手の数を表します。
'''

# B127 ◆
# B128 簡易的二次元バーコード
# utf-8
# 入力値の取得
N = input()

# 入力値の桁数を取得
H = len(N)

# 二次元バーコードのグリッドを初期化
s = [["." for _ in range(9)] for _ in range(H)]

for i in range(H):
    number = int(N[i])
    # グリッドの行インデックスを計算
    sy = (i // 3) * 3
    # グリッドの列インデックスを計算
    sx = (i % 3) * 3
    for y in range(sy, sy + 3):
        for x in range(sx, sx + 3):
            if number > 0:
                s[y][x] = "#"  # "#" を配置
                number -= 1

# 二次元バーコードの表示
for row in s:
    print("".join(row))
'''
ユーザーからの入力値を取得します。入力値の桁数を取得します。
二次元バーコードを表すためのグリッドを初期化します。グリッドは各桁の数値を表すために使用されます。
各桁ごとに処理を行います。桁ごとの数値を取得し、グリッドの適切な位置に "#" を配置します。
グリッド上の位置は、桁のインデックスに基づいて計算されます。
二次元バーコードを表示します。最終的に得られたグリッドを表示します。
各行のリストを文字列に変換し、連結して表示します。
'''

# B129 n毛作
# utf-8
import sys

n_times = 0  # 作業回数
m_type = 0  # 作物の種類数
h_height = 0  # 畑の行数
w_width = 0  # 畑の列数
count = 0  # 行数カウンター
works = []  # 作業データを格納するリスト
field = []  # 畑の状態を表すリスト
products = []  # 作物の収穫数を格納するリスト

# 入力の読み込み
for line in sys.stdin:
    line = line.strip()
    if count == 0:
        n_times, m_type = map(int, line.split(' '))  # 作業回数と作物の種類数の取得
    elif count == 1:
        h_height, w_width = map(int, line.split(' '))  # 畑の行数と列数の取得
    else:
        works.append(list(map(int, line.split(' '))))  # 作業データの取得
    count += 1

# 畑と作物の初期化
for i in range(h_height):
    field.append(['.'] * w_width)  # 全ての区画を'.'で初期化
products = [0] * m_type  # 作物の収穫数を0で初期化

# 畑の作業を実行
for work in works:
    for h in range(work[0] - 1, work[1]):  # 指定範囲の行を走査
        for w in range(work[2] - 1, work[3]):  # 指定範囲の列を走査
            if isinstance(field[h][w], int):  # 区画に作物が植えられている場合
                products[field[h][w] - 1] += 1  # 収穫数を加算
            field[h][w] = work[4]  # 作物を植える

# 出力
for p in products:
    print(p)  # 作物の収穫数を出力
for f in field:
    print(''.join(map(str, f)))  # 畑の状態を出力
'''
与えられた作業計画に基づいて農場の畑での作物栽培をシミュレートし、最終的な収穫量と畑の状態を出力します。
まず、入力部分では、sys.stdinを使用して標準入力から入力を読み取ります。入力の最初の行では、作業回数と作物の種類数を取得し、2番目の行では畑の行数と列数を取得します。残りの行では、各作業の範囲と植える作物の情報をリストとして取得します。
次に、畑と作物の初期化を行います。fieldリストは、畑の状態を表現する2次元リストで、全ての区画を'.'で初期化します。productsリストは、作物の収穫数を格納するリストで、作物の種類数分だけ0で初期化します。
その後、各作業について順番に処理を行います。作業は指定された範囲の区画を走査し、収穫と植え付けを行います。指定された範囲の行と列をループで走査し、区画に植えられている作物があれば収穫数を加算し、新しい作物を植えます。
最後に、出力部分では、収穫数と畑の状態を出力します。productsリストの各要素を順番に出力し、fieldリストの各行を文字列に変換して出力します。
このコードは、与えられた入力に基づいて作物の収穫数と畑の状態を正しく計算し、出力します。畑の状態は数値や'.'の組み合わせで表現され、'.'は何も植えられていないことを示します。
また、入力の制約に従って、適切な範囲で処理を行います。
'''

# B130 ブロック挿入
# utf-8
def can_place_block_at(board, block, x, y):
    # ブロックをボードの指定された位置(x, y)に配置できるかをチェックします
    for i in range(3):
        for j in range(3):
            if block[i][j] == 1:
                # ボードの範囲外にブロックがはみ出している場合や、既にブロックが配置されている場合は配置不可とします
                if x + i >= len(board) or y + j >= len(board[0]) or board[x + i][y + j] == 1:
                    return False
    return True

def rotate_block(block):
    # ブロックを反時計回りに回転させます
    rotated = [[0] * 3 for _ in range(3)]
    for i in range(3):
        for j in range(3):
            rotated[j][2 - i] = block[i][j]
    return rotated

def can_insert_block(board, block):
    # ブロックを4回回転させながらボードに配置できるかをチェックします
    for _ in range(4):
        for j in range(len(board)):
            for k in range(len(board[0])):
                if can_place_block_at(board, block, j, k):
                    # ブロックを配置できる位置が見つかった場合はTrueを返します
                    return True
        block = rotate_block(block)
    # ブロックをどの向きでも配置できなかった場合はFalseを返します
    return False

# 入力値を取得
N, M = map(int, input().split())

# ボードの状態を入力値に基づいて構築します
board = []
for _ in range(N):
    line = input()
    board.append([1 if ch == '#' else 0 for ch in line])

# ブロックの形状を入力値に基づいて構築します
block = []
for _ in range(3):
    line = input()
    block.append([1 if ch == '#' else 0 for ch in line])

# ブロックをボードに配置できるかを判定し、結果を出力します
if can_insert_block(board, block):
    print("Yes")
else:
    print("No")
'''
このプログラムは、与えられたボード上に指定されたブロックを配置できるかどうかを判定します。具体的には、ボードとブロックの形状を入力として受け取り、ブロックを回転させながらボード上に配置できるかを判定します。
まず、can_place_block_at関数は、指定された位置（x、y）にブロックを配置できるかどうかをチェックします。この関数は、ブロックの各セルをループして、ボードの範囲外にはみ出していないかや既にブロックが配置されていないかを確認します。
次に、rotate_block関数は、与えられたブロックを反時計回りに回転させます。この関数では、ブロックの行と列を入れ替えることで回転を実現します。
can_insert_block関数は、ボード上にブロックを配置できるかを判定します。4回のループを行い、各ループでブロックを回転させながらボード上の各位置に対して配置可能かどうかをチェックします。
can_place_block_at関数を使用してブロックが配置可能かを判定し、配置可能な位置が見つかった場合はTrueを返します。
メインのプログラムでは、入力値を受け取り、ボードとブロックを構築します。入力値では、ボードのサイズ（N、M）および各行の状態、ブロックの形状が与えられます。ボードとブロックは、#文字を1に変換し、それ以外の文字を0に変換することで構築されます。
最後に、can_insert_block関数を使用してブロックをボードに配置できるかを判定し、結果を出力します。
'''

--------------------------------------------- B131　※欠番 ◆
# B131 運賃計算
# utf-8
# 電車の路線数（N）と駅の数（M）を読み込む
N, M = map(int, input().split())

ways = []  # 各路線の各駅の運賃を格納するリスト

# 各路線の各駅の運賃を読み込む
for _ in range(N):
    t = list(map(int, input().split()))
    ways.append(t)

# 経由する駅の数を読み込む
x = int(input())

money = 0  # 合計の運賃を記録する変数
X, Y = 0, 0  # 現在の位置を初期化（最初の路線の最初の駅）

# 経由する駅について繰り返す
for _ in range(x):
    p, q = map(int, input().split())
    p -= 1  # 駅のインデックスを0から始まるインデックスに変換

    if Y == q - 1:
        # 現在の路線と次の駅の目的地駅が同じ場合
        X, Y = p, q - 1
    elif Y < q - 1:
        # 現在の路線で右に移動する場合
        money += ways[p][q - 1] - ways[p][Y]
        X, Y = p, q - 1
    elif Y > q - 1:
        # 現在の路線で左に移動する場合
        money += ways[p][Y] - ways[p][q - 1]
        X, Y = p, q - 1

print(money)  # 合計の運賃を出力する
'''
このコードは、Paiza市に存在する電車の路線と駅の運賃情報を元に、指定された経路を辿った場合の総運賃を計算するものです。
まず、最初の行で電車の路線数（N）と駅の数（M）を入力します。次に、各路線の各駅までの運賃を2次元リスト ways に読み込みます。各路線の1番目の駅からM番目の駅までの運賃が順番に入力されます。
その後、経由する駅の数を示す整数 x を入力します。その後の行で、x回だけ経由する駅の情報を読み込みます。各行には、現在の位置から移動すべき路線の番号 R_i とその路線の駅の番号 S_i が与えられます。
その後、X と Y の初期値を0に設定し、経由する駅の数だけループします。各ループで、現在の位置を p と q に設定し、経路の次の駅の目的地を表します。このとき、p と q を0ベースのインデックスに変換します。
その後、現在の位置と次の駅の目的地駅が同じ場合、X と Y を更新します。目的地が同じであれば、運賃はかかりません。
次に、現在の位置が目的地の右側にある場合、右に移動することになります。この場合、運賃を計算し、総運賃に加算します。X と Y を更新します。
最後に、現在の位置が目的地の左側にある場合、左に移動することになります。同様に、運賃を計算し、総運賃に加算します。X と Y を更新します。
最後に、指定された経路を辿った場合の総運賃を出力します。
'''

# B131(2) 復号の処理 ◆
# B132 踏切の計画
# utf-8
def max_down_time(train_info, c):
    n = len(train_info)
    dp = [0] * n  # 遮断機が下がっている時間の最大値を保持するDPテーブル

    for i in range(n):
        for j in range(i):
            if train_info[i] - train_info[j] <= c:
                # 電車iと電車jの間隔がc以下の場合、最大時間を更新
                dp[i] = max(dp[i], dp[j] + train_info[i] - train_info[j])
        # 遮断機が下がっている時間cを追加
        dp[i] = max(dp[i], c)

    return max(dp)

# 入力の受け取り
N, c = map(int, input().split())
train_info = []
for _ in range(N):
    t_i = int(input())
    train_info.append(t_i)

# 最も長い遮断機の下がっている時間を計算して出力
result = max_down_time(train_info, c)
print(result)
'''
まず、このプログラムは与えられた電車の情報を元に、遮断機が下がっている最も長い時間を求めるものです。
max_down_time 関数は、電車の情報と遮断機が下がっている時間 c を受け取ります。
変数 n には電車の本数が格納され、dp という長さ n のリストを作成します。このリストは遮断機が下がっている時間の最大値を保持します。
2つのループを使用します。外側のループは i を 0 から n-1 まで増加させます。内側のループは j を 0 から i-1 まで増加させます。
内側のループでは、現在の電車 i と前の電車 j の通過時刻の差が c 以下である場合、dp[i] を更新します。更新には、dp[j]（前の電車までの最大遮断機下がり時間）に現在の電車と前の電車の通過時刻の差を加えたものと、現在の dp[i] の値を比較して大きい方を選びます。
外側のループでは、現在の電車 i の通過時刻に遮断機が下がっている時間 c を加えた値と、現在の dp[i] の値を比較して大きい方を選び、dp[i] を更新します。
最終的に、dp リストの最大値が遮断機が下がっている最も長い時間となります。
入力として、電車の本数 N と遮断機が下がっている時間 c を受け取ります。その後、N 回ループを回して各電車の通過時刻を入力し、リスト train_info に格納します。
max_down_time 関数に train_info リストと遮断機が下がっている時間 c を渡し、遮断機が下がっている最も長い時間を計算します。
結果を出力します。
'''

# B133 ◆
# B134 種まきシミュレーション
# utf-8
def make_line(y, masu, x, hatake_box, hatake_size):
    # 基点 (x, y) を中心に、上下の行に masu マス分だけ種を植える関数
    for j in range(masu):
        a = x - (masu - j)
        if a > 0:
            hatake_box[y][a] += 1
        b = x + (masu - j)
        if b <= hatake_size[1]:
            hatake_box[y][b] += 1
    hatake_box[y][x] += 1

def add_line(x, masu, y, hatake_box, hatake_size):
    # 基点 (x, y) を中心に、左右の列に masu マス分だけ種を植える関数
    for j in range(masu - 1):
        a = y - (masu - 1 - j)
        if a > 0:
            hatake_box[a][x] += 1
        b = y + (masu - 1 - j)
        if b <= hatake_size[0]:
            hatake_box[b][x] += 1
    hatake_box[y][x] += 1

def main():
    # 畑の縦の区画数 N と横の区画数 M を入力
    n, m = map(int, input().split())
    # 何回種をまいたかを入力
    s = int(input())

    # 畑の状態を保持する二次元リストを作成し、すべての要素を 0 に初期化
    hatake_box = [[0] * (m + 1) for _ in range(n + 1)]

    for _ in range(s):
        # i 回目の種まきでの情報を入力
        t, x, y = map(int, input().split())

        if t == 1:
            # 高さが 1 の場合は、基点 (x, y) にのみ種を植える
            hatake_box[y][x] += 1
            continue

        # 基点 (x, y) から masu マス分だけ種を植える
        masu = t // 2

        if y - masu > 0:
            # 上段一列に masu マス分だけ種を植える
            make_line(y - masu, masu, x, hatake_box, (n, m))

        if y + masu <= n:
            # 下段一列に masu マス分だけ種を植える
            make_line(y + masu, masu, x, hatake_box, (n, m))

        if x - masu > 0:
            # 左側に masu マス分だけ種を植える
            add_line(x - masu, masu, y, hatake_box, (n, m))

        if x + masu <= m:
            # 右側に masu マス分だけ種を植える
            add_line(x + masu, masu, y, hatake_box, (n, m))

    # 結果を出力
    for row in hatake_box[1:]:
        print(*row[1:])


if __name__ == "__main__":
    main()
'''
与えられた問題の要件に従って、空中から種を植えるドローンの動作をシミュレーションし、畑の各区画に植えられた種の個数を計算して出力するプログラムです。
まず、入力から畑の縦の区画数 N と横の区画数 M を取得します。そして、何回種をまいたかを表す整数 S を取得します。
畑の状態を保持する二次元リスト hatake_box を作成し、すべての要素を0に初期化します。このリストは、畑の各区画に植えられた種の個数を保持します。行は1からNまで、列は1からMまでの範囲で表現します。
次に、S回の種まきの情報を入力から取得します。それぞれの情報は、高さ T 、種をまいた場所の列 X 、種をまいた場所の行 Y です。
高さ T が1の場合は、単一の区画にだけ種を植えます。それ以外の場合は、Tを奇数の整数として、ドローンのいる区画を中心として一辺が T マスの正方形の辺の位置に種を植えます。
以下の関数が、種をまく操作をシミュレートするために使用されます：
make_line(y, masu, x, hatake_box, hatake_size): 基点 (x, y) を中心に、上下の行に masu マス分だけ種を植える関数。
add_line(x, masu, y, hatake_box, hatake_size): 基点 (x, y) を中心に、左右の列に masu マス分だけ種を植える関数。
これらの関数を使って、与えられた情報に基づいてドローンが畑に種をまく操作を行い、hatake_boxリストに種の個数を記録します。

最後に、hatake_boxリストを使って、畑の各区画に植えられた種の個数を出力します。出力は、空白区切りで各行の種の個数を表示し、各行の末尾に改行を付け加えます。
'''

# B135 譜面チェック
# utf-8
def main():
    import sys
    input = sys.stdin.read
    data = input().strip().split('\n')  # 標準入力を読み込み、改行で分割してリストに格納

    N = int(data[0])  # 小節数を読み込む
    ans = []  # 条件を満たさない小節番号を格納するリスト

    for n in range(1, N + 1):  # 各小節について処理
        datas = data[n].split(' ')  # 小節のデータをスペースで分割
        M = int(datas[0])  # その小節の鍵盤数
        key = datas[1:M + 1]  # 鍵盤のリスト
        checker = ''.join(key)  # 鍵盤を連結して一つの文字列にする

        outcount = 0  # 制限違反のカウント
        okline = 1  # 制限違反を許容する回数（片側の手が空いている場合）

        # 両側の鍵盤を使う場合
        if 'L' in checker and 'R' in checker:  # 'L' と 'R' の両方が含まれる場合
            okline = 0  # 制限を許容しない

        # 上下の鍵盤
        if ('La' in checker and 'Lb' in checker) or ('Ra' in checker and 'Rb' in checker):
            outcount += 1  # 上下の鍵盤を同時に押す場合は違反カウントを増やす
            if outcount > okline:  # 許容範囲を超えた場合
                ans.append(n)  # 現在の小節番号をリストに追加
                continue  # 次の小節に進む

        # 両端の鍵盤
        if ('La_1' in checker and 'La_6' in checker) or ('Ra_1' in checker and 'Ra_6' in checker) \
                or ('Lb_1' in checker and 'Lb_6' in checker) or ('Rb_1' in checker and 'Rb_6' in checker):
            outcount += 1  # 両端の鍵盤を同時に押す場合は違反カウントを増やす
            if outcount > okline:  # 許容範囲を超えた場合
                ans.append(n)  # 現在の小節番号をリストに追加
                continue  # 次の小節に進む

    for i in ans:  # 条件を満たさない小節番号を出力
        print(i)

if __name__ == "__main__":
    main()  # メイン関数を呼び出し
'''
データの読み込みと分割: sys.stdin.readで標準入力を全て読み込み、改行で分割してリストに格納します。
小節数の取得: 最初の要素を小節数として整数に変換します。
条件を満たさない小節番号のリスト作成: ansリストを初期化します。
各小節の処理: 各小節について、データをスペースで分割し、鍵盤の情報を抽出します。
演奏制限のチェック: 鍵盤の文字列を連結し、違反条件をチェックします。
両側の鍵盤を同時に押す場合
上下の鍵盤を同時に押す場合
両端の鍵盤を同時に押す場合
違反があればリストに追加: 制限違反がある小節番号を ans に追加します。
結果の出力: 条件を満たさない小節番号を出力します。
'''

# B136　チョコのお返し
# utf-8
# N, H, Wの取得
N, H, W = map(int, input().split())

# あなたの座席の位置 (sy, sx) の取得
sy, sx = map(int, input().split())
sy -= 1  # 0-based indexに変換
sx -= 1  # 0-based indexに変換

# 移動経路を取得
s = input()

# 各席のクラスメイトからもらうチョコレートの数を取得
chocolates = [list(map(int, input().split())) for _ in range(H)]

# 移動方向を定義
dx = [-1, 1, 0, 0]  # 上、下、左、右
dy = [0, 0, -1, 1]

# チョコレートをもらった順番に貰ったチョコレートの個数を格納するリスト
result = []

# 訪れた座席を記録するセット
visited = set()

# 初期座席を訪れたことを記録
visited.add((sy, sx))

# 移動
for move in s:
    if move == "F": # 上
        nx, ny = sy + dx[0], sx + dy[0]
    elif move == "B": # 下
        nx, ny = sy + dx[1], sx + dy[1]
    elif move == "L": # 左
        nx, ny = sy + dx[2], sx + dy[2]
    elif move == "R": # 右
        nx, ny = sy + dx[3], sx + dy[3]

    # 移動先の座標が有効でかつ未訪問なら、チョコレートをもらう
    if 0 <= nx < H and 0 <= ny < W and (nx, ny) not in visited:
        result.append(chocolates[nx][ny])
        sy, sx = nx, ny  # 新しい座席に移動
        visited.add((sy, sx))  # 訪れた座席を記録

# 結果を出力
for e in result:
    print(e)
'''
このプログラムは、与えられた条件に基づいて、指定された移動経路に従ってクラスの座席を移動し、もらったチョコレートの個数を計算して出力するプログラムです。
最初に、N、H、Wを標準入力から取得します。これらは移動回数、クラスの縦の席数、クラスの横の席数を表します。
あなたの座席の位置 (sy, sx) を標準入力から取得します。これは、あなたの現在の座席の位置を表します。ここで、1-based indexを0-based indexに変換しています。
移動経路を取得します。これは、"F" (前方向に移動)、"B" (後方向に移動)、"L" (左方向に移動)、"R" (右方向に移動) の文字から成る長さNの文字列です。これは、どの方向に移動するかを示します。
各席のクラスメイトからもらうチョコレートの数を取得します。これは、H行W列の整数の行列として提供され、各席のクラスメイトがくれるチョコレートの数を表します。
移動方向を定義します。dxとdyのリストによって、上、下、左、右の4つの方向が定義されます。
チョコレートをもらった順番に貰ったチョコレートの個数を記録するためのresultというリストを初期化します。
訪れた座席を追跡するためのセットvisitedを初期化します。最初にあなたの座席を訪れたことを記録します。
移動経路sに従って座席を移動します。各移動について、次の座席が有効であり（範囲内である）、かつ訪れていない座席であることを確認します。条件を満たす場合、その座席からチョコレートの数を取得し、新しい座席に移動します。また、訪れた座席を記録します。
チョコレートをもらった順番に、resultリストにチョコレートの数を追加します。
最終的に、resultリストに格納されたチョコレートの数を順番に出力します。
'''

# B137　ブロック消し
# utf-8
import sys

# 入力を受け取ります
input_line = input().strip()
n, m, x = map(int, input_line.split())

array = []

# ブロックの初期配置を受け取ります
for _ in range(n):
    input_row = input().strip()
    array.append(input_row.split())

# ブロックの状態を確認するためのコピーを作成します
copy = [[0 for _ in range(m)] for _ in range(n)]

# 上下左右に同じ色のブロックが隣接しているかをチェックします
for i in range(n):
    for j in range(m):
        if (i > 0 and array[i][j] == array[i - 1][j]) or (i < n - 1 and array[i][j] == array[i + 1][j]) or (j > 0 and array[i][j] == array[i][j - 1]) or (j < m - 1 and array[i][j] == array[i][j + 1]):
            copy[i][j] = 1

# 消去すべきブロックを '#' で置き換えます
for i in range(n):
    for j in range(m):
        if copy[i][j] == 1:
            array[i][j] = "#"

# ブロックを下に移動させます
for k in range(n):
    for i in range(n - 2, -1, -1):
        for j in range(m):
            if array[i + 1][j] == "#":
                array[i + 1][j], array[i][j] = array[i][j], "#"

# 結果を出力します
for i in range(n):
    output = " ".join(array[i])
    print(output)
'''
最初に、標準入力から行数（n）、列数（m）、ブロックの色の種類（x）を読み取ります。
ブロックの初期配置を保持する2次元リストである array を作成し、入力から行ごとにブロックの色を読み取ります。
ブロックの隣接関係をチェックするための copy という2次元リストを作成します。このリストは、各ブロックの上下左右に同じ色のブロックがあるかどうかを示します。
各ブロックに対して、上下左右に同じ色のブロックが隣接しているかどうかをチェックし、隣接している場合は copy リストに1を設定します。
copy リストを元に、消去すべきブロックを '#' で置き換えます。
ブロックを下に移動させる処理を行います。ブロックが '#' の場合、上の行に同じ列番号のブロックがあれば、それに置き換えます。
最終的なブロックの配置を出力します。
ブロックの初期配置を受け取り、指定されたルールに従ってブロックを消去し、消去後のブロックの配置を計算し、最終的な結果を出力します。
'''

# B138　ドーナツ
# utf-8
# ドーナツの絵を数える関数
def count_donuts_in_picture(H, W, picture):
    # ドーナツのパターンを定義
    donut_pattern = [
        ["#", "#", "#"],
        ["#", ".", "#"],
        ["#", "#", "#"]
    ]

    # ドーナツの絵の数をカウントする変数を初期化
    donut_count = 0

    # 地上絵を走査
    for i in range(H - 2):
        for j in range(W - 2):
            # ドーナツの絵と一致するかを確認するフラグ
            is_donut = True
            # 3x3の領域を比較
            for x in range(3):
                for y in range(3):
                    if picture[i + x][j + y] != donut_pattern[x][y]:
                        is_donut = False
                        break
                if not is_donut:
                    break
            # ドーナツの絵と一致していればカウントを増やす
            if is_donut:
                donut_count += 1

    return donut_count

# メインの処理
# 地上絵のサイズを取得
H, W = map(int, input().split())

# 地上絵の各行を読み込む
picture = [input() for _ in range(H)]

# ドーナツの絵の数を計算
result = count_donuts_in_picture(H, W, picture)

# 結果を出力
print(result)
'''
ドーナツの絵を数えるための関数 count_donuts_in_picture を定義します。この関数は、地上絵のサイズ (H, W) と地上絵の各行を受け取り、ドーナツの絵の数を返す役割を担います。
donut_pattern という3x3のパターンを定義します。このパターンは、真ん中が白 (.) で周囲が黒 (#) である「ドーナツの絵」を示します。
donut_count 変数を初期化し、ドーナツの絵の数を数えるための変数を用意します。
2重のループを使用して、地上絵の各位置を走査します。具体的には、for i in range(H - 2) と for j in range(W - 2) で、地上絵の各位置から3x3の領域をチェックします。
3x3の領域内を走査して、「ドーナツの絵」のパターンと一致するかどうかを確認します。内部の2つのループを使用して、3x3の領域を比較します。もし一致すれば、is_donut を True に設定します。
もし is_donut が True のままであれば、その領域は「ドーナツの絵」のパターンと一致しているため、donut_count をインクリメントしてドーナツの絵の数を増やします。
ドーナツの絵の数を計算したら、最終的な数を donut_count として返します。
メインの処理では、まず、入力から地上絵のサイズ (H, W) を受け取ります。map(int, input().split()) を使用して、スペースで区切られた整数を読み込みます。
次に、地上絵の各行をリスト picture に読み込みます。input() を使用して、各行を読み取り、for ループを使用してリストに追加します。
地上絵のサイズと各行が準備できたら、count_donuts_in_picture 関数を呼び出してドーナツの絵の数を計算します。
最終的に、計算されたドーナツの絵の数を出力します。これにより、正しい結果が表示されます。
'''

# B139 ◆
# B140 ネズミ駆除
# utf-8
H, W = map(int, input().split())
N, T = map(int, input().split())

# 各区画に対するネズミの数を管理する辞書
mouse_count = {}

# ネズミの情報を読み込んでネズミの数をカウント
for _ in range(N):
    x, y = map(int, input().split())
    pos = (x, y)
    if pos in mouse_count:
        mouse_count[pos] += 1
    else:
        mouse_count[pos] = 1

# ネズミの数が多い順にソート
sorted_mouse_count = sorted(mouse_count.values(), reverse=True)

# 最大で T 枚のネズミ捕りを使って、ネズミを捕獲
result = 0
for i in range(min(T, len(sorted_mouse_count))):
    result += sorted_mouse_count[i]

print(result)
'''
最初に、領域の縦横のサイズと、ネズミの数(N)と使えるネズミ捕りの数(T)を入力から取得します。
各ネズミの座標を読み取り、それぞれの座標に現れるネズミの数をmouse_countという辞書で管理します。
各区画に現れるネズミの数を降順でソートし、sorted_mouse_countに格納します。
最大でT枚のネズミ捕りを使って、ネズミを捕獲します。min(T, len(sorted_mouse_count))は、Tとソートされたネズミの数の小さい方を選びます。そして、それだけのネズミを捕獲して、その数をresultに加算します。
最終的な結果を出力します。
'''

-----------------------------------------------B141　※欠番◆
# B141　ガーベラ・コレクション
# utf-8
def main():
    # ガーベラの色の数を受け取る
    n = int(input())

    # ガーベラの総本数を計算する
    m = 2 * n

    # ガーベラの色の配列を受け取る
    A = [int(input()) for _ in range(m)]

    # ガーベラの並び替え操作の回数を記録する変数 cnt を初期化
    cnt = 0

    for i in range(m):
        # ガーベラが期待される位置にあればスキップ
        if A[i] == i % n + 1:
            continue

        # 期待される位置にない場合、正しい位置を見つけて交換操作を行う
        j = i + 1
        while A[j % m] != i % n + 1:
            j += 1
            if j == i:  # インデックスが i に戻ってしまった場合、見つからないと判断
                break

        # 交換操作が終了すると、cnt が増加
        while j > i:
            A[j % m], A[(j - 1) % m] = A[(j - 1) % m], A[j % m]
            cnt += 1
            j -= 1

    # 結果を標準出力に出力
    print(cnt)

if __name__ == "__main__":
    main()
'''
main() 関数は、与えられた問題を解決するためのメイン関数です。
n はガーベラの色の種類数、m はガーベラの総本数です。
A はガーベラの色の配列を表します。リスト内包表記を使って、2N本分のガーベラの色を入力から受け取っています。
cnt はガーベラの並び替え操作の回数を記録する変数です。
メインの for ループでは、各ガーベラについて正しい位置に並ぶように操作を行います。
ガーベラが期待される位置にあればスキップし、期待される位置にない場合は正しい位置を見つけて交換操作を行います。
while ループ内で、ガーベラの位置を交換し、そのたびに cnt を増加させています。
最終的に cnt を標準出力に出力しています。
このコードは、指定された問題に対して隣り合う2本のガーベラを交換する操作を繰り返し、所望の順番にガーベラを並べ替えるための最小の操作回数を求めています。
'''

# B142　黒石
# utf-8
def count_black_moves(N, board):
    # 8方向の移動を定義
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]

    def is_valid_move(x, y):
        return 0 <= x < N and 0 <= y < N

    def is_valid_direction(x, y, dx, dy):
        # 挟む方向が相手の石であるかを確認
        return is_valid_move(x + dx, y + dy) and board[x + dx][y + dy] == 'W'

    def can_place_black(x, y):
        # 空白マスに黒石を置けるかを判定
        if board[x][y] != '.':
            return False

        for dx, dy in directions:
            if is_valid_direction(x, y, dx, dy):
                nx, ny = x + dx, y + dy
                # 相手の石を挟みながら自分の石にたどり着くかを確認
                while is_valid_move(nx, ny) and board[nx][ny] == 'W':
                    nx, ny = nx + dx, ny + dy
                if is_valid_move(nx, ny) and board[nx][ny] == 'B':
                    return True

        return False

    count = 0
    # 盤面全体を調べて黒石を置けるマスを数える
    for i in range(N):
        for j in range(N):
            if can_place_black(i, j):
                count += 1

    return count


if __name__ == "__main__":
    N = int(input())
    board = [input().strip() for _ in range(N)]

    # 黒石を置けるマスの数を計算して出力
    result = count_black_moves(N, board)
    print(result)
'''
このプログラムは、与えられたリバーシの盤面上で、黒石を置けるマスの数を数えるものです。
count_black_moves 関数:

Nは盤面の縦横のマス数を表す整数です。
boardは盤面の状態を表す文字列のリストで、各文字は'.'（空白）、'B'（黒石）、'W'（白石）のいずれかです。
directionsは8方向の移動を示すタプルのリストです。縦、横、斜めのいずれかに1つ以上の石を挟むことができます。
is_valid_move関数は盤面内の有効なマスであるかを確認します。
is_valid_direction関数は挟む方向が相手の石であるかを確認します。
can_place_black関数は特定のマスに黒石を置けるかを判定します。そのために、指定されたマスの周囲8方向に対して挟むことができるかを確認します。
メイン部分 (__main__ ブロック):

最初に盤面のサイズ N を標準入力から受け取ります。
次に、N 行分の盤面の状態を標準入力から受け取り、それぞれ board リストに格納します。
count_black_moves関数を呼び出して、黒石を置けるマスの数を計算します。
結果を出力します。
'''

# B143　じゃんけん列車
# utf-8
from collections import defaultdict  # defaultdictを使うためのインポート

def find_winner(N, M, records):
    # 初期状態: 各園児が1人の列車を持つ
    trains = {i: [i] for i in range(1, N+1)}

    # じゃんけんの勝敗情報を処理する
    for x, y in records:
        # 園児 x が園児 y に勝った場合
        # x の列車の末尾に y の列車を連結し、y の列車を削除する
        trains[x].extend(trains[y])
        del trains[y]

    # 最も長い列車の先頭の園児が優勝者
    max_length = max(len(train) for train in trains.values())
    winners = [train[0] for train in trains.values() if len(train) == max_length]

    return winners

# 入力を取得
N, M = map(int, input().split())
records = [tuple(map(int, input().split())) for _ in range(M)]

# 優勝者を見つける
winners = find_winner(N, M, records)

# 結果を出力
for winner in winners:
    print(winner)
'''
じゃんけん列車ゲームの優勝者を見つけるためのプログラムです。defaultdictは、辞書のようなデータ構造ですが、存在しないキーを参照した場合に自動的に初期値を返す機能を持っています。
find_winner関数は、与えられたじゃんけんの勝敗情報を元に、じゃんけん列車ゲームの優勝者を見つけるための関数です。引数として、園児の人数 N、じゃんけんの勝敗記録の個数 M、じゃんけんの勝敗記録の情報 records を受け取ります。
trainsは、園児の出席番号をキーとし、各園児の列車を値として持つ辞書です。初期状態では、各園児が1人の列車を持っています。
recordsから1つずつじゃんけんの勝敗情報を取り出し、各情報に基づいて列車を操作します。園児 x が園児 y に勝った場合、x の列車の末尾に y の列車を連結し、y の列車を削除します。
最も長い列車の先頭の園児が優勝者です。max_lengthに最も長い列車の長さを求め、その長さと同じ列車の先頭の園児をwinnersリストに追加します。
優勝者の出席番号を小さい順に出力します。入力を受け取り、find_winner関数を呼び出して優勝者を見つけ、その結果を出力します。
'''

# B144　お化け避け
# utf-8
def count_valid_cells(H, W, N, salts):
    grid = [[1] * W for _ in range(H)]  # すべての区画をお化けが存在できる状態で初期化
    
    # 盛り塩が置かれた区画を設定し、その周囲8区画のお化けが存在できない状態に更新
    for x, y in salts:
        grid[x - 1][y - 1] = 0
        for i in range(max(0, x - 2), min(H, x + 1)):
            for j in range(max(0, y - 2), min(W, y + 1)):
                grid[i][j] = 0
    
    # 残っているお化けが存在できる区画の数を数える
    count = sum(row.count(1) for row in grid)
    return count

# 入力処理
H, W = map(int, input().split())
N = int(input())
salts = [tuple(map(int, input().split())) for _ in range(N)]

# お化けが存在できる区画の数を計算して出力
result = count_valid_cells(H, W, N, salts)
print(result)
'''
この問題では、お化けが存在できる区画の数を数える必要があります。与えられた区域には、お化けを配置できない盛り塩の区画がいくつかあります。盛り塩の効果範囲内にはお化けが存在できません。
まず、与えられた区域を表す二次元のリストを作成します。このリストは、各区画にお化けが存在できるかどうかを示します。最初はすべての区画がお化けが存在できる状態として初期化されます。
次に、与えられた盛り塩の位置に基づいて、お化けが存在できない状態を示すようにリストを更新します。盛り塩の位置によって、その区画とその周囲8つの区画のお化けが存在できない状態に変更します。
最後に、残っているお化けが存在できる区画の数を数えます。リスト内の値が1である区画がお化けが存在できる区画であるため、1の数を合計します。
'''

# B145　ビンゴゲームの判定
# utf-8
class Bingo:
    def __init__(self, sheet_size):
        # ビンゴカードを初期化する
        self.sheet = []
        for _ in range(sheet_size):
            # ビンゴカードの各行を入力から読み込んでリストに格納する
            row = list(map(int, input().split()))
            self.sheet.append(row)

    def hole(self, lottery_time):
        # 抽選された数字を読み込む
        lottery_numbers = list(map(int, input().split()))
        for num in lottery_numbers:
            # 抽選された数字がビンゴカードに存在する場合、そのマスを開ける
            for i in range(len(self.sheet)):
                for j in range(len(self.sheet[0])):
                    if self.sheet[i][j] == num:
                        self.sheet[i][j] = 0
                        break

    def count(self):
        # ビンゴの数をカウントする
        sheet_size = len(self.sheet)
        bingo_num = 0

        # 横方向のビンゴをチェックする
        for i in range(sheet_size):
            if all(cell == 0 for cell in self.sheet[i]):
                bingo_num += 1

        # 縦方向のビンゴをチェックする
        for j in range(sheet_size):
            if all(self.sheet[i][j] == 0 for i in range(sheet_size)):
                bingo_num += 1

        # 斜め方向のビンゴをチェックする
        if all(self.sheet[i][i] == 0 for i in range(sheet_size)):
            bingo_num += 1
        if all(self.sheet[i][sheet_size - 1 - i] == 0 for i in range(sheet_size)):
            bingo_num += 1

        return bingo_num


def main():
    # 入力を読み込む
    sheet_size, lottery_time = map(int, input().split())
    # Bingoクラスのインスタンスを作成する
    bingo = Bingo(sheet_size)
    # 抽選を実行する
    bingo.hole(lottery_time)
    # ビンゴの数をカウントして結果を出力する
    bingo_num = bingo.count()
    print(bingo_num)

if __name__ == "__main__":
    main()
'''
このプログラムは、与えられたビンゴカードと抽選結果を処理し、最終的なビンゴの数を計算します。
Bingo クラスの定義:
__init__ メソッド: ビンゴカードを初期化します。ビンゴカードは、与えられたサイズの正方形の行列であり、各マスにはランダムに数字が書かれています。ビンゴカードの情報は、与えられた入力から読み込まれます。
hole メソッド: 抽選された数字がビンゴカードに存在する場合、そのマスを開けます。ビンゴカードは、抽選された数字と一致するマスを見つけて、そのマスの数字を0に変更します。
count メソッド: ビンゴカードの状態からビンゴの数を計算します。ビンゴの条件は、横、縦、斜めのいずれかの方向に、すべてのマスが開けられた状態です。
main 関数:
入力を読み込み、必要な処理を実行します。
入力は、ビンゴカードのサイズと抽選回数です。
Bingo クラスのインスタンスを作成し、ビンゴカードの初期化と抽選の実行を行います。
最後に、ビンゴの数を計算して出力します。
これにより、与えられたビンゴカードと抽選結果から、最終的なビンゴの数が計算され、出力されます。
'''

# B146 最少攻撃回数  
# utf-8
def min_attacks(A, B, N, h):
    # 最小攻撃回数の初期値を無限大に設定
    min_attacks = float('inf')

    # 全体攻撃の最大回数を計算
    # 最大のHPを全体攻撃Bで何回叩けば倒せるかを計算して、その1回多くまでループさせる
    max_whole_attacks = max(h) // B + 1

    # 全体攻撃の回数を0から最大回数まで試行
    for whole_attacks in range(max_whole_attacks + 1):
        # 全体攻撃を実行した後の各モンスターの残りHPを計算
        remaining_hp = [max(0, hp - whole_attacks * B) for hp in h]
        
        # 残ったHPに対して必要な単体攻撃の回数を計算
        # (hp + A - 1) // A でHPをAで割って切り上げる
        single_attacks = sum((hp + A - 1) // A for hp in remaining_hp)
        
        # 全体攻撃と単体攻撃の合計回数を計算し、最小攻撃回数を更新
        min_attacks = min(min_attacks, whole_attacks + single_attacks)

    return min_attacks

if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().strip().split()
    
    # 単体攻撃力A、全体攻撃力Bを入力から取得
    A = int(data[0])
    B = int(data[1])
    
    # モンスターの数Nを入力から取得
    N = int(data[2])
    
    # 各モンスターのHPをリストとして入力から取得
    h = list(map(int, data[3:]))

    # 最小攻撃回数を計算して出力
    print(min_attacks(A, B, N, h))
'''
初期設定:
min_attacks は最小攻撃回数を保持する変数で、初期値は非常に大きい数 (float('inf')) に設定します。
max_whole_attacks は全体攻撃の最大回数を計算します。これは、最大のモンスターのHPを全体攻撃力Bで割った値に1を足したものです。
全体攻撃の回数を試行:
for whole_attacks in range(max_whole_attacks + 1): で全体攻撃の回数を0から max_whole_attacks まで試行します。
残りHPの計算:
各モンスターの残りHPは remaining_hp = [max(0, hp - whole_attacks * B) for hp in h] で計算します。全体攻撃を複数回行った後のHPを計算します。
単体攻撃の回数の計算:
残ったHPに対して必要な単体攻撃の回数は、 (hp + A - 1) // A でHPを単体攻撃力Aで割って切り上げた値です。
single_attacks は全モンスターの必要な単体攻撃回数の合計です。
最小攻撃回数の更新:
min_attacks = min(min_attacks, whole_attacks + single_attacks) で、現在の全体攻撃と単体攻撃の合計回数が最小値より少ない場合、最小値を更新します。
'''

# B147 スライムの王
# utf-8
# 標準入力から入力を読み込みます
N, X = map(int, input().split())

# 各スライムのサイズをリストとして読み込みます
nums = list(map(int, input().split()))

# 大きい順にソートして、取り込みの効率を上げます
nums.sort(reverse=True)

# 二分探索を用いて、指定したサイズ以下のスライムを探す関数
def left_bound(arr: list, target: int) -> int:
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] < target:
            right = mid - 1
        elif arr[mid] > target:
            left = mid + 1
        elif arr[mid] == target:
            right = mid - 1
    # 目標値が存在するかを確認します
    if left < 0 or left >= len(nums):
        return -1
    # 見つけた左境界が目標値かどうかを確認し、見つからない場合は目標値より小さい最小のインデックスを返します
    return left 

# スライムを取り込みながら、王になるための関数
def find_slime_king(X: int, nums: list) -> int:
    count = 0  # 取り込んだスライムの数をカウント
    max_size = nums[0]  # 最も大きいスライムのサイズ
    idx = 0  # 取り込むスライムのインデックス
    while X <= max_size:
        # 取り込めるスライムを見つける
        idx = left_bound(nums, X)
        if idx == -1:  # 取り込めるスライムがない場合
            return -1
        else:
            # スライムを取り込んでサイズを増やす
            X += nums.pop(idx)
            count += 1
    return count

# 結果を出力
print(find_slime_king(X, nums))
'''
このコードは、スライムの国において、プレイヤーが他のスライムを取り込んで自分のサイズを大きくし、一番大きいスライム（王）になるために、最小限の取り込み回数を計算するものです。
ここでは、標準入力からスライムの数 N とプレイヤーの初期サイズ X を読み込みます。また、各スライムのサイズをリスト nums に格納します。
nums リストを降順（大きい順）にソートします。これにより、取り込むスライムを効率的に選択できます。
関数 left_bound は、二分探索を用いて、指定された target 以下のスライムのうち、最も大きいもののインデックスを返します。具体的には、ターゲットサイズ以下のスライムの左境界（最左位置）を見つけます。
関数 find_slime_king は、プレイヤーが一番大きいスライムになるために取り込むスライムの数を計算します。
count は取り込んだスライムの数をカウントします。
max_size は最も大きいスライムのサイズを格納します。
while ループ内で、取り込めるスライムを left_bound 関数を使って見つけます。
もし取り込めるスライムが存在しない場合（idx == -1）、-1 を返します。
スライムを取り込むと、プレイヤーのサイズ X にそのスライムのサイズを加え、count を増やし、リストからそのスライムを削除します。
ループを繰り返し、プレイヤーが最大のスライムになったら count を返します。
find_slime_king 関数を呼び出して、一番大きいスライムになるための最小の取り込み回数の結果を標準出力に表示します。
'''

# B148 順位決め
# utf-8
def calculate_ranks(scores):
    # スコアと元のインデックスをペアにしてリストにする
    indexed_scores = [(score, i) for i, score in enumerate(scores)]
    
    # スコアを降順にソート
    indexed_scores.sort(reverse=True, key=lambda x: x[0])
    
    ranks = [0] * len(scores)  # 結果を格納するリスト
    
    # 初期の順位を1位に設定
    current_rank = 1
    for i, (score, original_index) in enumerate(indexed_scores):
        # 同じスコアの参加者がいる場合の処理
        if i > 0 and score == indexed_scores[i - 1][0]:
            ranks[original_index] = current_rank
        else:
            current_rank = i + 1
            ranks[original_index] = current_rank
    
    return ranks

# 標準入力からデータを読み込む
import sys
input = sys.stdin.read
data = input().split()

N = int(data[0])
scores = list(map(int, data[1:N + 1]))

# 順位を計算
ranks = calculate_ranks(scores)

# 結果を出力
for rank in ranks:
    print(rank)
'''
参加者の得点に基づいて順位を計算し、その順位を出力するようになっています。標準入力を読み込むためにsysモジュールをインポートします。
sys.stdin.readを使って全ての入力を一度に読み込みます。その後、split()メソッドを使って空白で区切り、リストdataに格納します。
最初の要素data[0]を整数に変換して参加者の数Nを取得します。続いて、dataリストの2番目以降の要素を整数に変換し、scoresリストとして得点を格納します。

得点とインデックスのペアを作成：
enumerateを使って、各得点とその元のインデックスのタプルリストindexed_scoresを作成します。
ソート：
indexed_scoresを得点で降順にソートします。これにより、得点が高い順に並びます。
順位の計算：
ranksリストを初期化します。このリストには各参加者の順位が格納されます。
ソートされたリストをループして順位を計算します。前の得点と同じ場合は同じ順位を、異なる場合は新しい順位を割り当てます。

順位の計算：
calculate_ranks関数を呼び出して、得点リストから順位リストranksを取得します。
順位の出力：
ranksリストの各順位を一行ずつ標準出力に出力します。
'''

# B149 仲間探し
# utf-8
# 入力の取得
H, W = map(int, input().split())  # 地図の縦と横のサイズ
Y, X = map(int, input().split())  # プレイヤーの位置（1-based index）
map_data = [input().strip() for _ in range(H)]  # 地図データ

# 方角ごとの冒険者の数
adventurers = {'N': 0, 'E': 0, 'S': 0, 'W': 0}

# 北方向の探索（自分の位置より上の行全て）
for i in range(Y - 1):  # 0-based indexに対応
    for j in range(W):
        if map_data[i][j].isdigit():
            adventurers['N'] += int(map_data[i][j])

# 南方向の探索（自分の位置より下の行全て）
for i in range(Y, H):  # 0-based indexに対応
    for j in range(W):
        if map_data[i][j].isdigit():
            adventurers['S'] += int(map_data[i][j])

# 西方向の探索（自分の位置より左の列全て）
for i in range(H):
    for j in range(X - 1):  # 0-based indexに対応
        if map_data[i][j].isdigit():
            adventurers['W'] += int(map_data[i][j])

# 東方向の探索（自分の位置より右の列全て）
for i in range(H):
    for j in range(X, W):  # 0-based indexに対応
        if map_data[i][j].isdigit():
            adventurers['E'] += int(map_data[i][j])

# 方角の優先順位
priority_order = ['N', 'E', 'S', 'W']

# 最大人数を持つ方角を見つける
max_adventurers = -1
max_direction = None
for direction in priority_order:
    if adventurers[direction] > max_adventurers:
        max_adventurers = adventurers[direction]
        max_direction = direction

# 結果の出力
print(f"{max_direction} {adventurers[max_direction]}")
'''
このコードは、プレイヤーの位置から4つの方角（北、東、南、西）それぞれにおいて、数字で示された冒険者の数を集計し、その中で最も多くの冒険者がいる方角を優先順位に従って選ぶ問題を解決します。
地図のサイズ (H 行と W 列) を取得します。プレイヤーの位置 (Y 行と X 列、1-based index) を取得します。地図データを map_data として、各行のデータをリストとして読み込みます。
北（N）、東（E）、南（S）、西（W）それぞれの方角に対する冒険者の数を記録するための辞書を初期化します。
プレイヤーの位置より上の行（Y-1 行まで）を探索し、その行の各列を調べます。各セルに数字がある場合、その値を北方向の冒険者のカウントに加算します。
プレイヤーの位置より下の行（Y 行から最後まで）を探索し、その行の各列を調べます。各セルに数字がある場合、その値を南方向の冒険者のカウントに加算します。
全行を対象にし、プレイヤーの位置より左の列（X-1 列まで）を探索します。各セルに数字がある場合、その値を西方向の冒険者のカウントに加算します。
全行を対象にし、プレイヤーの位置より右の列（X 列から最後まで）を探索します。各セルに数字がある場合、その値を東方向の冒険者のカウントに加算します。
方角の優先順位リスト (priority_order) を使って、最大の冒険者数を持つ方角を選びます。max_adventurers 変数に最大人数を保持し、max_direction 変数にその方角を保持します。
各方角を優先順位リストの順に確認し、冒険者の数が現在の最大人数より多い場合は更新します。
最も多くの冒険者がいる方角 (max_direction) とその人数 (adventurers[max_direction]) を出力します。
'''

# B150 最適な投資
# utf-8
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    # 投資イベントの日数 N, 初期所持金 X, 目標金額 Y を読み取る
    N = int(data[0])
    X = int(data[1])
    Y = int(data[2])
    
    # 投資倍率をリスト A に格納する
    A = list(map(int, data[3:N+3]))
    
    # 投資倍率を降順にソート（高い倍率から選ぶため）
    A.sort(reverse=True)
    
    # 現在の所持金を初期所持金 X で初期化
    money = X

    # 最小の投資日数 K を探す
    for K in range(1, N + 1):
        # K日目の投資倍率を適用して所持金を更新
        money *= A[K - 1]
        
        # 現在の所持金を K 日数で割った結果が目標金額 Y 以上か確認
        if money // K >= Y:
            # 条件を満たす最小の K を出力して終了
            print(K)
            return
    
    # 目標金額を達成できない場合は -1 を出力
    print(-1)

# スクリプトが直接実行されたときのみ main 関数を呼び出す
if __name__ == "__main__":
    main()
'''
ライブラリのインポートと標準入力の読み込み:
import sys を使って sys.stdin.read 関数をインポートします。これにより、標準入力からデータを一度に読み込むことができます。
input = sys.stdin.read によって、標準入力から全データを一括で読み込む準備をします。
data = input().split() で、入力データを空白で分割し、リスト data に格納します。

データの抽出と変換:
N は投資イベントの日数を示し、X は初期の所持金額、Y は目標金額を表します。これらは data リストから整数として取り出し、それぞれ変数に格納します。
A は各日の投資倍率を示すリストです。map(int, data[3:N+3]) を使って、データリストの該当部分を整数に変換し、リストに変換します。

投資倍率の降順ソート:
A.sort(reverse=True) で、リスト A を降順にソートします。これにより、最も高い倍率の投資から試すことができます。
最小日数の計算:
money には初期所持金 X を設定します。
for K in range(1, N + 1) のループで、1日目から N 日目までの投資日数 K を試します。
各ループの中で、money *= A[K - 1] で現在の所持金に K 日目の投資倍率を掛けて更新します。
money // K >= Y で、投資後の所持金を K で割った結果が目標金額 Y 以上であるかを確認します。この条件を満たす K が見つかれば、その値を出力し、プログラムを終了します。

目標金額未達の場合:
すべての投資日数を試しても目標金額に達しない場合は print(-1) で -1 を出力します。これにより、目標金額を達成する方法がないことを示します。

スクリプトの実行:
if __name__ == "__main__": ガード句を使って、このスクリプトが直接実行された場合のみ main 関数を呼び出します。これにより、モジュールとしてインポートされた場合には main 関数が実行されないようにします。
このコードは、指定された投資イベントの日数と倍率を元に、目標金額を達成するための最小日数を効率的に見つけるためのものです。
'''

-----------------------------------------------B151　※欠番◆
# B151　お土産選び
# utf-8
def min_cost_to_buy_manjus(N, packs):
    # 十分に大きな値としてinfを設定
    INF = float('inf')
    
    # dp配列の初期化
    dp = [INF] * (N + 1)
    dp[0] = 0  # 0個の時は0円
    
    # 各パックに対してdpを更新
    for num_manjus, cost in packs:
        for i in range(N + 1):
            if dp[i] != INF:
                next_count = min(i + num_manjus, N)
                dp[next_count] = min(dp[next_count], dp[i] + cost)
    
    # 最終的なN個以上を満たすdpの値を出力
    print(dp[N])

# 入力の受け取り
N = int(input())
packs = [tuple(map(int, input().split())) for _ in range(3)]

# 関数の実行
min_cost_to_buy_manjus(N, packs)
'''
まず、INFという変数に非常に大きな値を設定しています。これは、後で使用するDP配列の初期値として、まだ到達していない状態を表すために使います。
dp配列は、0からNまでのサイズで初期化されます。この配列の各要素 dp[i] は、i個のまんじゅうを購入するのに必要な最小コストを表します。初期状態では、0個のまんじゅうを買うためのコストは0円と設定され、それ以外はすべて無限大(INF)に初期化されます。
ここで、3種類のパックそれぞれに対してDP配列を更新していきます。

外側のループは、各パック（num_manjus 個入り、cost 円）について処理を行います。
内側のループでは、現在の dp 配列の値を参照し、もし dp[i] が無限大でない場合、つまりi個のまんじゅうを購入できる場合に、次の状態 dp[next_count] を更新します。
next_count は、現在の個数 i にパック内の個数 num_manjus を足した値ですが、必要以上に多くなることを防ぐために min(i + num_manjus, N) としています。
その後、dp[next_count] を、すでに計算された値と、今回のパックを追加した場合の新しいコスト dp[i] + cost とで比較し、最小値に更新します。
このループがすべて終了すると、N個以上のまんじゅうを購入するための最小コストが dp[N] に格納されます。
最後に、N個以上のまんじゅうを購入するための最小コストを dp[N] として出力します。
N は、職場の人数（つまり必要なまんじゅうの数）を表します。
packs は、各パックの情報をリストとして受け取ります。リストには3つのタプルが格納され、それぞれのタプルは (個数, 価格) の形式です。
動的計画法を使って効率的に解を求めることができます。dp 配列を使って、各状態を少しずつ更新していくことで、N個以上のまんじゅうを購入するための最小金額を計算します。
'''

# B152 選べる日替わり弁当
# utf-8
from itertools import combinations  # 組み合わせを生成するためのモジュールをインポート

# 入力を受け取る
N, X = map(int, input().split())  # Nはおかずの種類数、Xは目標金額
prices = list(map(int, input().split()))  # おかずの値段リスト
satisfactions = list(map(int, input().split()))  # おかずの満足度リスト

# 最大満足度を格納する変数を負の無限大で初期化（最悪のケースでも最大値を見つけるため）
max_satisfaction = float('-inf')

# 1つ、2つ、3つのおかずの組み合わせを列挙する
for r in range(1, 4):  # おかずを1個〜3個選ぶ組み合わせを試す
    for comb in combinations(range(N), r):  # 組み合わせを生成
        total_price = sum(prices[i] for i in comb)  # 現在の組み合わせの値段の合計を計算
        total_satisfaction = sum(satisfactions[i] for i in comb)  # 現在の組み合わせの満足度の合計を計算
        
        # 合計金額がX円になるか確認
        if total_price == X:
            # 満足度がこれまでの最大値より大きければ更新
            max_satisfaction = max(max_satisfaction, total_satisfaction)

# 結果を出力
print(max_satisfaction)
'''
最初に、標準入力からおかずの種類の数 N と、弁当の目標価格 X を読み取ります。次に、各おかずの値段と満足度をそれぞれリストに格納します。
N はおかずの数であり、X は弁当の合計価格として目標にする値です。
例えば、入力が 6 1000 の場合、6種類のおかずがあり、弁当の価格を1000円にする必要があります。
次に、prices というリストにおかずの値段、satisfactions というリストに各おかずの満足度が保存されます。
次に、最大満足度を追跡するための変数 max_satisfaction を初期化します。この変数は、後に最適な組み合わせが見つかった際に更新されます。初期値として、負の無限大（float('-inf')）を使います。
これにより、どの満足度も最初はこの値より大きくなるため、正しく更新されます。
itertools.combinations を用いて、おかずを1つ、2つ、3つ選ぶ全ての可能な組み合わせを生成します。combinations(range(N), r) で、N種類のおかずのインデックスから r 個選ぶ組み合わせを作ります。
ここで、r は 1 から 3 まで動かし、1つ、2つ、3つのおかずの組み合わせを試します。comb には選ばれたおかずのインデックスが含まれています。そのインデックスを使って、各おかずの値段の合計と満足度の合計を計算します。
total_price には、その組み合わせのおかずの合計値段が入ります。total_satisfaction には、その組み合わせのおかずの満足度の合計が入ります。
計算した total_price が目標の X 円と一致するかどうかを確認します。もし total_price == X なら、その組み合わせは条件を満たすことになります。
条件を満たした組み合わせに対して、その満足度の合計 total_satisfaction がこれまでの最大満足度 max_satisfaction より大きいかを確認し、もし大きければ max_satisfaction を更新します。この過程で、最も満足度が高い組み合わせが記録されます。
すべての組み合わせを試し終わった後、最終的に得られた最大満足度 max_satisfaction を出力します。この値が、X円の条件を満たし、かつ最大の満足度を持つ組み合わせの満足度です。
'''

# B153 蚊取線香


# B154
# B155
# B156
# B157
# B158
# B159
# B160
-----------------------------------------------B161　※欠番◆
# B161
# B162
# B163
# B164
# B165
# B166
# B167
# B168
# B169
# B170
-----------------------------------------------B171　※欠番◆
# B171
# B172
# B173
# B174
# B175
# B176
# B177
# B178
# B179
# B180
-----------------------------------------------B181　※欠番◆
# B181
# B182
# B183
# B184
# B185
# B186
# B187
# B188
# B189
# B190
-----------------------------------------------B191　※欠番◆
# B191
# B192
# B193
# B194
# B195
# B196
# B197
# B198
# B199
# B200
