※欠番が存在する理由につきましては、出題自体を公開終了した問題が欠番となっております。

--------------------------------------------- B001　※欠番 ◆
# B001 ◆
# B002 ◆
# B003 ◆
# B004 ログファイルの抽出
# utf-8
def isValidIp(m, c):
    ret = False
    if m == "*" or m == c:
        ret = True
    elif m[0] == "[":
        a = m.split("-")
        ss = int(a[0].replace("[", ""))
        ee = int(a[1].replace("]", ""))
        if ss <= int(c) <= ee:
            ret = True
    return ret


def main():
    # IPアドレスを読み込む
    mip = input().strip().split(".")
    
    # ログの数を読み込む
    n = int(input())
    
    # ログを1行ずつ読み込み、IPアドレスをチェックする
    for i in range(n):
        s = input().strip().split(" ")
        tip = s[0].split(".")
        if mip[0] == tip[0] and \
           mip[1] == tip[1] and \
           isValidIp(mip[2], tip[2]) and \
           isValidIp(mip[3], tip[3]):
            print(s[0] + " " + s[3][1:] + " " + s[6])


if __name__ == '__main__':
    main()
'''
1 標準入力からIPアドレスとログの数を取得し、IPアドレスを「.」で分割してリストに格納する
2 ログの数だけ繰り返し、1行ずつログを取得する
3 取得したログのIPアドレスを「.」で分割してリストに格納する
4 IPアドレスの1〜3オクテットが一致し、4オクテットが以下の条件を満たす場合に、ログの情報を出力する
　・IPアドレスの4オクテットが、IPアドレスの4オクテットと完全一致する場合
　・IPアドレスの4オクテットが、ワイルドカード「*」の場合
　・IPアドレスの4オクテットが、範囲指定の場合（「[」と「]」で囲まれた範囲内の数値のみ許可される）
具体的には、以下のような関数を定義して使用しています。
isValidIp(m, c)
　・引数mが「*」またはcと完全一致する場合はTrueを返す
　・引数mが範囲指定の場合は、引数cが範囲内にある場合はTrueを返す
このコードは、ログのIPアドレスが与えられたIPアドレスにマッチするかどうかを判定する処理を行っており、与えられたIPアドレスがワイルドカードや範囲指定を含んでいる場合にも対応しています。
'''

# B005 ◆　
# B006 ダーツゲーム
# utf-8
# 標準入力からの値の取得
import sys
input_line = sys.stdin.read()
input_list = input_line.split()

# 初期値の設定
o_y = float(input_list[0])
s = float(input_list[1])
theta = float(input_list[2])
x = float(input_list[3])
y = float(input_list[4])
a = float(input_list[5])

# 矢が当たるかどうかの判定
import math
g = 9.8
rad = math.radians(theta)
t = x / (s * math.cos(rad))
y2 = o_y + s * math.sin(rad) * t - (g * t ** 2) / 2
if y - a / 2 <= y2 <= y + a / 2:
    # 当たった場合、的の中心からの距離を出力
    dist = abs(y2 - y)
    print("Hit {:.1f}".format(round(dist, 1)))
else:
    # 当たらなかった場合、Missを出力
    print("Miss")
'''
以下の手順で矢が的に当たるかどうかを判定し、当たった場合には的の中心からの距離を出力します。
まず、sys.stdin.read()で標準入力から値を読み込み、split()でスペース区切りの文字列をリストに変換します。
次に、リストから必要な値を取り出し、float()で数値に変換します。
これで、矢の初期値点の高さ o_y、初速 s、角度 theta、的までの距離 x、的の高さ y、的の大きさ a がそれぞれ変数に格納されました。

矢が当たるかどうかの判定には、以下の計算式を使用します。
y2 = o_y + s * sin(rad) * t - (g * t^2) / 2
ここで、radはthetaをラジアンに変換したもの、tは矢が的に当たるまでの時間です。この式は、矢の初期値点から投げた瞬間の高さ o_y に、矢が的に当たるまでに到達する高さを足し合わせたものを計算し、的の高さ y ± 的の大きさ a の範囲内にあるかどうかを判定します。

具体的には、以下のように計算します。
import math

# 重力加速度
g = 9.8

# 角度をラジアンに変換
rad = math.radians(theta)

# 矢が的に当たるまでの時間
t = x / (s * math.cos(rad))

# 矢が的に当たるときの高さ
y2 = o_y + s * math.sin(rad) * t - (g * t ** 2) / 2

矢が当たるかどうかを判定する部分では、まず重力加速度を9.8[m/s^2]として、投射角度θに対しての水平方向と鉛直方向の初速度を求めます。そして、投射角度θと初速度sを用いて、到達時間tを求めます。tを用いて、矢の到達位置y2を計算します。その後、的の位置yから、的の半径a/2の範囲内に矢の到達位置y2があるかどうかを判定しています。
当たった場合は、的の中心からの距離を求めています。このとき、求めた距離を絶対値をとっているのは、矢が的の上側に当たった場合でも、的の中心からの距離を正しく求めるためです。また、四捨五入して小数点第1位までの数値を出力するには、Pythonの組み込み関数であるround()関数を使います。
当たらなかった場合は、"Miss"を出力しています。
'''

# B007 ◆
# B008 ◆
# B009 カンファレンスのタイムテーブル作成
# utf-8
# coding: utf-8

# 分を時刻表記に変換する関数　m分をhh:mm形式の文字列に変換する関数
def m2h(m):
    hour = m // 60 % 24  # 24時間制での時間を算出
    minute = m % 60  # 分を算出
    return f'{hour:02}:{minute:02}'  # hh:mm形式の文字列に変換して返す

# 時刻表記を分に変換する関数　hh:mm形式の文字列をm分に変換する関数
def h2m(h):
    hour, minute = map(int, h.split(':'))  # : を区切り文字として文字列を分割して、時と分に分ける
    return hour * 60 + minute  # 時を分に変換して分と合算し、分単位で返す

# 各プレゼンテーションの開始・終了時刻を計算する関数　スケジュールの時間計算を行う関数
def presentation_time(start_time, duration):
    global rest   # お昼休憩のフラグ　# グローバル変数 rest を参照するため、global宣言
    noon = h2m('12:00')  # 12:00を分単位に変換して、お昼の時間として取得
    end_time = start_time + duration  # 終了時刻を算出
    if not rest and noon < end_time:  # お昼休憩が必要かどうかを判定　# 休憩をとっておらず、終了時刻がお昼を過ぎている場合
        start_time += 60 - 10  # お昼休憩をとるために開始時刻をずらす　# お昼休憩を含む1時間の空きを作るために10分引いた時間に移動
        end_time = start_time + duration  # 新しい終了時刻を再度算出
        rest = True  # 休憩を取ったことをフラグに設定
    return start_time, end_time  # スケジュールの開始時間と終了時間を返す

n = int(input())  # # プレゼンテーションスケジュールの個数を入力

start_time = h2m('10:00')  # 最初のプレゼンテーションの開始時刻を10:00として、分単位に変換して取得

rest = False  # お昼休憩をとっていないことをフラグに設定　お昼休憩のフラグを初期化
for _ in range(n):  # スケジュールの個数だけ繰り返し処理を実行
    name, duration = input().split()  # スケジュール名と時間を入力として受け取る
    start_time, end_time = presentation_time(start_time, int(duration))  # スケジュールの開始時間と終了時間を計算
    print(f'{m2h(start_time)} - {m2h(end_time)} {name}')  # スケジュールの時間と名前を出力
    start_time = end_time + 10 # 休憩時間10分を加算して次のプレゼンテーションの開始時刻を計算する
'''
m2h() 関数
この関数は、分単位の時間を時:分の形式の文字列に変換するためのものです。
入力された分を60で割った余りが分の値、60で割った商を24で割った余りが時の値として取得します。
最後に、f-string を使って、"時:分" の形式で文字列を生成し、それを返します。

h2m() 関数
この関数は、時:分の形式の文字列を分単位の時間に変換するためのものです。
split() 関数を使って、文字列を ":" で分割し、時と分の値を取得します。
時を60で掛けたものに分を足し合わせて、分単位の時間を計算し、それを返します。

presentation_time() 関数
この関数は、スピーカーのプレゼンテーションの開始時間と終了時間を計算するためのものです。
引数として、スピーカーのプレゼンテーションの開始時間と時間の長さを受け取ります。
global キーワードを使って、rest 変数をグローバル変数として宣言します。
noon 変数には、12:00の分単位の時間を代入します。
end_time 変数には、プレゼンテーションの終了時間を代入します。
rest 変数が False かつ noon より end_time が後の場合、つまり、プレゼンテーションがお昼休憩をまたいでいる場合、開始時間にお昼休憩の10分を足した時間から再スタートし、終了時間を再計算します。
最後に、開始時間と終了時間を返します。

それ以降のメイン部分
まず、n = int(input())で発表する人数nを受け取ります。
次に、発表が始まる開始時間を表す変数start_timeに、10:00の時間をh2m('10:00')を使って分単位で代入します。
そして、restフラグをFalseで初期化します。これは、お昼休憩のチェックのために使用されます。
forループを使って、各発表の時間を処理します。forループの中で、name, duration = input().split()で発表者の名前nameと発表時間durationを受け取ります。このdurationは単位が分であり、整数型であることに注意してください。
次に、presentation_time(start_time, int(duration))を呼び出して、発表の終了時刻を計算し、その時間を人間が読みやすい形式で出力します。presentation_time関数は、start_timeと発表時間durationを引数として受け取り、終了時間のタイムスタンプ（分単位）を返します。
また、restフラグがFalseである場合は、終了時間が12:00を超える場合に、お昼休憩の時間（10分）を追加します。noon = h2m('12:00')で、12:00の時間を分単位で取得します。そして、noonよりも終了時間が後である場合に、start_time += 60 - 10で、お昼休憩を考慮した新しい開始時間を計算します。最後に、restフラグをTrueに設定します。
各発表が終わった後、start_timeにend_time + 10を代入して、次の発表の開始時間を計算します。この+ 10は、前の発表の終了時間と次の発表の開始時間の間に10分の休憩時間が必要であることを示しています。
'''

# B010 サッカーのオフサイド判定
# utf-8
def team_lineup(players, reverse=False):
    if reverse:
        players = list(map(lambda x:-x, players))
    return zip(range(1, 12), players)

def is_offside(x_player, x_passer, x_offside_line):
    return x_passer < x_offside_line < x_player

def get_offside_players(offence_team, diffence_team, x_passer, x_offside_line):
    offside_players = []
    for idx, x_p in enumerate(offence_team):
        if is_offside(x_p, x_passer, x_offside_line):
            offside_players.append(idx+1)
    return offside_players

def get_offside_line(diffence_team):
    return sorted(diffence_team, reverse=True)[1]

def get_opponent(name):
    return 'A' if name == 'B' else 'B'

# main
offence_name, passer = input().split()
team = {}
team['A'] = list(map(int, input().split()))
team['B'] = list(map(int, input().split()))

if offence_name == 'B':
    for t in team:
        team[t] = list(map(lambda x:-x, team[t]))

diffence_name = get_opponent(offence_name)
offence_team = team[offence_name]
diffence_team = team[diffence_name]

x_offside_line = get_offside_line(diffence_team)
x_passer = int(offence_team[int(passer)-1])

offside_players = get_offside_players(offence_team, diffence_team, x_passer, x_offside_line)

if offside_players:
    for p in offside_players:
        print(p)
else:
    print('None')
'''
与えられたサッカーの試合状況に対して、次のパスを受け取るとオフサイドと判定される選手の背番号を小さいものから順に1行ずつ出力するものです。
まず、input()関数を使って標準入力から入力を受け取ります。1行目では攻撃するチームの名前(offence_name)と、パスを受け取る選手の背番号(passer)をスペース区切りで受け取り、
2行目と3行目ではそれぞれ攻撃するチームの選手の背番号(team_a_numbers, team_b_numbers)をスペース区切りで受け取ります。
次に、攻撃するチームと守備するチームの背番号をリストで保持します。if文で、offence_nameが'B'の場合、攻撃するチームと守備するチームの背番号を反転させます。
この処理によって、攻撃するチームが必ずAチームになるようにしています。
次に、守備するチームの最後尾から2番目の背番号を取得します。この背番号より前に攻撃するチームの選手がいる場合、オフサイドの判定が行われます。
最後に、攻撃するチームの選手の中でオフサイドとなる選手の背番号を出力します。オフサイドとなる選手がいない場合には、"None"を出力します。
このコードのポイントは、オフサイド判定を行うis_offside関数にあります。この関数は、与えられた選手の背番号(x_player)、パスを出した選手の背番号(x_passer)、
そして守備するチームのオフサイドラインの背番号(x_offside_line)を受け取り、オフサイド判定を行います。
オフサイド判定は、パスを出した選手より前方に守備するチームのオフサイドラインと、パスを受けた選手が存在する場合に成立します。
'''

--------------------------------------------- B011　※欠番 ◆
# B011 名刺バインダー管理
# utf-8
n, m = map(int, input().split())

# m番目の名刺が含まれるページを計算する
page = (m - 1) // (n * 2) + 1

# そのページの最後の名刺番号と最初の名刺番号を計算する
last_card_num = page * n * 2
first_card_num = last_card_num - (n * 2 - 1)

# m番目の名刺が表面か裏面かによって、裏側の名刺の番号を計算する
if m <= (first_card_num + n - 1):
    back_card_num = last_card_num - (m - first_card_num)
else:
    back_card_num = first_card_num + (last_card_num - m)

print(back_card_num)
'''
1行目では、入力された文字列をスペースで分割し、それぞれ整数型に変換して、nとmに代入しています。
2行目では、m番目の名刺が属するページ数を求めています。m-1をn*2で割り、+1をしているのは、pythonで整数を割った場合、小数点以下が切り捨てられるためです。
また、m-1をする理由は、1番目の名刺が0ページ目にあるとみなすためです。3行目では、pageページに含まれる最後の名刺の番号を計算しています。pageページには、n2枚の名刺があるため、pmaxにn2をかけ、その後page-1をかけます。
それに1を足すのは、1ページ目が0番目のページであるとしているためです。4行目では、pageページに含まれる最初の名刺の番号を計算しています。pminには、pmaxからn*2-1を引いた数が入ります。
この式は、pageページの最初の名刺の番号がpage-1ページの最後の名刺の番号に1を足したものであることから導かれます。
5行目では、m番目の名刺の裏面にある名刺の番号を計算しています。mは、pageページの中で何番目の名刺なのかを計算します。pageページの最初の名刺の番号から、m番目の名刺の番号を引いたものが、m番目の名刺の裏面にある名刺の番号になります。
'''

# B012 ◆
# B013 ◆
# B014 3Dプリンタ
# utf-8
X,Y,Z=list(map(int,input().split()))
m=[['.' for j in range(Y)] for i in range(Z)]
for k in range(Z):
    for i in range(X):
        n=input()
        for j in range(Y):
            if n[j]=='#':
                m[k][j]='#'
    l=input()
for i in reversed(range(Z)):
    l=map(str,m[i])
    s=''.join(l)
    print(s)
'''
入力されたX,Y,Zに対して、Z枚のX行Y列のマス目を作成しています。マス目は、二次元リストで表現されています。
そして、入力されたマス目の状態を、マス目に反映させます。
最後に、マス目を反転させ、反転したマス目を出力します。
ここで、マス目の反転は、reversed(range(Z))を使用して、Zから0までの範囲を逆順に取得していることで実現されています。
また、map(str, m[i])を使用して、マス目を文字列に変換し、join()関数でつなげて、横一列の文字列として出力しています。
'''

# B015 7セグメントディスプレイ（デジタル表示の数字）　※テストケース通過せず
# utf-8
def check_display(a, b):
    # 各数字に対応する7セグメントディスプレイの状態
    digits = {
        0: [1, 1, 1, 1, 1, 1, 0],
        1: [0, 1, 1, 0, 0, 0, 0],
        2: [1, 1, 0, 1, 1, 0, 1],
        3: [1, 1, 1, 1, 0, 0, 1],
        4: [0, 1, 1, 0, 0, 1, 1],
        5: [1, 0, 1, 1, 0, 1, 1],
        6: [1, 0, 1, 1, 1, 1, 1],
        7: [1, 1, 1, 0, 0, 0, 0],
        8: [1, 1, 1, 1, 1, 1, 1],
        9: [1, 1, 1, 1, 0, 1, 1]
    }

    def is_valid_display(display):
        # ディスプレイの状態が各数字のいずれかと一致するかを判定
        for digit in digits.values():
            if display == digit:
                return True
        return False

    def symmetric_move(display):
        # 対称移動を行った後のディスプレイの状態を返す
        return display[::-1]

    def rotate_move(display):
        # 回転移動を行った後のディスプレイの状態を返す
        return display[-1:] + display[:-1]

    # 入力をリストに変換
    a_list = list(map(int, a.split()))
    b_list = list(map(int, b.split()))

    # 1. 装置が正しく2桁の数字を表すかを判定
    condition1 = is_valid_display(a_list) and is_valid_display(b_list)

    # 2. 装置を対称移動すると正しく2桁の数字を表すかを判定
    a_symmetric = symmetric_move(a_list)
    b_symmetric = symmetric_move(b_list)
    condition2 = is_valid_display(a_symmetric) and is_valid_display(b_symmetric)

    # 3. 装置を回転移動すると正しく2桁の数字を表すかを判定
    a_rotated = rotate_move(a_list)
    b_rotated = rotate_move(b_list)
    condition3 = is_valid_display(a_rotated) and is_valid_display(b_rotated)

    # 結果を出力
    result = ["Yes" if condition else "No" for condition in [condition1, condition2, condition3]]
    return "\n".join(result)

# 入力の受け取り
a = input()
b = input()

# 出力結果の表示
print(check_display(a, b))

# 別解　同様にテストケース通過せず
def check_display():
    # 各数字に対応する7セグメントディスプレイの状態
    digits = {
        0: [1, 1, 1, 1, 1, 1, 0],
        1: [0, 1, 1, 0, 0, 0, 0],
        2: [1, 1, 0, 1, 1, 0, 1],
        3: [1, 1, 1, 1, 0, 0, 1],
        4: [0, 1, 1, 0, 0, 1, 1],
        5: [1, 0, 1, 1, 0, 1, 1],
        6: [1, 0, 1, 1, 1, 1, 1],
        7: [1, 1, 1, 0, 0, 0, 0],
        8: [1, 1, 1, 1, 1, 1, 1],
        9: [1, 1, 1, 1, 0, 1, 1]
    }

    def is_valid_display(display):
        # ディスプレイの状態が各数字のいずれかと一致するかを判定
        for digit in digits.values():
            if display == digit:
                return True
        return False

    def symmetric_move(display):
        # 対称移動を行った後のディスプレイの状態を返す
        return display[::-1]

    def rotate_move(display):
        # 回転移動を行った後のディスプレイの状態を返す
        return display[-1:] + display[:-1]

    # 入力を受け取る
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    # 1. 装置が正しく2桁の数字を表すかを判定
    condition1 = is_valid_display(a) and is_valid_display(b)

    # 2. 装置を対称移動すると正しく2桁の数字を表すかを判定
    a_symmetric = symmetric_move(a)
    b_symmetric = symmetric_move(b)
    condition2 = is_valid_display(a_symmetric) and is_valid_display(b_symmetric)

    # 3. 装置を回転移動すると正しく2桁の数字を表すかを判定
    a_rotated = rotate_move(a)
    b_rotated = rotate_move(b)
    condition3 = is_valid_display(a_rotated) and is_valid_display(b_rotated)

    # 結果を出力
    result = ["Yes" if condition1 else "No",
              "Yes" if condition2 else "No",
              "Yes" if condition3 else "No"]
    return "\n".join(result)

# テストケース
print(check_display())

# B016 ここはどこ？
# utf-8
class B016:
    def __init__(self):
        info = input().split()
        self.board = {"W": int(info[0]), "H": int(info[1])}
        self.move_times = int(info[2])
        self.player = {}

    def set_player_position(self):
        position = input().split()
        self.player["X"] = int(position[0])
        self.player["Y"] = int(position[1])

    def set_move_info(self):
        self.move_info = []
        for i in range(self.move_times):
            move = input().split()
            self.move_info.append({"dir": move[0], "step": int(move[1])})

    def get_final_position(self):
        for move in self.move_info:
            self.move(move["dir"], move["step"])

    def move(self, direction, step):
        if direction == "U":
            step = step % self.board["H"]
            if self.player["Y"] + step > self.board["H"] - 1:
                self.player["Y"] = step - (self.board["H"] - self.player["Y"])
            else:
                self.player["Y"] += step
        elif direction == "D":
            step = step % self.board["H"]
            if self.player["Y"] - step < 0:
                self.player["Y"] = self.board["H"] - (step - self.player["Y"])
            else:
                self.player["Y"] -= step
        elif direction == "L":
            step = step % self.board["W"]
            if self.player["X"] - step < 0:
                self.player["X"] = self.board["W"] - (step - self.player["X"])
            else:
                self.player["X"] -= step
        elif direction == "R":
            step = step % self.board["W"]
            if self.player["X"] + step > self.board["W"] - 1:
                self.player["X"] = step - (self.board["W"] - self.player["X"])
            else:
                self.player["X"] += step

    def display(self):
        print("{} {}".format(self.player["X"], self.player["Y"]))

b016 = B016()
b016.set_player_position()
b016.set_move_info()
b016.get_final_position()
b016.display()
'''
このコードは、与えられた初期位置と移動ログに基づいて、移動後の位置を計算して出力するプログラムです。
まず、1行目でマップの横幅 w、縦幅 h、移動ログの個数 nを読み取ります。2行目では初期位置 x, yを読み取り、3行目からn+2行目までの各行で移動ログを読み取ります。
移動ログには、「dir_i」と「m_i」があり、「dir_i」は移動する方向（"U"、"D"、"R"、"L"）を、「m_i」は移動する距離を表しています。各ログに基づいて、プログラムは現在の位置から移動後の位置を計算し、最後に移動後の位置を出力します。
「move」メソッドは、与えられた方向と距離に応じて、与えられた座標を更新する関数です。プログラムは、与えられた移動ログに基づいて、「move」メソッドを呼び出し、プレイヤーの位置を更新します。
最後に、「display」メソッドは、プレイヤーの最終位置を出力します。
'''

# B017 手役の強さ(花札)
# utf-8
class StrongestMeans:
    def __init__(self, cards):
        self.cards = cards
        self.countOfCard = {}

    def getMeans(self):
        self.countCard()

        means = ""
        max_count = max(self.countOfCard.values())
        if max_count == 1:
            means = "NoPair"
        elif max_count == 2:
            means = "TwoPair" if len(self.countOfCard) == 2 else "OnePair"
        elif max_count == 3:
            means = "ThreeCard"
        elif max_count == 4:
            means = "FourCard"

        return means

    def countCard(self):
        for card in self.cards:
            if card == "*":
                self.plusAllKindCardOne()
            else:
                self.plusSpecifiedCardOne(card)

    def plusAllKindCardOne(self):
        cards = set(self.cards)
        for card in cards:
            if card != "*":
                self.plusSpecifiedCardOne(card)

    def plusSpecifiedCardOne(self, card):
        self.countOfCard[card] = self.countOfCard.get(card, 0) + 1

cards = input().strip()
strongMeans = StrongestMeans(list(cards))
print(strongMeans.getMeans())
'''
このコードは、入力のフォーマットに合わせてカードの入力を受け取り、StrongestMeansクラスのインスタンスを作成して、getMeansメソッドを呼び出し、結果を表示しています。
注意点：
カードの入力は、スペースで区切られた4つの文字列として受け取ります。
input().strip()を使って末尾の改行文字を除去します。
入力の最後には余分な文字や空行が含まれていないことを確認してください。
このコードを使用して、与えられた入力に基づいて最高の手役を判定し、出力することができます。

まず、StrongestMeansという名前のクラスが定義されています。このクラスは、カードの集合から手役の強さを判定するためのメソッドを提供します。
__init__メソッドは、cardsという引数を受け取り、インスタンスの初期化を行います。cardsは入力されたカードのリストです。countOfCardはカードの出現回数を格納するための辞書です。
getMeansメソッドは手役の強さを返します。まず、countCardメソッドを呼び出してカードの出現回数を数えます。
次に、countOfCard辞書の値の中で最大の数を取得します。その最大数に応じて手役を判定し、meansに結果を格納します。

countCardメソッドは、カードの出現回数を数えるためのメソッドです。self.cardsの各カードについて、cardとして処理します。
もしcardがワイルドカード "*" ならば、plusAllKindCardOneメソッドを呼び出します。
そうでない場合は、plusSpecifiedCardOneメソッドを呼び出して指定されたカードの出現回数を増やします。

plusAllKindCardOneメソッドは、ワイルドカード "*" の場合に他のすべてのカードの出現回数を増やすためのメソッドです。
self.cardsのユニークな要素を取得し、それぞれのカードについて処理します。
'''

# B018 ◆
# B019 グレースケールの画像の縮小
# utf-8
def shrink_image(N, K, pixels):
    # N/K × N/Kの画像を作成
    new_N = N // K
    new_pixels = [[0] * new_N for _ in range(new_N)]

    # 各ブロックの平均値を計算
    for r in range(new_N):
        for c in range(new_N):
            block_sum = 0
            for i in range(r * K, (r + 1) * K):
                for j in range(c * K, (c + 1) * K):
                    block_sum += pixels[i][j]
            average = block_sum // (K * K)
            new_pixels[r][c] = average

    return new_pixels

# 入力を受け取る
N, K = map(int, input().split())
pixels = []
for _ in range(N):
    row = list(map(int, input().split()))
    pixels.append(row)

# 画像を縮小
result = shrink_image(N, K, pixels)

# 結果を出力
for row in result:
    print(*row)
'''
shrink_image(N, K, pixels) 関数は、元の画像を指定されたブロックサイズで縮小するための関数です。関数は以下の手順で動作します。

元の画像のサイズ N とブロックサイズ K を受け取ります。
新しい画像のサイズ new_N を計算します。new_N は N を K で割った商です。
新しい画像を表現するための二次元リスト new_pixels を作成します。サイズは new_N × new_N です。
各ブロックの平均値を計算し、新しい画像のピクセル値として new_pixels に格納します。
最終的に new_pixels を返します。
メインのプログラムでは、以下の手順で処理が行われます。

元の画像のサイズ N とブロックサイズ K を入力します。
N 行のピクセル値を受け取り、二次元リスト pixels に格納します。
shrink_image(N, K, pixels) 関数を呼び出して、画像を縮小します。結果は result に格納されます。
result を出力します。
'''

# B020 ネットサーフィン
# utf-8
n = int(input())  # クエリの数を取得
queries = []  # クエリを保持するリスト
history = ["blank page"]  # ページの履歴を保持するリスト

# クエリを入力してリストに追加
for _ in range(n):
    queries.append(input())

# 各クエリを処理
for query in queries:
    if query == "use the back button":
        if len(history) > 1:
            history.pop()  # 直前のページを履歴から削除
        print(history[-1])  # 現在のページを出力
    else:
        page_name = query[6:]  # ページ名を取得
        history.append(page_name)  # ページを履歴に追加
        print(page_name)  # ページ名を出力

print()  # 最後の改行を出力
'''
このコードでは、まずクエリの数を取得し、その後のクエリをリストに追加します。それぞれのクエリに対して以下の処理を行います。

"use the back button" の場合:

履歴が1つ以上存在する場合は、直前のページを履歴から削除します。
現在のページを出力します。
"go to [page_name]" の場合:

ページ名を取得し、履歴に追加します。
ページ名を出力します。
最後に改行を出力します。

この修正により、最初のページが "blank page" であること、"use the back button" の場合でも "blank page" 以外の指定されたページを開くこと、各テストケースでの出力例が要件を満たすようになります。

修正後のコードでは、入力例に対する出力例も要件を満たすようになります。それぞれのクエリに対して適切なページを開き、履歴を保持しながら出力しています。
'''
--------------------------------------------- B021　※欠番 ◆
# B021 ◆
# B022 ◆
# B023 マッチ棒パズル
# utf-8
def get_another(a, b):
    for i in range(len(a)):
        a[i] = b[i]
    return a


def set_number(number):
    number[0][0] = "69"
    number[0][1] = "8"
    number[0][2] = ""

    number[1][0] = ""
    number[1][1] = "7"
    number[1][2] = ""

    number[2][0] = "3"
    number[2][1] = ""
    number[2][2] = ""

    number[3][0] = "25"
    number[3][1] = "9"
    number[3][2] = ""

    number[4][0] = ""
    number[4][1] = ""
    number[4][2] = ""

    number[5][0] = "3"
    number[5][1] = "69"
    number[5][2] = ""

    number[6][0] = "09"
    number[6][1] = "8"
    number[6][2] = "5"

    number[7][0] = ""
    number[7][1] = ""
    number[7][2] = "1"

    number[8][0] = ""
    number[8][1] = ""
    number[8][2] = "069"

    number[9][0] = "06"
    number[9][1] = "8"
    number[9][2] = "35"

    return number


def main():
    charS = input().strip()
    result = []

    number = [["" for _ in range(3)] for _ in range(10)]
    number = set_number(number)

    temp = list(charS)
    temp = get_another(temp, list(charS))
    for i in range(len(charS)):
        for j in range(3):
            point = int(charS[i])

            for k in range(len(number[point][j])):
                if j == 0:
                    temp[i] = number[point][0][k]
                    output = "".join(temp)
                    result.append(output)
                    temp = get_another(temp, list(charS))
                elif j == 1:
                    for l in range(i + 1, len(charS)):
                        point2 = int(charS[l])
                        for m in range(len(number[point2][2])):
                            temp[i] = number[point][1][k]
                            temp[l] = number[point2][2][m]
                            output = "".join(temp)
                            result.append(output)
                            temp = get_another(temp, list(charS))
                else:
                    for l in range(i + 1, len(charS)):
                        point2 = int(charS[l])
                        for m in range(len(number[point2][1])):
                            temp[i] = number[point][2][k]
                            temp[l] = number[point2][1][m]
                            output = "".join(temp)
                            result.append(output)
                            temp = get_another(temp, list(charS))

    result.sort()

    if len(result) == 0:
        print("none")
    else:
        for i in range(len(result)):
            print(result[i])
main()
'''
get_another(a, b) 関数:
リスト a をリスト b の要素で上書きする関数です。
a と b の要素数は同じである必要があります。
set_number(number) 関数:
number という2次元リストを引数として受け取り、特定のパターンで要素を初期化します。
この関数は number リストを返します。
main() 関数:
・プログラムのエントリーポイントとなる関数です。
・入力文字列 charS を受け取り、結果のリスト result を初期化します。
・2次元リスト number を set_number() 関数で初期化します。
・charS の各文字を処理するループを開始します。
・charS の各文字について、3つのパターン (j の値) に対してループを開始します。
・パターンごとに、数字の置換を行い、結果を result リストに追加します。
・最後に result をソートし、結果を出力します。

このコードのアルゴリズムは、与えられた文字列 charS の各文字に対して、異なるパターンで数字の置換を行い、結果を生成しています。
これにより、全ての可能な置換パターンを網羅的に生成することができます。最終的な結果は辞書順にソートされています。
ただし、このコードでは一部の箇所で冗長な処理が行われており、効率的ではないと言えます。特に、リストのコピー (temp = get_another(temp, list(charS))) や結果のリストに要素を追加する際のループ処理が、改善の余地があります。
'''

# B024 格子を円で切り取る　※数学的アプローチが必要
# utf-8
import math # mathモジュールをインポートして円周率の計算や平方根の計算を行います。

while True: # 無限ループを開始
    try: # 入力を試みます。もし例外が発生した場合、exceptブロックに移動します。
        r = float(input()) # 半径 r の値を浮動小数点数として入力します。
        if r <= 0: # もし r が0以下の場合、無効な入力値として扱い、エラーメッセージを表示して次のループに移ります。
            print("Invalid input: r must be a positive number.")
            continue
        total = 0 # 格子点の合計数を初期化します。
        n = math.ceil(r) # r の値を切り上げて最も近い整数 n にします。これは最小の正方形の一辺の長さとなります。
        for i in range(n + 1): # 0から n までの範囲でループ
            if r * r - i * i < 0: # もし r * r - i * i が0より小さい場合、円の内部にないのでスキップします。
                continue
            total += math.ceil(math.sqrt(r * r - i * i)) # 円の内部にある格子点の数を計算し、それを total に加算します。
        print(total * 4) # 計算された格子点の合計数に4を乗算して出力します。
    except (ValueError, EOFError): # 入力時に ValueError や EOFError の例外が発生した場合、ループを終了します。
        break
'''
このコードでは、入力された半径 r をもとに最小の正方形内の格子点の数を求め、さらに円の内部にある格子点の数を計算しています。
最終的に、格子点の数に4を乗算して出力します。なお、無効な入力や入力の終了（EOF）に対しても適切に処理しているため、例外が発生しても安全に終了できます。
'''

# B025 うさぎジャンプ
# utf-8
# N, M, Kの入力を受け取る
N, M, K = map(int, input().split())

# 各うさぎの現在の位置をリストに格納する
s = [int(input()) for _ in range(M)]

# しげみの状態を管理するリストを作成する（初期値は0）
grass = [0] * N

# 各うさぎの初期位置をしげみのリストに反映する
for i in s:
    grass[i - 1] = i

# Kセットのジャンプを行う
for _ in range(K):
    for j in range(M):
        # うさぎがジャンプ先として選ぶしげみの番号（% nを行うことで範囲内に収める）
        grass_num = s[j] % N
        # ジャンプ先が他のうさぎに占拠されている場合、空いているしげみを探す
        while grass[grass_num] != 0:
            grass_num = (grass_num + 1) % N
        # ジャンプ元のしげみからうさぎを移動させる
        grass[grass_num] = grass[s[j] - 1]
        grass[s[j] - 1] = 0
        # うさぎの位置情報を更新する
        s[j] = grass_num + 1

# 各うさぎの最終位置を出力する
for i in s:
    print(i)
'''
標準入力からN、M、Kの値を受け取ります。それぞれ、しげみの数N、うさぎの数M、ジャンプ回数Kを表します。
うさぎの現在位置をリストsに格納しています。range(m)でうさぎの数M回ループし、int(input())によって各うさぎの位置を受け取ります。
しげみの状態を管理するためのリストgrassを作成、初期値は全て0です。次のループでは、リストsに格納されている各うさぎの位置情報を、リストgrassに反映させています。
各うさぎの位置-1のインデックスに対応する要素にうさぎの番号を代入しています。Kセットのジャンプを行っています。
外側のループはK回ループします。内側のループでは、各うさぎに対してジャンプ処理を行います。
grass_numはうさぎがジャンプ先として選ぶしげみの番号です。s[j] % nによって範囲内に収められます。
grass[grass_num] != 0は、ジャンプ先のしげみが他のうさぎに占拠されているかどうかを判定しています。もし占拠されている場合、次の空いているしげみを探すためにgrass_numを1ずつ増やしていきます。whileループを抜けた時点で、grass_numには空いているしげみの番号が格納されます。
ジャンプ元のしげみからうさぎを移動させるために、grass[grass_num]にジャンプ元のうさぎの番号を代入し、ジャンプ元のしげみを空にします。
最後に、うさぎの位置情報を更新するためにs[j]にgrass_num + 1を代入します。+ 1はインデックスと番号の差を調整するためです。
'''

# B026 自動販売機
# utf-8
class VendingMachine:
    def __init__(self, coin_in_machine):
        self.coin_in_machine = coin_in_machine

    def sell_result(self, customers):
        for customer in customers:
            arr_customer = customer.split(" ")

            # お客様が購入した商品の価格及び入れた各コインの枚数
            product_price = int(arr_customer[0])
            use_coin = {
                500: int(arr_customer[1]),
                100: int(arr_customer[2]),
                50: int(arr_customer[3]),
                10: int(arr_customer[4])
            }

            change_coin = {
                500: 0,
                100: 0,
                50: 0,
                10: 0
            }

            # お釣り
            change = [500 * use_coin[500] + 100 * use_coin[100] + 50 * use_coin[50] + 10 * use_coin[10] - product_price]
            tmp_change = change[0]

            for coin, coin_number in self.coin_in_machine.items():
                self.change(coin, coin_number, change, change_coin)

            message = ""
            if self.check_if_pass(change_coin, tmp_change):

                # 自動販売機内部コインの変化
                for coin, coin_number in self.coin_in_machine.items():
                    self.coin_in_machine[coin] = coin_number + use_coin[coin] - change_coin[coin]

                # 出力
                k = 0
                for coin, count in change_coin.items():
                    message += str(count)
                    if k == len(change_coin) - 1:
                        break
                    message += " "
                    k += 1

            else:
                message += "impossible"
            print(message)

    def change(self, coin, coin_number, change, change_coin):
        # お釣りの残りがcoin以下の場合は計算不要なので処理を終了する
        if change[0] < coin:
            return
        for num in range(coin_number, -1, -1):
            price = change[0] - num * coin
            # 残りのお釣りがcoinを使ってprice円支払える場合
            if price >= 0:
                change[0] -= num * coin
                change_coin[coin] = num
                return

    def check_if_pass(self, change_coin, tmp_change):
        # 50円玉と10円玉の合計が100円以上の場合は条件を満たさない
        if change_coin[50] * 50 + change_coin[10] * 10 >= 100:
            return False
        for coin, coin_number in self.coin_in_machine.items():
            # 自動販売機内のコインの枚数を超える場合は条件を満たさない
            if change_coin[coin] > coin_number:
                return False
        # お釣りの合計金額がtmp_change円と一致しない場合は条件を満たさない
        if change_coin[500] * 500 + change_coin[100] * 100 + change_coin[50] * 50 + change_coin[10] * 10 != tmp_change:
            return False
        return True


# 入力値の読み込み
info = input().strip()
arr_info = info.split(" ")

coin_in_machine = {
    500: int(arr_info[0]),
    100: int(arr_info[1]),
    50: int(arr_info[2]),
    10: int(arr_info[3])
}

count_of_customer = int(input().strip())
customers = []
for _ in range(count_of_customer):
    customers.append(input().strip())

# 自動販売機オブジェクトの作成と売り上げ結果の表示
vending_machine = VendingMachine(coin_in_machine)
vending_machine.sell_result(customers)
'''
VendingMachine クラス:
coin_in_machine インスタンス変数: 自動販売機内の各コインの枚数を格納する辞書です。
__init__ メソッド: coin_in_machine 辞書を受け取り、インスタンス変数に設定します。
sell_result メソッド: 複数の顧客の購入情報を受け取り、結果を表示します。
change メソッド: お釣りの計算を行います。指定されたコインで支払い可能な最大枚数を計算し、お釣りと使用したコインの枚数を更新します。
check_if_pass メソッド: お釣りの条件をチェックし、条件を満たすかどうかを判定します。

入力の読み込み:
最初の入力は自動販売機内のコインの枚数を表す文字列です。空白で区切られた各要素は、500円、100円、50円、10円のコインの枚数を表します。
2番目の入力は顧客の数を表す整数です。
続く入力は各顧客の購入情報を表す文字列です。空白で区切られた各要素は、商品の価格、500円、100円、50円、10円のコインの枚数を表します。

自動販売機オブジェクトの作成と売り上げ結果の出力:
入力から得られた情報をもとに、VendingMachine オブジェクトを作成します。
sell_result メソッドを呼び出し、顧客ごとの売り上げ結果を出力します。
'''

# B027 ◆
# B028 チャット記録
# utf-8
# 入力を取得
n, g, m = list(map(int, input().split()))
# グループの情報を取得
k = [list(map(int, input().split())) for i in range(g)]
# 各社員の画面に表示されるメッセージを格納するリストを初期化
N = [[] for i in range(n)]
# メッセージの数だけループ
for i in range(m):
    # メッセージの情報を入力し、送信者、受信者の種類、ターゲット、内容を取得
    s = input().split()
    sender = int(s[0])
    recipient_type = int(s[1])
    target = int(s[2])
    content = s[3:]
    
    # 受信者の種類が0の場合、送信者と受信者の両方の画面にメッセージを追加
    if recipient_type == 0 and sender != target:
        N[sender-1] += content
        N[target-1] += content
    
    # 受信者の種類が1の場合、対象のグループに所属するすべての社員の画面にメッセージを追加
    if recipient_type == 1:
        group_members = k[target-1][1:]  # グループのメンバーを取得
        for member in group_members:
            N[member-1] += content
    
# 各社員の画面に表示されるメッセージを出力
for i in range(n-1):
    print('\n'.join(N[i]))
    print('--')
print('\n'.join(N[-1]))
'''
このコードは、与えられた入力に基づいてメッセージのやり取りをシミュレーションし、各社員の画面に表示されるメッセージを出力します。
まず、社員数 n、グループ数 g、メッセージ数 m を入力します。次に、各グループの情報を入力し、グループに所属する社員のリストを作成します。
その後、メッセージの数だけループを回し、各メッセージに対して以下の処理を行います。
メッセージの情報を入力し、送信者と受信者の種類、ターゲット、内容を取得します。
受信者の種類が 0 の場合、送信者と受信者の両方の画面にメッセージを追加します。
受信者の種類が 1 の場合、対象のグループに所属するすべての社員の画面にメッセージを追加します。
最後に、各社員の画面に表示されるメッセージを出力します。各社員の画面ごとに、メッセージを改行区切りで表示し、最後にハイフンで区切ります。
'''

# B029 地価の予想
# utf-8 Pythonにすると90点
import math

def predict_land_price(x, y, k, known_points):
    # 地点A（x, y）から既知の地点までの距離と価格を計算して保持する
    distances = [(math.sqrt((x - xi) ** 2 + (y - yi) ** 2), pi) for xi, yi, pi in known_points]
    distances.sort(key=lambda d: (d[0], d[1]))  # 距離を昇順にソート

    # k個の最も近い地点の価格の合計を計算し、平均を求めて予測価格とする
    total_price = sum(p for _, p in distances[:k])
    predicted_price = round(total_price / k)

    return predicted_price

def main():
    # 入力値の読み込み
    x, y = map(int, input().split())
    k = int(input())
    N = int(input())

    # 入力条件の検証
    if not (2 <= N <= 100):
        raise ValueError("Nは2から100の範囲内である必要があります")
    if not (1 <= k <= N):
        raise ValueError("kは1からNの範囲内である必要があります")
    if not (0 <= x <= 1000) or not (0 <= y <= 1000):
        raise ValueError("xとyは0から1000の範囲内である必要があります")

    known_points = []
    for _ in range(N):
        # 既知の地点の座標と価格を読み込む
        xi, yi, pi = map(int, input().split())

        # 既知の地点の条件の検証
        if not (0 <= xi <= 1000) or not (0 <= yi <= 1000):
            raise ValueError("xiとyiは0から1000の範囲内である必要があります")
        if not (1 <= pi <= 100):
            raise ValueError("piは1から100の範囲内である必要があります")

        known_points.append((xi, yi, pi))

    # k-近傍法を使用して地点A（x, y）における地価を予測する
    predicted_price = predict_land_price(x, y, k, known_points)

    # 予測した地価を出力する
    print(predicted_price)

if __name__ == "__main__":
    try:
        main()
    except ValueError as e:
        print("入力が無効です:", str(e))

# utf-8　Java
import java.util.Scanner;
import java.util.TreeMap;

public class Main {

	public static void main(String[] args) {

		Scanner in = new Scanner(System.in);

		// 基準点のX座標,Y座標の設定

		int coordinateX = in.nextInt();// 基準点X座標入力
		int coordinateY = in.nextInt();// 基準点Y座標入力

		// 近い点の個数・既知の個数の設定

		int nearPointCount = in.nextInt();// 基準値からいくつ既知の点を使うか入力
		int knownPointCount = in.nextInt();// 既知の点はいくつあるか入力

		// 既知の点の座標・地価設定

		int[] knownPointCoordinateX = new int[knownPointCount];// 既知の点のX座標格納
		int[] knownPointCoordinateY = new int[knownPointCount];// 既知の点のY座標格納
		int[] landPrice = new int[knownPointCount];// 既知の点の地価格納

		for (int i = 0; i < knownPointCount; i++) {
			knownPointCoordinateX[i] = in.nextInt();// X座標入力
			knownPointCoordinateY[i] = in.nextInt();// Ｙ座標入力
			landPrice[i] = in.nextInt();// 地価入力
		}

		// 基準値と既知との距離計算設定

		TreeMap<Double, Integer> distanceLandPrice = new TreeMap<>(); // 基準値との距離ををkeyに地価をvalueのTreeMap
		double tmp = 0;// 基準値との距離の一時変数

		for (int i = 0; i < knownPointCount; i++) {

			// 距離計算
			tmp = Math.sqrt(Math.pow(coordinateX - knownPointCoordinateX[i], 2)
					+ Math.pow(coordinateY - knownPointCoordinateY[i], 2));

			distanceLandPrice.put(tmp, landPrice[i]);
		}

		// 基準点の地価計算設定

		double sumLandPrice = 0;// 地価合計 四捨五入するためdouble型で扱う
		int cnt = 0;// 既知の点をいくつ使ったかカウント

		for (double key : distanceLandPrice.keySet()) {// 昇順にソートされたkeyから取り出す = 基準値との距離が短いものから

			if (cnt == nearPointCount) {
				break;
			}
			sumLandPrice += distanceLandPrice.get(key);// 地価の合計更新
			cnt++;
		}

		// 結果出力

		System.out.println(Math.round(sumLandPrice / nearPointCount));

	}
}

# B030 氷のダンジョン　※入力例1のみOK
# utf-8
def explore_dungeon(H, W, dungeon, s_x, s_y, N, directions):
    # 方向ごとの座標の変化量
    dx = {'U': 0, 'R': 1, 'D': 0, 'L': -1}
    dy = {'U': -1, 'R': 0, 'D': 1, 'L': 0}

    # 初期座標
    x = s_x
    y = s_y

    # 移動を実行
    for direction in directions:
        while True:
            # 移動先の座標を計算
            nx = x + dx[direction]
            ny = y + dy[direction]

            # 移動先がダンジョン内かどうかをチェック
            if nx < 1 or nx > W or ny < 1 or ny > H:
                break  # 移動先がダンジョン外なら終了

            # 移動先が壁なら終了
            if dungeon[ny][nx] == '#':
                break

            # 移動先が土の床なら移動
            x = nx
            y = ny

    return x, y


# 入力の読み込み
H, W = map(int, input().split())
dungeon = []
for _ in range(H):
    dungeon.append(input().strip())
s_x, s_y = map(int, input().split())
N = int(input())
directions = []
for _ in range(N):
    directions.append(input().strip())

# ダンジョンの探索
final_x, final_y = explore_dungeon(H, W, dungeon, s_x, s_y, N, directions)

# 結果の出力
print(final_x, final_y)

--------------------------------------------- B031　※欠番 ◆
# B031 コインのウラとオモテ
# utf-8
def count_black_coins(N, s):
    board = list(s)  # 入力文字列をリストに変換してボードとして扱う
    black_count = board.count('b')  # 最初の黒コインの数を数える

    flipped = True  # 反転が行われたかどうかを表すフラグ
    while flipped:
        flipped = False  # 初期値は反転が行われなかったとする
        i = 0
        while i < N:
            if board[i] == 'b':  # 黒コインの場合
                j = i
                while j < N and board[j] == 'b':
                    j += 1
                if i > 0 and j < N and 'w' not in board[i:j]:
                    # 黒コインが白コインを挟めない場合、反転させる
                    for k in range(i, j):
                        board[k] = 'w'
                    flipped = True  # 反転が行われたのでフラグを立てる
            elif board[i] == 'w':  # 白コインの場合
                j = i
                while j < N and board[j] == 'w':
                    j += 1
                if i > 0 and j < N and 'b' not in board[i:j]:
                    # 白コインが黒コインを挟めない場合、反転させる
                    for k in range(i, j):
                        board[k] = 'b'
                    flipped = True  # 反転が行われたのでフラグを立てる
            i = j

    black_count = board.count('b')  # 最終的な黒コインの数を数える
    return black_count

# 入力の読み込み
N = int(input())
s = input().rstrip()

# 黒コインの個数の計算
result = count_black_coins(N, s)

# 結果の出力
print(result)
'''
まず、count_black_coinsという関数が定義されています。この関数は、引数としてボードの横の長さを表すNとゲーム開始時のコインの並びを表す文字列sを受け取り、最終的な黒コインの数を返します。
関数内では、boardというリストを作成し、sを文字ごとに分割して格納します。また、最初の黒コインの数を数えるための変数black_countを用意します。
flippedというフラグ変数をTrueで初期化します。この変数は、反転が行われたかどうかを示す役割を果たします。
次に、whileループが開始されます。ループ内では、まずflippedをFalseに設定します。これは、反転が行われなかった場合のデフォルトの状態です。
次に、インデックスiを初期化し、iがNより小さい間ループを繰り返します。ループ内では、以下の処理が行われます。

board[i]が黒コインの場合：
jをiとし、jがN以下かつboard[j]が黒コインである間ループを繰り返します。つまり、連続する黒コインの範囲を見つけます。
もしiより前に白コインがなく、jより後に白コインがない場合、つまり黒コインが白コインを挟めない状態であれば、その範囲のコインを反転させます。具体的には、board[i:j]の要素をすべて白コインに置き換えます。
反転が行われた場合、flippedをTrueに設定します。

board[i]が白コインの場合：
jをiとし、jがN以下かつboard[j]が白コインである間ループを繰り返します。つまり、連続する白コインの範囲を見つけます。
もしiより前に黒コインがなく、jより後に黒コインがない場合、つまり白コインが黒コインを挟めない状態であれば、その範囲のコインを反転させます。具体的には、board[i:j]の要素をすべて黒コインに置き換えます。
反転が行われた場合、flippedをTrueに設定します。
iをjの値に更新します。

ループの最後で、もしflippedがTrueのままであれば、まだ反転が行われる可能性があるため、再度の反転処理を行います。これは、連続するコインの範囲に対しての反転を繰り返し行うためです。
最後に、最終的なボードの状態で黒コインの数を数え、その結果をblack_countとして返します。
メインの処理では、入力を受け取り、count_black_coins関数を呼び出して最終的な黒コインの数を計算し、結果を出力します。
'''

# B032 デジタル計算機
# utf-8
class Abacus:
    def __init__(self, width):
        self.width = width

    def get_number(self):
        numbers = []
        # そろばんの状態を入力
        for _ in range(8):
            pearls = input().strip()
            numbers.append(list(pearls))
        
        result = ''
        # 列ごとに珠の移動をシミュレーション
        for pearls in zip(*numbers):
            tmp = 0
            for position, pearl in enumerate(pearls):
                if position < 2:
                    if position == 1 and pearl == '*':
                        tmp += 5  # 上の桁で2つ目の珠が存在し、'*' の場合は5を加算
                    continue
                if position == 2:
                    continue # 3つ目の位置は無視して次の位置へ進む
                if position > 2:
                    if pearl == '|':
                        break   # '|' が現れた場合は珠の移動が終了し、ループから抜ける
                    tmp += 1    # '|' が出現するまで、珠の移動回数をカウント
            result += str(tmp)  # 珠の移動回数を結果に追加

        return int(result.rjust(self.width, '0')) # 結果を指定の桁数に合わせてゼロで左詰めし、整数として返す

    def get_result(self, number):
        result = [['*' if i != 2 else '=' for _ in range(self.width)] for i in range(8)]
        # そろばんの初期状態を生成
        number = str(number).rjust(self.width, '0')
 
        # 数字をそろばんの状態に変換
        for i, digit in enumerate(number):
            digit = int(digit)
            if digit < 5:
                result[0][i] = '*'  # 上の桁の珠
                result[1][i] = '|'  # 下の桁の珠
            else:
                result[0][i] = '|'  # 上の桁の珠

            number = str(digit - 5) if digit >= 5 else str(digit)
            # 数字が5以上の場合は珠を1つ上に移動させた後の数字
            # 数字が5未満の場合は珠を移動させずそのままの数字
            # 条件が真の場合、珠を1つ上に移動させた後の数字を表す文字列に変換しています。
            # 条件が偽の場合、珠を移動させず、元の数字のままとなります。
            # 下の桁の珠を配置
            for j in range(3, 8):
                if j - 3 == int(number):
                    result[j][i] = '|'  # 下の桁の珠

        # 結果を表示
        for row in result:
            print(''.join(row))


W = int(input())  # そろばんの長さを入力
abacus = Abacus(W)
A = abacus.get_number()  # 数字 A のそろばんを取得
B = abacus.get_number()  # 数字 B のそろばんを取得
abacus.get_result(A + B)  # A + B のそろばんを表示
'''
Abacus クラスのコンストラクタで、そろばんの幅（桁数）を受け取り、インスタンス変数 width に設定します。
get_number メソッドは、そろばんの状態を入力として受け取り、その状態に対応する数値を返します。
入力されたそろばんの状態は、8行分の文字列として受け取ります。各行は桁ごとの珠の状態を表しています。それぞれの珠は '*' または '|' のいずれかです。
列ごとに珠の移動をシミュレーションし、数値に変換しています。具体的な処理は以下の通りです。

position と pearl には珠の位置と状態が順番に渡されます。
position が 0 または 1 の場合、2つ目の珠の位置であることを判定しています。
もし pearl が '*' の場合、上の桁で2つ目の珠が存在することを意味し、結果に 5 を加算します。
position が 2 の場合、3つ目の位置であることを判定して無視します。
position が 2 より大きい場合、下の桁の位置であることを意味します。
もし pearl が '|' の場合、珠の移動が終了し、ループから抜けます。
それ以外の場合、珠の移動回数を 1 加算します。
最終的に、結果を文字列 result に追加し、指定の桁数に合わせて左詰めし、整数として返します。

get_result メソッドは、数値をそろばんの状態に変換して表示します。
まず、数値 number を文字列に変換し、指定の桁数に合わせて左詰めします。
それぞれの桁の数字をそろばんの状態に変換して result に格納します。具体的な処理は以下の通りです。

i と digit には桁のインデックスと数字が順番に渡されます。
digit を整数に変換し、その値に応じて上の桁と下の桁の珠の状態を設定します。
もし digit が 5 未満の場合、上の桁の珠に '*' を、下の桁の珠に '|' を設定します。
もし digit が 5 以上の場合、上の桁の珠に '|' を設定します。
digit を 5 を引いた値に変換し、その結果を number に再代入します。これにより、次の桁の珠の配置に移ります。
下の桁の珠の位置 j が、j - 3 と number の値が一致する場合、下の桁の珠に '|' を設定します。
最終的に、結果のそろばんの状態を表示します。
'''

# B033 テーブルジェネレーター
# utf-8
def generate_table(headers, data):
    # 各列の最大幅を計算
    column_widths = [max(len(header), max(len(str(row[i])) for row in data)) for i, header in enumerate(headers)]

    # ヘッダー行を生成
    header_row = "| " + " | ".join(header.ljust(width) for header, width in zip(headers, column_widths)) + " |"

    # 区切り行を生成
    separator_row = "|-" + "-|-".join("-" * width for width in column_widths) + "-|"

    # データ行を生成
    data_rows = ""
    for row in data:
        data_row = "| " + " | ".join(str(cell).ljust(width) for cell, width in zip(row, column_widths)) + " |\n"
        data_rows += data_row

    # テーブルを結合して返す
    table = header_row + "\n" + separator_row + "\n" + data_rows
    return table

def generate_output(headers, data):
    # テーブルを生成
    table = generate_table(headers, data)
    # 改行と余分な空白を削除して出力用文字列を作成
    output = ""
    output += table.strip() + "\n"

    return output

# 入力の取得
W = int(input())
headers = input().split()
H = int(input())
data = [input().split() for _ in range(H)]

# テーブルの生成と出力
output = generate_output(headers, data)
print(output)
'''
generate_table(headers, data)関数は、与えられた見出しとデータから表を生成するための関数です。まず、各列の最大幅を計算します。
その後、ヘッダー行、区切り行、データ行を生成し、それらを結合してテーブルを作成します。最終的に、生成したテーブルを返します。
generate_output(headers, data)関数は、generate_table()関数を呼び出してテーブルを生成し、出力用の文字列を作成します。
テーブルの前後に余分な空白がないようにし、最終的な出力用文字列を返します。
入力部分では、まず見出しの個数 W を取得し、次に見出しのリスト headers を取得します。
続いて、データ行の行数 H を取得し、H 行分のデータをリストとして取得します。
最後に、generate_output()関数を呼び出してテーブルを生成し、出力します。
'''

# B034 ロボットの歩行実験
# utf-8
# 入力値の読み込み
sp_x, sp_y = map(int, input().split())  # 初期位置
move_forward, move_right, move_backward, move_left = map(int, input().split())  # 移動量
mCN = int(input())  # 移動コマンドの数
move_command = [list(map(str, input().split())) for _ in range(mCN)]  # 移動コマンド

current_state = 0
# 0 : F (前進)
# 1 : R (右に移動)
# 2 : B (後退)
# 3 : L (左に移動)

for i in range(mCN):
    if move_command[i][0] == 'm':  # 移動コマンド
        if move_command[i][1] == 'F':  # 前進
            if current_state == 0:
                sp_y += move_forward
            elif current_state == 1:
                sp_x += move_forward
            elif current_state == 2:
                sp_y -= move_forward
            elif current_state == 3:
                sp_x -= move_forward
        elif move_command[i][1] == 'R':  # 右に移動
            if current_state == 0:
                sp_x += move_right
            elif current_state == 1:
                sp_y -= move_right
            elif current_state == 2:
                sp_x -= move_right
            elif current_state == 3:
                sp_y += move_right
        elif move_command[i][1] == 'B':  # 後退
            if current_state == 0:
                sp_y -= move_backward
            elif current_state == 1:
                sp_x -= move_backward
            elif current_state == 2:
                sp_y += move_backward
            elif current_state == 3:
                sp_x += move_backward
        elif move_command[i][1] == 'L':  # 左に移動
            if current_state == 0:
                sp_x -= move_left
            elif current_state == 1:
                sp_y += move_left
            elif current_state == 2:
                sp_x += move_left
            elif current_state == 3:
                sp_y -= move_left
    elif move_command[i][0] == 't':  # 回転コマンド
        if move_command[i][1] == 'R':  # 右に回転
            current_state = (current_state + 1) % 4
        elif move_command[i][1] == 'B':  # 後ろ向きに回転
            current_state = (current_state + 2) % 4
        elif move_command[i][1] == 'L':  # 左に回転
            current_state = current_state - 1
            if current_state == -1:
                current_state = 3

    # 座標の範囲を制限
    if sp_x < -1000:
        sp_x = -1000
    elif sp_x > 1000:
        sp_x = 1000
    if sp_y < -1000:
        sp_y = -1000
    elif sp_y > 1000:
        sp_y = 1000

# 結果を出力
print(sp_x, sp_y)
'''
与えられた入力に基づいてロボットの移動をシミュレートし、最終的な座標を出力するものです。以下、コードの解説をします。

最初に、初期位置と移動量、移動コマンドの数を入力します。
次に、移動コマンドを入力します。移動コマンドは、移動（'m'）か回転（'t'）のどちらかであり、移動の場合は方向（'F', 'R', 'B', 'L'）も指定されます。
ロボットの現在の状態を表す変数 current_state を初期化します。0は前進（F）、1は右に移動（R）、2は後退（B）、3は左に移動（L）を表します。
移動コマンドの数だけループを実行します。
ループ内では、移動コマンドが移動の場合と回転の場合に分かれます。
移動の場合は、現在の状態に応じて座標を更新します。例えば、前進の場合は現在の状態に応じて sp_x や sp_y を増減させます。
回転の場合は、現在の状態を変更します。右回転（R）の場合は現在の状態に1を加え、後ろ向きに回転（B）の場合は2を加えます。左回転（L）の場合は現在の状態から1を引きますが、-1になる場合は3に戻します。
移動後に、座標の範囲を制限します。sp_x や sp_y が範囲外（-1000未満または1000を超える）の場合は、最小値または最大値に制限します。
最後に、最終的な座標 sp_x と sp_y を出力します。
このコードは、与えられた移動コマンドに従ってロボットを移動させ、最終的な座標を制限しながら計算します。移動と回転の操作を適切に行い、最終的な座標を正確に計算できるようになっています。
'''

# B035 ジョギングランキング
# utf-8
# 部員数 N、ジョギング記録数 M、上位人数 T を入力として受け取る
N, M, T = map(int, input().split())

# 前月のジョギング成績を格納するリスト
post_mon = []

# 前月のジョギング成績を受け取り、リストに追加する
for _ in range(N):
    post_mon.append(input().split())

# 今月のジョギング記録を格納するリスト
this_mon = []

# 今月のジョギング記録を受け取り、リストに追加する
for _ in range(M):
    this_mon.append(input().split())

# リストを距離の降順にソートする関数
def range_sort(lst):
    lst.sort(key=lambda x: (-int(x[1]), x[0]))
    return lst

# 前月のジョギング成績をソートする
post_mon = range_sort(post_mon)

# 上位のジョギング記録を取得する
top_post = post_mon[:T]

# 今月のジョギング記録の合計を計算し、名前と合計距離を格納するリスト
this_mon_sum = []

# 今月のジョギング記録の合計を計算する
for name in set(record[1] for record in this_mon):
    total_distance = sum(int(record[2]) for record in this_mon if record[1] == name)
    this_mon_sum.append([name, str(total_distance)])

# 前月のジョギング成績と今月のジョギング記録の合計を結合し、ソートする
this_mon_sum += [[name, '0'] for name in set(record[0] for record in post_mon) - set(record[0] for record in this_mon_sum)]
this_mon_sum = range_sort(this_mon_sum)

# 上位のジョギング記録を取得する
top_this = this_mon_sum[:T]

# 変動を判定し、結果を追加する
for i in range(T):
    if top_this[i][0] == top_post[i][0]:
        top_this[i].append("same")
    elif any(top_this[i][0] == record[0] for record in top_post[i + 1:]):
        top_this[i].append("up")
    elif any(top_this[i][0] == record[0] for record in top_post[:i]):
        top_this[i].append("down")
    else:
        top_this[i].append("new")

# 結果を出力する
for record in top_this:
    print(" ".join(record))
'''
まず、与えられた入力を受け取ります。N, M, T = map(int, input().split())を使って、整数値の N, M, T を取得します。
次に、post_monというリストに前月のジョギング成績を格納します。post_mon = [input().split() for _ in range(N)]の部分で、N 回のループを実行して、各行から名前と距離を受け取って post_mon リストに追加しています。
同様に、this_monというリストに今月のジョギング記録を格納します。this_mon = [input().split() for _ in range(M)]の部分で、M 回のループを実行して、各行から日付、名前、距離を受け取って this_mon リストに追加しています。
次に、range_sort関数を使って post_mon リストと this_mon_sum リストをソートします。range_sort関数は与えられたリストを距離の降順にソートし、距離が同じ場合は名前の辞書順でソートする関数です。
その後、上位のジョギング記録を top_post リストと top_this リストに格納します。top_post リストは post_mon リストの上位 T 件の記録を格納し、top_this リストは this_mon_sum リストの上位 T 件の記録を格納します。
top_post リストと top_this リストを比較し、各記録の変動を判定します。結果を top_this リストの各要素の3番目の要素に追加します。
最後に、top_this リストを出力します。各要素の名前、距離、変動結果がスペース区切りで表示されます。
'''

# B036 大統領選挙
# utf-8
def calculate_winner(candidate_num, candidates, voter_num, voter_preferences):
    voted_candidates = [0] * (candidate_num + 1)  # 候補者ごとの得票数を保持するリスト
    repub_vote = 0  # 共和党候補の得票数
    demo_vote = 0  # 民主党候補の得票数

    # 最初の投票
    for preferences in voter_preferences:
        for check in range(2):
            for candidate in preferences:
                if candidates[candidate] == check:
                    voted_candidates[candidate] += 1  # 候補者の得票数をインクリメント
                    break

    # 最初の投票結果
    repub = max((c for c in range(1, candidate_num + 1) if candidates[c] == 0), key=lambda x: voted_candidates[x])
    demo = max((c for c in range(1, candidate_num + 1) if candidates[c] == 1), key=lambda x: voted_candidates[x])

    # 最後の投票
    for preferences in voter_preferences:
        for candidate in preferences:
            if candidate == repub:
                repub_vote += 1
                break
            elif candidate == demo:
                demo_vote += 1
                break

    # 結果の出力
    if repub_vote > demo_vote:
        return repub
    else:
        return demo

# 入力
candidate_num = int(input())  # 候補者数の入力
candidates = [0] * (candidate_num + 1)  # 候補者の所属パーティーを保持するリスト
for i in range(1, candidate_num + 1):
    if input() == "Republican":
        candidates[i] = 0
    else:
        candidates[i] = 1

voter_num = int(input())  # 投票者数の入力
voter_preferences = []  # 投票者の選好順位を保持するリスト
for _ in range(voter_num):
    preferences = list(map(int, input().split()))  # 投票者の選好順位をリストとして入力
    voter_preferences.append(preferences)

# 勝者の計算
winner = calculate_winner(candidate_num, candidates, voter_num, voter_preferences)

# 結果の出力
print(winner)
'''
calculate_winner 関数は、候補者数、候補者の所属パーティー、投票者数、投票者の選好順位を受け取り、最終的な勝者を計算する関数です。共和党候補と民主党候補の得票数を数えて、最終的な勝者を決定します。
入力値を受け取ります。まず、候補者数と候補者の所属パーティーを入力し、その後、投票者数と各投票者の選好順位を入力します。
calculate_winner 関数を使用して最終的な勝者を計算し、結果を出力します。
このコードでは、最初の投票で各候補者の得票数をカウントし、その結果から共和党候補と民主党候補を決定します。その後、最後の投票で選好順位に基づいて得票数をカウントし、最終的な勝者を決定します。最終的な勝者の候補者番号が返され、結果が出力されます。
'''

# B037 幸運な1年
# utf-8
def get_lucky_day(M, D, a, b, m):
    w, x, y, z = 0, 0, 0, 0
    d = {}
    date = '{:0=2}'.format(M) + '{:0=2}'.format(D)
    datenum = set(date)
    
    # 日付の桁数と出現回数をカウント
    for i in datenum:
        d[i] = date.count(i)
    
    for i in range(10000):
        flag = True
        w = (a[0] * w + b[0]) % m[0]
        x = (a[1] * x + b[1]) % m[1]
        y = (a[2] * y + b[2]) % m[2]
        z = (a[3] * z + b[3]) % m[3]
        date2 = str(w % 10) + str(x % 10) + str(y % 10) + str(z % 10)
        
        # カードの数字と日付を比較
        for key in d:
            if key not in date2:
                flag = False
                break
            if date2.count(key) != d[key]:
                flag = False
                break
        
        if flag:
            return i + 1
    
    return -1

# 入力値の取得
M, D = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
m = list(map(int, input().split()))

# 幸運な日を取得
result = get_lucky_day(M, D, a, b, m)
print(result)
'''
get_lucky_day 関数は、引数として今日の日付 (M, D)、カードのパラメータ (a, b, m) を受け取り、幸運な日になるために必要なカードの引き直し回数を計算します。
変数 w, x, y, z はカードの擬似乱数を表すための変数で、初期値は 0 です。
辞書 d は日付の桁数と出現回数を保持します。桁数と出現回数の対応は、日付を文字列に変換してカウントします。
次に、10,000 回までのループを実行します。
フラグ flag は幸運な日になるかどうかを示す変数で、初期値は True です。
カードの擬似乱数を生成し、それぞれのカードの数字を 10 で割った余りを取得して date2 に格納します。
date2 と辞書 d を比較して、カードの数字が日付を作るために必要な条件を満たしているかどうかを判定します。条件を満たさない場合、flag を False に設定します。
もし flag が True のままであれば、ループ回数に 1 を加えた値を返します。これが幸運になるために必要なカードの引き直し回数です。
もしループが終了しても幸運な日になる条件を満たすカードの引き直し回数が見つからない場合、-1 を返します。
最後に、入力値を受け取り、get_lucky_day 関数を呼び出して結果を出力します。
'''

# B038 つるかめ算　※テストケース90点　条件内の特殊ケースで不一致
# utf-8
def estimate_animals(a, b, c, d):
    # パイザ鶴とパイザ亀の匹数を推定する関数

    # パイザ鶴の匹数を x、パイザ亀の匹数を y とする
    # 足の本数と頭の数から以下の連立方程式が成り立つ
    # c*x + d*y = a
    # x + y = b

    # 連立方程式を解く
    # 解が整数でない場合や一意に定まらない場合は "miss" を返す
    if c != d:
        x = (a - b*d) // (c - d)
        y = b - x
        if x >= 1 and y >= 1 and (a == c*x + d*y) and (b == x + y):
            return x, y

    return "miss"

# 入力の読み込み
a, b, c, d = map(int, input().split())

result = estimate_animals(a, b, c, d)
if result == "miss":
    print("miss")
else:
    print(result[0], result[1])

# utf-8　※入力例ではOK　テストケース通過せず
dat = input().split()

foot_all = int(dat[0])
head_all = int(dat[1])
tsuru = int(dat[2])
kame = int(dat[3])

tsuru_search = foot_all - head_all * tsuru
kame_search = head_all * kame - foot_all

res_tsuru = 0
res_kame = 0

if tsuru_search > 0:
	res_tsuru = tsuru_search/2
elif tsuru_search == 0:
	if tsuru == 1:
		res_tsuru = 1
	else:
		res_tsuru = -1

if kame_search > 0:
	res_kame = kame_search/2
elif kame_search == 0:
	if kame == 1:
		res_kame = 1
	else:
		res_kame = -1
	
if res_tsuru < 1:
	print("miss")
elif res_kame < 1:
	print("miss")
else:
	print(int(res_kame), int(res_tsuru))
	
# B039 雨上がりの道　※テストケース通過せず
# utf-8
def find_accessible_ponds(n, s, ponds):
    amembo_pond = ponds[s-1]  # アメンボがいる水たまりの座標
    accessible_ponds = []

    for i, pond in enumerate(ponds):
        if (amembo_pond[0] <= pond[2] and amembo_pond[2] >= pond[0] and
            amembo_pond[1] <= pond[3] and amembo_pond[3] >= pond[1]):
            accessible_ponds.append(i+1)

    return accessible_ponds

# 入力の解析と処理
n = int(input())
s = int(input())
ponds = []
for _ in range(n):
    x, y, a, b = map(int, input().split())
    ponds.append((x, y, a, b))

accessible_ponds = find_accessible_ponds(n, s, ponds)

# 結果の出力
print('\n'.join(map(str, accessible_ponds)))

# B040 たのしい暗号解読
# 入力値の取得
lines = []
while True:
    try:
        line = input()
        lines.append(line)
    except EOFError:
        break

# 回答方針
# [1] 必要な値を変数/配列化する。置換回数(count), 暗号文(codeText), 暗号ルール(codeRule), アルファベット(alphabet)
# [2] 暗号文を一文字ずつ置換ルールと比較。暗号文文字 = 暗号ルールとなる時の、置換ルールの文字列順を取得
# [3] [2]で取得した番号のアルファベット文字列を取得する。
# [4] [2][3]を暗号文の文字列回数分繰り返す
# [5] [2][3][4]の処理を置換回数(count)回、繰り返す。
# [5]で得られた文字列を表示する

alphabet = "abcdefghijklmnopqrstuvwxyz"
count, codeRule = lines[0].split()
count = int(count)
codeText = lines[1].strip()
decryption = ''

for c in range(count):
    for char in codeText:
        if char == ' ':
            decryption += ' '
            continue
        for n in range(len(codeRule)):
            if char == codeRule[n]:
                decryption += alphabet[n]
    codeText = decryption
    decryption = ''

print(codeText)
'''
最初に、入力を受け取るための処理が行われています。input()関数を使って一行ずつ入力を読み込み、linesリストに格納しています。EOFError例外が発生するまで繰り返します。
次に、アルファベットの文字列や復号に必要な変数を初期化しています。alphabet変数にはアルファベットの文字列が格納されています。count変数には置換回数が、codeRule変数には置換のルールが格納されます。countは整数に変換しています。また、codeText変数には暗号文が格納されます。strip()関数を使って行末の改行文字を削除しています。decryption変数は復号結果を格納するための空の文字列です。
指定された回数だけ復号処理を繰り返します。外側のループはcount回繰り返されます。内側のループでは、暗号文の各文字を一つずつ処理します。文字がスペースの場合は、スペースを復号結果に追加し、次の文字の処理へ進みます。それ以外の場合は、暗号ルールを順番に比較し、一致するルールの位置に対応するアルファベットを復号結果に追加します。
内側のループが終わった後、codeTextを更新して復号結果を反映します。そして、decryptionを空の文字列にリセットします。
最後に、復号された結果を出力します。
このコードでは、与えられた置換回数と置換ルールを使って暗号文を復号する処理が行われます。指定された回数だけ復号処理が繰り返され、最終的な復号結果が出力されます。
'''
--------------------------------------------- B041　※欠番 ◆
# B041 繰り返し模様
# utf-8
K = int(input())  # 繰り返し手順の回数を取得
N = int(input())  # 最初の正方形の辺の長さを取得
s = [list(input()) for _ in range(N)]  # 初期状態の模様を取得

for m in range(K):
    s1 = []  # 新しい模様を生成するためのリスト

    for i in range(N):
        for j in range(N):
            if s[i][j] == '.':
                if j == 0:
                    # 白色の場合は、同じ大きさの白い正方形を生成
                    for k in range(N):
                        s1.append(['.'] * N)
                elif j > 0:
                    # 白色の場合は、同じ大きさの白い正方形を追加
                    for k in range(N):
                        s1[i * N + k][len(s1[i * N + k]):len(s1[i * N + k])] = ['.'] * N
            else:
                if j == 0:
                    # 青色の場合は、元の模様をそのまま追加
                    for k in range(N):
                        s1.append(s[k][:])
                elif j > 0:
                    # 青色の場合は、元の模様を追加
                    for k in range(N):
                        s1[i * N + k][len(s1[i * N + k]):len(s1[i * N + k])] = s[k]

    N *= N  # 新しい模様の辺の長さを更新
    s = s1[:]  # 新しい模様で元の模様を上書き

for row in s1:
    print("".join(row))  # 生成された最終的な模様を出力
'''
入力値の受け取り:
K = int(input()): 繰り返し手順の回数を整数として受け取ります。
N = int(input()): 最初の正方形の辺の長さを整数として受け取ります。
s = [list(input()) for _ in range(N)]: N行の文字列を受け取り、それぞれの文字列をリストに変換して二次元リスト s に格納します。これにより、初期状態の模様が表現されます。

模様の生成と更新のループ:
for m in range(K):: K回の繰り返しを行います。各繰り返しでは、新しい模様が生成されて元の模様と入れ替わります。
s1 = []: 新しい模様を生成するための空のリスト s1 を作成します。

新しい模様の生成:
2重ループを使用して、元の模様を基に新しい模様を生成します。
if s[i][j] == '.':: もし現在の正方形が白色であれば、同じ大きさの白い正方形で置き換えます。
else:: もし現在の正方形が青色であれば、元の模様をそのまま追加します。

新しい模様の更新:
N *= N: 新しい模様の辺の長さを更新します。元の辺の長さの N 倍になります。
s = s1[:]: 生成された新しい模様で元の模様を上書きします。
最終的な模様の出力:

for row in s1: print("".join(row)): 生成された最終的な模様を出力します。各行の文字列を結合して表示します。
このコードは、与えられた繰り返し手順に基づいて模様を生成し、最終的な模様を出力します。初期状態の模様に対して、白色の正方形は同じ大きさの白い正方形で置き換えられ、青色の正方形は元の模様に置き換えられます。
この操作を指定された回数繰り返すことで、最終的な模様が生成されます。
'''

# B042 横入りするネコ
# utf-8
def check_cat(cat_num, M, cat_info, eat_time_info, cat_line):
    # 猫の順番を組み合わせて全パターンを調べる再帰関数
    if len(cat_line) == cat_num:
        cat_M = check_M(cat_num, cat_info, cat_line)
        if cat_M <= M:
            eat_time = check_eat_time(cat_num, cat_info, cat_line)
            eat_time_info.add(eat_time)
    else:
        for i in range(cat_num):
            if i + 1 not in cat_line:
                new_cat_line = cat_line.copy()
                new_cat_line.append(i + 1)
                check_cat(cat_num, M, cat_info, eat_time_info, new_cat_line)


def check_M(cat_num, cat_info, cat_line):
    # 各猫の不満度の合計を計算する関数
    cat_M = [0] * cat_num
    cat_line_info = [0] * cat_num
    sum_cat_M = 0

    for index, value in enumerate(cat_line):
        cat_line_info[index] = value

    for i in range(1, cat_num):
        for j in range(i):
            if cat_line_info[i] < cat_line_info[j]:
                cat_M[cat_line_info[i] - 1] += 1

    for i in range(cat_num):
        sum_cat_M += cat_M[i] * cat_info[i][1]

    return sum_cat_M


def check_eat_time(cat_num, cat_info, cat_line):
    # 各猫の食事時間の合計を計算する関数
    eat_time = 0
    eat_time_sum = 0
    cat_line_info = [0] * cat_num

    for index, value in enumerate(cat_line):
        cat_line_info[index] = value

    for i in range(cat_num):
        eat_time += eat_time_sum + cat_info[cat_line_info[i] - 1][0]
        eat_time_sum += cat_info[cat_line_info[i] - 1][0]

    return eat_time


cat_num, M = map(int, input().split())

cat_info = []
for _ in range(cat_num):
    cat_info.append(list(map(int, input().split())))

eat_time_info = set()
cat_line = []

check_cat(cat_num, M, cat_info, eat_time_info, cat_line)

min_eat_time = min(eat_time_info)

print(min_eat_time)
'''
check_cat関数:
引数:
cat_num: 猫の数
M: 許容される不満度の合計
cat_info: 猫の情報を格納した2次元リスト
eat_time_info: 結果として得られる食事時間の集合
cat_line: 現在の猫の順番のリスト
再帰的に全ての猫の順番の組み合わせをチェックし、条件を満たす場合に食事時間を計算して集合に追加します。
まだ順番が割り当てられていない猫に対して順番を割り当てて再帰呼び出しを行います。

check_M関数:
引数:
cat_num: 猫の数
cat_info: 猫の情報を格納した2次元リスト
cat_line: 現在の猫の順番のリスト
各猫の不満度の合計を計算して返します。
猫の順番が入れ替わった場合、その猫より前にいる猫の不満度を増やします。

check_eat_time関数:
引数:
cat_num: 猫の数
cat_info: 猫の情報を格納した2次元リスト
cat_line: 現在の猫の順番のリスト
各猫の食事時間の合計を計算して返します。
猫の順番に従って、各猫の食事時間を計算し合計します。

メイン部分:
ユーザーからの入力を受け取り、cat_numとMに代入します。
cat_infoリストを作成し、猫の情報を格納します。
結果の食事時間を格納するための集合eat_time_infoと、現在の猫の順番を格納するためのリストcat_lineを初期化します。
check_cat関数を呼び出して、全ての猫の順番の組み合わせをチェックします。
得られた食事時間の集合eat_time_infoから最小値を取得し、結果を出力します。
このコードは、猫の順番の組み合わせを全て試す方法を用いて最適解を求める力まで持っています。
ただし、猫の数が増えると組み合わせの数が爆発的に増えるため、実行時間が長くなる可能性があります。
より効率的なアルゴリズムを検討する必要があるかもしれません。
'''

# B043 ねずみ小僧
# utf-8
# 町の大きさを入力
H, W = map(int, input().split())

# ねずみ小僧の初期位置を入力
h0, w0 = map(int, input().split())

# 町の各家の状態を入力
houses = [list(input().strip()) for _ in range(H)]

# ねずみ小僧の初期設定
axis = 1  # 初期方向は北を示す
num = 1  # 移動回数の初期値
x, y = h0 - 1, w0 - 1  # 座標の初期値（0-indexedに変換）

# ねずみ小僧の移動ループ
while num <= 2000 and 0 <= x < H and 0 <= y < W:
    num += 1
    
    # 現在の座標の家の状態に応じて行動を決定
    if houses[x][y] == '.':  # 庶民の家の場合
        houses[x][y] = '*'  # 富豪の家に変更
        if axis == 1:  # 北を向いている場合
            axis = 2  # 東に方向転換
            y += 1
        elif axis == 2:  # 東を向いている場合
            axis = 3  # 南に方向転換
            x += 1
        elif axis == 3:  # 南を向いている場合
            axis = 4  # 西に方向転換
            y -= 1
        elif axis == 4:  # 西を向いている場合
            axis = 1  # 北に方向転換
            x -= 1
    else:  # 富豪の家の場合
        houses[x][y] = '.'  # 庶民の家に変更
        if axis == 1:  # 北を向いている場合
            axis = 4  # 西に方向転換
            y -= 1
        elif axis == 2:  # 東を向いている場合
            axis = 1  # 北に方向転換
            x -= 1
        elif axis == 3:  # 南を向いている場合
            axis = 2  # 東に方向転換
            y += 1
        elif axis == 4:  # 西を向いている場合
            axis = 3  # 南に方向転換
            x += 1

# 町の最終状態を出力
for row in houses:
    print("".join(row))
'''
最初の部分では、入力値を受け取り、必要な変数を初期化しています。

hとwには町の大きさが格納されます。
xとyにはねずみ小僧の初期位置が格納されます。
sは町の状態を表す二次元リストです。
axisはねずみ小僧の向いている方向を表す変数で、初期値は1です（北を意味します）。
numはねずみ小僧の移動回数を表す変数で、初期値は1です。
xとyは座標のインデックスとして使用されるため、1から0始まりのインデックスに変換しています。

while文からはねずみ小僧の移動ループです。ループは以下の条件を満たす間、繰り返されます:

numが2000以下であり、ねずみ小僧が町の範囲内にいること。
xが0以上h未満、yが0以上w未満であること。
ループ内の処理は次のようになっています:

s[x][y]が'.'（庶民の家）の場合、その家を'*'（富豪の家）に変えます。
ねずみ小僧の向き(axis)に応じて、座標を更新します。向きが1の場合、y座標を増やし、向きが2の場合、x座標を増やします。向きが3の場合、y座標を減らし、向きが4の場合、x座標を減らします。
s[x][y]が'*'（富豪の家）の場合、その家を'.'（庶民の家）に変えます。
ねずみ小僧の向き(axis)に応じて、座標を更新します。向きが1の場合、y座標を減らし、向きが2の場合、x座標を減らします。向きが3の場合、y座標を増やし、向きが4の場合、x座標を増やします。
移動が終了すると、ねずみ小僧が通過した後の町の状態が得られます。

最後の部分では、町の状態を出力しています。二次元リストsの各行を文字列に変換し、改行なしで出力します。
'''

# B044 爆弾ゲーム　※テストケース通過せず
# utf-8
def is_enemy_defeated(board):
    H, W = len(board), len(board[0])

    # 盤面を拡張して周囲を壁で囲む
    extended_board = ['#' * (W + 2)]
    for row in board:
        extended_board.append('#' + row + '#')
    extended_board.append('#' * (W + 2))

    bombs = []  # 爆弾の位置と火力を格納するリスト

    # 爆弾の位置と火力を取得
    for i in range(1, H + 1):
        for j in range(1, W + 1):
            if extended_board[i][j].isdigit():
                bombs.append((i, j, int(extended_board[i][j])))

    # 爆弾を順に試し、爆風の範囲にいる敵を倒せるか判定
    for bomb in bombs:
        i, j, power = bomb
        # 上方向の爆風
        for k in range(1, power + 1):
            if extended_board[i - k][j] == '#':
                break
            if extended_board[i - k][j] == 'X':
                extended_board[i - k] = extended_board[i - k][:j] + '.' + extended_board[i - k][j+1:]

        # 下方向の爆風
        for k in range(1, power + 1):
            if extended_board[i + k][j] == '#':
                break
            if extended_board[i + k][j] == 'X':
                extended_board[i + k] = extended_board[i + k][:j] + '.' + extended_board[i + k][j+1:]

        # 左方向の爆風
        for k in range(1, power + 1):
            if extended_board[i][j - k] == '#':
                break
            if extended_board[i][j - k] == 'X':
                extended_board[i] = extended_board[i][:j - k] + '.' + extended_board[i][j - k + 1:j] + 'X' + extended_board[i][j + 1:]

        # 右方向の爆風
        for k in range(1, power + 1):
            if extended_board[i][j + k] == '#':
                break
            if extended_board[i][j + k] == 'X':
                extended_board[i] = extended_board[i][:j] + 'X' + extended_board[i][j + 1:j + k] + '.' + extended_board[i][j + k + 1:]

    # 盤面上に敵(X)が残っているか判定
    for i in range(1, H + 1):
        if 'X' in extended_board[i]:
            return "NO"

    return "YES"


def main():
    H, W = map(int, input().split())
    board = [input() for _ in range(H)]
    result = is_enemy_defeated(board)
    print(result)


if __name__ == "__main__":
    main()

# B045 計算ドリル
# utf-8
import random

# 入力を取得し、足し算の問題数と引き算の問題数を設定する
setting = input()
set_data = setting.split()
plus = int(set_data[0])
minus = int(set_data[1])

problems = []  # 問題を格納するリスト

# 足し算の問題を生成
while len(problems) < plus:
    left = random.randint(0, 99)  # 0から99までのランダムな左辺を生成
    right = random.randint(0, 99 - left)  # 左辺以下の範囲でランダムな右辺を生成
    problem = f"{left} + {right} ="  # 問題文を作成
    if problem not in problems:  # 重複しない問題文の場合にリストに追加
        problems.append(problem)

# 引き算の問題を生成
while len(problems) < plus + minus:
    left = random.randint(0, 99)  # 0から99までのランダムな被減数を生成
    right = random.randint(0, left)  # 被減数以下の範囲でランダムな減数を生成
    problem = f"{left} - {right} ="  # 問題文を作成
    if problem not in problems:  # 重複しない問題文の場合にリストに追加
        problems.append(problem)

random.shuffle(problems)  # 問題の順序をランダムにシャッフル

# 問題を出力
for problem in problems:
    print(problem)
'''
このコードでは、random モジュールを使用してランダムな数値を生成しています。足し算の問題を生成する際には、0から99までのランダムな左辺と、左辺以下の範囲でランダムな右辺を生成し、問題文を作成しています。
同様に、引き算の問題を生成する際には、0から99までのランダムな被減数と、被減数以下の範囲でランダムな減数を生成して問題文を作成しています。
問題文の重複を防ぐため、生成した問題文が既にリストに存在するかをチェックしています。存在しない場合にのみリストに追加されます。
最後に、random.shuffle() 関数を使用して問題の順序をランダムにシャッフルしています。最終的に生成された問題は、for ループを使用して一つずつ出力されます。
このコードによって、与えられた条件を満たし、効率的かつランダムな問題のドリルが生成されます。
'''

# B046 街の距離
# utf-8
import math

class B046:
    def __init__(self, rounds):
        # 同心円の数
        self.rounds = int(rounds)
        # 現在位置の同心円番号
        self.now_around = None
        # 現在位置の方角
        self.now_direction = None
        # 目的地の同心円番号
        self.purpose_around = None
        # 目的地の方角
        self.purpose_direction = None
        # 最短距離
        self.distance = None

    def set_now_position_info(self, info):
        # 現在位置の同心円番号と方角を設定
        self.now_around, self.now_direction = info.split()

    def set_purpose_position_info(self, info):
        # 目的地の同心円番号と方角を設定
        self.purpose_around, self.purpose_direction = info.split()

    def calculation_shortest_distance(self):
        # 方向の組み合わせパターン
        check_direction = self.now_direction + self.purpose_direction
        one_line_direction = ["NS", "SN", "WE", "EW", "NN", "SS", "WW", "EE"]

        if check_direction in one_line_direction:
            if self.now_direction == self.purpose_direction:
                # 同じ直線上にいる場合は、直線距離のみ
                self.distance = abs(int(self.now_around) - int(self.purpose_around)) * 100
            else:
                # 直線上にいる場合は、同心円同士の距離を加算
                self.distance = (int(self.now_around) + int(self.purpose_around)) * 100
        else:
            if int(self.now_around) < int(self.purpose_around):
                # 短い方向に半周し、直線距離を加算
                self.distance = abs(int(self.now_around) - int(self.purpose_around)) * 100 + math.pi * 100 * int(self.now_around) / 2
            elif int(self.now_around) > int(self.purpose_around):
                # 短い方向に半周し、直線距離を加算
                self.distance = abs(int(self.now_around) - int(self.purpose_around)) * 100 + math.pi * 100 * int(self.purpose_around) / 2
            else:
                # 同心円上の同じ位置にいる場合は、半周距離のみ
                self.distance = math.pi * 100 * int(self.purpose_around) / 2

        return self.distance

N = input().strip()  # 同心円の数を入力
B046 = B046(N)  # B046クラスのインスタンスを生成
B046.set_now_position_info(input().strip())  # 現在位置情報を入力
B046.set_purpose_position_info(input().strip())  # 目的地情報を入力
B046.calculation_shortest_distance()  # 最短距離を計算
print("{:.9f}".format(B046.distance))  # 最短距離を表示
'''
このコードは、同心円状の道路が配置された環境で、現在位置と目的地の情報から最短距離を計算しています。
B046 クラスは、最短距離の計算と情報の設定を行うためのメソッドを提供します。インスタンス化された B046 オブジェクトを使用して、現在位置情報と目的地情報を設定し、最短距離を計算します。
set_now_position_info メソッドは、現在位置情報を設定します。文字列として渡された情報を分割して、現在の同心円位置と方角を設定します。
set_purpose_position_info メソッドは、目的地情報を設定します。文字列として渡された情報を分割して、目的地の同心円位置と方角を設定します。
calculation_shortest_distance メソッドは、現在位置と目的地から最短距離を計算します。まず、現在位置と目的地の方角の組み合わせをチェックし、直線上に位置する場合と曲線上に位置する場合で処理を分岐します。最短距離を計算して distance 属性に代入します。
メインの処理部分では、入力から同心円の数、現在位置情報、目的地情報を受け取り、B046 クラスのインスタンスを生成し、必要な情報を設定します。最後に最短距離を計算して表示します。
'''

# B047 ホームポジション　※テストケース通過しない
# utf-8
class Point:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

def is_miss_type(now, prev):
    return prev.y == now.y and ((prev.x == 4 and now.x == 5) or (now.x == 4 and prev.x == 5))

def is_neighbor(now, prev):
    return (now.y == prev.y and (prev.x - 1 <= now.x <= prev.x + 1)) or (now.x == prev.x and (prev.y - 1 <= now.y <= prev.y + 1))

def solve(input_str, point_map):
    count = 0
    mode = False
    prev = Point(-1, -1)
    for c in input_str:
        p = point_map[c]
        if mode:
            if is_neighbor(p, prev):
                count += 1
            else:
                mode = False
        else:
            if is_miss_type(p, prev):
                count += 1
                mode = True
        prev = p
    return count

def parse_input(input_str):
    lines = input_str.strip().split("\n")
    s = lines[0]
    return s

def format_output(output):
    return str(output)

def main():
    point_map = {}
    table = [
        "qwertyuiop",
        "asdfghjkl",
        "zxcvbnm"
    ]

    for y in range(len(table)):
        line = table[y]
        for x in range(len(line)):
            c = line[x]
            point_map[c] = Point(x, y)

    input_str = input()
    s = parse_input(input_str)

    output = solve(s, point_map)
    formatted_output = format_output(output)
    print(formatted_output)

main()

# B048 理想のビンゴ
# utf-8
N, M = map(int, input().split())
bingo_card = []  # ビンゴカードの盤面を格納するリスト
bingo_count = 0  # ビンゴ数をカウントする変数

# ビンゴカードの盤面を入力として受け取り、リストに格納する
for _ in range(N):
    row = list(map(int, input().split()))
    bingo_card.append(row)

# M-1回の数字の呼び出しを処理する
for _ in range(M - 1):
    called_number = int(input())
    for i in range(N):
        for j in range(N):
            if called_number == bingo_card[i][j]:
                bingo_card[i][j] = 0  # 呼び出された数字を0に置き換える

# 行のビンゴをチェック
for i in range(N):
    if bingo_card[i].count(0) == N:
        bingo_count += 1

columns = []  # 列ごとの数字を格納するリスト
for i in range(N):
    column = []
    for j in range(N):
        column.append(bingo_card[j][i])
    columns.append(column)
    if column.count(0) == N:
        bingo_count += 1

diagonal = []  # 対角線の数字を格納するリスト
for i in range(N):
    diagonal.append(bingo_card[i][i])

reverse_diagonal = []  # 逆対角線の数字を格納するリスト
for i in range(1, N + 1):
    reverse_diagonal.append(bingo_card[-i][i - 1])

lines = [diagonal, reverse_diagonal]  # 対角線と逆対角線をまとめたリスト

# 対角線と逆対角線のビンゴをチェック
for line in lines:
    if line.count(0) == N:
        bingo_count += 1

extra_numbers = []  # ビンゴの候補となる数字を格納するリスト

# ビンゴの候補となる数字を抽出
for i in range(N):
    if bingo_card[i].count(0) == N - 1:
        for j in range(N):
            if bingo_card[i][j] != 0:
                extra_numbers.append(bingo_card[i][j])

for i in range(N):
    if columns[i].count(0) == N - 1:
        for j in range(N):
            if columns[i][j] != 0:
                extra_numbers.append(columns[i][j])

for line in lines:
    if line.count(0) == N - 1:
        for j in range(N):
            if line[j] != 0:
                extra_numbers.append(line[j])

frequency = []  # ビンゴの候補数字の出現回数を格納するリスト

# ビンゴの候補数字の出現回数を計算し、最大のビンゴ数を更新
if len(extra_numbers) > 0:
    for i in range(len(extra_numbers)):
        frequency.append(extra_numbers.count(extra_numbers[i]))
    bingo_count += max(frequency)

print(bingo_count)  # 最大のビンゴ数を出力
'''
入力の受け取りと初期化:
N, M = map(int, input().split()): ビンゴカードのサイズと呼び出し回数を受け取ります。
bingo_card = []: ビンゴカードの盤面を格納するための空のリストを作成します。
bingo_count = 0: ビンゴ数をカウントする変数を初期化します。

ビンゴカードの入力と数字の呼び出し処理:
for _ in range(N): ...: ビンゴカードの盤面を入力として受け取り、リスト bingo_card に格納します。
for _ in range(M - 1): ...: 呼び出された数字を処理し、ビンゴカード上の該当する数字を0に置き換えます。

行・列・対角線のビンゴをチェック:
行のビンゴをチェックし、ビンゴ数をカウントします。
列ごとの数字を格納するリスト columns を作成し、列のビンゴをチェックし、ビンゴ数をカウントします。
対角線と逆対角線の数字を格納するリスト diagonal と reverse_diagonal を作成し、対角線と逆対角線のビンゴをチェックし、ビンゴ数をカウントします。

追加のビンゴの候補数字を抽出:
ビンゴの候補となる数字を格納するリスト extra_numbers を作成し、行・列・対角線・逆対角線のビンゴの候補数字を抽出します。

追加のビンゴ数の計算:
ビンゴの候補数字が存在する場合、その出現回数を計算し、最大のビンゴ数を更新します。

結果の出力:
最大のビンゴ数を出力します。
このコードでは、ビンゴカードの盤面と呼び出された数字を処理し、行・列・対角線・逆対角線のビンゴをチェックして最大のビンゴ数を求めるアルゴリズムが実装されています。ビンゴ数の計算は、ビンゴの候補数字が存在する場合にのみ行われます。最終的な結果は、最大のビンゴ数が出力されます。
'''

# B049 ◆
# B050 有効なチケット
# utf-8
# 入力の受け取りと制約のチェック
N = int(input())  # チケットの枚数
if not 1 <= N <= 100:
    raise ValueError("Nの値が制約を満たしていません")

S = input()  # 暗号チケットの指定された文字列
if not 1 <= len(S) <= 10 or not S.islower():
    raise ValueError("Sの値が制約を満たしていません")

valid_tickets = []
for _ in range(N):
    T = input()  # チケットに書かれた文字列
    if not 1 <= len(T) <= 20 or not T.islower():
        raise ValueError("Tの値が制約を満たしていません")
    
    if S in T:  # SがTに含まれる場合は有効
        valid_tickets.append("valid")
    elif any(S in T[:i] + T[i+1:] for i in range(len(T))):  # Tから1文字を削除してSが含まれる場合は有効
        valid_tickets.append("valid")
    else:  # 上記の条件に該当しない場合は無効
        valid_tickets.append("invalid")

# 有効/無効なチケットを出力
for ticket in valid_tickets:
    print(ticket)
'''
入力の受け取りと制約のチェック

N = int(input()): チケットの枚数を整数として受け取ります。
S = input(): 暗号チケットの指定された文字列を受け取ります。
制約を満たしていない場合は、ValueErrorを発生させます。
有効なチケットの判定

valid_tickets = []: 有効なチケットを格納するリストを初期化します。
for _ in range(N):: チケットの枚数分だけループを行います。
T = input(): チケットに書かれた文字列を受け取ります。
if S in T:: もし指定された文字列 S がチケット文字列 T に含まれる場合は、有効なチケットとして判定します。
elif any(S in T[:i] + T[i+1:] for i in range(len(T))):: それ以外の場合、チケット文字列 T から1文字ずつ削除した文字列に指定された文字列 S が含まれるかどうかを判定します。任意のインデックス i に対して、T[:i] + T[i+1:] で T の i 番目の文字を削除した文字列が得られます。
valid_tickets.append("valid"): 上記のいずれかの条件に該当する場合は、有効なチケットとしてリストに追加します。
else: valid_tickets.append("invalid"): 上記の条件に該当しない場合は、無効なチケットとしてリストに追加します。
有効/無効なチケットの出力

for ticket in valid_tickets: print(ticket): 有効/無効なチケットのリストを出力します。
'''
--------------------------------------------- B051　※欠番 ◆
# B051 ◆
# B052 積もる粒子
# B053 表の自動作成
# B054 不思議な足し算
# B055 ◆
# B056 リズムゲームの分析
# B057 回転寿司
# B058 ◆
# B059 占領区域
# B060 サイコロころがし
--------------------------------------------- B061　※欠番 ◆
# B061 福袋詰め
# B062 部屋掃除ロボット
# B063 支払う枚数とお釣りの枚数
# B064 うずを探せ
# B065 小さなライフゲーム
# B066 色のパズル
# B067 タスクの管理
# B068 チョコの分割
# B069 蟻の餌探し
# B070 駒の到達範囲
--------------------------------------------- B071　※欠番 ◆
# B071 ダンベルトレーニング
# B072 反転スイッチ
# B073 イルミネーションの調査
# B074 コメントの順序
# B075 商品の表示
# B076 パン屋さん
# B077 チケットの売り場
# B078 動画視聴スケジュール
# B079 相性チェック
# B080 みんなでスゴロク
--------------------------------------------- B081　※欠番 ◆
# B081 花壇のロープ
# B082 休暇の取り方
# B083 宝の地図
# B084 オススメのお店
# B085 宝探しの手順
# B086 公平な分割
# B087 隠された数
# B088 ロボットのデバッグ
# B089 秘密の言葉
# B090 選挙の議席
--------------------------------------------- B091　※欠番 ◆
# B091 山頂を探せ
# B092 セーブポイント
# B093 SNSの検索機能
# B094 ◆
# B095 カラオケ大会
# B096 ビンゴゲーム
# B096(2) 爆弾の大爆発
# B097 カウンター席
# B098 バズの検出
# B099 台風の接近
# B100 計算の遅延
--------------------------------------------- B101　※欠番 ◆
# B101 ◆
# B102 膨張と収縮
# B103 ◆
# B104 データのクレンジング
# B105 マッピングゲーム
# B106 席替えの席決め
# B107 カードシャッフル
# B108 観覧車の稼働状況
# B109 映画館の席の予約
# B110 解像度の向上
--------------------------------------------- B111　※欠番 ◆
# B111 天秤のつりあい
# B112 くじの作成
# B113 2のべき連結ゲーム
# B114 PAIZA運動会
# B115 アナグラムパズル
# B116 プレゼント交換
# B117 回る教習車
# B118 背の順
# B119 投網
# B120 ◆
--------------------------------------------- B121　※欠番 ◆
# B121 床の模様替え
# B122 うわさ
# B123 ビットゲーム
# B124 名前が似ている友達
# B125 工場のボトルネック
# B126 ダンスパーティー
# B127 ◆
# B128 簡易的二次元バーコード
# B129 n毛作
# B130 ブロック挿入
--------------------------------------------- B131　※欠番 ◆
# B131 運賃計算
# B131(2) 復号の処理
# B132
# B133
# B134
# B135
# B136
# B137
# B138
# B139
# B140
-----------------------------------------------B141　※欠番◆
