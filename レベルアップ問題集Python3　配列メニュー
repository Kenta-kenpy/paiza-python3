<【次元配列の入出力】i番目の出力 Boss>
step1　要素数の出力
# utf-8
list = [5, 1, 3, 4, 5, 12, 6, 8, 1, 3]
print(len(list))

step2　全要素の出力
# utf-8
li = [5, 1, 3, 4, 5, 12, 6, 8, 1, 3]
for ele in li:
    print(ele)
    
step3　i番目の出力
# utf-8
li = [5, 1, 3, 4, 5, 12, 6, 8, 1, 3]
print(li[3])
'''
リストのインデックスは 0 から始まるので、4 番目の要素のインデックスは 3 となります。
リストのインデックスが i の要素を取得するには、li[i] のようにします。
'''

step4　配列の入力１
# utf-8
li = [8, 1, 3, 3, 8, 1, 1, 3, 8, 8]

for ele in li:
    print(ele)
'''
for 文を用いて出力します。
for 文で for ele in li: のように記述すると、変数 ele にリスト li の要素が順に代入されます。
for 文の処理ブロック内で、print 関数を用いて出力をすれば解くことができます。
'''

step5　配列の入力２
# utf-8
A = input().split()
for a in A:
    print(a)
'''
input 関数は標準入力 1 行を文字列で受け取ります。
【 split メソッドについて 】
split メソッドは () に囲まれている文字列を区切り文字として文字列を分割してリストを生成する
区切り文字のデフォルトは半角スペースなので、引数なしで使うと半角スペースが区切り文字となる
よって、input().split() の流れは以下のようになります。
input() で標準入力 1 行を文字列として受け取る
split() で input() で取得した標準入力 1 行の文字列を半角スペースで区切り、リストを生成する
'''

step6　配列の入力３
# utf-8
n = int(input())
li = input().split()

for ele in li:
    print(ele)
'''
Python3 では、標準入力を行単位で文字列として受け取るので、この様な書き方もできます。
input().split() で a_1 ... a_N を半角スペースで区切ってリストを生成するので N の情報がなくてもリストを生成できます。
'''

# 別解
# utf-8
n = int(input())

li = [0] * n
values = input().split()
for i in range(n):
    li[i] = int(values[i])

for ele in li:
    print(ele)

'''
標準入力 1 行目で、要素数 n が与えられるので、それに応じてリストを用意します。
li = [0] * n では 「要素数が n で全ての要素が 0 であるリストを生成する」 という操作を行っています。
変数values で数列を半角スペース区切りで受け取ったあと、for文 を用いて 
変数li の i 番目の要素に 変数values の i 番目の要素を整数に変換して代入します。
'''

step7  i番目の出力１
# utf-8
K = int(input())
li = [1, 3, 5, 4, 6, 2, 1, 7, 1, 5]

print(li[K - 1])
'''
「何番目の要素を出力するか」 という情報を標準入力で受け取ります。
受け取りの際、整数型に変換しないと、リストの k 番目の要素を取得するときに型エラーが発生するので注意して下さい。なお、整数型に変換するときは int() を使います。
リストのインデックス k の要素を取得するときは、変数名[k] の様にします。
リストのインデックスは 0 から始まるので、k 番目の要素のインデックスは k-1 となることに注意が必要です。
'''

step8　i番目の出力２
# utf-8
K = int(input())
A = input().split()

print(A[K - 1])

'''
input 関数は標準入力 1 行を文字列で受け取るので、以下の 2 点に注意が必要。
K を整数型に変換しないと、A[k - 1] で型エラーが発生する
input() は 1 行単位での取得なので、2 行の入力が与えられる今回は input() は 2 回実行するだけでよい
リストのインデックスは 0 から始まることに注意すること。
'''

final  i番目の出力Boss
# utf-8
values = input().split()
N = int(values[0])
K = int(values[1])

A = [0] * N
values = input().split()
for i in range(N):
    A[i] = int(values[i])

print(A[K - 1])

'''
標準入力 1 行目で N K が与えられるので、半角スペースで区切り、それぞれ整数型に変換して変数に代入します。
A = [0] * N では「要素数が N で全ての要素が 0 であるリストを生成する」という操作を行っています。
変数 values で数列を半角スペース区切りで受け取ったあと、for 文を用いて、変数 A の i 番目の要素に
変数 values の i 番目の要素を代入します。
リストのインデックスは 0 から始まるので、K 番目の要素のインデックスは K-1 となるので、注意して下さい。
'''

<【二次元配列の入出力】i番目の出力 Boss>
step1　要素数の出力
# utf-8
li = [[1, 2, 3, 4, 5, 6], [8, 1, 3, 1, 3, 8]]
print(len(li) * len(li[0]))
'''
Python3 では、リストの要素にリストを入れることも可能です。
配列の要素の総数は (配列の行数) * (配列の列数) で求めることができます。
行数、列数の求め方を以下で説明します。
【 行数の求め方 】
len 関数で求めます。
len(li) は、変数 li の要素数がいくつかを返します。今回の場合、変数 li が持っている要素は以下の 2 つです。
[1, 2, 3, 4, 5, 6]
[8, 1, 3, 1, 3, 8]
よって、len(li) は 2 を返します。
【 列数の求め方 】
こちらも len 関数で求めます。
今回の場合、リスト [1, 2, 3, 4, 5, 6] と、リスト [8, 1, 3, 1, 3, 8] の要素数は同じなので、
どちらの要素数を求めてもよいですが、ここでは、リスト [1, 2, 3, 4, 5, 6] の要素数を求めます。
リスト [1, 2, 3, 4, 5, 6] は、変数 li の 0 番目の要素なので、li[0] で取得します。
リスト li[0] の要素数は len(li[0]) で取得できます。
以上より、リストの要素の総数は len(li) * len(li[0]) で求めることができます。
'''

step2　全要素の出力
# utf-8
li = [[6, 5, 4, 3, 2, 1], [3, 1, 8, 8, 1, 3]]

for i in range(len(li)):
    for j in range(len(li[i])):
        print(li[i][j], end="")

        if j < len(li[i]) - 1:
            print(end=" ")
        else:
            print()
'''
2 次元リストを出力するために、2 重ループを使います。
2 重ループの構造は以下のようになっています。
for i in range(len(li)): は 0 以上 リスト li の要素数 未満の整数列の要素を順に変数 i に代入して処理をする
for i in range(len(li)): の周回毎に for j in range(len(li[i])): の処理がおこなわれる
for j in range(len(li[i])): は 0 以上 リストli[i] の要素数 未満の整数列の要素を順に変数 j に代入して処理をする
具体的に見ていくと次のようになります。
変数 i に 0 が代入される
変数 j に 0 が代入される
変数 j に 1 が代入される
( 同様に繰り返す )
変数 j に 5 が代入される
変数 i に 1 が代入される
変数 j に 0 が代入される
変数 j に 1 が代入される
( 同様に繰り返す )
変数 j に 5 が代入される
li[i][j] を出力することで、求められている出力ができます。
出力の際、各行の末端の要素を出力したとき ( j=len(li[i]-1) のとき) 改行して、それ以外は改行しないで半角スペースを入れるようにします。
'''

step3　行数の出力
# utf-8
li = [[1, 2, 3], [4, 5, 6], [8, 1, 3]]
print(len(li))
'''
2 次元リストの定義は、リストの要素をリストとすることで実現できます。
len(li) は、変数 li の要素数を返します。いま、変数 li の要素は
[1, 2, 3]
[4, 5, 6]
[8, 1, 3]
の 3 つなので、len(li) は 3 を返します。
'''

step4　列数の出力
# utf-8
li = [[1, 2, 3, 4], [6, 5, 4, 3], [3, 1, 8, 1]]
print(len(li[0]))
'''
2 次元リストの定義は、リストの要素をリストとすることで実現できます。
列数は、変数 li が持つ要素のリストの要素数に一致します。
よって、len(li[0]) を出力することで解くことができます。
また、変数 li の要素 [1, 2, 3, 4], [6, 5, 4, 3], [3, 1, 8, 1] の要素数はどれも同じなので、
len(li[0]), len(li[1]), len(li[2]) のどれを出力しても構いません。
'''

step5　各行の要素数の出力
step6　i行目j列目の出力
step7  二次元配列の入力１
step8　二次元配列の入力２
step9  二次元配列の入力３
step10　二次元配列の入力４
step11  i番目の出力１
step12  i番目の出力２
final  i番目の出力Boss

<【配列の検索】何個ある? Boss>
step1　配列に含まれている?１
step2　配列に含まれている?２
step3　配列に含まれている?３
step4　何番目にある？１
step5　何番目にある？２
step6　何番目にある？３
step7  何個ある？１
step8　何個ある？２
final  何個ある？Boss

<【文字列の配列】辞書順に出力 Boss>
step1　配列の書き換え
step2　2変数の入れ替え
step3　配列の要素の入れ替え
step4　部分配列
step5　配列の連結
step6　配列のソート
step7  配列の反転
step8　要素のカウント
step9  配列末尾への追加
step10　要素の削除
step11  要素の挿入
step12  要素数の出力
step13　全要素の出力
step14　i番目の出力
step15　文字列の配列の入力１
step16　文字列の配列の入力２
step17　文字列の配列の入力３
step18　i番目の出力１
step19　i番目の出力２
step20　i番目の出力３
step21　i番目の出力４
step22　辞書順に出力１
step23　辞書順に出力２
step24　辞書順に出力３
final　 辞書順に出力 Boss

<フィボナッチ数>
step1　重複の削除
step2　配列の最大最小
step3　ある数以上以下の要素の列挙１
step4　ある数以上以下の要素の列挙２
step5　ある数以上以下の要素の列挙３
step6　二点間の距離１
step7　二点間の距離２
final　フィボナッチ数
