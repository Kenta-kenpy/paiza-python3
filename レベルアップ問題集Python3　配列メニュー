<【次元配列の入出力】i番目の出力 Boss>
step1　要素数の出力
# utf-8
list = [5, 1, 3, 4, 5, 12, 6, 8, 1, 3]
print(len(list))

step2　全要素の出力
# utf-8
li = [5, 1, 3, 4, 5, 12, 6, 8, 1, 3]
for ele in li:
    print(ele)
    
step3　i番目の出力
# utf-8
li = [5, 1, 3, 4, 5, 12, 6, 8, 1, 3]
print(li[3])
'''
リストのインデックスは 0 から始まるので、4 番目の要素のインデックスは 3 となります。
リストのインデックスが i の要素を取得するには、li[i] のようにします。
'''

step4　配列の入力１
# utf-8
li = [8, 1, 3, 3, 8, 1, 1, 3, 8, 8]

for ele in li:
    print(ele)
'''
for 文を用いて出力します。
for 文で for ele in li: のように記述すると、変数 ele にリスト li の要素が順に代入されます。
for 文の処理ブロック内で、print 関数を用いて出力をすれば解くことができます。
'''

step5　配列の入力２
# utf-8
A = input().split()
for a in A:
    print(a)
'''
input 関数は標準入力 1 行を文字列で受け取ります。
【 split メソッドについて 】
split メソッドは () に囲まれている文字列を区切り文字として文字列を分割してリストを生成する
区切り文字のデフォルトは半角スペースなので、引数なしで使うと半角スペースが区切り文字となる
よって、input().split() の流れは以下のようになります。
input() で標準入力 1 行を文字列として受け取る
split() で input() で取得した標準入力 1 行の文字列を半角スペースで区切り、リストを生成する
'''

step6　配列の入力３
# utf-8
n = int(input())
li = input().split()

for ele in li:
    print(ele)
'''
Python3 では、標準入力を行単位で文字列として受け取るので、この様な書き方もできます。
input().split() で a_1 ... a_N を半角スペースで区切ってリストを生成するので N の情報がなくてもリストを生成できます。
'''

# 別解
# utf-8
n = int(input())

li = [0] * n
values = input().split()
for i in range(n):
    li[i] = int(values[i])

for ele in li:
    print(ele)

'''
標準入力 1 行目で、要素数 n が与えられるので、それに応じてリストを用意します。
li = [0] * n では 「要素数が n で全ての要素が 0 であるリストを生成する」 という操作を行っています。
変数values で数列を半角スペース区切りで受け取ったあと、for文 を用いて 
変数li の i 番目の要素に 変数values の i 番目の要素を整数に変換して代入します。
'''

step7  i番目の出力１
# utf-8
K = int(input())
li = [1, 3, 5, 4, 6, 2, 1, 7, 1, 5]

print(li[K - 1])
'''
「何番目の要素を出力するか」 という情報を標準入力で受け取ります。
受け取りの際、整数型に変換しないと、リストの k 番目の要素を取得するときに型エラーが発生するので注意して下さい。なお、整数型に変換するときは int() を使います。
リストのインデックス k の要素を取得するときは、変数名[k] の様にします。
リストのインデックスは 0 から始まるので、k 番目の要素のインデックスは k-1 となることに注意が必要です。
'''

step8　i番目の出力２
# utf-8
K = int(input())
A = input().split()

print(A[K - 1])

'''
input 関数は標準入力 1 行を文字列で受け取るので、以下の 2 点に注意が必要。
K を整数型に変換しないと、A[k - 1] で型エラーが発生する
input() は 1 行単位での取得なので、2 行の入力が与えられる今回は input() は 2 回実行するだけでよい
リストのインデックスは 0 から始まることに注意すること。
'''

final  i番目の出力Boss
# utf-8
values = input().split()
N = int(values[0])
K = int(values[1])

A = [0] * N
values = input().split()
for i in range(N):
    A[i] = int(values[i])

print(A[K - 1])

'''
標準入力 1 行目で N K が与えられるので、半角スペースで区切り、それぞれ整数型に変換して変数に代入します。
A = [0] * N では「要素数が N で全ての要素が 0 であるリストを生成する」という操作を行っています。
変数 values で数列を半角スペース区切りで受け取ったあと、for 文を用いて、変数 A の i 番目の要素に
変数 values の i 番目の要素を代入します。
リストのインデックスは 0 から始まるので、K 番目の要素のインデックスは K-1 となるので、注意して下さい。
'''

<【二次元配列の入出力】i番目の出力 Boss>
step1　要素数の出力
# utf-8
li = [[1, 2, 3, 4, 5, 6], [8, 1, 3, 1, 3, 8]]
print(len(li) * len(li[0]))
'''
Python3 では、リストの要素にリストを入れることも可能です。
配列の要素の総数は (配列の行数) * (配列の列数) で求めることができます。
行数、列数の求め方を以下で説明します。
【 行数の求め方 】
len 関数で求めます。
len(li) は、変数 li の要素数がいくつかを返します。今回の場合、変数 li が持っている要素は以下の 2 つです。
[1, 2, 3, 4, 5, 6]
[8, 1, 3, 1, 3, 8]
よって、len(li) は 2 を返します。
【 列数の求め方 】
こちらも len 関数で求めます。
今回の場合、リスト [1, 2, 3, 4, 5, 6] と、リスト [8, 1, 3, 1, 3, 8] の要素数は同じなので、
どちらの要素数を求めてもよいですが、ここでは、リスト [1, 2, 3, 4, 5, 6] の要素数を求めます。
リスト [1, 2, 3, 4, 5, 6] は、変数 li の 0 番目の要素なので、li[0] で取得します。
リスト li[0] の要素数は len(li[0]) で取得できます。
以上より、リストの要素の総数は len(li) * len(li[0]) で求めることができます。
'''

step2　全要素の出力
# utf-8
li = [[6, 5, 4, 3, 2, 1], [3, 1, 8, 8, 1, 3]]

for i in range(len(li)):
    for j in range(len(li[i])):
        print(li[i][j], end="")

        if j < len(li[i]) - 1:
            print(end=" ")
        else:
            print()
'''
2 次元リストを出力するために、2 重ループを使います。
2 重ループの構造は以下のようになっています。
for i in range(len(li)): は 0 以上 リスト li の要素数 未満の整数列の要素を順に変数 i に代入して処理をする
for i in range(len(li)): の周回毎に for j in range(len(li[i])): の処理がおこなわれる
for j in range(len(li[i])): は 0 以上 リストli[i] の要素数 未満の整数列の要素を順に変数 j に代入して処理をする
具体的に見ていくと次のようになります。
変数 i に 0 が代入される
変数 j に 0 が代入される
変数 j に 1 が代入される
( 同様に繰り返す )
変数 j に 5 が代入される
変数 i に 1 が代入される
変数 j に 0 が代入される
変数 j に 1 が代入される
( 同様に繰り返す )
変数 j に 5 が代入される
li[i][j] を出力することで、求められている出力ができます。
出力の際、各行の末端の要素を出力したとき ( j=len(li[i]-1) のとき) 改行して、それ以外は改行しないで半角スペースを入れるようにします。
'''

step3　行数の出力
# utf-8
li = [[1, 2, 3], [4, 5, 6], [8, 1, 3]]
print(len(li))
'''
2 次元リストの定義は、リストの要素をリストとすることで実現できます。
len(li) は、変数 li の要素数を返します。いま、変数 li の要素は
[1, 2, 3]
[4, 5, 6]
[8, 1, 3]
の 3 つなので、len(li) は 3 を返します。
'''

step4　列数の出力
# utf-8
li = [[1, 2, 3, 4], [6, 5, 4, 3], [3, 1, 8, 1]]
print(len(li[0]))
'''
2 次元リストの定義は、リストの要素をリストとすることで実現できます。
列数は、変数 li が持つ要素のリストの要素数に一致します。
よって、len(li[0]) を出力することで解くことができます。
また、変数 li の要素 [1, 2, 3, 4], [6, 5, 4, 3], [3, 1, 8, 1] の要素数はどれも同じなので、
len(li[0]), len(li[1]), len(li[2]) のどれを出力しても構いません。
'''

step5　各行の要素数の出力
# utf-8
li = [[1], [2, 3], [4, 5, 6]]
for ele_li in li:
    print(len(ele_li))
'''
for ele_li in li: で変数 ele_li に変数 li の各要素が順に代入されます。
for ele_li in li: のループ処理内で、len 関数を用いて変数 ele_li の要素数を出力することで求められている出力ができます。
'''

step6　i行目j列目の出力
# utf-8
li = [[1, 2, 3], [8, 1, 3], [10, 100, 1]]
print(li[1][2])
'''
2 次元リストの要素は 変数名[行][列] で取得することができます。
リストのインデックスは 0 から始まるので、2 行目 3 列目の要素は 変数名[1][2] で取得します。
よって、今回は li[1][2] を出力すれば解くことができます。
'''

step7  二次元配列の入力１
# utf-8
li = [[1, 3, 5, 7], [8, 1, 3, 8]]
for i in range(len(li)):
    for j in range(len(li[i])):
        print(li[i][j], end="")

        if j < len(li[i]) - 1:
            print(end=" ")
        else:
            print()
'''
2 重ループを用いて出力を行います。
2 重ループの構造は以下のようになっています。
for i in range(len(li)): は 0 以上 リストli の要素数 未満の整数列の要素を順に変数 i に代入して処理をする
for i in range(len(li)): の周回毎に for j in range(len(li[i])): の処理がおこなわれる
for j in range(len(li[i])): は 0 以上 リストli[i] の要素数 未満の整数列の要素を順に変数 j に代入して処理をする
具体的に見ていくと次のようになります。
変数 i に 0 が代入される
変数 j に 0 が代入される
変数 j に 1 が代入される
変数 j に 2 が代入される
変数 j に 3 が代入される
変数 i に 1 が代入される
変数 j に 0 が代入される
変数 j に 1 が代入される
変数 j に 2 が代入される
変数 j に 3 が代入される
li[i][j] を出力することで、求められている出力ができます。
出力の際、各行の末端の要素を出力したとき ( j=len(li[i]-1) のとき) 改行して、それ以外は改行しないで半角スペースを入れるようにします。
'''

step8　二次元配列の入力２
# utf-8
M = int(input())

A = [[0] * M for _ in range(5)]
for i in range(5):
    values = input().split()
    for j in range(M):
        A[i][j] = int(values[j])

for i in range(5):
    for j in range(M):
        print(A[i][j], end="")

        if j < M - 1:
            print(end=" ")
        else:
            print()
 
 '''
 出力の考え方は前問と同じなので、ここでは入力の受け方に絞って説明します。
まず、リストを初期化します。
[[0] * M for _ in range(5)] は 0 を M 個要素として持ったリストを 5 つ持ったリストを生成しています。
[[0] * M for _ in range(5)] には主に「反復」と「内包表記」の 2 つの文法要素があります。
「反復」と「内包表記」については Python3 の解説の最後に説明します。
次に、入力を受け取って、リストに代入していきます。
5 行 M 列の入力を受け取ることがわかっているので、以下の for 文を使います。
for i in range(5):
    for j in range(M):
        # ここでリストに代入
また、Python の input 関数は行単位で入力を受け取るため、「入力を受け取る」->「for 文でリストの各要素に代入する」という順番で処理を行います。
したがって、上記の for 文にこの処理を加えると以下のようになります。
for i in range(5):
    # ここで入力を受け取る
    for j in range(M):
        # ここでリストに代入
以下で「反復」と「内包表記」について説明します。
【 反復 】
【 特徴 】
反復は同じ要素を任意の数持つリストを生成したいときに使われます。
【 書き方 ・ 考え方 】
反復は * 演算子を使います。
書き方は [0] * n のように書き、これは 0 を n 個要素に持つリストを生成します。
【 内包表記 】
【 特徴 】
内包表記はリストなどを 1 行で簡潔に定義する際に使われます。
内包表記はリストなどを定義するときに使われる Python の長所の 1 つである書き方です。
[] の中に for 文が書かれている見慣れない記述方法ですが、コツを掴むことでコードが簡潔に書けるようになります。
【 書き方 ・ 考え方 】
説明の便宜上、[(1) for (2) in (3)] をモデルとします。
(3) に記述されるものは、変数名[i] のようにインデックスを指定して値を取得できるものなら何でも構いません。
例えば、文字列、リスト、タプル などが挙げられます。
(1) と (2) については 2 パターンあります。
1 パターン目は、[a for b in range(n)] のように、(1) と (2) が一致しない場合です。これは、n 個の a を要素に持つリストを生成し、b は特に意味を持ちません。
2 パターン目は、[a for a in range(n)] のように、(1) と (2) が一致する場合です。これは for a in range(n) を実行するときに、
変数 a に代入される値を要素に持つリストを生成します。
【 反復 + 内包表記 】
上記の内容を [[0] * M for _ in range(5)] に適用して考えます。
[0] * M で [0, ... , 0] の計 M 個の 0 を要素に持つリストを生成
for _ in range(5) で、前段階で生成されたリスト 5 個を要素に持つリストを生成
したがって、[[0] * M for _ in range(5)] で最終的に生成されるリストは、M 個 の 0 を要素とするリストを 5 個持った
[[0, ... , 0], [0, ... , 0], [0, ... , 0], [0, ... , 0], [0, ... , 0]] のような 2 次元リストとなります。
【 変数 _ の意味 】
変数 _ は for 文を使う上でカウンタ変数は必要ですが、その変数を使わないときに使われます。
これは慣習的なことであるので、必ず守らなければならないルールという訳ではありません。
 '''
 
step9  二次元配列の入力３
# utf-8
N = int(input())

A = [[0] * 5 for _ in range(N)]
for i in range(N):
    values = input().split()
    for j in range(5):
        A[i][j] = int(values[j])

for i in range(N):
    for j in range(5):
        print(A[i][j], end="")

        if j < 4:
            print(end=" ")
        else:
            print()

'''
出力の考え方は「二次元配列の入力 1」と同じなので、ここでは入力の受け方に絞って説明します。
まず、リストを「反復」と「内包表記」を使って初期化します。
[[0] * 5 for _ in range(N)] は 0 を 5 個要素として持ったリストを N 個持ったリストを生成しています。
反復と内包表記、変数 _ については前問の解説で説明しています。
次に、入力を受け取って、リストに代入していきます。
N 行 5 列の入力を受け取ることがわかっているので、以下の for 文を使います。
for i in range(N):
    for j in range(5):
        # ここでリストに代入
また、Python の input 関数は行単位で入力を受け取るため、「入力を受け取る」->「for 文でリストの各要素に代入する」という順番で処理を行います。
したがって、上記の for 文にこの処理を加えると以下のようになります。
for i in range(N):
    # ここで入力を受け取る
    for j in range(5):
        # ここでリストに代入
'''

step10　二次元配列の入力４
# utf-8
values = [int(x) for x in input().split()]
N = values[0]
M = values[1]

A = [[int(x) for x in input().split()] for _ in range(N)]
for i in range(N):
    for j in range(M):
        print(A[i][j], end="")

        if j < M - 1:
            print(end=" ")
        else:
            print()

'''
内包表記で入力を受け取ると、このようにコードを簡潔に書くことができます。
以下で簡単に説明します。
変数 x には input().split() で入力を受け取り、半角スペースで区切って生成したリストの各要素が順に代入されます。
[int(x) for x in input().split()] では、変数 x の値を整数型に変換した値を要素にもつリストを生成しています。
[[int(x) for x in input().split()] for _ in range(N)] では、入力が N 行であることがわかっているので、
[int(x) for x in input().split()] を N 回繰り返して 2 次元リストを生成します。
'''


step11  i番目の出力１
# utf-8
values = input().split()
K = int(values[0])
L = int(values[1])

li = [[1, 2, 3, 4], [10, 100, 0, 5], [8, 1, 3, 8], [15, 34, 94, 25]]

print(li[K - 1][L - 1])
'''
2 次元リストは 変数名[行][列] の形式で値を取得できます。
リストのインデックスは 0 から始まるので、K 行 L 列の要素を取得するとき、変数名[K-1][L-1] とする必要があります。
'''

step12  i番目の出力２
# utf-8

final  i番目の出力Boss
# utf-8
N, M, K, L = map(int, input().split())
A = [[int(x) for x in input().split()] for _ in range(N)]

print(A[K-1][L-1])

'''
使った方法は、「内包表記」と「アンパック」です。
内包表記は、リストなどを定義するときによく使われます。
アンパックは、リストなどのオブジェクトの要素を 1 つ 1 つの変数に代入するときに使われます。
アンパックについてもう少し説明します。
【 アンパックについて 】
左辺にリストなどのオブジェクトの要素数と同数の変数を置くことで、そのオブジェクトの要素を左辺のそれぞれの変数に代入できる
たとえば、
a, b, c, d = [1, 2, 3, 4]
print(a, b, c, d)
      
の出力は 1 2 3 4 となります。
map 関数は map オブジェクトを生成しますが、この map オブジェクトはアンパックが可能です。
'''

<【配列の検索】何個ある? Boss>
step1　配列に含まれている?１
step2　配列に含まれている?２
step3　配列に含まれている?３
step4　何番目にある？１
step5　何番目にある？２
step6　何番目にある？３
step7  何個ある？１
step8　何個ある？２
final  何個ある？Boss

<【文字列の配列】辞書順に出力 Boss>
step1　配列の書き換え
step2　2変数の入れ替え
step3　配列の要素の入れ替え
step4　部分配列
step5　配列の連結
step6　配列のソート
step7  配列の反転
step8　要素のカウント
step9  配列末尾への追加
step10　要素の削除
step11  要素の挿入
step12  要素数の出力
step13　全要素の出力
step14　i番目の出力
step15　文字列の配列の入力１
step16　文字列の配列の入力２
step17　文字列の配列の入力３
step18　i番目の出力１
step19　i番目の出力２
step20　i番目の出力３
step21　i番目の出力４
step22　辞書順に出力１
step23　辞書順に出力２
step24　辞書順に出力３
final　 辞書順に出力 Boss

<フィボナッチ数>
step1　重複の削除
step2　配列の最大最小
step3　ある数以上以下の要素の列挙１
step4　ある数以上以下の要素の列挙２
step5　ある数以上以下の要素の列挙３
step6　二点間の距離１
step7　二点間の距離２
final　フィボナッチ数
