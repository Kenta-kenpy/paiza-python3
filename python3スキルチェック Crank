※欠番が存在する理由につきましては、出題自体を公開終了した問題が欠番となっております。

--------------------------------------------- C001　※欠番 ◆
# C001 ◆
# C002 ◆
# C003 ◆
# C004 ◆
# C005　アドレス調査
# utf-8
def is_valid_ipv4(ip_string):
    # 入力されたIPアドレスを"."で分割し、各部分が10進数の範囲内にあるかをチェック
    parts = ip_string.split(".")
    if len(parts) != 4:  # IPアドレスが4つの部分で構成されているかをチェック
        return False

    for part in parts:
        if not part.isdigit():  # 数字以外の文字が含まれていないかをチェック
            return False

        num = int(part)
        if num < 0 or num > 255:  # 0から255の範囲内にあるかをチェック
            return False

    return True

# IPアドレスの数を取得
M = int(input().rstrip())

# M行の入力を受け取り、それぞれのIPアドレスの書式を判定して結果を出力
for _ in range(M):
    ip_string = input().rstrip()  # 入力文字列を取得し、末尾の改行を削除
    valid = is_valid_ipv4(ip_string)
    print(valid)  # 書式が合っているかどうかを出力
    
# C006 ハイスコアランキング
# utf-8
def calculate_score(C, X):
    """
    スコアを計算する関数
    :param C: アイテム種別ごとの得点を格納したリスト
    :param X: ユーザーのアイテム持ち数を格納したリスト
    :return: スコア
    """
    score = sum([C[i] * X[i] for i in range(len(C))])
    return round(score)

def top_k_scores(C, X, M, K):
    """
    トップKのスコアを計算する関数
    :param C: アイテム種別ごとの得点を格納したリスト
    :param X: ユーザーのアイテム持ち数を格納したリスト
    :param M: ユーザーの数
    :param K: トップKのスコアを取得する数
    :return: トップKのスコアを格納したリスト
    """
    scores = []
    for i in range(M):
        score = calculate_score(C, X[i])
        scores.append(score)
    top_k_scores = sorted(scores, reverse=True)[:K]
    return top_k_scores

# 入力を受け取る
params = input().split() # 一行目のパラメータをスペースで分割してリストに格納
N = int(params[0])
M = int(params[1])
K = int(params[2])

C = list(map(float, input().split())) # 二行目のパラメータをスペースで分割してリストに格納し、float型に変換
X = [] # 三行目以降のパラメータを二次元リストに格納
for _ in range(M):
    x = list(map(int, input().split())) # 三行目以降のパラメータをスペースで分割してリストに格納し、int型に変換
    X.append(x)

# トップKのスコアを計算
top_k_scores = top_k_scores(C, X, M, K)

# 結果を改行で出力
for i in range(K):
    print(top_k_scores[i])
    
# C007 ◆
# C008 ◆
# C009 ◆
# C010 安息の地を求めて
# utf-8
s = input().strip().split(" ")
n1 = list(map(int, s))  # int変換

cnt = int(input())

for i in range(cnt):
    s = input().strip().split(" ")
    n3 = list(map(int, s))  # int変換

    if ((n3[0] - n1[0]) ** 2) + ((n3[1] - n1[1]) ** 2) >= (n1[2] ** 2):
        print("silent")
    else:
        print("noisy")
        
--------------------------------------------- C011　※欠番 ◆
# C011 ◆
# C012 ◆
# C013　嫌いな数字
# utf-8
# 嫌いな数字を入力
n = int(input())

# 範囲外の場合はエラーを出力して終了
if n < 0 or n > 9:
    print("嫌いな数字は0から9の範囲で入力してください。")
    exit()

# 病室の総数を入力
m = int(input())

# 範囲外の場合はエラーを出力して終了
if m < 1 or m > 100:
    print("病室の総数は1から100の範囲で入力してください。")
    exit()

# 希望する病室の部屋番号を格納するリスト
desired_rooms = []

# 各病室の部屋番号を入力し、希望する病室をリストに追加
for i in range(m):
    room_number = int(input())

    # 範囲外の場合はエラーを出力して終了
    if room_number < 1 or room_number > 1000:
        print("部屋番号は1から1000の範囲で入力してください。")
        exit()

    if str(n) not in str(room_number): # 部屋番号に嫌いな数字が含まれていない場合
        desired_rooms.append(room_number)

# 希望する病室があるかどうかを判定し、出力
if len(desired_rooms) > 0:
    for room in desired_rooms:
        print(room)
else:
    print("none")
        
# C014　ボールが入る箱
# utf-8
# 入力からボールの半径と箱の情報を取得
n, r = map(int, input().split())
boxes = []
for i in range(n):
    h, w, d = map(int, input().split())
    boxes.append((h, w, d))

# ボールを収納することができる箱の番号を格納するリストを初期化
result = []

# 各箱について、ボールを収納できるかを判定
for i in range(n):
    h, w, d = boxes[i]
    # 箱の高さ、幅、奥行きのうち最も短いものを取得
    shortest_side = min(h, w, d)
    # ボールの直径が最も短い箱の辺の長さ以下であれば、ボールを収納できる
    if shortest_side >= 2 * r:
        result.append(i + 1)  # 箱の番号をリストに追加

# 結果を昇順に出力
for num in result:
    print(num)
    
# C015 ポイントカードの計算
# utf-8
# coding: utf-8
import math

cnt = int(input())

sum = 0
for i in range(cnt):
    s = input().strip().split(" ")
    a = str(s[0])
    n = int(s[1])

    if "3" in a:
        sum += math.floor(n / 100 * 3)
    elif "5" in a:
        sum += math.floor(n / 100 * 5)
    else:
        sum += math.floor(n / 100)

print(sum)

# C016 Leet文字列
# utf-8
def to_leet_string(input_string):
    leet_rules = {
        'A': '4',
        'E': '3',
        'G': '6',
        'I': '1',
        'O': '0',
        'S': '5',
        'Z': '2'
    }

    leet_string = ''
    for char in input_string:
        if char.upper() in leet_rules:
            leet_string += leet_rules[char.upper()]
        else:
            leet_string += char

    return leet_string

input_string = input().rstrip() # 入力文字列を取得し、末尾の改行を削除
leet_string = to_leet_string(input_string)
print(leet_string, end='\n') # Leet文字列を出力し、最後に改行を追加

# C017　ハイアンドロー・カードゲーム
def compare_cards(parent_card, child_card):
    """
    親カードと子カードの強弱関係を比較する関数

    Args:
        parent_card (tuple): 親カードの情報。(1つ目の番号, 2つ目の番号)
        child_card (tuple): 子カードの情報。 (1つ目の番号, 2つ目の番号)

    Returns:
        str: 強弱関係の結果を表す文字列。'High'、'Low'のいずれか。
    """
    parent_num1, parent_num2 = parent_card
    child_num1, child_num2 = child_card

    if parent_num1 > child_num1:
        return 'High'
    elif parent_num1 < child_num1:
        return 'Low'
    else:
        if parent_num2 < child_num2:
            return 'High'
        else:
            return 'Low'

# 親カードの情報を入力
parent_card = tuple(map(int, input().split()))

# 子カードの数を入力
n = int(input())

# 子カードの情報を入力し、強弱関係を判定して出力
for i in range(n):
    child_card = tuple(map(int, input().split()))
    result = compare_cards(parent_card, child_card)
    print(result)

# C018 何人前作れる?
# レシピに書かれている食材の数を取得
n = int(input())

# レシピの食材と必要量を辞書に格納
recipe = {}
for i in range(n):
    a, b = input().split()
    recipe[a] = int(b)

# あなたが所持している食材の数を取得
m = int(input())

# 所持している食材と数量を辞書に格納
ingredients = {}
for i in range(m):
    c, d = input().split()
    ingredients[c] = int(d)

# 最大で何人前作れるかを計算
max_servings = float('inf')  # 初期値を無限大に設定

# レシピの食材と必要量をループし、所持している食材と比較
for ingredient, amount in recipe.items():
    if ingredient in ingredients:
        max_servings = min(max_servings, ingredients[ingredient] // amount)
    else:
        max_servings = 0
        break

# 最大で何人前作れるかを出力
print(max_servings)

# C019 完全数とほぼ完全数
# utf-8
def is_perfect_or_almost_perfect_number(n):
    """
    入力された整数が完全数かほぼ完全数かそのいずれでもないかを判定する関数

    Args:
        n (int): 判定する整数

    Returns:
        str: 完全数、ほぼ完全数、そのいずれでもないことを示す文字列
    """
    # 約数の和を計算
    s = 0
    for i in range(1, n):
        if n % i == 0:
            s += i

    # 完全数の判定
    if n == s:
        return "perfect"

    # ほぼ完全数の判定
    if abs(n - s) == 1:
        return "nearly"

    # その他の場合
    return "neither"


# 判定したい整数の個数を入力
q = int(input())

# 入力範囲を満たすかチェック
if q < 1 or q > 50:
    print("Error: 1 ≦ Q ≦ 50 の範囲で入力してください。")
    exit(1)

# 各整数について判定を行い結果を出力
for i in range(q):
    n = int(input())

    # 入力範囲を満たすかチェック
    if n < 2 or n > 1000:
        print("Error: 2 ≦ N_i ≦ 1000 の範囲で入力してください。")
        exit(1)

    result = is_perfect_or_almost_perfect_number(n)
    print(result)
        
# C020　残り物の量
# utf-8
def calculate_leftover_amount(m, p, q):
    """
    生鮮食品の売れ残り量を計算する関数

    Args:
        m (int): 生鮮食品の仕入れ量(kg)
        p (int): 生のまま売れた割合(%)
        q (int): お総菜に変換された売れ残りの割合(%)

    Returns:
        float: 最終的な売れ残り量(kg)
    """
    # 生鮮食品の売れ残り量を計算
    leftover_amount = m * (100 - p) / 100

    # お総菜に変換された売れ残り量を計算
    leftover_amount = leftover_amount * (100 - q) / 100

    return leftover_amount


# 生鮮食品の仕入れ量、生のまま売れた割合、お総菜に変換された売れ残りの割合を入力
m, p, q = map(int, input().split())

# 生鮮食品の売れ残り量を計算
leftover_amount = calculate_leftover_amount(m, p, q)

# 売れ残り量を小数値で出力
print("{:.4f}".format(leftover_amount))
--------------------------------------------- C021　※欠番 ◆
# C021　暴風域にいますか
# utf-8
import math

def is_in_typhoon(xc, yc, r1, r2, x, y):
    """
    台風の暴風域にあるかどうかを判定する関数

    Args:
        xc (int): 台風1の中心のx座標
        yc (int): 台風1の中心のy座標
        r1 (int): 台風1の半径
        r2 (int): 台風2の半径
        x (int): 判定する人のx座標
        y (int): 判定する人のy座標

    Returns:
        bool: 台風の暴風域にある場合True、そうでない場合False
    """
    distance_squared = (x - xc) ** 2 + (y - yc) ** 2
    if r1 ** 2 <= distance_squared <= r2 ** 2:
        return True
    else:
        return False

# 台風情報の入力
xc, yc, r1, r2 = map(int, input().split())
# 人の数の入力
n = int(input())

# 各人の座標の入力と判定
for i in range(n):
    x, y = map(int, input().split())
    if is_in_typhoon(xc, yc, r1, r2, x, y):
        print("yes")
    else:
        print("no")
    
# C022 ローソク足
# utf-8
# 日数 n を入力
n = int(input())

# 株価データを入力し、始値、終値、高値、安値を計算
start_prices = []
end_prices = []
high_prices = []
low_prices = []

for i in range(n):
    s, e, h, l = map(int, input().split())
    start_prices.append(s)
    end_prices.append(e)
    high_prices.append(h)
    low_prices.append(l)

# n日間の始値を計算
start_price = start_prices[0]

# n日間の終値を計算
end_price = end_prices[-1]

# n日間の高値を計算
high_price = max(high_prices)

# n日間の安値を計算
low_price = min(low_prices)

# 結果を出力
print(start_price, end_price, high_price, low_price, end='')

# C023 クジの当選番号
# utf-8
import sys
a = [int(s) for s in sys.stdin.readline().split()]
N=int(input())
b = [[int(s) for s in line.split()] for line in sys.stdin]
for j in range(N):
    c=0
    for i in range(len(b[0])):
        if a[i] in b[j]:
            c += 1
    print(c)
    
# C024　ミニ・コンピュータ
# coding: utf-8
n = int(input())
num1 = 0
num2 = 0

cul = []

for i in range(0, n):
    cul.append(input().split(" "))

    #SET
    if("SET" in cul[i]):
        if(cul[i][1] == "1"):
            num1 = int(cul[i][2])
        else:
            num2 = int(cul[i][2])
    #ADD
    elif("ADD" in cul[i]):
        num2 = num1 + int(cul[i][1])
    #SUB
    else:
        num2 = num1 - int(cul[i][1])

print(num1, num2)

# C025　ファックスの用紙回収
# utf-8
def simulate_computer(instructions):
    """
    コンピュータをシミュレートする関数

    Args:
        instructions (list): コンピュータに与える命令のリスト

    Returns:
        tuple: 変数1と変数2の最終的な値のタプル
    """
    var1 = 0  # 変数1の初期値
    var2 = 0  # 変数2の初期値

    for instruction in instructions:
        operation = instruction[0]
        value = instruction[1]

        if operation == "SET":
            var_idx = int(instruction[2]) - 1  # 変数のインデックス
            if var_idx == 0:
                var1 = value
            elif var_idx == 1:
                var2 = value
        elif operation == "ADD":
            var2 += value
        elif operation == "SUB":
            var2 -= value

    return var1, var2

# 命令の数を入力
n = int(input("命令の個数を入力してください: "))

instructions = []
# 命令のリストを入力
for i in range(n):
    while True:
        instr = input(f"命令{i+1}を入力してください（例: SET 1 10、ADD 5、SUB 3）: ").split()
        if len(instr) != 3 or instr[0] not in ["SET", "ADD", "SUB"] or not instr[1].isdigit() or not instr[2].isdigit():
            print("命令のフォーマットが不正です。再度入力してください。")
        else:
            break
    instructions.append([instr[0], int(instr[1]), int(instr[2])])

# コンピュータをシミュレートし、変数1と変数2の最終的な値を取得
result = simulate_computer(instructions)

# 変数1と変数2の最終的な値を半角スペース区切りで1行に出力し、最後に改行を追加
print(*result, sep=" ", end="\n")

# C026　ウサギと人参
# utf-8
# 入力を受け取る
N, S, p = map(int, input().split())  # 人参のデータの数、目安となる糖分、許容誤差

max_mass = -1  # 最大質量を初期化
max_index = -1  # 最大質量の人参の番号を初期化

# N個の人参データを入力として受け取る
for i in range(1, N + 1):
    data = list(map(int, input().split()))  # 質量と糖分をスペース区切りで入力
    mass = data[0]  # 人参の質量
    sugar = data[1]  # 人参の糖分

    # 糖分が許容範囲内でかつ質量が最大の場合、最大質量とその人参の番号を更新
    if S - p <= sugar <= S + p and mass > max_mass:
        max_mass = mass
        max_index = i

if max_index != -1:
    print(max_index)  # 最大質量の人参の番号を出力
else:
    print("not found")  # 見つからなかった場合は "not found" を出力

# C027　◆
# C028　単語テストの採点
# utf-8
N = int(input())
words = [input().split() for x in range(N)] #出力[q_1,a_1][q_2,a_2]....
score = 0

for word in words:
    if len(word[0]) == len(word[1]):
        miss = 0 #missは毎回０になる必要がある
        for i in range(len(word[0])):#文字の長さだけ繰り返される(if文で文字列の数が違うものは省いているので差異を気にする必要はない)
            if (word[0])[i] != (word[1])[i]:#リストにしている単語を1文字ずつ(i)比べる
                miss += 1
        
        if miss < 1:
            score += 2
            
        elif miss < 2:
            score += 1
            
print(score)

# C029　旅行の計画
# utf-8
# 連休の日数を表す整数 M と 旅行の日数を表す整数 N を入力から取得
M, N = map(int, input().split())

# 連休の日付と降水確率を格納するリスト
dates = []
rainfall_probs = []

# 連休の日付と降水確率を入力から取得
for _ in range(M):
    d, r = map(int, input().split())
    dates.append(d)
    rainfall_probs.append(r)

# N日間の降水確率の平均が最も低くなる日程の最初の日付と最後の日付を初期化
min_avg_rainfall_prob = float('inf')
start_date = -1
end_date = -1

# 連休の日付をスライドさせながらN日間の降水確率の平均を計算し、最も低い値を探索
for i in range(M - N + 1):
    avg_rainfall_prob = sum(rainfall_probs[i:i+N]) / N
    if avg_rainfall_prob < min_avg_rainfall_prob:
        min_avg_rainfall_prob = avg_rainfall_prob
        start_date = dates[i]
        end_date = dates[i + N - 1]

# 結果を出力
print(start_date, end_date)

# C030　白にするか黒にするか
# utf-8
# 画像のサイズを表す整数 H, W を入力から取得
H, W = map(int, input().split())

# 画像の各画素値を表す整数の二次元配列 img を入力から取得
img = []
for _ in range(H):
    row = list(map(int, input().split()))
    img.append(row)

# 二値画像に変換して結果を出力
for i in range(H):
    for j in range(W):
        # 画素値が 128 以上ならば 1 (白)、それ以下ならば 0 (黒) に変換
        if img[i][j] >= 128:
            img[i][j] = 1
        else:
            img[i][j] = 0
        print(img[i][j], end=" ")  # 変換結果をスペース区切りで出力
    print()  # 改行して次の行を出力

--------------------------------------------- C031　※欠番 ◆
# C031　時差を求めたい
# utf-8
# 都市ごとの時差を管理する辞書を作成
time_difference = {}

# 都市の総数を入力
N = int(input())

# 都市ごとの時差情報を入力
for i in range(N):
    city_info = input().split()
    city_name = city_info[0]
    time_difference[city_name] = int(city_info[1])

# ユーザの所在地の都市と投稿時刻を入力
user_city, user_time = input().split()

# ユーザの所在地の都市の時差を取得
user_time_difference = time_difference[user_city]

# ユーザの投稿時刻を時と分に分割
user_hour, user_minute = map(int, user_time.split(':'))

# 各都市ごとに投稿時刻を修正して出力
for city, diff in time_difference.items():
    # ユーザの所在地の都市の場合はそのまま出力
    if city == user_city:
        print(user_time)
    else:
        # 各都市の時差を考慮して投稿時刻を修正
        city_hour = (user_hour + diff - user_time_difference + 24) % 24
        city_minute = user_minute
        # 時と分を0埋め2桁の文字列に変換して出力
        print('{:02d}:{:02d}'.format(city_hour, city_minute))

# C032　お得な買い物
# utf-8
n=int(input())
a=[0]*4
for i in range(n):
    v,p=map(int, input().split())
    a[v]=a[v]+p
print(a[0]//100*5+a[1]//100*3+a[2]//100*2+a[3]//100*1)

# C033　◆
# C034　先生の宿題
def calculate_answer(problem):
    # 問題をスペースで分割して、各要素を取得
    elements = problem.split(" ")
    a = elements[0]
    op = elements[1]
    b = elements[2]
    c = elements[4]
    
    # a, b, c のうち空欄を特定し、答えを計算
    if a == "x":
        if op == "+":
            answer = int(c) - int(b)
        elif op == "-":
            answer = int(c) + int(b)
    elif b == "x":
        if op == "+":
            answer = int(c) - int(a)
        elif op == "-":
            answer = int(a) - int(c)
    elif c == "x":
        if op == "+":
            answer = int(a) + int(b)
        elif op == "-":
            answer = int(a) - int(b)
    
    # 答えが 0 から 9 の間に収まるように制限
    if answer < 0:
        answer = 0
    elif answer > 9:
        answer = 9
        
    return str(answer)
            
# 問題を入力として受け取る
problem = input()

# 答えを計算して出力
answer = calculate_answer(problem)
print(answer)

# C035　試験の合格判定
# utf-8
# 受験者の人数を入力
N = int(input())

# 2段階選抜を通過できる人数をカウントする変数を初期化
passed_count = 0

# 各受験者の情報を入力し、2段階選抜を通過できるかを判定
for i in range(N):
    # 受験者の情報を入力
    data = input().split()
    t_i = data[0]  # 文理の区分
    e_i = int(data[1])  # 英語の点数
    m_i = int(data[2])  # 数学の点数
    s_i = int(data[3])  # 理科の点数
    j_i = int(data[4])  # 国語の点数
    g_i = int(data[5])  # 地理歴史の点数
    
    # 各科目の合計得点を計算
    total_score = e_i + m_i + s_i + j_i + g_i
    
    # 理系か文系かを判定
    is_science_major = t_i == "s"
    is_literature_major = t_i == "l"
    
    # 2段階選抜の条件を満たすかを判定
    if total_score >= 350 and ((is_science_major and (m_i + s_i) >= 160) or (is_literature_major and (j_i + g_i) >= 160)):
        passed_count += 1

# 2段階選抜を通過できる人数を出力
print(passed_count)

# C036　犬ぞりトーナメント
# utf-8
f1 = [int(_) for _ in sorted(input().split())]
f2 = [int(_) for _ in sorted(input().split())]
t1 = [int(_) for _ in input().split()]
t2 = [int(_) for _ in input().split()]

s = [f1[0] if t1[f1[0]-1] < t1[f1[1]-1] else f1[1]]
s += [f2[0] if t1[f2[0]-1] < t1[f2[1]-1] else f2[1]]
s.sort()
print(s[0] if t2[0] < t2[1] else s[1])
print(s[1] if t2[0] < t2[1] else s[0])

# C037　アニメの日時
# utf-8
import re
# 入力を受け取る
t = input().rstrip()

# 正規表現を使って入力の日付時刻をパース
pattern = r'(\d{2})/(\d{2}) (\d{2}):(\d{2})'
match = re.match(pattern, t)

if match:
    # パースに成功した場合
    month = int(match.group(1))
    day = int(match.group(2))
    hour = int(match.group(3))
    minute = int(match.group(4))
    
    # 月と日が不正な値の場合には修正する
    while month > 12 or day > 31:
        if month > 12:
            month -= 12
        if day > 31:
            day -= 31
    
    # 時間が 24 以上の場合は日付を繰り上げる
    while hour >= 24:
        hour -= 24
        day += 1
        
    # パースした値を元のフォーマットで出力
    print("{:02d}/{:02d} {:02d}:{:02d}".format(month, day, hour, minute))
else:
    # パースに失敗した場合は入力の日付時刻をそのまま出力
    print(t)

# C038　お菓子の分配
# utf-8
n = input().strip().split(" ")
n = list(map(int, n))   # int変換

ans = [0, 1001, 1001]  # No, mod, q

for i in range(n[0]):
    a = int(input())
    m = n[1] % a
    q = n[1] // a

    if (m < ans[1])or (m == ans[1] and q < ans[2]):
        ans[0] = i + 1
        ans[1] = m
        ans[2] = q

print(ans[0])

# C039　古代の数式
# utf-8
line = input()
# print(line)
line_list = list(line)
# print(line_list)

cnt_k=0
cnt_l=0

for i in range(len(line)):
    # print(i)
    if line_list[i]=="<":
        cnt_k += 1
    # print(cnt_k)
    if line_list[i]=="/":
        cnt_l += 1
    
print(cnt_k*10 + cnt_l)

# C040　背比べ
# utf-8
n = int(input())
comps = [input().split() for x in range(n)]
l,r=0,1000
for comp in comps:
  if comp[0] == 'ge':
    l = max(l,float(comp[1]))
  else:
    r = min(r,float(comp[1]))
print(l,r)

--------------------------------------------- C041　※欠番 ◆
# C041　メダルランキングの作成
# utf-8
# 入力を受け取る
N = int(input())  # 国の総数
medals = []  # メダルの獲得数を格納するリスト

# メダルの獲得数を入力から取得し、リストに格納
for i in range(N):
    g, s, b = map(int, input().split())
    medals.append((g, s, b))

# メダルの獲得数を条件にそってソート
medals.sort(reverse=True)

# ソートされたメダルの獲得数を出力
for medal in medals:
    print(*medal)

# C042　リーグ表の作成
# utf-8
# 参加者数を入力から取得
N = int(input())

# 各試合の結果を入力から取得
results = {}
for i in range(1, N * (N - 1) // 2 + 1):
    f, s = map(int, input().split())
    results[i] = (f, s)

# 表の初期化
table = [['-' for _ in range(N)] for _ in range(N)]

# 各試合の結果を表に反映
for i, (f, s) in results.items():
    table[f - 1][s - 1] = 'W'
    table[s - 1][f - 1] = 'L'

# 表の出力
for row in table:
    print(' '.join(row))
    
# C043　使用回数の調査
# utf-8
import collections

n = int(input())
m = input().strip().split(" ")
m = list(map(int, m))   # int変換

c = collections.Counter(m)

mc = c.most_common()

mx = mc[0][1]
l = []

for x in mc:
    if x[1] < mx:
        break
    else:
        l.append(x[0])

l.sort()

print(" ".join([str(x) for x in l]))

# C044　手の組み合わせ
# utf-8
n = int(input())

h = []
for i in range(n):
    h.append(input())

h = sorted(set(h))

if len(h) == 2:
    if h[0] == 'paper':
        if h[1] == 'rock':
            print(h[0])
        else:
            print(h[1])
    else:
        print(h[0])

else:
    print("draw")
    
# C045　ページネーション
# utf-8
def paginate_search_results(n, s, p):
    start = (p - 1) * s + 1 # 開始番号
    end = min(n, p * s) # 終了番号
    if start > n:
        return "none" # 検索結果が存在しない場合は"none"を返す
    else:
        return list(range(start, end + 1)) # 開始番号から終了番号までのリストを返す

# 入力の取得
n, s, p = map(int, input().split())

# ページネーションの実行
result = paginate_search_results(n, s, p)

# 出力
if result == "none":
    print(result)
else:
    print(*result)
    
# C046　書籍購入費ランキング
# utf-8
member = int(input())
name = input()
names = name.split()

book = int(input())
buy = [input() for i in range(book)]

dic = {}

for members in range(member):
	dic[names[members]] = 0

for books in buy:
	temp = books.split()
	dic[temp[0]] += int(temp[1])
	
for k, v in sorted(dic.items(), key=lambda x: x[1], reverse=True):
	print(k)
    
# C047　◆
# C048　タダ飲みコーヒー
# utf-8
import math

row = input()

sp = row.split()

# print(sp)

price = int(sp[0])
discount = int(sp[1])

after_price = price
total = price
count = 0

while after_price > 0:
	# 切り捨て
	after_price = math.floor(after_price * (100 - discount)/100)
	total += after_price
	
print(total)

# C049　エレベーター
# utf-8
# 入力を受け取る
N = int(input())  # ログの行数
floors = []  # エレベーターが止まった階のリスト
for _ in range(N):
    floor = int(input())
    floors.append(floor)

# エレベーターが合計で何階分の距離を動いたか計算する
total_distance = 0  # 合計の距離
current_floor = 1  # 現在の階数は必ず1階とする
for floor in floors:
    distance = abs(floor - current_floor)  # 現在の階数から目的の階数までの距離
    total_distance += distance  # 合計の距離に加算
    current_floor = floor  # 現在の階数を更新

# 結果を出力
print(total_distance)

# C050　オークションの結果
# utf-8
S,a,b=map(int,input().split())
while True:
    if a>=S+10:
        S=S+10
    else:
        print("B",S)
        break
    if b>=S+1000:
        S=S+1000
    else:
        print("A",S)
        break
--------------------------------------------- C051　※欠番 ◆
# C051　カード並べ
# utf-8
numlist=list(map(int,input().split()))#a, b, c, d はそれぞれ 4 枚のカード
newlist=sorted(numlist)#昇順に並び替え #例： 2, 3, 8 , 9
num1=str(newlist[3])+str(newlist[1])
num2=str(newlist[2])+str(newlist[0])
print(int(num1)+int(num2))

# C052　ゲームの画面
# utf-8
w = input().strip().split(" ")
w = list(map(int, w))   # int変換

n = input().strip().split(" ")
n = list(map(int, n))   # int変換

ful = w[0] * w[1]
used = (w[0] - abs(n[0])) * (w[1] - abs(n[1]))

print(ful - used)

# C053　カードの合計
# utf-8
party = int(input())

cards = input()
cards_split = cards.split()
ten = "x10" in cards_split

bonus = 1

if ten is True:
    cards_split.remove("x10")
    bonus = 10

cards_split_i = [int(s) for s in cards_split]

zero = "0" in cards_split

if zero is True:
    max_num = max(cards_split_i)
    cards_split_i.remove(max_num)

res = sum(cards_split_i) * bonus

print(res)

# C054　スピード違反の取り締まり
# utf-8
n = input().strip().split(" ")
n = list(map(int, n))   # int変換

t = []
p = []
while True:
    try:
        a = input().strip().split(" ")
        a = list(map(int, a))   # int変換
        t.append(a[0])
        p.append(a[1])

    except EOFError:
        break

ans = "NO"

for i in range(n[0]):
    if i == 0:
        continue

    if (p[i] - p[i-1]) / (t[i] - t[i-1]) > n[1]:
        ans = "YES"
        break

print(ans)

# C055　ログのフィルター
# utf-8
import re

N = int(input())
# print(N)
string = input()
# print(string)
flag = 0
for i in range(N):
    abc = input()
    
    if string in abc:
        print(abc)
        flag = 1
        
if flag == 0:
    print('None')
    
# C056　テストの採点
# utf-8
from sys import stdin

n, m = map(int, stdin.readline().rstrip().split())
test_results = [list(map(int, stdin.readline().rstrip().split())) for i in range(n)]
# pass_students_id = [i + 1 for i, result in enumerate(test_results) if (result[0] - result[1] * 5) >= m]
pass_students_id = []
for i, result in enumerate(test_results):
  r1 = result[0] - result[1] * 5
  r = r1 if r1 >= 0 else 0
  if r >= m:
    pass_students_id.append(i+1)
for i in pass_students_id:
  print(i)

# C057　シャボン玉飛ばし
# utf-8
# 入力を受け取る
T, x, y = map(int, input().split())
wind = []
for _ in range(T):
    a, b = map(int, input().split())
    wind.append((a, b))

# シャボン玉の位置を更新しながら最大の x 座標を求める
max_x = x
for i in range(T):
    a, b = wind[i]
    # シャボン玉の位置を更新
    x += a
    y += b
    # y 座標が 0 以下になったらシャボン玉が割れるので、最大の x 座標を出力して終了
    if y <= 0:
        print(max_x)
        exit()
    # x 座標の最大値を更新
    max_x = max(max_x, x)

# T 時間経過後までシャボン玉が割れずに生き残った場合、最終的な x 座標を出力
print(max_x)

# C058　模様そろえ
# utf-8
# 入力を受け取る
input_line = input().strip().split()
N = int(input_line[0])  # 箱の側面の数
t = input_line[1]  # そろえる向きを表す文字列
s = input_line[2]  # 最初の箱の向きを表す文字列

# 最小回転数を計算
rotation = (s + s).find(t)  # sを2つ繋げて、tが最初に出現するインデックスを求める

# 最小回転数がN以上の場合は、回転数を修正する
if rotation >= N:
    rotation = N - rotation

# 結果を出力
print(rotation)

# C059　パリティチェック
# utf-8
# 入力データの取得
N = int(input())  # 2進数の数
binary_list = []  # 2進数のリスト
for i in range(N):
    binary = input().strip()
    binary_list.append(binary)

# 排他的論理和(XOR)を計算して結果を出力する関数
def calculate_xor(binary_list):
    result = ""
    for i in range(4):  # 4桁の2進数なので4回繰り返す
        count = 0
        for j in range(N):
            if binary_list[j][i] == '1':
                count += 1
        if count % 2 == 1:
            result += '1'
        else:
            result += '0'
    return result

# 排他的論理和(XOR)を計算して結果を出力
result = calculate_xor(binary_list)
print(result)

# C060　辞書の作成
# utf-8
def get_words_on_page(N, K, P, words):
    # 辞書順に単語を並び替える
    words.sort()

    # P ページ目に載る単語のインデックスを計算
    start_idx = (P - 1) * K
    end_idx = min(start_idx + K, N)

    # P ページ目に載る単語のリストを取得
    words_on_page = words[start_idx:end_idx]

    return words_on_page

# 入力の受け取り
N, K, P = map(int, input().split())
words = input().strip().split()

# 入力のバリデーション
if not (3 <= N <= 1000) or not (1 <= K <= N) or not (1 <= P <= N):
    print("入力値が条件を満たしていません。")
    exit(1)

if len(words) != N or len(set(words)) != N:
    print("入力される単語が条件を満たしていません。")
    exit(1)

for word in words:
    if not (0 <= len(word) <= 10):
        print("入力される単語の長さが条件を満たしていません。")
        exit(1)

# P ページ目に載る単語のリストを取得
words_on_page = get_words_on_page(N, K, P, words)

# 結果を改行区切りで出力
print("\n".join(words_on_page))

'''
# 別解
N, K, P = map(int,input().split())
s = input().split()
s.sort()
j = []
for i in range(0, N, K):
    j.append(s[i:i+K])
for k in j[P-1]:
    print(k)

'''
--------------------------------------------- C061　※欠番 ◆
# C061　繰り上がりのない足し算
# utf-8
A, B = map(str,input().split())
s = ""
if max(len(A), len(B)) == 3:
    s += str((int(A) // 100 + int(B) // 100) % 10)
if max(len(A), len(B)) >= 2:
    s += str((int(A) // 10 + int(B) // 10) % 10)
s += str((int(A) + int(B)) % 10)
print(s)

# 別解
def add_with_kids_method(num1, num2):
    len_diff = abs(len(num1) - len(num2))

    if len(num1) > len(num2):
        num2 = '0' * len_diff + num2
    else:
        num1 = '0' * len_diff + num1

    result = ''
    for i in range(len(num1)-1, -1, -1):
        digit1 = int(num1[i])
        digit2 = int(num2[i])
        sum_digits = digit1 + digit2
        result = str(sum_digits % 10) + result

    return result


# 入力を受け取る
input_str = input().rstrip()  # 入力を1行受け取り、末尾の改行を削除
num1, num2 = input_str.split()  # スペース区切りで入力を分割
result = add_with_kids_method(num1, num2)  # 繰り上がりを無視して足し算を実行
print(result)  # 結果を出力

# C062　回転寿司のメロン
# utf-8
t = int(input())  # 皿の数を取得

a = 0  # 食べたメロンの数をカウントする変数
b = 10  # 滞在時間のカウントダウン用の変数

for i in range(t):
    n = input()  # ネタを取得
    b += 1  # 滞在時間をカウントダウン
    if n == 'melon' and b > 10:  # ネタがメロンであり、滞在時間が10を超えた場合にメロンを食べる
        a += 1  # メロンの数をカウント
        b = 0  # 滞在時間をリセット

print(a)  # 結果を出力

# C063　ガーデニング
# utf-8
N = int(input())

flowers = [[int(i) for i in input().split()] for j in range(N)]
bloom_days = []
max_count = 0
max_date = 10000

for i, j in flowers:
    bloom_day = i + j
    bloom_days.append(bloom_day)

for day in bloom_days:
    count = bloom_days.count(day)
    if count > max_count or (count == max_count and day < max_date):
        max_count = count
        max_date = day

print(max_date)
'''
x リストを使用せずに、bloom_days リストに直接花が咲く日数を追加しました。
2 重の for ループを使用する代わりに、count() メソッドを使用して同じ日数の花の個数を数えました。
最大の花の個数と日数を更新する際に、max_count と max_date の比較を行い、必要に応じて更新しました。
'''

# C064　paizaでお食事
# utf-8
M, N = map(int, input().split())

c = [int(input()) for i in range(M)]
a = [list(map(int, input().split())) for i in range(N)]

for i in range(N):
    total_calories = sum([c[j-1]*a[i][j-1]//100 for j in range(1, M+1)])
    print(total_calories)

# C065　数字あてゲーム
# utf-8
def find_unique_integer(N, hints):
    nums = set(range(1, 101))

    for hint in hints:
        op = hint[0]
        num = hint[1]
        temp = set()

        if op == '>':
            for i in nums:
                if i > num:
                    temp.add(i)
        elif op == '<':
            for i in nums:
                if i < num:
                    temp.add(i)
        elif op == '/':
            for i in nums:
                if i % num == 0:
                    temp.add(i)

        nums = temp

    return nums.pop()


# 入力の読み込み
N = int(input())
hints = []
for i in range(N):
    hint = input().split()
    hints.append((hint[0], int(hint[1])))

# 一意の正整数を探す
result = find_unique_integer(N, hints)
print(result)

# C066　金魚すくい
# utf-8
M, N, X = map(int, input().split())
w = [int(input()) for _ in range(M)]
c = 0
d = 0
while True:
    if N <= 0:
        break
    if len(w) == d:
        break
    p = X
    N -= 1
    while len(w) > d:
        k = w[d]
        p -= k
        if p <= 0:
            break
        c += 1
        d += 1
print(c)
'''
入力から金魚の数M、ポイの数N、ポイの耐久値Xを取得し、金魚の重量wをリストに格納します。そして、ループを使ってポイを使って金魚をすくいます。
内側のループでは、ポイの耐久値Xを金魚の重量w[d]で減らしていきます。ポイの耐久値が0以下になった場合、そのポイではもう金魚をすくうことができないので、内側のループを抜けます。また、ポイで金魚をすくった場合、すくった金魚の数cを1増やし、金魚の重量wとポイのインデックスdを1増やします。
外側のループでは、ポイの数Nが0になるか、金魚の重量wのインデックスdが金魚の数Mに達するまでループを繰り返します。最終的にすくった金魚の数cを出力します。
'''

# C067　数字の調査
# utf-8
def binary_digit_check(N, X, k):
    # Xを2進数に変換し、0bを除いた2進数文字列に変換する
    binary = bin(X)[2:]
    # binaryの先頭に0を追加して、指定された桁が存在しない場合に備える
    binary = '0' + binary

    result = []
    for ki in k:
        # 指定された桁の値を判定し、0ならFalse、1ならTrueを追加する
        result.append(binary[-int(ki)] == '1')

    return result

# 入力の受け取り
N, X = map(int, input().split())
k = [int(input()) for _ in range(N)]

# プログラムの実行
result = binary_digit_check(N, X, k)

# 結果の出力
for res in result:
    print(int(res))

# C068　秘密の手紙
# utf-8
def decrypt(ciphertext, N):
    # アルファベットのリストを作成
    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    # 復号結果を格納する変数を初期化
    plaintext = ''
    # 暗号文の文字を順番に処理
    for i in range(len(ciphertext)):
        # 文字が奇数番目の場合
        if i % 2 == 0:
            # アルファベットを逆方向に N 文字ずらす
            shifted_char = alphabet[(alphabet.index(ciphertext[i]) - N) % 26]
        # 文字が偶数番目の場合
        else:
            # アルファベットを順方向に N 文字ずらす
            shifted_char = alphabet[(alphabet.index(ciphertext[i]) + N) % 26]
        # 復号結果に追加
        plaintext += shifted_char
    return plaintext

# ずらした文字数 N を入力から取得
N = int(input())
# 暗号文を入力から取得
ciphertext = input().rstrip()
# 元に戻された文字列を取得
plaintext = decrypt(ciphertext, N)
# 復号結果を出力
print(plaintext)

# C069　お祭りの日付
# utf-8
def is_leap_year(year):
    if year % 4 == 1:
        return True
    else:
        return False

def days_in_month(month, leap_year=False):
    if month % 2 == 0:
        return 15
    else:
        return 13

def days_until_next_paiza_festival(y, m, d, a, b):
    if m % 2 == 0:
        c = 15 - d
    else:
        c = 13 - d
    m += 1

    while not is_leap_year(y):
        c += days_in_month(m)
        m += 1
        if m == 14:
            m = 1
            y += 1

    for i in range(1, a):
        c += days_in_month(i)

    if a % 2 == 0:
        c += b
    else:
        c += b

    return c

# 1行目の入力を受け取る
y, m, d = map(int, input().split())

# 2行目の入力を受け取る
a, b = map(int, input().split())

# 入力値の範囲チェック
if not (1 <= y <= 10000) or not (1 <= m <= 13) or not (1 <= d <= days_in_month(m)) or not (1 <= a <= 13) or not (1 <= b <= days_in_month(a)):
    print("入力値が範囲外です。")
elif y % 4 == 1:
    print("入力値 y は 4 で割った余りが 1 になることはありません。")
else:
    # パイーザ祭の開催日までの日数を計算
    days = days_until_next_paiza_festival(y, m, d, a, b)

    # 結果の出力
    print(days, end="\n")

# C070　簡易カードゲーム
# utf-8
N = int(input())
for i in range(N):
    k = input()
    pair = 0
    for j in range(9):
        kazu = k.count(str(j+1))
        if kazu == 4:
            print('Four Card')
            pair = -1
            break
        elif kazu == 3:
            print('Three Card')
            pair = -1
            break
        elif kazu == 2:
            pair += 1
    if pair == 2:
        print('Two Pair')
    elif pair == 1:
        print('One Pair')
    elif pair == 0:
        print('No Pair')
--------------------------------------------- C071　※欠番 ◆
# C071　直角三角形
'''
直角三角形の二辺の長さについて　Mより小さい底辺, Nより小さい高さを持つ
全ての辺の長さは整数
斜辺も整数である直角三角形の個数を求める
例: 10 10の時 4   (10-8-6,10-6-8,5-3-4,5-4-3の4組)
例: 20 20の時 12  (13-12-5, 13-5-12, 10-8-6, 10-6-8, 5-3-4, 5-4-3, 17-15-8, 17-8-15, 
15-12-9, 15-9-12, 20-16-12, 20-12-16の12組)
'''

def count_right_angle_triangles(M, N):
    def pm(a, b):
        return min(M // a, N // b) + min(M // b, N // a)

    count = 0
    count += pm(3, 4)
    count += pm(5, 12)
    count += pm(7, 24)
    count += pm(8, 15)
    count += pm(20, 21)

    return count

# 入力を取得
M, N = map(int, input().split())

# 直角三角形の個数を計算
count = count_right_angle_triangles(M - 1, N - 1)  # M, N を修正

# 結果を出力
print(count)

# C072　モンスターの進化
# utf-8
ATK, DEF, AGI = (int(x) for x in input().split())
N = int(input())
List = []
for i in range(N):
    List.append(input().split())

flag = 0
for l in List:
    name = l[0]
    MINATK, MAXATK, MINDEF, MAXDEF, MINAGI, MAXAGI = int(
        l[1]), int(l[2]), int(l[3]), int(l[4]), int(l[5]), int(l[6])
    if MINATK <= ATK and ATK <= MAXATK and MINDEF <= DEF and DEF <= MAXDEF and MINAGI <= AGI and AGI <= MAXAGI:
        flag = 1
        print(name)

if flag == 0:
    print('no evolution')
    
# C073　うさぎとかめ
# utf-8
# 入力を受け取る
L = int(input())    # 2匹が走る距離を表す整数 L
u, a, b = map(int, input().split())    # うさぎの速さと休憩のハンデを表す整数 u, a, b
v = int(input())    # かめの速さを表す整数 v

# うさぎとかめの総走行時間を計算
c = (L * u) + (((L // a) - ((L % a) == 0)) * b)    # うさぎの総走行時間
d = L * v    # かめの総走行時間

# 総走行時間を比較して結果を出力
if c < d:
    print('USAGI')    # うさぎが先にゴールする場合
elif c > d:
    print('KAME')    # かめが先にゴールする場合
else:
    print('DRAW')    # 引き分けの場合
'''
与えられた条件に基づいて、うさぎとかめが競走し、どちらが先にゴールするかを判定するプログラムです。
まず、input() 関数を使って、入力値を受け取ります。L は競走する距離を表し、u、a、b、v はそれぞれうさぎとかめの速さや休憩のハンデを表します。
次に、うさぎとかめの総走行時間を計算します。うさぎの総走行時間 c は、L に u を掛けた値に、L を a で割った商に b を掛けた値を加えたものです。
この計算により、うさぎが L km 走るごとに b 分の休憩を取ることが考慮されます。
かめの総走行時間 d は、L に v を掛けた値です。
そして、if 文を使って、うさぎとかめの総走行時間を比較し、結果を出力します。
c が d より小さい場合は、うさぎが先にゴールすると判定されて 'USAGI' が出力されます。c が d より大きい場合は、かめが先にゴールすると判定されて 'KAME' が出力されます。
c と d が等しい場合は、引き分けとして 'DRAW' が出力されます。
このように、与えられた条件を考慮して、うさぎとかめの総走行時間を比較することで、どちらが先にゴールするかを判定しています。
'''
# C074　文章サイズ変更
# utf-8
# 入力を受け取る
H, W, X = map(int, input().split())
s = []
for i in range(H):
    s.append(input().rstrip())

# 文字列を結合して一つの文字列にする
s = ''.join(s)

# 文字列を X 文字ごとに分割し、リストに格納する
s_list = [s[i:i+X] for i in range(0, len(s), X)]

# 出力文字列を作成する
output = ''
for i in range(len(s_list)):
    output += s_list[i] + '\n'

# 最終的な出力文字列を出力する
print(output.rstrip())
'''
入力された文字列を改行文字を除いて一つの文字列に結合します。
文字列を X 文字ごとに分割し、リストに格納します。
リストをループで回しながら、各要素に改行文字を追加し、出力文字列を作成します。
最終的な出力文字列を出力します。
'''
    
# C075　ポイント払い
# utf-8
# 入力を受け取る
N, M = map(int, input().split(' '))
fare_list = list()

# バスの運賃を入力してリストに格納
for i in range(M):
    fare = int(input())
    fare_list.append(fare)

point = 0
for fare in fare_list:
    if point >= fare:
        point -= fare
    else:
        N -= fare
        point += fare * 0.1

    # カード残高とポイントを出力
    print(N, int(point))
    
# C076　給与の計算
# utf-8
x,y,z = map(int, input().split())
n=int(input())
ans=0
for i in range(n):
    s,e=map(int, input().split())
    t=e-s
    s1,e1=0,0
    if 9<=s<17:
        s1=s
    elif s<9 and e>9:
        s1=9
    if 9<e<=17 and e>s:
        e1=e
    elif e>17 and s<17:
        e1=17
    t1=e1-s1
    s1,e1=0,0
    if 17<=s<22:
        s1=s
    elif s<17 and e>17:
        s1=17
    if 17<e<=22 and e>s:
        e1=e
    elif e>22 and s<22:
        e1=22
    t2=e1-s1
    ans=ans+(t1)*x + (t2)*y + (t-t1-t2)*z
print(ans)
'''
与えられた通常の時給、夜の時給、深夜の時給、および出勤日数に基づいて、労働時間に応じた給料の合計金額を計算するものです。
まず、入力値を取得します。通常の時給、夜の時給、深夜の時給は整数として取得し、出勤日数は整数として取得します。また、出勤日数分の出勤時刻と退勤時刻をリストとして取得します。
次に、1 時間単位の労働時間を計算するための関数 calculate_work_hours を定義します。
この関数は、出勤時刻と退勤時刻を受け取り、労働時間を計算します。
具体的には、出勤時刻と退勤時刻がそれぞれ 17 時以降にある場合は出勤時刻と退勤時刻の差を、出勤時刻が 17 時以降で退勤時刻が 17 時以前の場合は出勤時刻から 17 時までの時間を、
出勤時刻が 17 時以前で退勤時刻が 17 時以降の場合は退勤時刻から 17 時までの時間を、それ以外の場合は労働時間を 0 時間として返します。
その後、合計給料を初期化します。
出勤日数分のループを行い、各日の労働時間を calculate_work_hours 関数を呼び出して計算します。
労働時間が 8 時間であれば通常の時給を適用し、それ以外の場合は夜の時給と深夜の時給を適用して合計給料に加算します。
最後に、合計給料を出力します。
'''

# C077　レポートの評価
def evaluate_report(k, n, submissions):
    scores = []
    for i in range(k):
        d_i, a_i = submissions[i]
        if d_i == 0:
            score = (a_i * 100 // n)
        elif d_i < 0:
            score = (a_i * 100 // n)
        elif d_i <= 9:
            score = (0.8 * a_i * 100 // n)
        else:
            score = 0

        scores.append(score)

    results = []
    for score in scores:
        if score >= 80:
            results.append('A')
        elif score >= 70:
            results.append('B')
        elif score >= 60:
            results.append('C')
        else:
            results.append('D')

    return results

# 入力の受け取り
k, n = map(int, input().split())
submissions = []
for i in range(k):
    d_i, a_i = map(int, input().split())
    submissions.append([d_i, a_i])

# レポートの評価を計算
results = evaluate_report(k, n, submissions)

# 結果を出力
for result in results:
    print(result)

# C078　株の売買
# utf-8
# 入力値の取得
N, c1, c2 = map(int, input().split())
prices = []
for _ in range(N):
    prices.append(int(input()))

# 初期設定
stocks = 0
total_profit = 0

# N日間の売買ルールに従って処理
for i in range(N):
    # 株価がc1円以下の場合、1株買う
    if prices[i] <= c1:
        stocks += 1
    # 株価がc2円以上の場合、持ち株をすべて売る
    elif prices[i] >= c2:
        total_profit += stocks * prices[i]
        stocks = 0
    # 株価がc1円とc2円の間の場合は何もしない
    # N日目には、持ち株をすべて売る
    elif i == N - 1:
        total_profit += stocks * prices[i]
        stocks = 0

# 残った持ち株を売った後の損益を計算
total_profit -= stocks * c1

# 結果を出力
print(total_profit)

# C079　カードを集める
# utf-8
# 入力の受け取り
N, M = map(int, input().split()) # N: カードの枚数, M: カードの種類数
cards = set() # 開封したカードの種類を格納するset

# カードを開封して全種類が揃った回数をカウント
for i in range(N):
    card = int(input()) # カード番号を受け取る
    cards.add(card) # カードをsetに追加
    if len(cards) == M: # カードの種類数が全種類になったらループを抜ける
        print(i + 1) # 全種類が揃った回数を出力
        exit()

# カードを全て開封しても全種類が揃わなかった場合はunluckyを出力
print("unlucky")

# C080　ボタンを押すゲーム
# utf-8
# 入力を受け取る
N, Y = map(int, input().split())
M = int(input())
log = list(map(int, input().split()))

# 正しいボタンを押した回数をカウントする変数
correct_count = 0
# 誤ったボタンを押した回数をカウントする変数
wrong_count = 0
# 直前に押されたボタンの番号を保持する変数
prev_button = 1

# 操作ログを順に処理する
for button in log:
    # ボタンが正しい場合
    if button == prev_button:
        correct_count += 1
    # ボタンが誤った場合
    else:
        wrong_count += 1
    prev_button = button

# スコアの計算
score = correct_count * 1000

# 誤ったボタンを押した回数がゲームオーバーの回数以上の場合、スコアを-1にする
if wrong_count >= Y:
    score = -1

# スコアの出力
print(score)

--------------------------------------------- C081　※欠番 ◆
# C081　靴下の整理
# utf-8
# 靴下の数を取得
N = int(input())

# 靴下の情報を辞書に格納
socks = {}
for i in range(N):
    t, d = input().split()
    key = t  # 種類のみをキーとする
    if key in socks:
        socks[key].append(d)  # 左右の情報をリストとして追加
    else:
        socks[key] = [d]  # 新しいキーを作成して左右の情報をリストとして格納

# 同じ種類の靴下で左右が揃っているペアの数を計算
pairs = 0
for key in socks:
    # 同じ種類の靴下が2つ以上ある場合、左右が揃っているペアとしてカウント
    if len(socks[key]) >= 2 and 'L' in socks[key] and 'R' in socks[key]:
        pairs += min(socks[key].count('L'), socks[key].count('R'))

# 結果を出力
print(pairs)
'''
# 靴下の数を取得
N = int(input())

# 靴下の情報を辞書に格納
socks = {}
for i in range(N):
    t, d = input().split()
    key = t  # 種類のみをキーとする
    if key in socks:
        socks[key].append(d)  # 左右の情報をリストとして追加
    else:
        socks[key] = [d]  # 新しいキーを作成して左右の情報をリストとして格納

# 同じ種類の靴下で左右が揃っているペアの数を計算
pairs = 0
for key in socks:
    # 同じ種類の靴下が2つ以上ある場合、左右が揃っているペアとしてカウント
    if len(socks[key]) >= 2 and 'L' in socks[key] and 'R' in socks[key]:
        pairs += min(socks[key].count('L'), socks[key].count('R'))

# 結果を出力
print(pairs)

'''

# C082　テストの赤点
# utf-8
def count_red_points(X, Y, scores):
    # 各生徒の赤点科目の数を格納するリスト
    red_points = []

    # 各生徒の赤点科目の数を計算
    for i in range(X):
        count = 0
        for j in range(X):
            if i != j:
                # i番目の生徒の点数がj番目の生徒よりも低い場合にカウント
                if scores[i][0] <= scores[j][0] and scores[i][1] <= scores[j][1] and scores[i][2] <= scores[j][2]:
                    count += 1
        red_points.append(count + 1)  # 下から1位なので1を足す

    return red_points


# 入力を受け取る
X, Y = map(int, input().split())

# 入力値のチェック
if not (2 <= X <= 100):
    print("Error: 2 ≦ X ≦ 100 の条件を満たしていません。")
    exit(1)
if not (1 <= Y <= X):
    print("Error: 1 ≦ Y ≦ X の条件を満たしていません。")
    exit(1)

scores = []
for i in range(X):
    E, J, M = map(int, input().split())
    if not (0 <= E <= 100 and 0 <= J <= 100 and 0 <= M <= 100):
        print("Error: 0 ≦ E_i, J_i, M_i ≦ 100 の条件を満たしていません。")
        exit(1)
    scores.append((E, J, M))

# 赤点科目の数を計算
red_points = count_red_points(X, Y, scores)

# 結果を出力
for rp in red_points:
    print(rp)
'''
まず、XとYの値が条件を満たしているかをチェックしています。
Xは2以上100以下である必要があり、Yは1以上X以下である必要があります。
もし条件を満たしていない場合には、エラーメッセージを出力し、exit(1)によってプログラムを終了しています。
次に、scoresというリストに生徒の点数をタプル(E, J, M)の形で格納しています。
そして、各生徒の赤点科目の数を計算するためのcount_red_points()関数を呼び出しています。
count_red_points()関数では、scoresリストから生徒の点数を取り出し、各生徒について他の生徒と比較して赤点科目の数を数えています。
条件を満たす場合には、カウントをインクリメントしています。最終的に、赤点科目の数を格納したリストred_pointsを返します。
最後に、red_pointsリストの各要素を出力しています。
このように修正済みのコードでは、入力値が問題の条件を満たしているかをチェックして、
満たしていない場合にはエラーメッセージを出力し、プログラムを終了するようになっています。
これにより、正しい条件下でのみプログラムが実行されるようになります。
'''

# C083　売上の発表
# utf-8
# 入力の受け取り
N, R = map(int, input().split())  # N, Rを受け取る
sales = []  # 売上データを格納するリスト
for i in range(N):
    a = int(input())  # 売上データを受け取る
    sales.append(a)

# 最大売上データの計算
max_sales = max(sales)

# 棒グラフの生成
for i in range(N):
    bar_length = sales[i] // R  # 棒の長さを計算
    bar = '*' * bar_length + '.' * (max_sales // R - bar_length)  # "*"と"."を組み合わせて棒グラフを生成
    print(f"{i + 1}:{bar}")  # 棒グラフを出力
'''
まず、入力として N と R を受け取ります。N は売上データの個数を表し、R はデータの表示単位を表します。
map() 関数を使って入力された値をスペースで区切って int 型に変換して取得します。
また、sales という空のリストを作成し、売上データをそのリストに追加します。
sales リストの中から最大の売上データを max() 関数を使って計算し、max_sales という変数に格納します。
for ループを使って売上データの個数 N 回分繰り返します。各期の売上データを sales リストから取得し、
R で割って bar_length という変数に格納します。これは、その期の棒グラフの長さを表します。
次に、'*' と '.' を組み合わせて、棒グラフを生成します。'*' の数は bar_length であり、
残りのスペースを '.' で埋めるために、max_sales // R - bar_length の数だけ '.' を並べます。
最後に、print() 関数を使って、期と棒グラフを出力します。f-string を使って、期を i + 1 で表示し、
棒グラフを bar で表示します。
以上の処理を通じて、期待する出力の形式で売上の棒グラフを生成し、出力することができます。
'''

# C084　枠で囲む
# utf-8
# 入力を受け取る
S = input().rstrip()

# 枠で囲んで装飾した文字列を生成
decorated_string = "+" * (len(S) + 2) + "\n"
decorated_string += "+" + S + "+" + "\n"
decorated_string += "+" * (len(S) + 2) + "\n"

# 結果を出力
print(decorated_string, end='')

# C085　壊れかけのキーボード
# utf-8
# 入力を受け取る
t = list(map(int, input().split()))
S = input()

# 出力文字列を初期化
output_str = ""

# 入力された文字列を一文字ずつ処理
for char in S:
    # 文字に対応するキーの耐久度を取得
    durability = t[ord(char) - ord('a')]
    
    # キーの耐久度を減らす
    durability -= 1
    
    # キーの耐久度が0以上の場合、出力文字列に追加
    if durability >= 0:
        output_str += char
        
    # キーの耐久度を更新
    t[ord(char) - ord('a')] = durability

# 出力文字列を表示
print(output_str)

# C086　ハンドルネームの生成
# utf-8
# 名前を入力
S = input().rstrip()

# 母音を除去して子音のみを連結して生成
handle_name = "".join(c for c in S if c not in "aeiouAEIOU")

# ハンドルネームを出力
print(handle_name)

# C087　数字の規則
# utf-8
def is_palindrome(n):
    # 数字が回文数かどうかを判定する関数
    s = str(n)
    return s == s[::-1]

def reverse_and_add(n):
    # 規則に従って数字を反転し足し算を行う関数
    return n + int(str(n)[::-1])

# 入力を受け取る
N = int(input())

while True:
    # 規則に従って計算を繰り返し、回文数が出現するまで続ける
    N = reverse_and_add(N)
    if is_palindrome(N):
        print(N)
        break
'''
この実装では、is_palindrome関数で与えられた数字が回文数かどうかを判定し、reverse_and_add関数で数字を反転し足し算を行います。
入力された数字に対してこれらの関数を繰り返し適用し、最初に回文数が出現したらそれを出力して終了します。
'''

# C088　RPGでお買い物
# utf-8
# 道具の個数を取得
N = int(input())

# 道具の単価を取得
prices = list(map(int, input().split()))

# 初期の所持金と注文回数を取得
T, Q = map(int, input().split())

# 注文履歴を取得
orders = []
for _ in range(Q):
    order = list(map(int, input().split()))
    orders.append(order)

# 残金を計算
remaining_money = T
for order in orders:
    item_idx = order[0] - 1
    item_price = prices[item_idx]
    item_quantity = order[1]
    total_cost = item_price * item_quantity
    if remaining_money >= total_cost:
        remaining_money -= total_cost

# 残金を出力
print(remaining_money)

'''
与えられた入力に基づいて、所持金を管理し、注文を処理して最終的な所持金を計算するプログラムです。
まず、入力された情報を適切に変数に格納します。例えば、道具の個数を表す整数Nは N に、各道具の単価を表す整数のリストは prices に格納されます。
また、最初の所持金を表す整数Tは T に、注文回数を表す整数Qは Q に格納されます。
次に、各注文の情報を処理して所持金を更新していきます。Q 回のループを回して、各注文の情報を取得し、注文の個数を所持金と比較して、
所持金が足りない場合は注文をキャンセルします。
最終的に、所持金の値を出力してプログラムの実行を終了します。
具体的な処理の流れは以下のようになります。

入力された情報を変数に格納する。
Q 回のループを回して、各注文の情報を取得する。
注文の個数と道具の単価を掛けて、所持金と比較する。
所持金が足りない場合は注文をキャンセルし、足りている場合は所持金を更新する。
全ての注文を処理し終えた後の所持金の値を出力する。
'''

# C089　ストラックアウト
# utf-8
# 入力を受け取る
H, W = map(int, input().split())
s = [input().rstrip() for _ in range(H)]
p = [list(map(int, input().split())) for _ in range(H)]

# 撃ち抜かれたパネルの得点を合計する
total_score = 0
for i in range(H):
    for j in range(W):
        if s[i][j] == "o":  # "o"は撃ち抜かれた状態を表す
            total_score += p[i][j]

# 結果を出力
print(total_score)
'''
入力されたHとWに基づいて、sとpのリストを作成します。
sはゲーム終了時のパネルの状態を示す文字列のリストで、pは各パネルの得点を示す整数のリストです。
それぞれのi行j列のパネルについて、sが"o"であれば撃ち抜かれたので、対応するpの得点をtotal_scoreに加算します。
最終的にtotal_scoreを出力します。
'''

# C090　黒電話
# utf-8
def calculate_dial_distance(phone_number):
    pho_dic = {"0": 12, "1": 3, "2": 4, "3": 5, "4": 6,
               "5": 7, "6": 8, "7": 9, "8": 10, "9": 11}
    dial_distance = 0
    for digit in phone_number:
        if digit.isdigit():
            dial_distance += pho_dic[digit]
    return dial_distance * 2

# 電話番号の入力
S = input().strip().replace("-", "")

# ダイヤルが回る必要のある総距離を計算
dial_distance = calculate_dial_distance(S)

# 総距離を整数で出力
print(dial_distance)
'''
def calculate_dial_distance(phone_number):
電話番号の文字列を引数として受け取り、ダイヤルが回る必要のある総距離を計算する関数です。

pho_dic = {"0": 12, "1": 3, "2": 4, "3": 5, "4": 6, "5": 7, "6": 8, "7": 9, "8": 10, "9": 11}:
数字に対するダイヤル回転距離の辞書を定義します。例えば、数字 "0" の場合は 12 が対応しています。

dial_distance = 0:
ダイヤルが回る必要のある総距離を初期化します。

for digit in phone_number::
電話番号の各文字を順に取り出してループします。

if digit.isdigit(): dial_distance += pho_dic[digit]:
文字が数字であれば、対応するダイヤル回転距離を dial_distance に加算します。

return dial_distance * 2:
ダイヤルが回る必要のある総距離を計算し、その値を返します。

S = input().strip().replace("-", ""):
入力された電話番号を受け取り、不要な空白文字を削除し、ハイフンを除去して S に代入します。

dial_distance = calculate_dial_distance(S):
S を引数として calculate_dial_distance 関数を呼び出し、ダイヤルが回る必要のある総距離を計算し、dial_distance に代入します。

print(dial_distance):
計算されたダイヤル回転距離を整数として出力します。
'''
--------------------------------------------- C091　※欠番 ◆
# C091　みかんの仕分け
# utf-8
def classify_oranges(weight, num_oranges, oranges):
    # 仕分け先の重さを格納するリスト
    class_weights = []

    # 仕分け先の重さを計算してリストに追加
    for i in range(1, num_oranges + 1):
        class_weight = weight * i
        class_weights.append(class_weight)

    # 各みかんの仕分け先の重さを計算して出力
    for orange in oranges:
        if orange <= weight:
            print(weight)
        elif orange % weight < weight / 2:
            print(orange // weight * weight)
        else:
            print((orange // weight + 1) * weight)


# 入力の受け取り
N, M = map(int, input().split())
weight = N
num_oranges = M
oranges = [int(input()) for i in range(num_oranges)]

# みかんを仕分ける
classify_oranges(weight, num_oranges, oranges)

# C092　工場のベルトコンベア
# utf-8
nab_list = list(input().split())
s_N = input()
s_A = input()
s_B = input()

N = int(nab_list[0])
A = int(nab_list[1])
B = int(nab_list[2])

for n in range(N):
    if A > 0 and s_A[0] == s_N[n]:
        s_A = s_A[1:]
        A -= 1

    if B > 0 and s_B[0] == s_N[n]:
        s_B = s_B[1:]
        B -= 1

print(A, B)

# C093　下桁ルール
# utf-8
# ボブの期末テストの点数とアリスの期末テストの点数を入力から取得
X, Y = input().split()

# 各位の数を足した数の一の位を計算
bob_digit_sum = sum(map(int, str(int(X)))) % 10
alice_digit_sum = sum(map(int, str(int(Y)))) % 10

# 勝敗を判定
if bob_digit_sum > alice_digit_sum:
    print("Bob")
elif bob_digit_sum < alice_digit_sum:
    print("Alice")
else:
    print("Draw")

# C094　国民の税金
# utf-8
def calculate_tax(income):
    if income <= 100000:
        return 0  # 0 ~ 100,000に対しては税金がかかりません
    elif income <= 750000:
        return int((income - 100000) * 0.1)  # 100,001 ~ 750,000に対しては10%の税率がかかります
    elif income <= 1500000:
        return int((income - 750000) * 0.2 + 650000 * 0.1)  # 750,001 ~ 1500,000に対しては20%の税率がかかります
    else:
        return int((income - 1500000) * 0.4 + 750000 * 0.2 + 650000 * 0.1)  # それ以上に対しては40%の税率がかかります

# 入力の受け取り
N = int(input())  # PAIZA 国民の人数を受け取る
incomes = []  # 各人の所得を格納するリストを初期化

# 各人の所得を受け取り、リストに追加
for i in range(N):
    x_i = int(input())  # i 番目の人の所得を受け取る
    incomes.append(x_i)

# 各人の所得に対して税金を計算し、合計を計算
total_tax = sum(calculate_tax(income) for income in incomes)

# 税金の合計を出力
print(total_tax)

# C095　合言葉
# utf-8
# 入力を取得
s = input().rstrip()
t = input().rstrip()

# 文字列tを並び替えてsができるかをチェックし、一致する場合はNOを出力、それ以外はYESを出力
if sorted(s) == sorted(t) and s != t:
    print("YES")
else:
    print("NO")
'''
入力された文字列sとtを取得し、末尾の改行文字を除去します。
sorted() 関数を使って、文字列sとtをソートします。ソートされた結果が同じであり、かつsとtが一致していない場合、
tを並び替えてsができると判定し "YES" を出力します。
上記の条件に該当しない場合は、tがsと一致するか、tを並び替えてsができない場合であるため、 "NO" を出力します。
'''

# C095　バスの時間(番号ダブり)
# utf-8
# 入力の読み込み
N, K = map(int, input().split())
bus_times = []
for _ in range(N):
    bus_time = int(input())
    bus_times.append(bus_time)

# K 分後に最も近いバスの時間を求める
nearest_buses = []
min_diff = float('inf')

for time in bus_times:
    diff = abs(K - time)
    if diff < min_diff:
        min_diff = diff
        nearest_buses = [time]
    elif diff == min_diff:
        nearest_buses.append(time)

# 最も近いバスの時間を時間の昇順でソート
nearest_buses.sort()

# 結果の出力
for bus in nearest_buses:
    print(bus)
'''
入力の読み込み: 最初に N と K を入力として読み込みます。N はバスの時間帯の数を表し、K は K 分後を表します。
次に、N 回のループでバスの時間帯を入力として読み込み、bus_times というリストに格納しています。
K 分後に最も近いバスの時間を求める: bus_times に格納されたバスの時間帯ごとに、K 分後に最も近い時間を計算します。
これには、min_diff という変数を用意し、初期値を正の無限大に設定します。
次に、bus_times の各要素 time について、abs(K - time) を計算し、K との差分を絶対値で求めます。この差分を diff として取得し、
diff が min_diff より小さければ、min_diff を diff に更新し、nearest_buses を time で初期化します。
また、diff が min_diff と等しい場合には、nearest_buses に time を追加します。
最も近いバスの時間を時間の昇順でソート: 最も近いバスの時間を格納した nearest_buses を時間の昇順でソートします。これには sort() メソッドを使用しています。
結果の出力: ソートされた nearest_buses の各要素を順に出力します。
これにより、K 分後に最も近いバスの時間を 2 行で時間の昇順に出力することができます。
以上の手順を経て、このコードは K 分後に最も近いバスの時間を求め、時間の昇順に出力する処理を行っています。
'''
# C096　夏休み
# utf-8
# 入力の読み込み
N = int(input())  # メンバーの人数
s_e_list = [list(map(int, input().split())) for _ in range(N)]  # メンバーの休みを取れる期間の入力

# 休みの共通日を探す
common_days = set(range(1, 32))  # 1～31の整数を集合として初期化
for s, e in s_e_list:
    # 各メンバーの休みを取れる期間を集合に変換し、共通日を求める
    days = set(range(s, e + 1))
    common_days &= days

# 出力
if common_days:
    print("OK")
else:
    print("NG")
'''
この問題は、複数のメンバーの休みの期間を比較し、共通する日があるかどうかを判定する問題です。
まず、入力された休みの期間をそれぞれのメンバーごとに集合に変換します。
集合は重複を許さず、要素の順序は関係ありません。これにより、各メンバーの休みの期間を簡単に比較できるようになります。
次に、各メンバーの休みの期間の共通部分を求めるために、集合の積集合を計算します。
集合の積集合は、共通する要素のみを残す演算です。ここで、集合の要素は日付を表しており、
共通する日付がある場合はその日付が残ります。最終的に、共通する日付があるかどうかを判定します。
共通する日付があれば "OK"、なければ "NG" を出力します。
この解答は、入力された休みの期間を集合として扱い、集合の演算を用いて共通する日付を効率的に求めています。
'''
# C097　プレゼント応募企画の実施
# utf-8
def present_lottery(N, X, Y):
    result = []
    for i in range(1, N+1):
        if i % X == 0 and i % Y == 0:
            result.append("AB")
        elif i % X == 0:
            result.append("A")
        elif i % Y == 0:
            result.append("B")
        else:
            result.append("N")
    return result

# 入力の読み込み
N, X, Y = map(int, input().split())

# 当選情報の計算
result = present_lottery(N, X, Y)

# 当選情報の出力
for res in result:
    print(res)

# C098　多重パス回し
# utf-8
# 人数Nの入力
N = int(input())

# 人ごとの最初のボールの個数の入力
s = []
for i in range(N):
    s_i = int(input())
    s.append(s_i)

# パス回しの情報の数Mの入力
M = int(input())

# パス回しの情報の入力と処理
for i in range(M):
    a_i, b_i, x_i = map(int, input().split())
    # パスする相手が持っているボールの個数を計算
    pass_balls = min(s[a_i-1], x_i)
    # ボールをパス
    s[a_i-1] -= pass_balls
    s[b_i-1] += pass_balls

# 最終的なボールの個数を出力
for i in range(N):
    print(s[i])
'''
まず、最初に人数Nを入力し、各人の最初のボールの個数をリストsに格納します。
次に、パス回しの情報の数Mを入力し、各パス回しの情報を処理していきます。
パス回しの情報は、a_i, b_i, x_iの3つの整数で与えられます。
a_iはボールをパスする人のインデックス（1からNまでの整数）、
b_iはボールを受け取る人のインデックス（1からNまでの整数）、x_iはパスするボールの個数を表します。
パスする相手が持っているボールの個数は、min(s[a_i-1], x_i)で計算されます。
これは、パスする人a_iが持っているボールの個数s[a_i-1]と、パスするボールの個数x_iのうち、小さい方を取得しています。
これは、パスする相手に渡すことができる最大のボールの個数を計算するためです。
その後、s[a_i-1]からpass_ballsを減算し、s[b_i-1]にpass_ballsを加算することで、ボールのパスをシミュレーションしています。
最終的に、各人の持っているボールの個数がリストsに格納されているので、それを順番に出力することで、最終的なボールの個数を求めることができます。
'''

# C099　折り紙の貼り合わせ
# utf-8
def calculate_banner_area(N, D, overlaps):
    total_area = D * D  # 最初の折り紙の面積

    for i in range(1, N):
        overlap = overlaps[i - 1]  # i番目の折り紙の重なり具合
        width = D - overlap  # 垂れ幕の横幅
        height = D  # 垂れ幕の縦幅
        area = width * height  # 折り紙の面積
        total_area += area  # 面積を合計

    return total_area

# 入力の取得
N, D = map(int, input().split())  # N: 折り紙の枚数、D: 折り紙の初期の辺の長さ
overlaps = [int(input()) for _ in range(N - 1)]  # 折り紙の重なり具合の入力

# 垂れ幕の面積の計算
banner_area = calculate_banner_area(N, D, overlaps)

# 結果の出力
print(banner_area)
'''
与えられた入力に対して垂れ幕の面積を計算する関数 calculate_banner_area を定義しています。
この関数では、最初の折り紙の面積を total_area として初期化し、2枚目以降の折り紙については、
直前の折り紙との重なり具合を overlap として取得し、それを用いて垂れ幕の横幅 width を計算しています。
垂れ幕の縦幅は初期の辺の長さ D となります。折り紙の面積は width * height で計算し、
それを total_area に加算していくことで、垂れ幕の面積を計算しています。
最後に、入力を受け取り、垂れ幕の面積を計算して結果を出力しています。
'''

# C100　選曲の方法
# utf-8
def max_songs(N, M, S, songs):
    total_time = M * 60 + S  # 持ち時間を秒に変換
    songs.sort()  # 曲を時間順にソート
    count = 0  # 流すことのできる曲の数をカウントする変数
    for song in songs:
        if total_time >= song[0] * 60 + song[1]:
            total_time -= song[0] * 60 + song[1]
            count += 1
        else:
            break  # 持ち時間を超えたらループを終了
    return count

# 入力の読み込み
N, M, S = map(int, input().split())
songs = []
for i in range(N):
    x, y = map(int, input().split())
    songs.append((x, y))

# 結果の出力
print(max_songs(N, M, S, songs))

--------------------------------------------- C101　※欠番 ◆
# C101　ラッキーデイ ※境界条件がエラー
# utf-8
def count_lucky_days_in_year(X):
    count = 0
    for day in range(1, 365):
        date = str(day).zfill(3)  # 日を3桁の文字列に変換
        if str(X) in date:
            count += 1
    return count

# 数字Xの入力
X = input().strip()

# 幸運な日の数を計算
output = count_lucky_days_in_year(X)

# 結果を出力
print(output)
'''
数字Xを標準入力から取得し、1月1日から12月31日までの日数を順番に調べて、
文字列としてのXを含む日をカウントしています。結果は整数値として出力されます。
'''
# C102　行きたいライブのスケジュール
# utf-8
# 入力の取得
M = int(input())  # バンドAのライブ日数
A = [int(input()) for _ in range(M)]  # バンドAのライブ日程のリスト
N = int(input())  # バンドBのライブ日数
B = [int(input()) for _ in range(N)]  # バンドBのライブ日程のリスト

c = 0
l = ['A', 'B']
S = sorted(list(set(A + B)))
R = list()
for i in range(1, 32):
    if i in S:
        if i in A and i in B:
            R.append(l[c % 2])
            c += 1
        else:
            R.append(('B', 'A')[i in A])
    else:
        R.append('x')
print('\n'.join(R))
'''
バンドAのライブ日程をA、バンドBのライブ日程をBとして、AとBの共通日程をSに取得しています。
そして、1から31までの日程に対して以下のルールに従って出力を生成しています。
日程がSに含まれる場合：
日程がAとBの両方に含まれる場合：lリストの順番に従ってAまたはBを出力し、cを更新する。
日程がAのみに含まれる場合：Aを出力する。
日程がBのみに含まれる場合：Bを出力する。
日程がSに含まれない場合：xを出力する。
最終的に、出力を改行で結合して出力しています。
'''
# C103　ロボット芸人
# utf-8
# 入力を取得
N, M = map(int, input().split())
conditions = []
for i in range(M):
    a, b = input().split()
    conditions.append((int(a), b))

# ロボットの動きのシミュレーション
output = []
for i in range(1, N + 1):
    result = ""
    for condition in conditions:
        a = condition[0]
        b = condition[1]
        if i % a == 0:
            result += b + " "
    if result == "":
        output.append(str(i))
    else:
        output.append(result.rstrip())

# 結果を出力
for line in output:
    print(line)
'''
入力された条件に基づいてロボットの動きをシミュレーションし、期待される形式で結果を出力します。
各条件について、ロボットが条件を満たす場合には対応する文字列を、満たさない場合にはそのままの数字を出力します。
'''

# C104　虫食い算
# utf-8
def solve_bug_eaten_equation(a, b):
    al = []
    for x in range(1, 10):
        for y in range(10):
            if (10*x + y) * y == 100*a + 10*x + b:
                al.append([x, y])
    if len(al) == 0:
        return None
    else:
        return al[0]

# 入力を受け取る
a, b = map(int, input().split())

# 問題を解いて結果を出力
result = solve_bug_eaten_equation(a, b)
if result is None:
    print("No")
else:
    print(result[0], result[1])
'''
まず、solve_bug_eaten_equation という関数を定義しています。この関数は、虫食い算の条件を満たす数字のペアを探し、
その結果をリスト al に格納します。具体的には、1 から 9 までの x と 0 から 9 までの y をそれぞれのループで繰り返しながら、
以下の条件を満たす場合に x と y をリスト al に追加しています。

(10 * x + y) * y == 100 * a + 10 * x + b

この条件は、虫食い算の式を数式に置き換えたものであり、左辺が式の左側を、右辺が式の右側を表しています。
この条件を満たす x と y の組が見つかれば、それをリスト al に追加しています。
その後、リスト al の長さを確認し、リストが空であれば "No" を出力し、リストに要素があればリストの最初の要素を出力しています。
これにより、虫食い算の答えとなる数字のペアを出力しています。
最後に、a と b の入力を受け取り、先ほど定義した関数を用いて問題を解いて結果を出力しています。
修正を加えたコードは、与えられた虫食い算の条件を正確に満たし、期待する出力を生成することができます。
'''

# C105　カードのスコア
# utf-8
n = int(input())
cards = list(map(int, input().split()))
cards.sort()

groups = []
current_group = [cards[0]]
for i in range(1, n):
    if cards[i] - current_group[-1] == 1:
        current_group.append(cards[i])
    else:
        groups.append(current_group)
        current_group = [cards[i]]
groups.append(current_group)

total_score = 0
for group in groups:
    total_score += max(group)

print(total_score)
'''
与えられたカードの数字をグループに分け、各グループの最大の数字を合計して総合スコアを求める問題です。
まず、入力されたカードの数字をリストとして取得します。次に、取得したリストを昇順にソートします。
ソートすることで、カードの数字が連続しているかどうかを判定しやすくなります。
次に、1の差で連続しているカードをグループに分けます。ループを使用して、リストの要素を1つずつ見ていきます。
現在見ているカードの数字が前のカードの数字と1の差であれば、同じグループに属すると判定し、現在のグループに追加します。そうでなければ、新しいグループが始まると判定し、現在のグループをgroupsというリストに追加します。最後に、最後のグループをgroupsに追加してループを終了します。
各グループのスコアは、そのグループの最大の数字となります。ループを使用して各グループの最大の数字を取得し、total_scoreという変数に加算していきます。
最後に、total_scoreを出力することで、与えられたカードの総合スコアを求めることができます。
'''
# C106　メダル授与式
# utf-8
# 入力から取得する変数
N = int(input())  # 競技者の人数
scores = list(map(int, input().split()))  # 競技者の点数をリストとして取得

# 出力する結果を格納するリスト
medals = []

# 競技者ごとにメダルの色を判定して medals リストに追加
for i in range(N):
    if scores[i] == max(scores):
        medals.append("G")
    elif scores[i] == sorted(scores, reverse=True)[1]:
        medals.append("S")
    elif scores[i] == sorted(scores, reverse=True)[2]:
        medals.append("B")
    else:
        medals.append("N")

# 結果を出力
for medal in medals:
    print(medal)
'''
入力の受け取り
最初に、input() 関数を使って競技者の人数を表す整数 N を入力から受け取ります
。次に、input() 関数と split() メソッドを組み合わせて、半角スペースで区切られた競技者の点数を一度に取得し、リスト scores として格納します。

メダルの色の判定
次に、for ループを使って、競技者ごとにメダルの色を判定します。scores リストを順番に参照し、
以下の条件に従ってメダルの色を判定し、medals リストに追加していきます。

競技者の点数が最大値であれば、"G" (金メダル)
競技者の点数が2番目に高い値であれば、"S" (銀メダル)
競技者の点数が3番目に高い値であれば、"B" (銅メダル)
上記のいずれにも該当しない場合は、"N" (メダルなし)
結果の出力
for ループを使って medals リストの中身を順番に出力し、競技者ごとのメダルの色を表示します。
'''

# C107　ランクの計算
# utf-8
n, k = map(int, input().split())

# 各馬のN回分の順位を取得
horse_a = [int(input()) for _ in range(n)]
horse_b = [int(input()) for _ in range(n)]
horse_c = [int(input()) for _ in range(n)]

# 連続するK回分の平均値の最小値を求める関数
def calc_min_avg(horse):
    min_avg = float('inf')
    for i in range(n - k + 1):
        avg = sum(horse[i:i+k]) / k
        if avg < min_avg:
            min_avg = avg
    return min_avg

# 各馬の連続するK回分の平均値を計算
avg_a = calc_min_avg(horse_a)
avg_b = calc_min_avg(horse_b)
avg_c = calc_min_avg(horse_c)

# ランクを計算
rank_a = sum(avg_a > avg for avg in [avg_b, avg_c]) + 1
rank_b = sum(avg_b > avg for avg in [avg_a, avg_c]) + 1
rank_c = sum(avg_c > avg for avg in [avg_a, avg_b]) + 1

# ランクが最も小さい馬を出力
if rank_a < rank_b and rank_a < rank_c:
    print(1)
elif rank_b < rank_a and rank_b < rank_c:
    print(2)
else:
    print(3)

'''
この問題は、与えられたデータに対して順位の平均値を求めることが求められているので、
以下のようなアルゴリズムで解くことができます。

各馬の順位を入力として受け取る
1位からK位までの順位の平均値を求める
順位の平均値が最小となる馬を出力する
'''

# C108　観光の計画
# utf-8
N = int(input())
time = []
program=[]
for i in range(N):
    time.append(int(input()))
move_time = [list(map(int, input().split())) for l in range(N)]
# print(time,move_time)


K = int(input())
for i in range(K):
    program.append(int(input()))
# print(K,program)
count = 0
# print(move_time[1][0])
for i in range(K):
    # print('roop',i)
    # print('所要',time[program[i]-1])
    count = count + time[program[i]-1]
    if i+1 <K:
        # print(program[i + 1])
        # print('移動',move_time[program[i]-1][program[i+1]-1])
        count = count + move_time[program[i]-1][program[i+1]-1]

    # print(move_time[program[i]][program[i+1]])
print(count)
'''
まず、観光名所の数 N と各観光名所の滞在時間 time、各観光名所間の移動時間 move_time を入力します。
その後、訪れたい観光名所の数 K と訪れたい観光名所のリスト program を入力します。
最後に、訪れたい観光名所のリスト program を順に処理して、各観光名所に滞在する時間 time[i] を加算します。
ただし、最後の観光名所に到着した場合は移動時間を加算しないため、i+1<K の場合のみ移動時間を加算します。
以上の処理によって、訪れたい観光名所を順に巡るために必要な時間が求められます。
'''

# C109　IDを登録順に並べよう
# utf-8
import re

# ユーザー数を取得
n = int(input())

# ユーザーIDを取得
users = []
for i in range(n):
    users.append(input().rstrip())

# ユーザーIDを早い順にソート
users_sorted = sorted(users, key=lambda u: int(re.findall(r'\d+', u)[0]))

# ソート結果を出力
for user in users_sorted:
    print(user)
'''
splitの引数を空白文字で分割した場合、
'paiza1'は'paiza1'という1つの文字列として取り出されてしまいます。
そこで、空白文字と数字を分ける区切り文字として、正規表現を使うことができます。
以下は正規表現を使ったコード例です。re.findall(r'\d+', u)は文字列uから、数字の列を取り出す正規表現の表現です。
こうすることで、ユーザーIDの数字部分のみを取り出すことができます。
この問題では、与えられたユーザー ID のリストを、登録の早い順に並び替えて出力する必要があります。
与えられたユーザー ID は、「ユーザーネーム + 通し番号」の形式を取っており、通し番号は登録順に振られた番号です。
例えば、paiza さんが 1 番目に登録した場合、ユーザー ID は「paiza1」となります。
この問題を解くためには、与えられたユーザー ID のリストを通し番号の昇順に並び替える必要があります。
そのために、Python の組み込み関数である sorted 関数を使用することができます。
sorted 関数は、第 1 引数にリストを取り、第 2 引数にソートに使用するキーを指定することができます。
キーには、任意の関数を渡すことができます。この問題では、通し番号を昇順に並び替えたいので、キーとして「通し番号」を取り出す関数を指定する必要があります。
具体的には、lambda 関数を使って、ユーザー ID を分割し、通し番号を取り出すことができます。
ユーザー ID は「ユーザーネーム + 通し番号」という形式であるため、スペースを区切り文字として split メソッドを使って分割し、通し番号の部分を取り出します。
このとき、通し番号は文字列であるため、int 関数を使って整数に変換する必要があります。
以上をまとめると、与えられたユーザー ID のリストを次のように並び替えることができます。
このコードは、与えられたユーザー ID のリスト users を、通し番号の昇順に並び替えた結果を users_sorted に格納します。
通し番号の昇順に並び替えるために、キーとして lambda 関数を使用し、ユーザー ID をスペースで分割して最後の要素（通し番号）を整数に変換して指定しています。
'''

# C110　就職活動
# utf-8
N = int(input())
d = [int(input()) for _ in range(N)]

max_count = 0
start = 0
end = 0

current_start = 0
count = 0

for i in range(N):
    if i == 0:
        current_start = d[i]
        count = 1
    else:
        if d[i] == d[i-1] + 1:
            count += 1
        else:
            if count > max_count:
                max_count = count
                start = current_start
                end = d[i-1]
            current_start = d[i]
            count = 1

# 最後の日程のチェック
if count > max_count:
    max_count = count
    start = current_start
    end = d[-1]

print(start, end)
'''
まず、Nとdを入力します。Nは企業説明会の回数、dはそれぞれの説明会の日程を表します。
次に、最長の連続した期間を求めます。最長の期間を保持するために、変数max_count、start、endを初期化します。
また、現在の期間を保持するために、変数current_start、countを初期化します。
最長の連続した期間の初日と終日を出力します。
'''
--------------------------------------------- C111　※欠番 ◆
# C111　ハッシュ関数
# utf-8
N, M = map(int, input().split())
s = input()

# 最後のブロックには 0 を追加して長さ M に調整
last_block = s[(N // M) * M:].ljust(M, '0')
blocks = [s[i:i+M] for i in range(0, N-M+1, M)] + [last_block]

# ブロックに XOR を適用
result = ['0'] * M
for block in blocks:
    result = [str(int(result[i]) ^ int(block[i])) for i in range(M)]

print(''.join(result))
'''
このプログラムは、与えられた文字列を指定された長さのブロックに分割し、各ブロックに XOR 演算を適用して、
最終的に指定された長さのハッシュ値を出力するものです。
まず、文字列をブロック長 M で分割します。最後のブロックは、M で割り切れない場合、"0" を適当な数追加して M の倍数にします。
次に、各ブロックに XOR 演算を適用します。ブロック間の XOR は、左から 1 文字ずつ XOR 適用するものとします。
つまり、ブロック1とブロック2をXORした結果を、その結果とブロック3をXORし、その結果とブロック4をXORしていくことになります。
最後に、最終的なハッシュ値を出力します。ハッシュ値は、XOR 演算を適用した結果の先頭 M 文字を取得することで得られます。
このプログラムでは、入力として与えられる文字列の長さ N と、ブロックの長さ M を変数として扱い、入力例のように動作するように実装されています。
'''

# C112　時差ボケ
# utf-8
n = int(input())
total_time = []
for i in range(n):
    s, f, t = map(int, input().split())
    total_time.append(s + f + 24 - t)
print(min(total_time))
print(max(total_time))

'''
1.入力された日数 n を整数型で受け取ります。
2.各日の旅行時間の合計を表すリスト total_time を初期化します。
3.n 回分、次の処理を繰り返します。
3-1.input() 関数を使ってスペース区切りで整数値を受け取ります。これらをそれぞれ s, f, t とします。
3-2.その日の旅行時間の合計を計算し、total_time リストに追加します。
4.total_time リストの最小値と最大値を min() と max() 関数を使って計算し、それぞれ出力します。

具体的には、各日の旅行時間の合計を計算する際に、以下のように式を書いています。

Copy code
s + f + 24 - t
ここで、s は出発時刻、f は飛行時間、t は到着時刻を表します。この式は、出発時刻 s から飛行時間 f 分だけ時間が経過し、
到着地の現地時間が t 時ということを考慮して、パイザ氏がその日に体験した時間の長さを計算しています。

最後に、求めた最小値と最大値をそれぞれ min() と max() 関数で求めて出力しています。

'''

# C113　一人でスゴロク
# utf-8
N, M = map(int, input().split())

# 各マスの効果を格納するリスト a
a = [input() for _ in range(N-2)]
# スタートとゴール以外のマスは効果を受けないので、効果なしとして追加
a.insert(0, "x")
a.append("goal")

# 駒の位置を表す変数 pos を初期化
pos = 0
for i in range(M):
    # サイコロを振った目を取得
    c = int(input())

    # 駒を進める
    pos += c

    # 駒がゴールに到達した場合
    if pos >= N-1:
        print("goal")
        print(i+1)  # i は 0-indexed なので、1 を足す
        break

    # 駒がスタートに戻ってしまった場合
    if a[pos] == "r":
        pos = 0

    # 駒が効果なしのマスに止まった場合
    elif a[pos] == "x":
        continue

    # 駒がマイナス効果のマスに止まった場合
    elif a[pos] == "-":
        pos -= 1

    # 駒がプラス効果のマスに止まった場合
    elif a[pos] == "+":
        pos += 1

# ゴールに到達しなかった場合は、最後の位置を出力
else:
    print("still")
    print(pos)
'''
まず、 pos 変数を使って現在の駒の位置を表しています。駒は初期状態では 0 番目のマスにあると仮定して、
ゲームが進行するにつれて pos の値が変化していきます。
次に、 for ループを使ってサイコロを振る回数分だけ、サイコロの出目に応じて駒を進めたり戻したりしています。
このループ内で pos を変更することで、駒の位置を更新しています。
そして、 if 文を使って駒がゴールしたかどうかを判定しています。
ゴールしている場合は goal という文字列と、ゴールするまでに振ったサイコロの回数を出力します。
ゴールしていない場合は still という文字列と、最後にいたマスの番号を出力します。
また、 a リストのインデックスを pos - 1 としている理由は、リストのインデックスが 0 から始まるため、
現在の駒の位置に応じてリストのインデックスを調整する必要があるからです。
最後に、 while True ループで pos の値が範囲外になる場合をチェックしています。
このループは pos の値が 0 未満の場合や、N - 1 以上の場合に入ります。
このような場合は、ループ内で pos の値を適切な範囲内に修正するようにしています。
'''

# C114　しりとりの判定
# utf-8
n = int(input())
words = [input() for _ in range(n)]

for i in range(1, n):
    if words[i-1][-1] != words[i][0]:
        print(words[i-1][-1], words[i][0])
        exit()

print("Yes")
'''
【解法】
しりとりが成立するためには、前の単語の末尾の文字と現在の単語の先頭の文字が一致している
必要があります。従って、与えられた単語を順に見ていき、前の単語の末尾の文字と現在の単語の
先頭の文字が異なる場合、その2つの文字を出力して処理を終了します。全ての単語を見終わっても処理が
終了しない場合は、しりとりが成立するので "Yes" を出力します。
【注意点】
入力された単語は英字小文字または英字大文字からなるため、単純に文字列の末尾や先頭の文字を
取り出すことができます。
'''

# C115　渋滞の距離
# utf-8
n, m = map(int, input().split(' '))
traffic = 0

for i in range(n-1):
    distance = int(input())
    if distance <= m:
        traffic += distance

print(traffic)

# C116　あたり棒の検査
# utf-8
N, M = map(int, input().split())
a = list(map(int, input().split()))

for i in range(N - M + 1):
    if sum(a[i:i+M]) == 0:
        print("NG")
        break
else:
    print("OK")
'''
与えられた整数列中に、M 回の「はずれ」が連続する部分列が存在しないかどうかを判定する問題です。
解法としては、与えられた整数列を先頭から順に見ていき、現在注目している部分列の中に「はずれ」が M 個連続している部分列があるかどうかを調べていく方法があります。
具体的には、以下のようなアルゴリズムを考えることができます。
整数列 a を先頭から順に見ていく
現在注目している部分列が M 個の「はずれ」を含むかどうかを調べる
含む場合は、NG を出力して終了する
a の末尾に達した場合は、OK を出力して終了する
まずこの問題では、M個連続で"はずれ"が出ているかどうかを判定する必要があります。
入力された文字列を配列に変換する
配列を先頭からM個の要素を取り出し、その中に"はずれ"があるかどうかをチェックする
取り出した要素を1つずつ右にずらしながら、その中に"はずれ"があるかどうかをチェックする
M個連続で"はずれ"が出ていなければ、"OK"と出力する。そうでなければ、"NG"と出力する。
'''

# C117　大量出店
# utf-8
N, M = map(int, input().split())
A, B, C = map(int, input().split())

# 各店舗の収益を計算してリストに格納する
profits = []
for i in range(N):
    r = int(input())
    revenue = r * C - A - B * M
    profits.append(revenue)

# 利益が負の店舗を閉店させる
closed = 0
for p in profits:
    if p < 0:
        closed += 1

print(closed)

'''
この問題は、各店舗が閉店するかどうかを判断することが問題の主要な部分です。
各店舗で得られる利益は、売り上げの合計にコストを差し引いたものになります。各店舗での利益が負の場合、その店舗は閉店する必要があります。
解決策のアプローチは、各店舗で得られる利益を計算し、負の利益を持つ店舗をカウントすることです。
利益は、売り上げの合計にコストを差し引いたものです。店舗の費用は、建設費用と人件費の合計であり、この金額を開店費用と呼びます。
売り上げの合計は、各店舗で販売されるラーメンの杯数に利益を乗算したものの合計です。
アルゴリズムのステップは以下のようになります。

入力値を読み取ります。
各店舗で得られる利益を計算します。
利益が負の店舗をカウントします。
結果を出力します。
'''
# C118　ダイヤル数
# utf-8
D, N, L = map(int, input().split())
keys = [int(input()) for _ in range(N)]

current = 0  # 現在のダイヤルの位置
count = 0  # 合計目盛り数
for i in range(N):
    # 目的のダイヤル番号まで、どちらの方向に回した方が目盛り数が少ないか計算する
    dist_cw = (keys[i] - current + D) % D
    dist_ccw = (current - keys[i] + D) % D
    count += min(dist_cw, dist_ccw)  # 目盛り数を加算
    current = keys[i]  # 現在のダイヤルの位置を更新
    if count > L:  # 合計目盛り数がLを超えたら壊れるのでNoを出力して終了
        print("No")
        exit()

# 解錠できたらYesを出力
print("Yes")
'''
この問題は、与えられたダイヤル番号を順に合わせていき、ダイヤルを0から回転させることで、
合計の目盛数が L 以下になるように解錠することができるかどうかを判定する問題です。
与えられたダイヤル番号を順に合わせていくことをシミュレートするために、変数 total で現在の目盛数を表します。
total には、ダイヤルを0から回転させた回数も加算されます。total が L 以下である限り、
ダイヤル番号を順に合わせていくことができます。一方、total が L を超えてしまう場合、鍵が壊れてしまうため、
解錠することはできません。
全てのダイヤル番号を順に調べ終わった後、total が L 以下であれば解錠することができ、
total が L を超えていれば解錠することができないため、適切に Yes または No を出力すればよいです。
'''

# C119　お菓子かいたずらか
# utf-8
N, M, K = map(int, input().split())
houses = set(range(1, N+1))
trick_houses = set(int(input()) for _ in range(M))
satisfy_count = 0
unsatisfy_count = 0
for house in houses:
    if house in trick_houses:
        unsatisfy_count += 1
        if unsatisfy_count == K:
            break
    else:
        satisfy_count += 1
        unsatisfy_count = 0
print(satisfy_count)
'''
まず、入力から町の家の数 N、男の子の数 M、K 軒の家で連続して驚かされると泣いて帰る Alice の条件を読み込みます。
そして、range(1, n+1)で全ての家の集合を作り、男の子たちが隠れている家の集合を作ります。
その後、for文で、全ての家について以下の処理を行います。
その家が男の子たちが隠れている家である場合、Alice は驚かされたので、unsatisfy_count を1増やします。
その家が男の子たちが隠れていない家である場合、Alice は驚かされていないので、satisfy_count を1増やします。
unsatisfy_count が K に等しくなった場合、Alice は驚かされた家が K 軒以上であるため泣いて帰ってしまうため、for文を抜けます。
最後に、Alice が貰えるお菓子の個数である satisfy_count を出力します。
'''
# C120　花のリース
# utf-8
N = int(input())  # リースを構成する花の数
S1 = input().strip()  # 1つ目のリースの状態
S2 = input().strip()  # 2つ目のリースの状態

# 1つ目のリースを1つずつ回転させながら、2つ目のリースと比較する
for i in range(N):
    if S1 == S2:
        print("Yes")
        break
    S1 = S1[1:] + S1[0]  # リースを1つ回転させる
else:
    print("No")
'''
この問題は、2つのリースが同じ種類であるかどうかを判定する問題です。リースは複数の種類の花からなり、花が手前を向くように並べられています。
2つのリースが同じ種類であるとは、共に表にした状態で、回転させることで同じ並びにすることができることを言います。
この問題を解くために、まずは1つ目のリースを固定して、回転させながら2つ目のリースと比較します。
リースを回転させる際には、文字列のスライスを用いて先頭の文字を末尾に移動させます。この操作により、リースの配置が回転することになります。
1つ目のリースを固定して比較を行う理由は、2つのリースが同じ種類であるかどうかを判定するために、リースのどこから回転させても同じリースになる場合があるからです。
このような場合、1つ目のリースを固定して、2つ目のリースと比較していくことで、同じ種類であることを判定することができます。
比較が終了した時点で2つのリースが同じ種類であることが分かっていない場合は、「No」と出力します。
'''
--------------------------------------------- C121　※欠番 ◆
# C121　レストランの人気メニュー　

# C122　プレゼントのセール
# C123　節分ロボット
# C124　インターンへの応募
# C125　カードの積
# C126　宿泊費と交通費
# C127　割引キャンペーン
# C128　連分数
# C129
# C130
--------------------------------------------- C131　※欠番 ◆
# C131　
# C132　
# C133　
# C134　
# C135　
# C136　
# C137　
# C138　
# C139
# C140
--------------------------------------------- C141　※欠番 ◆
# C141　
# C142　
# C143　
# C144　
# C145　
# C146　
# C147　
# C148　
# C149
# C150
