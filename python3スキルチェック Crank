※欠番が存在する理由につきましては、出題自体を公開終了した問題が欠番となっております。

--------------------------------------------- C001　※欠番 ◆
# C001 ◆
# C002 ◆
# C003 ◆
# C004 ◆
# C005　アドレス調査
# utf-8
def is_valid_ipv4(ip_string):
    # 入力されたIPアドレスを"."で分割し、各部分が10進数の範囲内にあるかをチェック
    parts = ip_string.split(".")
    if len(parts) != 4:  # IPアドレスが4つの部分で構成されているかをチェック
        return False

    for part in parts:
        if not part.isdigit():  # 数字以外の文字が含まれていないかをチェック
            return False

        num = int(part)
        if num < 0 or num > 255:  # 0から255の範囲内にあるかをチェック
            return False

    return True

# IPアドレスの数を取得
M = int(input().rstrip())

# M行の入力を受け取り、それぞれのIPアドレスの書式を判定して結果を出力
for _ in range(M):
    ip_string = input().rstrip()  # 入力文字列を取得し、末尾の改行を削除
    valid = is_valid_ipv4(ip_string)
    print(valid)  # 書式が合っているかどうかを出力
    
# C006 ハイスコアランキング
# utf-8
s = input().strip().split(" ")  # アイテム数N、プレイ人数M、ランキング順位K
n1 = list(map(int, s))  # 数値変換

s = input().strip().split(" ")  # 得点Ci
n2 = list(map(float, s))  # 数値変換

score = [0 for i in range(n1[1])]  # 人数分の成績

for i in range(n1[1]):  # 一人ずつ設定
    s = input().strip().split(" ")  # 所持数Xi
    n3 = list(map(int, s))  # 数値変換

    for j in range(n1[0]):
        score[i] += n2[j] * n3[j]

score.sort()
score.reverse()

for i in range(n1[2]):
    print(int(score[i] + 0.5))
'''
最初にアイテムの種類N、ユーザーの人数M、トップKの順位を入力として読み込みます。
次に各アイテムの得点Ciを読み込み、浮動小数点数に変換します。
各ユーザーについて、アイテムごとの所持数Xiを読み込み、ユーザーのスコアを計算します。
各ユーザーのスコアを降順にソートします。
上位K個のスコアを整数に変換して出力します。
最後に、各ユーザーのスコア計算やソートなどの処理が行われ、最終的に上位K個のスコアが整数で出力されます。
'''

# C007 ◆
# C008 ◆
# C009 ◆
# C010 安息の地を求めて
# utf-8
s = input().strip().split(" ")
n1 = list(map(int, s))  # int変換

cnt = int(input())

for i in range(cnt):
    s = input().strip().split(" ")
    n3 = list(map(int, s))  # int変換

    if ((n3[0] - n1[0]) ** 2) + ((n3[1] - n1[1]) ** 2) >= (n1[2] ** 2):
        print("silent")
    else:
        print("noisy")
'''
各木陰が読書に適しているかどうかを判定するものです。以下に、プログラムの概要を説明します。
最初の行では、工事現場の座標と騒音の大きさを入力として受け取り、それを整数のリスト n1 に格納しています。
次に、木陰の数を表す整数 cnt を受け取ります。
for ループを通じて、各木陰の座標を入力として受け取ります。各座標は整数のリスト n3 に格納されます。
各木陰に対して、与えられた条件に基づいて判定を行います。具体的には、工事現場と木陰の距離が R メートル以上であれば "silent"、未満であれば "noisy" と判定します。
判定結果を出力します。
プログラムのポイントとしては、座標の距離を求める部分で、ユークリッド距離の計算式を用いています。具体的には、点 (x1, y1) と点 (x2, y2) の距離は sqrt((x2-x1)^2 + (y2-y1)^2) で計算されますが、この問題では距離の比較のみが求められているため、実際に平方根を計算する必要はありません。
代わりに、距離の2乗を比較しています。
'''
--------------------------------------------- C011　※欠番 ◆
# C011 ◆
# C012 ◆
# C013　嫌いな数字
# utf-8
# 嫌いな数字を入力
n = int(input())

# 範囲外の場合はエラーを出力して終了
if n < 0 or n > 9:
    print("嫌いな数字は0から9の範囲で入力してください。")
    exit()

# 病室の総数を入力
m = int(input())

# 範囲外の場合はエラーを出力して終了
if m < 1 or m > 100:
    print("病室の総数は1から100の範囲で入力してください。")
    exit()

# 希望する病室の部屋番号を格納するリスト
desired_rooms = []

# 各病室の部屋番号を入力し、希望する病室をリストに追加
for i in range(m):
    room_number = int(input())

    # 範囲外の場合はエラーを出力して終了
    if room_number < 1 or room_number > 1000:
        print("部屋番号は1から1000の範囲で入力してください。")
        exit()

    if str(n) not in str(room_number): # 部屋番号に嫌いな数字が含まれていない場合
        desired_rooms.append(room_number)

# 希望する病室があるかどうかを判定し、出力
if len(desired_rooms) > 0:
    for room in desired_rooms:
        print(room)
else:
    print("none")
'''
最初に、嫌いな数字 n を入力します。この数字は0から9の範囲で指定される必要があります。それ以外の場合はエラーメッセージを表示してプログラムを終了します。
次に、病室の総数 m を入力します。この数は1から100の範囲で指定される必要があります。それ以外の場合もエラーメッセージを表示してプログラムを終了します。
希望する病室の部屋番号を格納するリスト desired_rooms を初期化します。各病室の部屋番号を入力し、希望する病室をリストに追加します。部屋番号は1から1000の範囲で指定される必要があります。それ以外の場合もエラーメッセージを表示してプログラムを終了します。
希望する病室があるかどうかを判定し、あればそれらを出力します。希望する病室が1つもない場合は "none" を出力します。
'''

# C014　ボールが入る箱
# utf-8
# 入力からボールの半径と箱の情報を取得
n, r = map(int, input().split())
boxes = []
for i in range(n):
    h, w, d = map(int, input().split())
    boxes.append((h, w, d))

# ボールを収納することができる箱の番号を格納するリストを初期化
result = []

# 各箱について、ボールを収納できるかを判定
for i in range(n):
    h, w, d = boxes[i]
    # 箱の高さ、幅、奥行きのうち最も短いものを取得
    shortest_side = min(h, w, d)
    # ボールの直径が最も短い箱の辺の長さ以下であれば、ボールを収納できる
    if shortest_side >= 2 * r:
        result.append(i + 1)  # 箱の番号をリストに追加

# 結果を昇順に出力
for num in result:
    print(num)
'''
最初の行では、入力からボールの個数(n)と半径(r)を取得しています。次に、各箱の情報を取得します。n回分のループを回り、各箱の高さ(h)、幅(w)、奥行き(d)を取得してリストboxesにタプルとして格納しています。
ボールを収納できる箱の番号を格納するためのリストresultを初期化します。各箱について、ボールを収納できるかを判定します。それぞれの箱に対して、その箱の最も短い辺（高さ、幅、奥行きの中で最小の値）を取得し、その辺の長さがボールの直径の2倍以上であれば、ボールを収納できるとみなして、その箱の番号をresultリストに追加します。
最後に、収納できる箱の番号を昇順に出力します。このコードは、ボールを収納できるかどうかを判定する基本的なロジックを持っています。ボールの直径が最も短い辺の長さよりも小さい場合、その箱は収納できないと見なされます。
'''

# C015 ポイントカードの計算
# utf-8
import math

# レシートの数を取得
cnt = int(input())

# 初期ポイントを0に設定
sum = 0

# 各レシートの情報を処理
for i in range(cnt):
    # レシートの情報を取得し、日付と購入金額に分割
    s = input().strip().split(" ")
    a = str(s[0])  # 日付
    n = int(s[1])  # 購入金額

    # ポイントの計算ルールに基づいてポイントを加算
    if "3" in a:
        sum += math.floor(n / 100 * 3)
    elif "5" in a:
        sum += math.floor(n / 100 * 5)
    else:
        sum += math.floor(n / 100)

# 計算されたポイントを出力
print(sum)
'''
レシートの数を受け取ります。
各レシートの情報を取得します。
日付に応じてポイントを計算し、それを合計ポイントに加算します。
最終的な合計ポイントを出力します。
プログラムは日付に「3」が含まれる場合は3%のポイント、日付に「5」が含まれる場合は5%のポイント、それ以外の場合は1%のポイントを計算しています。最終的に、今月末までにたまったポイントの合計が出力されます。
'''

# C016 Leet文字列
# utf-8
# Leetに変換する関数を定義
def to_leet_string(input_string):
    # Leetの置き換え規則を辞書として定義
    leet_rules = {
        'A': '4',
        'E': '3',
        'G': '6',
        'I': '1',
        'O': '0',
        'S': '5',
        'Z': '2'
    }

    # 変換されたLeet文字列を格納する変数を初期化
    leet_string = ''

    # 入力文字列の各文字に対してLeetの置き換えを行う
    for char in input_string:
        # 文字が置き換え規則に含まれていれば置き換え、それ以外はそのまま追加
        if char.upper() in leet_rules:
            leet_string += leet_rules[char.upper()]
        else:
            leet_string += char

    # 変換されたLeet文字列を返す
    return leet_string

# 入力文字列を取得し、末尾の改行を削除
input_string = input().rstrip()
# Leetに変換した文字列を取得
leet_string = to_leet_string(input_string)
# Leet文字列を出力し、最後に改行を追加
print(leet_string, end='\n')
'''
最初に、Leetスラングの置き換え規則が辞書として leet_rules に定義されています。この辞書は、特定のアルファベットがどのように置き換えられるかを示しています。
次に、Leetに変換するための関数 to_leet_string が定義されています。この関数は、与えられた文字列を受け取り、Leetスラングに変換した文字列を返します。
最後に、ユーザーからの入力を受け取り、Leetに変換した結果を表示します。
'''

# C017　ハイアンドロー・カードゲーム
# utf-8
def compare_cards(parent_card, child_card):
    """
    親カードと子カードの強弱関係を比較する関数

    Args:
        parent_card (tuple): 親カードの情報。(1つ目の番号, 2つ目の番号)
        child_card (tuple): 子カードの情報。 (1つ目の番号, 2つ目の番号)

    Returns:
        str: 強弱関係の結果を表す文字列。'High'、'Low'のいずれか。
    """
    parent_num1, parent_num2 = parent_card
    child_num1, child_num2 = child_card

    if parent_num1 > child_num1:
        return 'High'
    elif parent_num1 < child_num1:
        return 'Low'
    else:
        if parent_num2 < child_num2:
            return 'High'
        else:
            return 'Low'

# 親カードの情報を入力
parent_card = tuple(map(int, input().split()))

# 子カードの数を入力
n = int(input())

# 子カードの情報を入力し、強弱関係を判定して出力
for i in range(n):
    child_card = tuple(map(int, input().split()))
    result = compare_cards(parent_card, child_card)
    print(result)
'''
compare_cards 関数:
この関数は、親カードと子カードの強弱関係を比較するために作成されました。
引数として、親カードの情報と子カードの情報を受け取ります。
親カードの1つ目の番号が子カードの1つ目の番号よりも大きい場合、「High」を返します。
または、1つ目の番号が同じである場合で、親カードの2つ目の番号が子カードの2つ目の番号よりも小さい場合も「High」を返します。
上記の条件に該当しない場合は、「Low」を返します。
main 関数:
この関数は、プログラムのメインの制御フローを担当しています。
最初に親カードの情報を標準入力から受け取り、整数に変換してタプルに格納します。
次に、子カードの数を標準入力から受け取ります。
ループを通じて各子カードの情報を受け取り、compare_cards 関数を呼び出して親カードとの強弱関係を判定し、その結果を出力します。
if __name__ == "__main__": 条件文:
この条件文は、スクリプトが直接実行された場合にのみ main 関数を呼び出すようにします。これにより、他のスクリプトからこのコードをインポートしても、main 関数が実行されないようになっています。
特記事項:
map 関数を使用して、標準入力から受け取った文字列を整数に変換しています。
'''

# C018 何人前作れる?
# utf-8
# レシピに書かれている食材の数を取得
n = int(input())

# レシピの食材と必要量を辞書に格納
recipe = {}
for i in range(n):
    a, b = input().split()
    recipe[a] = int(b)

# あなたが所持している食材の数を取得
m = int(input())

# 所持している食材と数量を辞書に格納
ingredients = {}
for i in range(m):
    c, d = input().split()
    ingredients[c] = int(d)

# 最大で何人前作れるかを計算
max_servings = float('inf')  # 初期値を無限大に設定

# レシピの食材と必要量をループし、所持している食材と比較
for ingredient, amount in recipe.items():
    if ingredient in ingredients:
        max_servings = min(max_servings, ingredients[ingredient] // amount)
    else:
        max_servings = 0
        break

# 最大で何人前作れるかを出力
print(max_servings)
'''
レシピに書かれている食材の数を取得する（n）。
レシピの食材と必要量を辞書に格納する（recipe）。
所持している食材の数を取得する（m）。
所持している食材と数量を辞書に格納する（ingredients）。
最大で何人前作れるかを計算する。この部分では、各食材について、所持している量と必要な量を比較し、最小で何人前作れるかを求めています。
最大で何人前作れるかを出力する。
'''

# C019 完全数とほぼ完全数
# utf-8
def is_perfect_or_almost_perfect_number(n):
    """
    入力された整数が完全数かほぼ完全数かそのいずれでもないかを判定する関数

    Args:
        n (int): 判定する整数

    Returns:
        str: 完全数、ほぼ完全数、そのいずれでもないことを示す文字列
    """
    # 約数の和を計算
    s = 0
    for i in range(1, n):
        if n % i == 0:
            s += i

    # 完全数の判定
    if n == s:
        return "perfect"

    # ほぼ完全数の判定
    if abs(n - s) == 1:
        return "nearly"

    # その他の場合
    return "neither"


# 判定したい整数の個数を入力
q = int(input())

# 入力範囲を満たすかチェック
if q < 1 or q > 50:
    print("Error: 1 ≦ Q ≦ 50 の範囲で入力してください。")
    exit(1)

# 各整数について判定を行い結果を出力
for i in range(q):
    n = int(input())

    # 入力範囲を満たすかチェック
    if n < 2 or n > 1000:
        print("Error: 2 ≦ N_i ≦ 1000 の範囲で入力してください。")
        exit(1)

    result = is_perfect_or_almost_perfect_number(n)
    print(result)
'''
与えられた整数が完全数、ほぼ完全数、またはそのいずれでもないかを判定するものです。以下にコードの主な要素を解説します。

is_perfect_or_almost_perfect_number 関数:
n が与えられると、その整数が完全数かほぼ完全数かを判定します。
s という変数に、n の約数の和を計算しています。
最初の for ループで、1 から n-1 までの範囲で n の約数を探し、それを s に加算しています。
次に、n と s を比較して、完全数かどうかを判定します。
続いて、abs(n - s) == 1 の条件で、ほぼ完全数かどうかを判定します。
上記の条件にどれも当てはまらない場合は、その他の場合として、"neither" を返します。

メイン部分:
判定したい整数の個数 q を入力します。
q の範囲が 1 から 50 まででない場合、エラーメッセージを表示してプログラムを終了します。
各整数について判定を行い、その結果を出力します。
'''

# C020　残り物の量
# utf-8
def calculate_leftover_amount(m, p, q):
    """
    生鮮食品の売れ残り量を計算する関数

    Args:
        m (int): 生鮮食品の仕入れ量(kg)
        p (int): 生のまま売れた割合(%)
        q (int): お総菜に変換された売れ残りの割合(%)

    Returns:
        float: 最終的な売れ残り量(kg)
    """
    # 生鮮食品の売れ残り量を計算
    leftover_amount = m * (100 - p) / 100

    # お総菜に変換された売れ残り量を計算
    leftover_amount = leftover_amount * (100 - q) / 100

    return leftover_amount


# 生鮮食品の仕入れ量、生のまま売れた割合、お総菜に変換された売れ残りの割合を入力
m, p, q = map(int, input().split())

# 生鮮食品の売れ残り量を計算
leftover_amount = calculate_leftover_amount(m, p, q)

# 売れ残り量を小数値で出力
print("{:.4f}".format(leftover_amount))
'''
与えられた条件に基づいて、生鮮食品の仕入れ量や売れ残りの割合に応じて最終的な売れ残り量を計算します。
関数 calculate_leftover_amount の定義:
この関数は、生鮮食品の仕入れ量（m）、生のまま売れた割合（p）、お総菜に変換された売れ残りの割合（q）を引数として受け取ります。
最初に、生のまま売れた分の量を計算します。これは、仕入れ量 m から生のまま売れた割合 p を引いて計算されます。
次に、生のまま売れた残りの量をお総菜に変換した分の割合 q を引いて計算します。
計算結果として、最終的な売れ残り量が返されます。
メインコード:
map(int, input().split()) を使用して、標準入力から生鮮食品の仕入れ量（m）、生のまま売れた割合（p）、お総菜に変換された売れ残りの割合（q）を整数として取得します。
calculate_leftover_amount 関数を呼び出して、最終的な売れ残り量を計算します。
最終的な売れ残り量を小数点以下4桁まで表示して標準出力に出力します。
'''
--------------------------------------------- C021　※欠番 ◆
# C021　暴風域にいますか
# utf-8
import math

def is_in_typhoon(xc, yc, r1, r2, x, y):
    """
    台風の暴風域にあるかどうかを判定する関数

    Args:
        xc (int): 台風1の中心のx座標
        yc (int): 台風1の中心のy座標
        r1 (int): 台風1の半径
        r2 (int): 台風2の半径
        x (int): 判定する人のx座標
        y (int): 判定する人のy座標

    Returns:
        bool: 台風の暴風域にある場合True、そうでない場合False
    """
    distance_squared = (x - xc) ** 2 + (y - yc) ** 2
    if r1 ** 2 <= distance_squared <= r2 ** 2:
        return True
    else:
        return False

# 台風情報の入力
xc, yc, r1, r2 = map(int, input().split())
# 人の数の入力
n = int(input())

# 各人の座標の入力と判定
for i in range(n):
    x, y = map(int, input().split())
    if is_in_typhoon(xc, yc, r1, r2, x, y):
        print("yes")
    else:
        print("no")
'''
このコードは、与えられた台風の情報と各人の座標に基づいて、各人が台風の暴風域にいるかどうかを判定するものです。
is_in_typhoon関数の定義:
台風の暴風域にあるかどうかを判定するための関数です。
引数として、台風の中心座標 (xc, yc)、台風の半径 r1, r2、判定する人の座標 (x, y) を受け取ります。
台風の中心と人の座標との距離を計算し、その距離が台風の半径の範囲内にあるかどうかを判定します。
台風の暴風域にあればTrue、そうでなければFalseを返します。
メインの処理:
台風情報の入力として、xc, yc, r1, r2を標準入力から受け取ります。
人の数 n を標準入力から受け取ります。
各人の座標を入力として受け取り、is_in_typhoon関数を用いて暴風域にいるかどうかを判定します。
判定結果に基づいて、"yes"または"no"を出力します。
コードの実行:
具体的な例として、入力例1および入力例2が示されています。
各人に対して、暴風域にいる場合は"yes"、いない場合は"no"が出力されます。
'''

# C022 ローソク足
# utf-8
# 日数 n を入力
n = int(input())

# 株価データを入力し、始値、終値、高値、安値を計算
start_prices = []
end_prices = []
high_prices = []
low_prices = []

for i in range(n):
    s, e, h, l = map(int, input().split())
    start_prices.append(s)
    end_prices.append(e)
    high_prices.append(h)
    low_prices.append(l)

# n日間の始値を計算
start_price = start_prices[0]

# n日間の終値を計算
end_price = end_prices[-1]

# n日間の高値を計算
high_price = max(high_prices)

# n日間の安値を計算
low_price = min(low_prices)

# 結果を出力
print(start_price, end_price, high_price, low_price, end='')
'''
与えられた株価データからn日間の始値、終値、高値、安値を計算し、それを1行で出力するものです。以下はコードの解説です。
n = int(input()): 最初に日数 n を入力します。これは株価データの日数です。
start_prices, end_prices, high_prices, low_prices: 各日の始値、終値、高値、安値を格納するためのリストを用意します。
for i in range(n):: 入力された日数分だけループします。
a. s, e, h, l = map(int, input().split()): 各日の始値、終値、高値、安値を取得し、整数に変換して変数に格納します。
b. start_prices.append(s), end_prices.append(e), high_prices.append(h), low_prices.append(l): 各日のデータを対応するリストに格納します。
start_price = start_prices[0]: n日間の始値は最初の日の始値です。この値を start_price に格納します。
end_price = end_prices[-1]: n日間の終値は最後の日の終値です。この値を end_price に格納します。
high_price = max(high_prices): n日間の高値は最大の高値です。max() 関数を使用して最大値を求め、それを high_price に格納します。
low_price = min(low_prices): n日間の安値は最小の安値です。min() 関数を使用して最小値を求め、それを low_price に格納します。
print(start_price, end_price, high_price, low_price, end=''): 計算結果を1行で出力します。end='' は改行を抑制しています。
'''

# C023 クジの当選番号
# utf-8
import sys
a = [int(s) for s in sys.stdin.readline().split()]
N=int(input())
b = [[int(s) for s in line.split()] for line in sys.stdin]
for j in range(N):
    c=0
    for i in range(len(b[0])):
        if a[i] in b[j]:
            c += 1
    print(c)
'''
このプログラムは、くじの当選番号と購入したくじの数字を比較して、一致する数字の数を出力するものです。
最初に、当選番号をリスト a に格納します。次に、購入したくじの枚数 N を受け取ります。その後、くじごとの数字を2次元リスト b に格納します。
ループを使って各くじについて、当選番号と一致する数字の数を数え、結果を出力します。
for j in range(N):：各くじについてのループ。
c = 0：当選番号と一致する数字の数を格納する変数を初期化。
for i in range(len(b[0])):：当選番号の各数字についてのループ。
if a[i] in b[j]:：当選番号の数字がくじの中に含まれていれば、一致する数字の数を増やす。
print(c)：くじごとに当選番号と一致する数字の数を出力。
このようにして、各くじについて当選番号と一致する数字の数を求めるプログラムが完成しています。
'''

# C024　ミニ・コンピュータ
# utf-8
def simulate_computer(n, commands):
    # 変数1と変数2の初期化
    variables = [0, 0]

    # 各命令を順番に実行
    for command in commands:
        # 命令をトークンに分割
        tokens = command.split()
        
        # SET命令の場合
        if tokens[0] == "SET":
            i, a = int(tokens[1]) - 1, int(tokens[2])
            # 変数iに値aを代入
            variables[i] = a
        # ADD命令の場合
        elif tokens[0] == "ADD":
            a = int(tokens[1])
            # 変数1の値にaを加え、結果を変数2に代入
            variables[1] = variables[0] + a
        # SUB命令の場合
        elif tokens[0] == "SUB":
            a = int(tokens[1])
            # 変数1の値からaを引き、結果を変数2に代入
            variables[1] = variables[0] - a

    # 最終的な変数1と変数2の値を返す
    return variables

# 入力の読み込み
n = int(input())
commands = [input().strip() for _ in range(n)]

# コンピュータのシミュレーション
result = simulate_computer(n, commands)

# 結果の出力
print(result[0], result[1])
'''
simulate_computer 関数:
この関数は、コンピュータのシミュレーションを行うためのメインの関数です。
nは命令の個数で、commandsは各命令を格納したリストです。
variablesリストは2つの変数の初期値を保持します。
コンピュータの初期化:
variablesリストは [0, 0] で初期化され、変数1と変数2の初期値がそれぞれ0に設定されます。
各命令の実行:
for ループは各命令を順番に処理します。
各命令は文字列として受け取られ、split() メソッドを使用してトークンに分割されます。
SET命令の場合:
SET 命令では、変数に特定の値を代入します。
i は変数のインデックス（1または2）、a は代入される値です。
ADD命令の場合:
ADD 命令では、変数1の値に特定の値を加え、その結果を変数2に代入します。
a は加算される値です。
SUB命令の場合:
SUB 命令では、変数1の値から特定の値を引き、その結果を変数2に代入します。
a は減算される値です。
最終的な変数の値を返す:
simulate_computer 関数は最終的に、変数1と変数2の値を保持するリスト variables を返します。
入力の読み込みと出力:
n と commands を標準入力から受け取ります。
simulate_computer 関数にこれらの入力を渡して、コンピュータをシミュレートします。
最終的な変数の値を出力します。
このプログラムは、与えられた命令に基づいて変数1と変数2の値を計算し、最終的な結果を出力します。
'''

# C025　ファックスの用紙回収
# utf-8
import math

# 1度に運べる紙の最大枚数 M を取得し、0.0 で浮動小数点に変換
M = int(input()) + 0.0
# 1日にファックスが届く回数 N を取得
N = int(input())

# N 回分の時刻とファックスの枚数を2次元リスト Fax に格納
Fax = [[int(i) for i in input().split()]for j in range(N)]
# 最初のファックスが届く時間を最初に格納
hours = Fax[0][0]
# 1度に取りに行ける最大枚数を累積する変数
paper = 0
# 取りに行く回数の総計を格納する変数
total = 0

# Fax リストをイテレート
for i, j, k in Fax:
    # 時間が同じ場合は紙の枚数を累積
    if hours == i:
        paper += k
    else:
        # 時間が異なる場合はそれまでに累積された枚数を1度に運べる最大枚数で割り、切り上げて取りに行く回数を計算
        total += math.ceil(paper / M)
        # 累積された枚数をリセットし、新しい時間と枚数を格納
        paper = 0
        hours = i
        paper += k

# 最後に最後のファックスまでに累積された枚数を同様に計算し、total に加えて、取りに行く必要がある総回数を出力
total += math.ceil(paper / M)
print(total)
'''
このプログラムは、与えられた条件に基づいて、ファックスが届く時間と枚数に基づいて、ファックスを取りに行く必要がある回数を計算します。
最初に、1度に運べる紙の最大枚数 M と、1日にファックスが届く回数 N を入力から受け取ります。
N 回分の時刻とファックスの枚数を受け取り、それを2次元リスト Fax に格納します。
変数 hours には、最初のファックスが届く時間を格納し、変数 paper にはその時間に届いたファックスの枚数を格納します。また、変数 total には今までに取りに行った回数を格納します。
Fax リストをイテレートしながら、時間が同じ場合は紙の枚数を累積し、異なる場合はそれまでに累積された枚数を1度に運べる最大枚数で割り、切り上げて取りに行く回数を計算します。
最後に、最後のファックスまでに累積された枚数を同様に計算し、total に加えて、取りに行く必要がある総回数を出力します。
'''

# C026　ウサギと人参
# utf-8
# 入力を受け取る
N, S, p = map(int, input().split())  # 人参のデータの数、目安となる糖分、許容誤差

max_mass = -1  # 最大質量を初期化
max_index = -1  # 最大質量の人参の番号を初期化

# N個の人参データを入力として受け取る
for i in range(1, N + 1):
    data = list(map(int, input().split()))  # 質量と糖分をスペース区切りで入力
    mass = data[0]  # 人参の質量
    sugar = data[1]  # 人参の糖分

    # 糖分が許容範囲内でかつ質量が最大の場合、最大質量とその人参の番号を更新
    if S - p <= sugar <= S + p and mass > max_mass:
        max_mass = mass
        max_index = i

if max_index != -1:
    print(max_index)  # 最大質量の人参の番号を出力
else:
    print("not found")  # 見つからなかった場合は "not found" を出力
'''
Rabbit社の要件に基づいて、与えられた人参のデータから糖分が許容範囲内で質量が最も大きい人参の番号を見つけるものです。
最初に、3つの整数 N, S, p を1行で入力として受け取ります。これは、人参のデータの数、目安となる糖分、許容誤差を表しています。
最大質量とその人参の番号を記録する変数 max_mass と max_index を初期化します。N回のループを行い、各人参のデータを入力として受け取ります。人参の質量を mass、糖分を sugar として取得します。
各人参について、糖分が許容範囲内でかつ質量が最大の場合、最大質量とその人参の番号を更新します。最後に、最大質量の人参の番号を出力します。もし見つからなかった場合は "not found" を出力します。
'''

# C027　◆
# C028　単語テストの採点
# utf-8
N = int(input())  # 問題数を表す N を取得

# N 行分の入力を取得し、それぞれ正解と生徒の解答をリストに格納
words = [input().split() for x in range(N)]

score = 0  # 合計得点を初期化

for word in words:
    if len(word[0]) == len(word[1]):  # 正解と解答の長さが一致する場合
        miss = 0  # missは1問ごとに初期化されるべき変数で、不一致の文字数を保持する
        for i in range(len(word[0])):  # 文字の長さだけ繰り返し
            if word[0][i] != word[1][i]:  # 正解と解答の対応する位置の文字が異なる場合
                miss += 1  # 不一致の文字数を増やす

        if miss < 1:
            score += 2  # 完全一致なら2点加算

        elif miss < 2:
            score += 1  # 不一致が1文字の場合は1点加算

print(score)  # 生徒の合計得点を出力
'''
入力から問題数 N を取得し、各問題の正解と生徒の解答をリストに格納します。
各問題について、正解と解答の長さが一致するかを確認します。
長さが一致する場合、対応する位置の文字を比較し、不一致の文字数をカウントします。
不一致の文字数に基づいて得点を計算し、合計得点に加えます。
全ての問題に対して得点を計算した後、最終的な合計得点を出力します。
'''

# C029　旅行の計画
# utf-8
# 連休の日数を表す整数 M と 旅行の日数を表す整数 N を入力から取得
M, N = map(int, input().split())

# 連休の日付と降水確率を格納するリスト
dates = []
rainfall_probs = []

# 連休の日付と降水確率を入力から取得
for _ in range(M):
    d, r = map(int, input().split())
    dates.append(d)
    rainfall_probs.append(r)

# N日間の降水確率の平均が最も低くなる日程の最初の日付と最後の日付を初期化
min_avg_rainfall_prob = float('inf')
start_date = -1
end_date = -1

# 連休の日付をスライドさせながらN日間の降水確率の平均を計算し、最も低い値を探索
for i in range(M - N + 1):
    avg_rainfall_prob = sum(rainfall_probs[i:i+N]) / N
    if avg_rainfall_prob < min_avg_rainfall_prob:
        min_avg_rainfall_prob = avg_rainfall_prob
        start_date = dates[i]
        end_date = dates[i + N - 1]

# 結果を出力
print(start_date, end_date)
'''
まず、連休の日数Mと旅行の日数Nを入力として受け取ります。
次に、M日間の連休の各日付と降水確率を受け取ります。
その後、各日付からN日間の期間を選択し、その期間の降水確率の平均値を計算します。
平均値が最も低い期間を見つけ、その開始日と終了日を出力します。
'''

# C030　白にするか黒にするか
# utf-8
# 画像のサイズを表す整数 H, W を入力から取得
H, W = map(int, input().split())

for i in range(H):
    # 画像の各行をリストとして取得
    row = list(map(int, input().split()))
    
    for j in range(W):
        # 画素値が 128 以上ならば 1 (白)、それ以下ならば 0 (黒) に変換
        if row[j] >= 128:
            row[j] = 1
        else:
            row[j] = 0
    
    # リスト内の各要素を文字列に変換し、スペースで区切って1行にする
    s = ' '.join(map(str, row))
    
    # 1行ごとに出力
    print(s)
'''
与えられたグレースケールの画像を白黒の二値画像に変換するものです。
最初に、画像のサイズを表す整数HとWを入力から取得します。
画像の各行ごとに処理を行います。ループを使って、各行の情報を取得します。
それぞれの画素値について、グレースケールから二値化を行います。ピクセルの値が128以上の場合は1（白）、それ以下の場合は0（黒）に変換します。
画素値を二値化した各行の情報を文字列として結合し、1行にまとめます。その後、各行を出力します。
入力されたグレースケールの画像を二値画像に変換し、その結果を出力します。各ピクセルの値が閾値（128）以上ならば白（1）、それ以下ならば黒（0）に変換されます。
'''
--------------------------------------------- C031　※欠番 ◆
# C031　時差を求めたい
# utf-8
# 都市ごとの時差を管理する辞書を作成
time_difference = {}

# 都市の総数を入力
N = int(input())

# 都市ごとの時差情報を入力
for i in range(N):
    city_info = input().split()
    city_name = city_info[0]
    time_difference[city_name] = int(city_info[1])

# ユーザの所在地の都市と投稿時刻を入力
user_city, user_time = input().split()

# ユーザの所在地の都市の時差を取得
user_time_difference = time_difference[user_city]

# ユーザの投稿時刻を時と分に分割
user_hour, user_minute = map(int, user_time.split(':'))

# 各都市ごとに投稿時刻を修正して出力
for city, diff in time_difference.items():
    # ユーザの所在地の都市の場合はそのまま出力
    if city == user_city:
        print(user_time)
    else:
        # 各都市の時差を考慮して投稿時刻を修正
        city_hour = (user_hour + diff - user_time_difference + 24) % 24
        city_minute = user_minute
        # 時と分を0埋め2桁の文字列に変換して出力
        print('{:02d}:{:02d}'.format(city_hour, city_minute))
'''
このプログラムは、各都市の時差を考慮して投稿時刻を修正し、それぞれの都市に住むユーザの画面に表示される投稿時刻を出力します。
都市ごとの時差を管理する辞書を作成: time_difference という空の辞書を作成します。この辞書は都市名をキーとし、その都市の時差を値として持ちます。
都市の総数を入力: N に都市の総数を入力します。
都市ごとの時差情報を入力: N 回のループを通じて、各都市の名前と時差を入力し、time_difference 辞書に都市名をキーとして、時差を値として保存します。
ユーザの所在地の都市と投稿時刻を入力: ユーザの所在地の都市と投稿時刻を入力し、それぞれ user_city と user_time に保存します。
ユーザの所在地の都市の時差を取得: ユーザの所在地の都市の時差を time_difference 辞書から取得し、user_time_difference に保存します。
ユーザの投稿時刻を時と分に分割: user_time を ":" で分割し、user_hour と user_minute にそれぞれ時と分を保存します。
各都市ごとに投稿時刻を修正して出力: time_difference 辞書をループし、各都市の投稿時刻を修正して出力します。
ユーザの所在地の都市の場合は、そのままユーザの投稿時刻を出力します。
それ以外の都市の場合は、ユーザの投稿時刻にその都市の時差を加味して、投稿時刻を修正し、出力します。
'''

# C032　お得な買い物
# utf-8
n=int(input())
a=[0]*4
for i in range(n):
    v,p=map(int, input().split())
    a[v]=a[v]+p
print(a[0]//100*5+a[1]//100*3+a[2]//100*2+a[3]//100*1)
'''
商品の種類ごとに合計金額を集計するリストを用意します。
入力を処理して、各商品の種類ごとの金額をリストに加算します。
ポイント付与基準に基づいて、各商品の種類ごとのポイントを計算します。
合計ポイントを出力します。
このコードは、入力を受け取り、それぞれの商品の種類ごとに金額を合計します。
そして、ポイント付与基準に基づいて各商品のポイントを計算し、最終的な合計ポイントを出力します。
'''

# C033　◆
# C034　先生の宿題
def calculate_answer(problem):
    # 問題をスペースで分割して、各要素を取得
    elements = problem.split(" ")
    a = elements[0]
    op = elements[1]
    b = elements[2]
    c = elements[4]
    
    # a, b, c のうち空欄を特定し、答えを計算
    if a == "x":
        if op == "+":
            answer = int(c) - int(b)
        elif op == "-":
            answer = int(c) + int(b)
    elif b == "x":
        if op == "+":
            answer = int(c) - int(a)
        elif op == "-":
            answer = int(a) - int(c)
    elif c == "x":
        if op == "+":
            answer = int(a) + int(b)
        elif op == "-":
            answer = int(a) - int(b)
    
    # 答えが 0 から 9 の間に収まるように制限
    if answer < 0:
        answer = 0
    elif answer > 9:
        answer = 9
        
    return str(answer)
            
# 問題を入力として受け取る
problem = input()

# 答えを計算して出力
answer = calculate_answer(problem)
print(answer)
'''
与えられた数式から空欄に入るべき整数（答え）を計算するためのロジックを実装しています。
まず、与えられた数式をスペースで分割し、それぞれの要素を取得します。そして、空欄がどの位置にあるかを確認し、それに基づいて答えを計算します。

具体的には、以下の手順で計算を行います：
もし a が空欄であれば、b と c の値から足し算または引き算を行い、その結果を答えとします。
もし b が空欄であれば、a と c の値から足し算または引き算を行い、その結果を答えとします。
もし c が空欄であれば、a と b の値から足し算または引き算を行い、その結果を答えとします。
計算された答えは、0から9の範囲内に収められます。これは、与えられた条件で答えが0以上9以下の整数であることが保証されているためです。
'''

# C035　試験の合格判定
# utf-8
# 受験者の人数を入力
N = int(input())

# 2段階選抜を通過できる人数をカウントする変数を初期化
passed_count = 0

# 各受験者の情報を入力し、2段階選抜を通過できるかを判定
for i in range(N):
    # 受験者の情報を入力
    data = input().split()
    t_i = data[0]  # 文理の区分
    e_i = int(data[1])  # 英語の点数
    m_i = int(data[2])  # 数学の点数
    s_i = int(data[3])  # 理科の点数
    j_i = int(data[4])  # 国語の点数
    g_i = int(data[5])  # 地理歴史の点数
    
    # 各科目の合計得点を計算
    total_score = e_i + m_i + s_i + j_i + g_i
    
    # 理系か文系かを判定
    is_science_major = t_i == "s"
    is_literature_major = t_i == "l"
    
    # 2段階選抜の条件を満たすかを判定
    if total_score >= 350 and ((is_science_major and (m_i + s_i) >= 160) or (is_literature_major and (j_i + g_i) >= 160)):
        passed_count += 1

# 2段階選抜を通過できる人数を出力
print(passed_count)
'''
このプログラムは、与えられた受験者の情報を元に、paiza大学の入試の2段階選抜を通過する人数を計算します。
受験者の情報を入力：各受験者について、文理の区分と各科目の点数を入力します。これはループを通じて行われます。
合計得点を計算：各受験者の各科目の点数を合算して、その合計得点を算出します。
文系か理系かを判定：受験者が文系か理系かを判定します。文系の場合は国語と地理歴史の合計点数、理系の場合は数学と理科の合計点数を考慮します。
2段階選抜の条件を満たすかを判定：合計得点が350点以上で、かつ文系の場合は国語と地理歴史の合計点数が160点以上、理系の場合は数学と理科の合計点数が160点以上であるかを判定します。
通過者の数をカウント：条件を満たす場合、通過者の数をカウントします。
通過者の数を出力：最終的に、通過した受験者の数を出力します。
'''

# C036　犬ぞりトーナメント
# utf-8
f1 = [int(_) for _ in sorted(input().split())]
f2 = [int(_) for _ in sorted(input().split())]
t1 = [int(_) for _ in input().split()]
t2 = [int(_) for _ in input().split()]

s = [f1[0] if t1[f1[0]-1] < t1[f1[1]-1] else f1[1]]
s += [f2[0] if t1[f2[0]-1] < t1[f2[1]-1] else f2[1]]
s.sort()
print(s[0] if t2[0] < t2[1] else s[1])
print(s[1] if t2[0] < t2[1] else s[0])

# C037　アニメの日時
# utf-8
import re
# 入力を受け取る
t = input().rstrip()

# 正規表現を使って入力の日付時刻をパース
pattern = r'(\d{2})/(\d{2}) (\d{2}):(\d{2})'
match = re.match(pattern, t)

if match:
    # パースに成功した場合
    month = int(match.group(1))
    day = int(match.group(2))
    hour = int(match.group(3))
    minute = int(match.group(4))
    
    # 月と日が不正な値の場合には修正する
    while month > 12 or day > 31:
        if month > 12:
            month -= 12
        if day > 31:
            day -= 31
    
    # 時間が 24 以上の場合は日付を繰り上げる
    while hour >= 24:
        hour -= 24
        day += 1
        
    # パースした値を元のフォーマットで出力
    print("{:02d}/{:02d} {:02d}:{:02d}".format(month, day, hour, minute))
else:
    # パースに失敗した場合は入力の日付時刻をそのまま出力
    print(t)

# C038　お菓子の分配
# utf-8
n = input().strip().split(" ")
n = list(map(int, n))   # int変換

ans = [0, 1001, 1001]  # No, mod, q

for i in range(n[0]):
    a = int(input())
    m = n[1] % a
    q = n[1] // a

    if (m < ans[1])or (m == ans[1] and q < ans[2]):
        ans[0] = i + 1
        ans[1] = m
        ans[2] = q

print(ans[0])

# C039　古代の数式
# utf-8
line = input()
# print(line)
line_list = list(line)
# print(line_list)

cnt_k=0
cnt_l=0

for i in range(len(line)):
    # print(i)
    if line_list[i]=="<":
        cnt_k += 1
    # print(cnt_k)
    if line_list[i]=="/":
        cnt_l += 1
    
print(cnt_k*10 + cnt_l)

# C040　背比べ
# utf-8
n = int(input())
comps = [input().split() for x in range(n)]
l,r=0,1000
for comp in comps:
  if comp[0] == 'ge':
    l = max(l,float(comp[1]))
  else:
    r = min(r,float(comp[1]))
print(l,r)

--------------------------------------------- C041　※欠番 ◆
# C041　メダルランキングの作成
# utf-8
# 入力を受け取る
N = int(input())  # 国の総数
medals = []  # メダルの獲得数を格納するリスト

# メダルの獲得数を入力から取得し、リストに格納
for i in range(N):
    g, s, b = map(int, input().split())
    medals.append((g, s, b))

# メダルの獲得数を条件にそってソート
medals.sort(reverse=True)

# ソートされたメダルの獲得数を出力
for medal in medals:
    print(*medal)

# C042　リーグ表の作成
# utf-8
# 参加者数を入力から取得
N = int(input())

# 各試合の結果を入力から取得
results = {}
for i in range(1, N * (N - 1) // 2 + 1):
    f, s = map(int, input().split())
    results[i] = (f, s)

# 表の初期化
table = [['-' for _ in range(N)] for _ in range(N)]

# 各試合の結果を表に反映
for i, (f, s) in results.items():
    table[f - 1][s - 1] = 'W'
    table[s - 1][f - 1] = 'L'

# 表の出力
for row in table:
    print(' '.join(row))
    
# C043　使用回数の調査
# utf-8
import collections

n = int(input())
m = input().strip().split(" ")
m = list(map(int, m))   # int変換

c = collections.Counter(m)

mc = c.most_common()

mx = mc[0][1]
l = []

for x in mc:
    if x[1] < mx:
        break
    else:
        l.append(x[0])

l.sort()

print(" ".join([str(x) for x in l]))

# C044　手の組み合わせ
# utf-8
n = int(input())

h = []
for i in range(n):
    h.append(input())

h = sorted(set(h))

if len(h) == 2:
    if h[0] == 'paper':
        if h[1] == 'rock':
            print(h[0])
        else:
            print(h[1])
    else:
        print(h[0])

else:
    print("draw")
    
# C045　ページネーション
# utf-8
def paginate_search_results(n, s, p):
    start = (p - 1) * s + 1 # 開始番号
    end = min(n, p * s) # 終了番号
    if start > n:
        return "none" # 検索結果が存在しない場合は"none"を返す
    else:
        return list(range(start, end + 1)) # 開始番号から終了番号までのリストを返す

# 入力の取得
n, s, p = map(int, input().split())

# ページネーションの実行
result = paginate_search_results(n, s, p)

# 出力
if result == "none":
    print(result)
else:
    print(*result)
    
# C046　書籍購入費ランキング
# utf-8
member = int(input())
name = input()
names = name.split()

book = int(input())
buy = [input() for i in range(book)]

dic = {}

for members in range(member):
	dic[names[members]] = 0

for books in buy:
	temp = books.split()
	dic[temp[0]] += int(temp[1])
	
for k, v in sorted(dic.items(), key=lambda x: x[1], reverse=True):
	print(k)
    
# C047　◆
# C048　タダ飲みコーヒー
# utf-8
import math

row = input()

sp = row.split()

# print(sp)

price = int(sp[0])
discount = int(sp[1])

after_price = price
total = price
count = 0

while after_price > 0:
	# 切り捨て
	after_price = math.floor(after_price * (100 - discount)/100)
	total += after_price
	
print(total)

# C049　エレベーター
# utf-8
# 入力を受け取る
N = int(input())  # ログの行数
floors = []  # エレベーターが止まった階のリスト
for _ in range(N):
    floor = int(input())
    floors.append(floor)

# エレベーターが合計で何階分の距離を動いたか計算する
total_distance = 0  # 合計の距離
current_floor = 1  # 現在の階数は必ず1階とする
for floor in floors:
    distance = abs(floor - current_floor)  # 現在の階数から目的の階数までの距離
    total_distance += distance  # 合計の距離に加算
    current_floor = floor  # 現在の階数を更新

# 結果を出力
print(total_distance)

# C050　オークションの結果
# utf-8
S,a,b=map(int,input().split())
while True:
    if a>=S+10:
        S=S+10
    else:
        print("B",S)
        break
    if b>=S+1000:
        S=S+1000
    else:
        print("A",S)
        break
--------------------------------------------- C051　※欠番 ◆
# C051　カード並べ
# utf-8
numlist=list(map(int,input().split()))#a, b, c, d はそれぞれ 4 枚のカード
newlist=sorted(numlist)#昇順に並び替え #例： 2, 3, 8 , 9
num1=str(newlist[3])+str(newlist[1])
num2=str(newlist[2])+str(newlist[0])
print(int(num1)+int(num2))

# C052　ゲームの画面
# utf-8
w = input().strip().split(" ")
w = list(map(int, w))   # int変換

n = input().strip().split(" ")
n = list(map(int, n))   # int変換

ful = w[0] * w[1]
used = (w[0] - abs(n[0])) * (w[1] - abs(n[1]))

print(ful - used)

# C053　カードの合計
# utf-8
party = int(input())

cards = input()
cards_split = cards.split()
ten = "x10" in cards_split

bonus = 1

if ten is True:
    cards_split.remove("x10")
    bonus = 10

cards_split_i = [int(s) for s in cards_split]

zero = "0" in cards_split

if zero is True:
    max_num = max(cards_split_i)
    cards_split_i.remove(max_num)

res = sum(cards_split_i) * bonus

print(res)

# C054　スピード違反の取り締まり
# utf-8
n = input().strip().split(" ")
n = list(map(int, n))   # int変換

t = []
p = []
while True:
    try:
        a = input().strip().split(" ")
        a = list(map(int, a))   # int変換
        t.append(a[0])
        p.append(a[1])

    except EOFError:
        break

ans = "NO"

for i in range(n[0]):
    if i == 0:
        continue

    if (p[i] - p[i-1]) / (t[i] - t[i-1]) > n[1]:
        ans = "YES"
        break

print(ans)

# C055　ログのフィルター
# utf-8
import re

N = int(input())
# print(N)
string = input()
# print(string)
flag = 0
for i in range(N):
    abc = input()
    
    if string in abc:
        print(abc)
        flag = 1
        
if flag == 0:
    print('None')
    
# C056　テストの採点
# utf-8
from sys import stdin

n, m = map(int, stdin.readline().rstrip().split())
test_results = [list(map(int, stdin.readline().rstrip().split())) for i in range(n)]
# pass_students_id = [i + 1 for i, result in enumerate(test_results) if (result[0] - result[1] * 5) >= m]
pass_students_id = []
for i, result in enumerate(test_results):
  r1 = result[0] - result[1] * 5
  r = r1 if r1 >= 0 else 0
  if r >= m:
    pass_students_id.append(i+1)
for i in pass_students_id:
  print(i)

# C057　シャボン玉飛ばし
# utf-8
# 入力を受け取る
T, x, y = map(int, input().split())
wind = []
for _ in range(T):
    a, b = map(int, input().split())
    wind.append((a, b))

# シャボン玉の位置を更新しながら最大の x 座標を求める
max_x = x
for i in range(T):
    a, b = wind[i]
    # シャボン玉の位置を更新
    x += a
    y += b
    # y 座標が 0 以下になったらシャボン玉が割れるので、最大の x 座標を出力して終了
    if y <= 0:
        print(max_x)
        exit()
    # x 座標の最大値を更新
    max_x = max(max_x, x)

# T 時間経過後までシャボン玉が割れずに生き残った場合、最終的な x 座標を出力
print(max_x)

# C058　模様そろえ
# utf-8
# 入力を受け取る
input_line = input().strip().split()
N = int(input_line[0])  # 箱の側面の数
t = input_line[1]  # そろえる向きを表す文字列
s = input_line[2]  # 最初の箱の向きを表す文字列

# 最小回転数を計算
rotation = (s + s).find(t)  # sを2つ繋げて、tが最初に出現するインデックスを求める

# 最小回転数がN以上の場合は、回転数を修正する
if rotation >= N:
    rotation = N - rotation

# 結果を出力
print(rotation)

# C059　パリティチェック
# utf-8
# 入力データの取得
N = int(input())  # 2進数の数
binary_list = []  # 2進数のリスト
for i in range(N):
    binary = input().strip()
    binary_list.append(binary)

# 排他的論理和(XOR)を計算して結果を出力する関数
def calculate_xor(binary_list):
    result = ""
    for i in range(4):  # 4桁の2進数なので4回繰り返す
        count = 0
        for j in range(N):
            if binary_list[j][i] == '1':
                count += 1
        if count % 2 == 1:
            result += '1'
        else:
            result += '0'
    return result

# 排他的論理和(XOR)を計算して結果を出力
result = calculate_xor(binary_list)
print(result)

# C060　辞書の作成
# utf-8
def get_words_on_page(N, K, P, words):
    # 辞書順に単語を並び替える
    words.sort()

    # P ページ目に載る単語のインデックスを計算
    start_idx = (P - 1) * K
    end_idx = min(start_idx + K, N)

    # P ページ目に載る単語のリストを取得
    words_on_page = words[start_idx:end_idx]

    return words_on_page

# 入力の受け取り
N, K, P = map(int, input().split())
words = input().strip().split()

# 入力のバリデーション
if not (3 <= N <= 1000) or not (1 <= K <= N) or not (1 <= P <= N):
    print("入力値が条件を満たしていません。")
    exit(1)

if len(words) != N or len(set(words)) != N:
    print("入力される単語が条件を満たしていません。")
    exit(1)

for word in words:
    if not (0 <= len(word) <= 10):
        print("入力される単語の長さが条件を満たしていません。")
        exit(1)

# P ページ目に載る単語のリストを取得
words_on_page = get_words_on_page(N, K, P, words)

# 結果を改行区切りで出力
print("\n".join(words_on_page))

'''
# 別解
N, K, P = map(int,input().split())
s = input().split()
s.sort()
j = []
for i in range(0, N, K):
    j.append(s[i:i+K])
for k in j[P-1]:
    print(k)

'''
--------------------------------------------- C061　※欠番 ◆
# C061　繰り上がりのない足し算
# utf-8
A, B = map(str,input().split())
s = ""
if max(len(A), len(B)) == 3:
    s += str((int(A) // 100 + int(B) // 100) % 10)
if max(len(A), len(B)) >= 2:
    s += str((int(A) // 10 + int(B) // 10) % 10)
s += str((int(A) + int(B)) % 10)
print(s)

# 別解
def add_with_kids_method(num1, num2):
    len_diff = abs(len(num1) - len(num2))

    if len(num1) > len(num2):
        num2 = '0' * len_diff + num2
    else:
        num1 = '0' * len_diff + num1

    result = ''
    for i in range(len(num1)-1, -1, -1):
        digit1 = int(num1[i])
        digit2 = int(num2[i])
        sum_digits = digit1 + digit2
        result = str(sum_digits % 10) + result

    return result


# 入力を受け取る
input_str = input().rstrip()  # 入力を1行受け取り、末尾の改行を削除
num1, num2 = input_str.split()  # スペース区切りで入力を分割
result = add_with_kids_method(num1, num2)  # 繰り上がりを無視して足し算を実行
print(result)  # 結果を出力

# C062　回転寿司のメロン
# utf-8
t = int(input())  # 皿の数を取得

a = 0  # 食べたメロンの数をカウントする変数
b = 10  # 滞在時間のカウントダウン用の変数

for i in range(t):
    n = input()  # ネタを取得
    b += 1  # 滞在時間をカウントダウン
    if n == 'melon' and b > 10:  # ネタがメロンであり、滞在時間が10を超えた場合にメロンを食べる
        a += 1  # メロンの数をカウント
        b = 0  # 滞在時間をリセット

print(a)  # 結果を出力

# C063　ガーデニング
# utf-8
N = int(input())

flowers = [[int(i) for i in input().split()] for j in range(N)]
bloom_days = []
max_count = 0
max_date = 10000

for i, j in flowers:
    bloom_day = i + j
    bloom_days.append(bloom_day)

for day in bloom_days:
    count = bloom_days.count(day)
    if count > max_count or (count == max_count and day < max_date):
        max_count = count
        max_date = day

print(max_date)
'''
x リストを使用せずに、bloom_days リストに直接花が咲く日数を追加しました。
2 重の for ループを使用する代わりに、count() メソッドを使用して同じ日数の花の個数を数えました。
最大の花の個数と日数を更新する際に、max_count と max_date の比較を行い、必要に応じて更新しました。
'''

# C064　paizaでお食事
# utf-8
M, N = map(int, input().split())

c = [int(input()) for i in range(M)]
a = [list(map(int, input().split())) for i in range(N)]

for i in range(N):
    total_calories = sum([c[j-1]*a[i][j-1]//100 for j in range(1, M+1)])
    print(total_calories)

# C065　数字あてゲーム
# utf-8
def find_unique_integer(N, hints):
    nums = set(range(1, 101))

    for hint in hints:
        op = hint[0]
        num = hint[1]
        temp = set()

        if op == '>':
            for i in nums:
                if i > num:
                    temp.add(i)
        elif op == '<':
            for i in nums:
                if i < num:
                    temp.add(i)
        elif op == '/':
            for i in nums:
                if i % num == 0:
                    temp.add(i)

        nums = temp

    return nums.pop()


# 入力の読み込み
N = int(input())
hints = []
for i in range(N):
    hint = input().split()
    hints.append((hint[0], int(hint[1])))

# 一意の正整数を探す
result = find_unique_integer(N, hints)
print(result)

# C066　金魚すくい
# utf-8
M, N, X = map(int, input().split())
w = [int(input()) for _ in range(M)]
c = 0
d = 0
while True:
    if N <= 0:
        break
    if len(w) == d:
        break
    p = X
    N -= 1
    while len(w) > d:
        k = w[d]
        p -= k
        if p <= 0:
            break
        c += 1
        d += 1
print(c)
'''
入力から金魚の数M、ポイの数N、ポイの耐久値Xを取得し、金魚の重量wをリストに格納します。そして、ループを使ってポイを使って金魚をすくいます。
内側のループでは、ポイの耐久値Xを金魚の重量w[d]で減らしていきます。ポイの耐久値が0以下になった場合、そのポイではもう金魚をすくうことができないので、内側のループを抜けます。また、ポイで金魚をすくった場合、すくった金魚の数cを1増やし、金魚の重量wとポイのインデックスdを1増やします。
外側のループでは、ポイの数Nが0になるか、金魚の重量wのインデックスdが金魚の数Mに達するまでループを繰り返します。最終的にすくった金魚の数cを出力します。
'''

# C067　数字の調査
# utf-8
def binary_digit_check(N, X, k):
    # Xを2進数に変換し、0bを除いた2進数文字列に変換する
    binary = bin(X)[2:]
    # binaryの先頭に0を追加して、指定された桁が存在しない場合に備える
    binary = '0' + binary

    result = []
    for ki in k:
        # 指定された桁の値を判定し、0ならFalse、1ならTrueを追加する
        result.append(binary[-int(ki)] == '1')

    return result

# 入力の受け取り
N, X = map(int, input().split())
k = [int(input()) for _ in range(N)]

# プログラムの実行
result = binary_digit_check(N, X, k)

# 結果の出力
for res in result:
    print(int(res))

# C068　秘密の手紙
# utf-8
def decrypt(ciphertext, N):
    # アルファベットのリストを作成
    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    # 復号結果を格納する変数を初期化
    plaintext = ''
    # 暗号文の文字を順番に処理
    for i in range(len(ciphertext)):
        # 文字が奇数番目の場合
        if i % 2 == 0:
            # アルファベットを逆方向に N 文字ずらす
            shifted_char = alphabet[(alphabet.index(ciphertext[i]) - N) % 26]
        # 文字が偶数番目の場合
        else:
            # アルファベットを順方向に N 文字ずらす
            shifted_char = alphabet[(alphabet.index(ciphertext[i]) + N) % 26]
        # 復号結果に追加
        plaintext += shifted_char
    return plaintext

# ずらした文字数 N を入力から取得
N = int(input())
# 暗号文を入力から取得
ciphertext = input().rstrip()
# 元に戻された文字列を取得
plaintext = decrypt(ciphertext, N)
# 復号結果を出力
print(plaintext)

# C069　お祭りの日付
# utf-8
def is_leap_year(year):
    if year % 4 == 1:
        return True
    else:
        return False

def days_in_month(month, leap_year=False):
    if month % 2 == 0:
        return 15
    else:
        return 13

def days_until_next_paiza_festival(y, m, d, a, b):
    if m % 2 == 0:
        c = 15 - d
    else:
        c = 13 - d
    m += 1

    while not is_leap_year(y):
        c += days_in_month(m)
        m += 1
        if m == 14:
            m = 1
            y += 1

    for i in range(1, a):
        c += days_in_month(i)

    if a % 2 == 0:
        c += b
    else:
        c += b

    return c

# 1行目の入力を受け取る
y, m, d = map(int, input().split())

# 2行目の入力を受け取る
a, b = map(int, input().split())

# 入力値の範囲チェック
if not (1 <= y <= 10000) or not (1 <= m <= 13) or not (1 <= d <= days_in_month(m)) or not (1 <= a <= 13) or not (1 <= b <= days_in_month(a)):
    print("入力値が範囲外です。")
elif y % 4 == 1:
    print("入力値 y は 4 で割った余りが 1 になることはありません。")
else:
    # パイーザ祭の開催日までの日数を計算
    days = days_until_next_paiza_festival(y, m, d, a, b)

    # 結果の出力
    print(days, end="\n")

# C070　簡易カードゲーム
# utf-8
N = int(input())
for i in range(N):
    k = input()
    pair = 0
    for j in range(9):
        kazu = k.count(str(j+1))
        if kazu == 4:
            print('Four Card')
            pair = -1
            break
        elif kazu == 3:
            print('Three Card')
            pair = -1
            break
        elif kazu == 2:
            pair += 1
    if pair == 2:
        print('Two Pair')
    elif pair == 1:
        print('One Pair')
    elif pair == 0:
        print('No Pair')
--------------------------------------------- C071　※欠番 ◆
# C071　直角三角形
'''
直角三角形の二辺の長さについて　Mより小さい底辺, Nより小さい高さを持つ
全ての辺の長さは整数
斜辺も整数である直角三角形の個数を求める
例: 10 10の時 4   (10-8-6,10-6-8,5-3-4,5-4-3の4組)
例: 20 20の時 12  (13-12-5, 13-5-12, 10-8-6, 10-6-8, 5-3-4, 5-4-3, 17-15-8, 17-8-15, 
15-12-9, 15-9-12, 20-16-12, 20-12-16の12組)
'''

def count_right_angle_triangles(M, N):
    def pm(a, b):
        return min(M // a, N // b) + min(M // b, N // a)

    count = 0
    count += pm(3, 4)
    count += pm(5, 12)
    count += pm(7, 24)
    count += pm(8, 15)
    count += pm(20, 21)

    return count

# 入力を取得
M, N = map(int, input().split())

# 直角三角形の個数を計算
count = count_right_angle_triangles(M - 1, N - 1)  # M, N を修正

# 結果を出力
print(count)

# C072　モンスターの進化
# utf-8
ATK, DEF, AGI = (int(x) for x in input().split())
N = int(input())
List = []
for i in range(N):
    List.append(input().split())

flag = 0
for l in List:
    name = l[0]
    MINATK, MAXATK, MINDEF, MAXDEF, MINAGI, MAXAGI = int(
        l[1]), int(l[2]), int(l[3]), int(l[4]), int(l[5]), int(l[6])
    if MINATK <= ATK and ATK <= MAXATK and MINDEF <= DEF and DEF <= MAXDEF and MINAGI <= AGI and AGI <= MAXAGI:
        flag = 1
        print(name)

if flag == 0:
    print('no evolution')
    
# C073　うさぎとかめ
# utf-8
# 入力を受け取る
L = int(input())    # 2匹が走る距離を表す整数 L
u, a, b = map(int, input().split())    # うさぎの速さと休憩のハンデを表す整数 u, a, b
v = int(input())    # かめの速さを表す整数 v

# うさぎとかめの総走行時間を計算
c = (L * u) + (((L // a) - ((L % a) == 0)) * b)    # うさぎの総走行時間
d = L * v    # かめの総走行時間

# 総走行時間を比較して結果を出力
if c < d:
    print('USAGI')    # うさぎが先にゴールする場合
elif c > d:
    print('KAME')    # かめが先にゴールする場合
else:
    print('DRAW')    # 引き分けの場合
'''
与えられた条件に基づいて、うさぎとかめが競走し、どちらが先にゴールするかを判定するプログラムです。
まず、input() 関数を使って、入力値を受け取ります。L は競走する距離を表し、u、a、b、v はそれぞれうさぎとかめの速さや休憩のハンデを表します。
次に、うさぎとかめの総走行時間を計算します。うさぎの総走行時間 c は、L に u を掛けた値に、L を a で割った商に b を掛けた値を加えたものです。
この計算により、うさぎが L km 走るごとに b 分の休憩を取ることが考慮されます。
かめの総走行時間 d は、L に v を掛けた値です。
そして、if 文を使って、うさぎとかめの総走行時間を比較し、結果を出力します。
c が d より小さい場合は、うさぎが先にゴールすると判定されて 'USAGI' が出力されます。c が d より大きい場合は、かめが先にゴールすると判定されて 'KAME' が出力されます。
c と d が等しい場合は、引き分けとして 'DRAW' が出力されます。
このように、与えられた条件を考慮して、うさぎとかめの総走行時間を比較することで、どちらが先にゴールするかを判定しています。
'''
# C074　文章サイズ変更
# utf-8
# 入力を受け取る
H, W, X = map(int, input().split())
s = []
for i in range(H):
    s.append(input().rstrip())

# 文字列を結合して一つの文字列にする
s = ''.join(s)

# 文字列を X 文字ごとに分割し、リストに格納する
s_list = [s[i:i+X] for i in range(0, len(s), X)]

# 出力文字列を作成する
output = ''
for i in range(len(s_list)):
    output += s_list[i] + '\n'

# 最終的な出力文字列を出力する
print(output.rstrip())
'''
入力された文字列を改行文字を除いて一つの文字列に結合します。
文字列を X 文字ごとに分割し、リストに格納します。
リストをループで回しながら、各要素に改行文字を追加し、出力文字列を作成します。
最終的な出力文字列を出力します。
'''
    
# C075　ポイント払い
# utf-8
# 入力を受け取る
N, M = map(int, input().split(' '))
fare_list = list()

# バスの運賃を入力してリストに格納
for i in range(M):
    fare = int(input())
    fare_list.append(fare)

point = 0
for fare in fare_list:
    if point >= fare:
        point -= fare
    else:
        N -= fare
        point += fare * 0.1

    # カード残高とポイントを出力
    print(N, int(point))
    
# C076　給与の計算
# utf-8
x,y,z = map(int, input().split())
n=int(input())
ans=0
for i in range(n):
    s,e=map(int, input().split())
    t=e-s
    s1,e1=0,0
    if 9<=s<17:
        s1=s
    elif s<9 and e>9:
        s1=9
    if 9<e<=17 and e>s:
        e1=e
    elif e>17 and s<17:
        e1=17
    t1=e1-s1
    s1,e1=0,0
    if 17<=s<22:
        s1=s
    elif s<17 and e>17:
        s1=17
    if 17<e<=22 and e>s:
        e1=e
    elif e>22 and s<22:
        e1=22
    t2=e1-s1
    ans=ans+(t1)*x + (t2)*y + (t-t1-t2)*z
print(ans)
'''
与えられた通常の時給、夜の時給、深夜の時給、および出勤日数に基づいて、労働時間に応じた給料の合計金額を計算するものです。
まず、入力値を取得します。通常の時給、夜の時給、深夜の時給は整数として取得し、出勤日数は整数として取得します。また、出勤日数分の出勤時刻と退勤時刻をリストとして取得します。
次に、1 時間単位の労働時間を計算するための関数 calculate_work_hours を定義します。
この関数は、出勤時刻と退勤時刻を受け取り、労働時間を計算します。
具体的には、出勤時刻と退勤時刻がそれぞれ 17 時以降にある場合は出勤時刻と退勤時刻の差を、出勤時刻が 17 時以降で退勤時刻が 17 時以前の場合は出勤時刻から 17 時までの時間を、
出勤時刻が 17 時以前で退勤時刻が 17 時以降の場合は退勤時刻から 17 時までの時間を、それ以外の場合は労働時間を 0 時間として返します。
その後、合計給料を初期化します。
出勤日数分のループを行い、各日の労働時間を calculate_work_hours 関数を呼び出して計算します。
労働時間が 8 時間であれば通常の時給を適用し、それ以外の場合は夜の時給と深夜の時給を適用して合計給料に加算します。
最後に、合計給料を出力します。
'''

# C077　レポートの評価
def evaluate_report(k, n, submissions):
    scores = []
    for i in range(k):
        d_i, a_i = submissions[i]
        if d_i == 0:
            score = (a_i * 100 // n)
        elif d_i < 0:
            score = (a_i * 100 // n)
        elif d_i <= 9:
            score = (0.8 * a_i * 100 // n)
        else:
            score = 0

        scores.append(score)

    results = []
    for score in scores:
        if score >= 80:
            results.append('A')
        elif score >= 70:
            results.append('B')
        elif score >= 60:
            results.append('C')
        else:
            results.append('D')

    return results

# 入力の受け取り
k, n = map(int, input().split())
submissions = []
for i in range(k):
    d_i, a_i = map(int, input().split())
    submissions.append([d_i, a_i])

# レポートの評価を計算
results = evaluate_report(k, n, submissions)

# 結果を出力
for result in results:
    print(result)

# C078　株の売買
# utf-8
# 入力値の取得
N, c1, c2 = map(int, input().split())
prices = []
for _ in range(N):
    prices.append(int(input()))

# 初期設定
stocks = 0
total_profit = 0

# N日間の売買ルールに従って処理
for i in range(N):
    # 株価がc1円以下の場合、1株買う
    if prices[i] <= c1:
        stocks += 1
    # 株価がc2円以上の場合、持ち株をすべて売る
    elif prices[i] >= c2:
        total_profit += stocks * prices[i]
        stocks = 0
    # 株価がc1円とc2円の間の場合は何もしない
    # N日目には、持ち株をすべて売る
    elif i == N - 1:
        total_profit += stocks * prices[i]
        stocks = 0

# 残った持ち株を売った後の損益を計算
total_profit -= stocks * c1

# 結果を出力
print(total_profit)

# C079　カードを集める
# utf-8
# 入力の受け取り
N, M = map(int, input().split()) # N: カードの枚数, M: カードの種類数
cards = set() # 開封したカードの種類を格納するset

# カードを開封して全種類が揃った回数をカウント
for i in range(N):
    card = int(input()) # カード番号を受け取る
    cards.add(card) # カードをsetに追加
    if len(cards) == M: # カードの種類数が全種類になったらループを抜ける
        print(i + 1) # 全種類が揃った回数を出力
        exit()

# カードを全て開封しても全種類が揃わなかった場合はunluckyを出力
print("unlucky")

# C080　ボタンを押すゲーム
# utf-8
# 入力を受け取る
N, Y = map(int, input().split())
M = int(input())
log = list(map(int, input().split()))

# 正しいボタンを押した回数をカウントする変数
correct_count = 0
# 誤ったボタンを押した回数をカウントする変数
wrong_count = 0
# 直前に押されたボタンの番号を保持する変数
prev_button = 1

# 操作ログを順に処理する
for button in log:
    # ボタンが正しい場合
    if button == prev_button:
        correct_count += 1
    # ボタンが誤った場合
    else:
        wrong_count += 1
    prev_button = button

# スコアの計算
score = correct_count * 1000

# 誤ったボタンを押した回数がゲームオーバーの回数以上の場合、スコアを-1にする
if wrong_count >= Y:
    score = -1

# スコアの出力
print(score)

--------------------------------------------- C081　※欠番 ◆
# C081　靴下の整理
# utf-8
# 靴下の数を取得
N = int(input())

# 靴下の情報を辞書に格納
socks = {}
for i in range(N):
    t, d = input().split()
    key = t  # 種類のみをキーとする
    if key in socks:
        socks[key].append(d)  # 左右の情報をリストとして追加
    else:
        socks[key] = [d]  # 新しいキーを作成して左右の情報をリストとして格納

# 同じ種類の靴下で左右が揃っているペアの数を計算
pairs = 0
for key in socks:
    # 同じ種類の靴下が2つ以上ある場合、左右が揃っているペアとしてカウント
    if len(socks[key]) >= 2 and 'L' in socks[key] and 'R' in socks[key]:
        pairs += min(socks[key].count('L'), socks[key].count('R'))

# 結果を出力
print(pairs)
'''
# 靴下の数を取得
N = int(input())

# 靴下の情報を辞書に格納
socks = {}
for i in range(N):
    t, d = input().split()
    key = t  # 種類のみをキーとする
    if key in socks:
        socks[key].append(d)  # 左右の情報をリストとして追加
    else:
        socks[key] = [d]  # 新しいキーを作成して左右の情報をリストとして格納

# 同じ種類の靴下で左右が揃っているペアの数を計算
pairs = 0
for key in socks:
    # 同じ種類の靴下が2つ以上ある場合、左右が揃っているペアとしてカウント
    if len(socks[key]) >= 2 and 'L' in socks[key] and 'R' in socks[key]:
        pairs += min(socks[key].count('L'), socks[key].count('R'))

# 結果を出力
print(pairs)

'''

# C082　テストの赤点
# utf-8
def count_red_points(X, Y, scores):
    # 各生徒の赤点科目の数を格納するリスト
    red_points = []

    # 各生徒の赤点科目の数を計算
    for i in range(X):
        count = 0
        for j in range(X):
            if i != j:
                # i番目の生徒の点数がj番目の生徒よりも低い場合にカウント
                if scores[i][0] <= scores[j][0] and scores[i][1] <= scores[j][1] and scores[i][2] <= scores[j][2]:
                    count += 1
        red_points.append(count + 1)  # 下から1位なので1を足す

    return red_points


# 入力を受け取る
X, Y = map(int, input().split())

# 入力値のチェック
if not (2 <= X <= 100):
    print("Error: 2 ≦ X ≦ 100 の条件を満たしていません。")
    exit(1)
if not (1 <= Y <= X):
    print("Error: 1 ≦ Y ≦ X の条件を満たしていません。")
    exit(1)

scores = []
for i in range(X):
    E, J, M = map(int, input().split())
    if not (0 <= E <= 100 and 0 <= J <= 100 and 0 <= M <= 100):
        print("Error: 0 ≦ E_i, J_i, M_i ≦ 100 の条件を満たしていません。")
        exit(1)
    scores.append((E, J, M))

# 赤点科目の数を計算
red_points = count_red_points(X, Y, scores)

# 結果を出力
for rp in red_points:
    print(rp)
'''
まず、XとYの値が条件を満たしているかをチェックしています。
Xは2以上100以下である必要があり、Yは1以上X以下である必要があります。
もし条件を満たしていない場合には、エラーメッセージを出力し、exit(1)によってプログラムを終了しています。
次に、scoresというリストに生徒の点数をタプル(E, J, M)の形で格納しています。
そして、各生徒の赤点科目の数を計算するためのcount_red_points()関数を呼び出しています。
count_red_points()関数では、scoresリストから生徒の点数を取り出し、各生徒について他の生徒と比較して赤点科目の数を数えています。
条件を満たす場合には、カウントをインクリメントしています。最終的に、赤点科目の数を格納したリストred_pointsを返します。
最後に、red_pointsリストの各要素を出力しています。
このように修正済みのコードでは、入力値が問題の条件を満たしているかをチェックして、
満たしていない場合にはエラーメッセージを出力し、プログラムを終了するようになっています。
これにより、正しい条件下でのみプログラムが実行されるようになります。
'''

# C083　売上の発表
# utf-8
# 入力の受け取り
N, R = map(int, input().split())  # N, Rを受け取る
sales = []  # 売上データを格納するリスト
for i in range(N):
    a = int(input())  # 売上データを受け取る
    sales.append(a)

# 最大売上データの計算
max_sales = max(sales)

# 棒グラフの生成
for i in range(N):
    bar_length = sales[i] // R  # 棒の長さを計算
    bar = '*' * bar_length + '.' * (max_sales // R - bar_length)  # "*"と"."を組み合わせて棒グラフを生成
    print(f"{i + 1}:{bar}")  # 棒グラフを出力
'''
まず、入力として N と R を受け取ります。N は売上データの個数を表し、R はデータの表示単位を表します。
map() 関数を使って入力された値をスペースで区切って int 型に変換して取得します。
また、sales という空のリストを作成し、売上データをそのリストに追加します。
sales リストの中から最大の売上データを max() 関数を使って計算し、max_sales という変数に格納します。
for ループを使って売上データの個数 N 回分繰り返します。各期の売上データを sales リストから取得し、
R で割って bar_length という変数に格納します。これは、その期の棒グラフの長さを表します。
次に、'*' と '.' を組み合わせて、棒グラフを生成します。'*' の数は bar_length であり、
残りのスペースを '.' で埋めるために、max_sales // R - bar_length の数だけ '.' を並べます。
最後に、print() 関数を使って、期と棒グラフを出力します。f-string を使って、期を i + 1 で表示し、
棒グラフを bar で表示します。
以上の処理を通じて、期待する出力の形式で売上の棒グラフを生成し、出力することができます。
'''

# C084　枠で囲む
# utf-8
# 入力を受け取る
S = input().rstrip()

# 枠で囲んで装飾した文字列を生成
decorated_string = "+" * (len(S) + 2) + "\n"
decorated_string += "+" + S + "+" + "\n"
decorated_string += "+" * (len(S) + 2) + "\n"

# 結果を出力
print(decorated_string, end='')

# C085　壊れかけのキーボード
# utf-8
# 入力を受け取る
t = list(map(int, input().split()))
S = input()

# 出力文字列を初期化
output_str = ""

# 入力された文字列を一文字ずつ処理
for char in S:
    # 文字に対応するキーの耐久度を取得
    durability = t[ord(char) - ord('a')]
    
    # キーの耐久度を減らす
    durability -= 1
    
    # キーの耐久度が0以上の場合、出力文字列に追加
    if durability >= 0:
        output_str += char
        
    # キーの耐久度を更新
    t[ord(char) - ord('a')] = durability

# 出力文字列を表示
print(output_str)

# C086　ハンドルネームの生成
# utf-8
# 名前を入力
S = input().rstrip()

# 母音を除去して子音のみを連結して生成
handle_name = "".join(c for c in S if c not in "aeiouAEIOU")

# ハンドルネームを出力
print(handle_name)

# C087　数字の規則
# utf-8
def is_palindrome(n):
    # 数字が回文数かどうかを判定する関数
    s = str(n)
    return s == s[::-1]

def reverse_and_add(n):
    # 規則に従って数字を反転し足し算を行う関数
    return n + int(str(n)[::-1])

# 入力を受け取る
N = int(input())

while True:
    # 規則に従って計算を繰り返し、回文数が出現するまで続ける
    N = reverse_and_add(N)
    if is_palindrome(N):
        print(N)
        break
'''
この実装では、is_palindrome関数で与えられた数字が回文数かどうかを判定し、reverse_and_add関数で数字を反転し足し算を行います。
入力された数字に対してこれらの関数を繰り返し適用し、最初に回文数が出現したらそれを出力して終了します。
'''

# C088　RPGでお買い物
# utf-8
# 道具の個数を取得
N = int(input())

# 道具の単価を取得
prices = list(map(int, input().split()))

# 初期の所持金と注文回数を取得
T, Q = map(int, input().split())

# 注文履歴を取得
orders = []
for _ in range(Q):
    order = list(map(int, input().split()))
    orders.append(order)

# 残金を計算
remaining_money = T
for order in orders:
    item_idx = order[0] - 1
    item_price = prices[item_idx]
    item_quantity = order[1]
    total_cost = item_price * item_quantity
    if remaining_money >= total_cost:
        remaining_money -= total_cost

# 残金を出力
print(remaining_money)

'''
与えられた入力に基づいて、所持金を管理し、注文を処理して最終的な所持金を計算するプログラムです。
まず、入力された情報を適切に変数に格納します。例えば、道具の個数を表す整数Nは N に、各道具の単価を表す整数のリストは prices に格納されます。
また、最初の所持金を表す整数Tは T に、注文回数を表す整数Qは Q に格納されます。
次に、各注文の情報を処理して所持金を更新していきます。Q 回のループを回して、各注文の情報を取得し、注文の個数を所持金と比較して、
所持金が足りない場合は注文をキャンセルします。
最終的に、所持金の値を出力してプログラムの実行を終了します。
具体的な処理の流れは以下のようになります。

入力された情報を変数に格納する。
Q 回のループを回して、各注文の情報を取得する。
注文の個数と道具の単価を掛けて、所持金と比較する。
所持金が足りない場合は注文をキャンセルし、足りている場合は所持金を更新する。
全ての注文を処理し終えた後の所持金の値を出力する。
'''

# C089　ストラックアウト
# utf-8
# 入力を受け取る
H, W = map(int, input().split())
s = [input().rstrip() for _ in range(H)]
p = [list(map(int, input().split())) for _ in range(H)]

# 撃ち抜かれたパネルの得点を合計する
total_score = 0
for i in range(H):
    for j in range(W):
        if s[i][j] == "o":  # "o"は撃ち抜かれた状態を表す
            total_score += p[i][j]

# 結果を出力
print(total_score)
'''
入力されたHとWに基づいて、sとpのリストを作成します。
sはゲーム終了時のパネルの状態を示す文字列のリストで、pは各パネルの得点を示す整数のリストです。
それぞれのi行j列のパネルについて、sが"o"であれば撃ち抜かれたので、対応するpの得点をtotal_scoreに加算します。
最終的にtotal_scoreを出力します。
'''

# C090　黒電話
# utf-8
def calculate_dial_distance(phone_number):
    pho_dic = {"0": 12, "1": 3, "2": 4, "3": 5, "4": 6,
               "5": 7, "6": 8, "7": 9, "8": 10, "9": 11}
    dial_distance = 0
    for digit in phone_number:
        if digit.isdigit():
            dial_distance += pho_dic[digit]
    return dial_distance * 2

# 電話番号の入力
S = input().strip().replace("-", "")

# ダイヤルが回る必要のある総距離を計算
dial_distance = calculate_dial_distance(S)

# 総距離を整数で出力
print(dial_distance)
'''
def calculate_dial_distance(phone_number):
電話番号の文字列を引数として受け取り、ダイヤルが回る必要のある総距離を計算する関数です。

pho_dic = {"0": 12, "1": 3, "2": 4, "3": 5, "4": 6, "5": 7, "6": 8, "7": 9, "8": 10, "9": 11}:
数字に対するダイヤル回転距離の辞書を定義します。例えば、数字 "0" の場合は 12 が対応しています。

dial_distance = 0:
ダイヤルが回る必要のある総距離を初期化します。

for digit in phone_number::
電話番号の各文字を順に取り出してループします。

if digit.isdigit(): dial_distance += pho_dic[digit]:
文字が数字であれば、対応するダイヤル回転距離を dial_distance に加算します。

return dial_distance * 2:
ダイヤルが回る必要のある総距離を計算し、その値を返します。

S = input().strip().replace("-", ""):
入力された電話番号を受け取り、不要な空白文字を削除し、ハイフンを除去して S に代入します。

dial_distance = calculate_dial_distance(S):
S を引数として calculate_dial_distance 関数を呼び出し、ダイヤルが回る必要のある総距離を計算し、dial_distance に代入します。

print(dial_distance):
計算されたダイヤル回転距離を整数として出力します。
'''
--------------------------------------------- C091　※欠番 ◆
# C091　みかんの仕分け
# utf-8
def classify_oranges(weight, num_oranges, oranges):
    # 仕分け先の重さを格納するリスト
    class_weights = []

    # 仕分け先の重さを計算してリストに追加
    for i in range(1, num_oranges + 1):
        class_weight = weight * i
        class_weights.append(class_weight)

    # 各みかんの仕分け先の重さを計算して出力
    for orange in oranges:
        if orange <= weight:
            print(weight)
        elif orange % weight < weight / 2:
            print(orange // weight * weight)
        else:
            print((orange // weight + 1) * weight)


# 入力の受け取り
N, M = map(int, input().split())
weight = N
num_oranges = M
oranges = [int(input()) for i in range(num_oranges)]

# みかんを仕分ける
classify_oranges(weight, num_oranges, oranges)

# C092　工場のベルトコンベア
# utf-8
nab_list = list(input().split())
s_N = input()
s_A = input()
s_B = input()

N = int(nab_list[0])
A = int(nab_list[1])
B = int(nab_list[2])

for n in range(N):
    if A > 0 and s_A[0] == s_N[n]:
        s_A = s_A[1:]
        A -= 1

    if B > 0 and s_B[0] == s_N[n]:
        s_B = s_B[1:]
        B -= 1

print(A, B)

# C093　下桁ルール
# utf-8
# ボブの期末テストの点数とアリスの期末テストの点数を入力から取得
X, Y = input().split()

# 各位の数を足した数の一の位を計算
bob_digit_sum = sum(map(int, str(int(X)))) % 10
alice_digit_sum = sum(map(int, str(int(Y)))) % 10

# 勝敗を判定
if bob_digit_sum > alice_digit_sum:
    print("Bob")
elif bob_digit_sum < alice_digit_sum:
    print("Alice")
else:
    print("Draw")

# C094　国民の税金
# utf-8
def calculate_tax(income):
    if income <= 100000:
        return 0  # 0 ~ 100,000に対しては税金がかかりません
    elif income <= 750000:
        return int((income - 100000) * 0.1)  # 100,001 ~ 750,000に対しては10%の税率がかかります
    elif income <= 1500000:
        return int((income - 750000) * 0.2 + 650000 * 0.1)  # 750,001 ~ 1500,000に対しては20%の税率がかかります
    else:
        return int((income - 1500000) * 0.4 + 750000 * 0.2 + 650000 * 0.1)  # それ以上に対しては40%の税率がかかります

# 入力の受け取り
N = int(input())  # PAIZA 国民の人数を受け取る
incomes = []  # 各人の所得を格納するリストを初期化

# 各人の所得を受け取り、リストに追加
for i in range(N):
    x_i = int(input())  # i 番目の人の所得を受け取る
    incomes.append(x_i)

# 各人の所得に対して税金を計算し、合計を計算
total_tax = sum(calculate_tax(income) for income in incomes)

# 税金の合計を出力
print(total_tax)

# C095　合言葉
# utf-8
# 入力を取得
s = input().rstrip()
t = input().rstrip()

# 文字列tを並び替えてsができるかをチェックし、一致する場合はNOを出力、それ以外はYESを出力
if sorted(s) == sorted(t) and s != t:
    print("YES")
else:
    print("NO")
'''
入力された文字列sとtを取得し、末尾の改行文字を除去します。
sorted() 関数を使って、文字列sとtをソートします。ソートされた結果が同じであり、かつsとtが一致していない場合、
tを並び替えてsができると判定し "YES" を出力します。
上記の条件に該当しない場合は、tがsと一致するか、tを並び替えてsができない場合であるため、 "NO" を出力します。
'''

# C095　バスの時間(番号ダブり)
# utf-8
# 入力の読み込み
N, K = map(int, input().split())
bus_times = []
for _ in range(N):
    bus_time = int(input())
    bus_times.append(bus_time)

# K 分後に最も近いバスの時間を求める
nearest_buses = []
min_diff = float('inf')

for time in bus_times:
    diff = abs(K - time)
    if diff < min_diff:
        min_diff = diff
        nearest_buses = [time]
    elif diff == min_diff:
        nearest_buses.append(time)

# 最も近いバスの時間を時間の昇順でソート
nearest_buses.sort()

# 結果の出力
for bus in nearest_buses:
    print(bus)
'''
入力の読み込み: 最初に N と K を入力として読み込みます。N はバスの時間帯の数を表し、K は K 分後を表します。
次に、N 回のループでバスの時間帯を入力として読み込み、bus_times というリストに格納しています。
K 分後に最も近いバスの時間を求める: bus_times に格納されたバスの時間帯ごとに、K 分後に最も近い時間を計算します。
これには、min_diff という変数を用意し、初期値を正の無限大に設定します。
次に、bus_times の各要素 time について、abs(K - time) を計算し、K との差分を絶対値で求めます。この差分を diff として取得し、
diff が min_diff より小さければ、min_diff を diff に更新し、nearest_buses を time で初期化します。
また、diff が min_diff と等しい場合には、nearest_buses に time を追加します。
最も近いバスの時間を時間の昇順でソート: 最も近いバスの時間を格納した nearest_buses を時間の昇順でソートします。これには sort() メソッドを使用しています。
結果の出力: ソートされた nearest_buses の各要素を順に出力します。
これにより、K 分後に最も近いバスの時間を 2 行で時間の昇順に出力することができます。
以上の手順を経て、このコードは K 分後に最も近いバスの時間を求め、時間の昇順に出力する処理を行っています。
'''
# C096　夏休み
# utf-8
# 入力の読み込み
N = int(input())  # メンバーの人数
s_e_list = [list(map(int, input().split())) for _ in range(N)]  # メンバーの休みを取れる期間の入力

# 休みの共通日を探す
common_days = set(range(1, 32))  # 1～31の整数を集合として初期化
for s, e in s_e_list:
    # 各メンバーの休みを取れる期間を集合に変換し、共通日を求める
    days = set(range(s, e + 1))
    common_days &= days

# 出力
if common_days:
    print("OK")
else:
    print("NG")
'''
この問題は、複数のメンバーの休みの期間を比較し、共通する日があるかどうかを判定する問題です。
まず、入力された休みの期間をそれぞれのメンバーごとに集合に変換します。
集合は重複を許さず、要素の順序は関係ありません。これにより、各メンバーの休みの期間を簡単に比較できるようになります。
次に、各メンバーの休みの期間の共通部分を求めるために、集合の積集合を計算します。
集合の積集合は、共通する要素のみを残す演算です。ここで、集合の要素は日付を表しており、
共通する日付がある場合はその日付が残ります。最終的に、共通する日付があるかどうかを判定します。
共通する日付があれば "OK"、なければ "NG" を出力します。
この解答は、入力された休みの期間を集合として扱い、集合の演算を用いて共通する日付を効率的に求めています。
'''
# C097　プレゼント応募企画の実施
# utf-8
def present_lottery(N, X, Y):
    result = []
    for i in range(1, N+1):
        if i % X == 0 and i % Y == 0:
            result.append("AB")
        elif i % X == 0:
            result.append("A")
        elif i % Y == 0:
            result.append("B")
        else:
            result.append("N")
    return result

# 入力の読み込み
N, X, Y = map(int, input().split())

# 当選情報の計算
result = present_lottery(N, X, Y)

# 当選情報の出力
for res in result:
    print(res)

# C098　多重パス回し
# utf-8
# 人数Nの入力
N = int(input())

# 人ごとの最初のボールの個数の入力
s = []
for i in range(N):
    s_i = int(input())
    s.append(s_i)

# パス回しの情報の数Mの入力
M = int(input())

# パス回しの情報の入力と処理
for i in range(M):
    a_i, b_i, x_i = map(int, input().split())
    # パスする相手が持っているボールの個数を計算
    pass_balls = min(s[a_i-1], x_i)
    # ボールをパス
    s[a_i-1] -= pass_balls
    s[b_i-1] += pass_balls

# 最終的なボールの個数を出力
for i in range(N):
    print(s[i])
'''
まず、最初に人数Nを入力し、各人の最初のボールの個数をリストsに格納します。
次に、パス回しの情報の数Mを入力し、各パス回しの情報を処理していきます。
パス回しの情報は、a_i, b_i, x_iの3つの整数で与えられます。
a_iはボールをパスする人のインデックス（1からNまでの整数）、
b_iはボールを受け取る人のインデックス（1からNまでの整数）、x_iはパスするボールの個数を表します。
パスする相手が持っているボールの個数は、min(s[a_i-1], x_i)で計算されます。
これは、パスする人a_iが持っているボールの個数s[a_i-1]と、パスするボールの個数x_iのうち、小さい方を取得しています。
これは、パスする相手に渡すことができる最大のボールの個数を計算するためです。
その後、s[a_i-1]からpass_ballsを減算し、s[b_i-1]にpass_ballsを加算することで、ボールのパスをシミュレーションしています。
最終的に、各人の持っているボールの個数がリストsに格納されているので、それを順番に出力することで、最終的なボールの個数を求めることができます。
'''

# C099　折り紙の貼り合わせ
# utf-8
def calculate_banner_area(N, D, overlaps):
    total_area = D * D  # 最初の折り紙の面積

    for i in range(1, N):
        overlap = overlaps[i - 1]  # i番目の折り紙の重なり具合
        width = D - overlap  # 垂れ幕の横幅
        height = D  # 垂れ幕の縦幅
        area = width * height  # 折り紙の面積
        total_area += area  # 面積を合計

    return total_area

# 入力の取得
N, D = map(int, input().split())  # N: 折り紙の枚数、D: 折り紙の初期の辺の長さ
overlaps = [int(input()) for _ in range(N - 1)]  # 折り紙の重なり具合の入力

# 垂れ幕の面積の計算
banner_area = calculate_banner_area(N, D, overlaps)

# 結果の出力
print(banner_area)
'''
与えられた入力に対して垂れ幕の面積を計算する関数 calculate_banner_area を定義しています。
この関数では、最初の折り紙の面積を total_area として初期化し、2枚目以降の折り紙については、
直前の折り紙との重なり具合を overlap として取得し、それを用いて垂れ幕の横幅 width を計算しています。
垂れ幕の縦幅は初期の辺の長さ D となります。折り紙の面積は width * height で計算し、
それを total_area に加算していくことで、垂れ幕の面積を計算しています。
最後に、入力を受け取り、垂れ幕の面積を計算して結果を出力しています。
'''

# C100　選曲の方法
# utf-8
def max_songs(N, M, S, songs):
    total_time = M * 60 + S  # 持ち時間を秒に変換
    songs.sort()  # 曲を時間順にソート
    count = 0  # 流すことのできる曲の数をカウントする変数
    for song in songs:
        if total_time >= song[0] * 60 + song[1]:
            total_time -= song[0] * 60 + song[1]
            count += 1
        else:
            break  # 持ち時間を超えたらループを終了
    return count

# 入力の読み込み
N, M, S = map(int, input().split())
songs = []
for i in range(N):
    x, y = map(int, input().split())
    songs.append((x, y))

# 結果の出力
print(max_songs(N, M, S, songs))

--------------------------------------------- C101　※欠番 ◆
# C101　ラッキーデイ
# utf-8
# 入力を受け取る
X = int(input())

# 1年の日数
days_in_year = 365

# 幸運な日の数をカウントする変数
lucky_days = 0

# 1月1日から12月31日までの各日に対して、Xが含まれるか確認
for day in range(days_in_year):
    # 日数を文字列に変換してXが含まれるか確認
    if str(X) in str(day):
        lucky_days += 1

# 結果を出力
print(lucky_days)
'''
与えられた数字Xに対して、1年の中での幸運な日の数を数えるプログラムです。ユーザーから整数Xを入力として受け取ります。これが、1月1日からの経過日数に含まれていると幸運な日であると考えられる数字です。
1年の日数を365日と仮定します。幸運な日の数をカウントする変数を初期化します。1月1日から12月31日までの各日に対してループを行います。
日数を文字列に変換し、その中にXが含まれるかどうかを確認します。Xが含まれる場合、幸運な日の数を増やします。最終的な幸運な日の数を整数で出力します。
'''
# C102　行きたいライブのスケジュール
# utf-8
# 入力の取得
M = int(input())  # バンドAのライブ日数
A = [int(input()) for _ in range(M)]  # バンドAのライブ日程のリスト
N = int(input())  # バンドBのライブ日数
B = [int(input()) for _ in range(N)]  # バンドBのライブ日程のリスト

c = 0
l = ['A', 'B']
S = sorted(list(set(A + B)))
R = list()
for i in range(1, 32):
    if i in S:
        if i in A and i in B:
            R.append(l[c % 2])
            c += 1
        else:
            R.append(('B', 'A')[i in A])
    else:
        R.append('x')
print('\n'.join(R))
'''
バンドAのライブ日程をA、バンドBのライブ日程をBとして、AとBの共通日程をSに取得しています。
そして、1から31までの日程に対して以下のルールに従って出力を生成しています。
日程がSに含まれる場合：
日程がAとBの両方に含まれる場合：lリストの順番に従ってAまたはBを出力し、cを更新する。
日程がAのみに含まれる場合：Aを出力する。
日程がBのみに含まれる場合：Bを出力する。
日程がSに含まれない場合：xを出力する。
最終的に、出力を改行で結合して出力しています。
'''
# C103　ロボット芸人
# utf-8
# 入力を取得
N, M = map(int, input().split())
conditions = []
for i in range(M):
    a, b = input().split()
    conditions.append((int(a), b))

# ロボットの動きのシミュレーション
output = []
for i in range(1, N + 1):
    result = ""
    for condition in conditions:
        a = condition[0]
        b = condition[1]
        if i % a == 0:
            result += b + " "
    if result == "":
        output.append(str(i))
    else:
        output.append(result.rstrip())

# 結果を出力
for line in output:
    print(line)
'''
入力された条件に基づいてロボットの動きをシミュレーションし、期待される形式で結果を出力します。
各条件について、ロボットが条件を満たす場合には対応する文字列を、満たさない場合にはそのままの数字を出力します。
'''

# C104　虫食い算
# utf-8
def solve_bug_eaten_equation(a, b):
    al = []
    for x in range(1, 10):
        for y in range(10):
            if (10*x + y) * y == 100*a + 10*x + b:
                al.append([x, y])
    if len(al) == 0:
        return None
    else:
        return al[0]

# 入力を受け取る
a, b = map(int, input().split())

# 問題を解いて結果を出力
result = solve_bug_eaten_equation(a, b)
if result is None:
    print("No")
else:
    print(result[0], result[1])
'''
まず、solve_bug_eaten_equation という関数を定義しています。この関数は、虫食い算の条件を満たす数字のペアを探し、
その結果をリスト al に格納します。具体的には、1 から 9 までの x と 0 から 9 までの y をそれぞれのループで繰り返しながら、
以下の条件を満たす場合に x と y をリスト al に追加しています。

(10 * x + y) * y == 100 * a + 10 * x + b

この条件は、虫食い算の式を数式に置き換えたものであり、左辺が式の左側を、右辺が式の右側を表しています。
この条件を満たす x と y の組が見つかれば、それをリスト al に追加しています。
その後、リスト al の長さを確認し、リストが空であれば "No" を出力し、リストに要素があればリストの最初の要素を出力しています。
これにより、虫食い算の答えとなる数字のペアを出力しています。
最後に、a と b の入力を受け取り、先ほど定義した関数を用いて問題を解いて結果を出力しています。
修正を加えたコードは、与えられた虫食い算の条件を正確に満たし、期待する出力を生成することができます。
'''

# C105　カードのスコア
# utf-8
n = int(input())
cards = list(map(int, input().split()))
cards.sort()

groups = []
current_group = [cards[0]]
for i in range(1, n):
    if cards[i] - current_group[-1] == 1:
        current_group.append(cards[i])
    else:
        groups.append(current_group)
        current_group = [cards[i]]
groups.append(current_group)

total_score = 0
for group in groups:
    total_score += max(group)

print(total_score)
'''
与えられたカードの数字をグループに分け、各グループの最大の数字を合計して総合スコアを求める問題です。
まず、入力されたカードの数字をリストとして取得します。次に、取得したリストを昇順にソートします。
ソートすることで、カードの数字が連続しているかどうかを判定しやすくなります。
次に、1の差で連続しているカードをグループに分けます。ループを使用して、リストの要素を1つずつ見ていきます。
現在見ているカードの数字が前のカードの数字と1の差であれば、同じグループに属すると判定し、現在のグループに追加します。そうでなければ、新しいグループが始まると判定し、現在のグループをgroupsというリストに追加します。最後に、最後のグループをgroupsに追加してループを終了します。
各グループのスコアは、そのグループの最大の数字となります。ループを使用して各グループの最大の数字を取得し、total_scoreという変数に加算していきます。
最後に、total_scoreを出力することで、与えられたカードの総合スコアを求めることができます。
'''
# C106　メダル授与式
# utf-8
# 入力から取得する変数
N = int(input())  # 競技者の人数
scores = list(map(int, input().split()))  # 競技者の点数をリストとして取得

# 出力する結果を格納するリスト
medals = []

# 競技者ごとにメダルの色を判定して medals リストに追加
for i in range(N):
    if scores[i] == max(scores):
        medals.append("G")
    elif scores[i] == sorted(scores, reverse=True)[1]:
        medals.append("S")
    elif scores[i] == sorted(scores, reverse=True)[2]:
        medals.append("B")
    else:
        medals.append("N")

# 結果を出力
for medal in medals:
    print(medal)
'''
入力の受け取り
最初に、input() 関数を使って競技者の人数を表す整数 N を入力から受け取ります
。次に、input() 関数と split() メソッドを組み合わせて、半角スペースで区切られた競技者の点数を一度に取得し、リスト scores として格納します。

メダルの色の判定
次に、for ループを使って、競技者ごとにメダルの色を判定します。scores リストを順番に参照し、
以下の条件に従ってメダルの色を判定し、medals リストに追加していきます。

競技者の点数が最大値であれば、"G" (金メダル)
競技者の点数が2番目に高い値であれば、"S" (銀メダル)
競技者の点数が3番目に高い値であれば、"B" (銅メダル)
上記のいずれにも該当しない場合は、"N" (メダルなし)
結果の出力
for ループを使って medals リストの中身を順番に出力し、競技者ごとのメダルの色を表示します。
'''

# C107　ランクの計算
# utf-8
n, k = map(int, input().split())

# 各馬のN回分の順位を取得
horse_a = [int(input()) for _ in range(n)]
horse_b = [int(input()) for _ in range(n)]
horse_c = [int(input()) for _ in range(n)]

# 連続するK回分の平均値の最小値を求める関数
def calc_min_avg(horse):
    min_avg = float('inf')
    for i in range(n - k + 1):
        avg = sum(horse[i:i+k]) / k
        if avg < min_avg:
            min_avg = avg
    return min_avg

# 各馬の連続するK回分の平均値を計算
avg_a = calc_min_avg(horse_a)
avg_b = calc_min_avg(horse_b)
avg_c = calc_min_avg(horse_c)

# ランクを計算
rank_a = sum(avg_a > avg for avg in [avg_b, avg_c]) + 1
rank_b = sum(avg_b > avg for avg in [avg_a, avg_c]) + 1
rank_c = sum(avg_c > avg for avg in [avg_a, avg_b]) + 1

# ランクが最も小さい馬を出力
if rank_a < rank_b and rank_a < rank_c:
    print(1)
elif rank_b < rank_a and rank_b < rank_c:
    print(2)
else:
    print(3)

'''
この問題は、与えられたデータに対して順位の平均値を求めることが求められているので、
以下のようなアルゴリズムで解くことができます。

各馬の順位を入力として受け取る
1位からK位までの順位の平均値を求める
順位の平均値が最小となる馬を出力する
'''

# C108　観光の計画
# utf-8
N = int(input())
time = []
program=[]
for i in range(N):
    time.append(int(input()))
move_time = [list(map(int, input().split())) for l in range(N)]
# print(time,move_time)


K = int(input())
for i in range(K):
    program.append(int(input()))
# print(K,program)
count = 0
# print(move_time[1][0])
for i in range(K):
    # print('roop',i)
    # print('所要',time[program[i]-1])
    count = count + time[program[i]-1]
    if i+1 <K:
        # print(program[i + 1])
        # print('移動',move_time[program[i]-1][program[i+1]-1])
        count = count + move_time[program[i]-1][program[i+1]-1]

    # print(move_time[program[i]][program[i+1]])
print(count)
'''
まず、観光名所の数 N と各観光名所の滞在時間 time、各観光名所間の移動時間 move_time を入力します。
その後、訪れたい観光名所の数 K と訪れたい観光名所のリスト program を入力します。
最後に、訪れたい観光名所のリスト program を順に処理して、各観光名所に滞在する時間 time[i] を加算します。
ただし、最後の観光名所に到着した場合は移動時間を加算しないため、i+1<K の場合のみ移動時間を加算します。
以上の処理によって、訪れたい観光名所を順に巡るために必要な時間が求められます。
'''

# C109　IDを登録順に並べよう
# utf-8
import re

# ユーザー数を取得
n = int(input())

# ユーザーIDを取得
users = []
for i in range(n):
    users.append(input().rstrip())

# ユーザーIDを早い順にソート
users_sorted = sorted(users, key=lambda u: int(re.findall(r'\d+', u)[0]))

# ソート結果を出力
for user in users_sorted:
    print(user)
'''
splitの引数を空白文字で分割した場合、
'paiza1'は'paiza1'という1つの文字列として取り出されてしまいます。
そこで、空白文字と数字を分ける区切り文字として、正規表現を使うことができます。
以下は正規表現を使ったコード例です。re.findall(r'\d+', u)は文字列uから、数字の列を取り出す正規表現の表現です。
こうすることで、ユーザーIDの数字部分のみを取り出すことができます。
この問題では、与えられたユーザー ID のリストを、登録の早い順に並び替えて出力する必要があります。
与えられたユーザー ID は、「ユーザーネーム + 通し番号」の形式を取っており、通し番号は登録順に振られた番号です。
例えば、paiza さんが 1 番目に登録した場合、ユーザー ID は「paiza1」となります。
この問題を解くためには、与えられたユーザー ID のリストを通し番号の昇順に並び替える必要があります。
そのために、Python の組み込み関数である sorted 関数を使用することができます。
sorted 関数は、第 1 引数にリストを取り、第 2 引数にソートに使用するキーを指定することができます。
キーには、任意の関数を渡すことができます。この問題では、通し番号を昇順に並び替えたいので、キーとして「通し番号」を取り出す関数を指定する必要があります。
具体的には、lambda 関数を使って、ユーザー ID を分割し、通し番号を取り出すことができます。
ユーザー ID は「ユーザーネーム + 通し番号」という形式であるため、スペースを区切り文字として split メソッドを使って分割し、通し番号の部分を取り出します。
このとき、通し番号は文字列であるため、int 関数を使って整数に変換する必要があります。
以上をまとめると、与えられたユーザー ID のリストを次のように並び替えることができます。
このコードは、与えられたユーザー ID のリスト users を、通し番号の昇順に並び替えた結果を users_sorted に格納します。
通し番号の昇順に並び替えるために、キーとして lambda 関数を使用し、ユーザー ID をスペースで分割して最後の要素（通し番号）を整数に変換して指定しています。
'''

# C110　就職活動
# utf-8
N = int(input())
d = [int(input()) for _ in range(N)]

max_count = 0
start = 0
end = 0

current_start = 0
count = 0

for i in range(N):
    if i == 0:
        current_start = d[i]
        count = 1
    else:
        if d[i] == d[i-1] + 1:
            count += 1
        else:
            if count > max_count:
                max_count = count
                start = current_start
                end = d[i-1]
            current_start = d[i]
            count = 1

# 最後の日程のチェック
if count > max_count:
    max_count = count
    start = current_start
    end = d[-1]

print(start, end)
'''
まず、Nとdを入力します。Nは企業説明会の回数、dはそれぞれの説明会の日程を表します。
次に、最長の連続した期間を求めます。最長の期間を保持するために、変数max_count、start、endを初期化します。
また、現在の期間を保持するために、変数current_start、countを初期化します。
最長の連続した期間の初日と終日を出力します。
'''
--------------------------------------------- C111　※欠番 ◆
# C111　ハッシュ関数
# utf-8
N, M = map(int, input().split())
s = input()

# 最後のブロックには 0 を追加して長さ M に調整
last_block = s[(N // M) * M:].ljust(M, '0')
blocks = [s[i:i+M] for i in range(0, N-M+1, M)] + [last_block]

# ブロックに XOR を適用
result = ['0'] * M
for block in blocks:
    result = [str(int(result[i]) ^ int(block[i])) for i in range(M)]

print(''.join(result))
'''
このプログラムは、与えられた文字列を指定された長さのブロックに分割し、各ブロックに XOR 演算を適用して、
最終的に指定された長さのハッシュ値を出力するものです。
まず、文字列をブロック長 M で分割します。最後のブロックは、M で割り切れない場合、"0" を適当な数追加して M の倍数にします。
次に、各ブロックに XOR 演算を適用します。ブロック間の XOR は、左から 1 文字ずつ XOR 適用するものとします。
つまり、ブロック1とブロック2をXORした結果を、その結果とブロック3をXORし、その結果とブロック4をXORしていくことになります。
最後に、最終的なハッシュ値を出力します。ハッシュ値は、XOR 演算を適用した結果の先頭 M 文字を取得することで得られます。
このプログラムでは、入力として与えられる文字列の長さ N と、ブロックの長さ M を変数として扱い、入力例のように動作するように実装されています。
'''

# C112　時差ボケ
# utf-8
n = int(input())
total_time = []
for i in range(n):
    s, f, t = map(int, input().split())
    total_time.append(s + f + 24 - t)
print(min(total_time))
print(max(total_time))

'''
1.入力された日数 n を整数型で受け取ります。
2.各日の旅行時間の合計を表すリスト total_time を初期化します。
3.n 回分、次の処理を繰り返します。
3-1.input() 関数を使ってスペース区切りで整数値を受け取ります。これらをそれぞれ s, f, t とします。
3-2.その日の旅行時間の合計を計算し、total_time リストに追加します。
4.total_time リストの最小値と最大値を min() と max() 関数を使って計算し、それぞれ出力します。

具体的には、各日の旅行時間の合計を計算する際に、以下のように式を書いています。

Copy code
s + f + 24 - t
ここで、s は出発時刻、f は飛行時間、t は到着時刻を表します。この式は、出発時刻 s から飛行時間 f 分だけ時間が経過し、
到着地の現地時間が t 時ということを考慮して、パイザ氏がその日に体験した時間の長さを計算しています。

最後に、求めた最小値と最大値をそれぞれ min() と max() 関数で求めて出力しています。

'''

# C113　一人でスゴロク
# utf-8
N, M = map(int, input().split())

# 各マスの効果を格納するリスト a
a = [input() for _ in range(N-2)]
# スタートとゴール以外のマスは効果を受けないので、効果なしとして追加
a.insert(0, "x")
a.append("goal")

# 駒の位置を表す変数 pos を初期化
pos = 0
for i in range(M):
    # サイコロを振った目を取得
    c = int(input())

    # 駒を進める
    pos += c

    # 駒がゴールに到達した場合
    if pos >= N-1:
        print("goal")
        print(i+1)  # i は 0-indexed なので、1 を足す
        break

    # 駒がスタートに戻ってしまった場合
    if a[pos] == "r":
        pos = 0

    # 駒が効果なしのマスに止まった場合
    elif a[pos] == "x":
        continue

    # 駒がマイナス効果のマスに止まった場合
    elif a[pos] == "-":
        pos -= 1

    # 駒がプラス効果のマスに止まった場合
    elif a[pos] == "+":
        pos += 1

# ゴールに到達しなかった場合は、最後の位置を出力
else:
    print("still")
    print(pos)
'''
まず、 pos 変数を使って現在の駒の位置を表しています。駒は初期状態では 0 番目のマスにあると仮定して、
ゲームが進行するにつれて pos の値が変化していきます。
次に、 for ループを使ってサイコロを振る回数分だけ、サイコロの出目に応じて駒を進めたり戻したりしています。
このループ内で pos を変更することで、駒の位置を更新しています。
そして、 if 文を使って駒がゴールしたかどうかを判定しています。
ゴールしている場合は goal という文字列と、ゴールするまでに振ったサイコロの回数を出力します。
ゴールしていない場合は still という文字列と、最後にいたマスの番号を出力します。
また、 a リストのインデックスを pos - 1 としている理由は、リストのインデックスが 0 から始まるため、
現在の駒の位置に応じてリストのインデックスを調整する必要があるからです。
最後に、 while True ループで pos の値が範囲外になる場合をチェックしています。
このループは pos の値が 0 未満の場合や、N - 1 以上の場合に入ります。
このような場合は、ループ内で pos の値を適切な範囲内に修正するようにしています。
'''

# C114　しりとりの判定
# utf-8
n = int(input())
words = [input() for _ in range(n)]

for i in range(1, n):
    if words[i-1][-1] != words[i][0]:
        print(words[i-1][-1], words[i][0])
        exit()

print("Yes")
'''
【解法】
しりとりが成立するためには、前の単語の末尾の文字と現在の単語の先頭の文字が一致している
必要があります。従って、与えられた単語を順に見ていき、前の単語の末尾の文字と現在の単語の
先頭の文字が異なる場合、その2つの文字を出力して処理を終了します。全ての単語を見終わっても処理が
終了しない場合は、しりとりが成立するので "Yes" を出力します。
【注意点】
入力された単語は英字小文字または英字大文字からなるため、単純に文字列の末尾や先頭の文字を
取り出すことができます。
'''

# C115　渋滞の距離
# utf-8
n, m = map(int, input().split(' '))
traffic = 0

for i in range(n-1):
    distance = int(input())
    if distance <= m:
        traffic += distance

print(traffic)

# C116　あたり棒の検査
# utf-8
N, M = map(int, input().split())
a = list(map(int, input().split()))

for i in range(N - M + 1):
    if sum(a[i:i+M]) == 0:
        print("NG")
        break
else:
    print("OK")
'''
与えられた整数列中に、M 回の「はずれ」が連続する部分列が存在しないかどうかを判定する問題です。
解法としては、与えられた整数列を先頭から順に見ていき、現在注目している部分列の中に「はずれ」が M 個連続している部分列があるかどうかを調べていく方法があります。
具体的には、以下のようなアルゴリズムを考えることができます。
整数列 a を先頭から順に見ていく
現在注目している部分列が M 個の「はずれ」を含むかどうかを調べる
含む場合は、NG を出力して終了する
a の末尾に達した場合は、OK を出力して終了する
まずこの問題では、M個連続で"はずれ"が出ているかどうかを判定する必要があります。
入力された文字列を配列に変換する
配列を先頭からM個の要素を取り出し、その中に"はずれ"があるかどうかをチェックする
取り出した要素を1つずつ右にずらしながら、その中に"はずれ"があるかどうかをチェックする
M個連続で"はずれ"が出ていなければ、"OK"と出力する。そうでなければ、"NG"と出力する。
'''

# C117　大量出店
# utf-8
N, M = map(int, input().split())
A, B, C = map(int, input().split())

# 各店舗の収益を計算してリストに格納する
profits = []
for i in range(N):
    r = int(input())
    revenue = r * C - A - B * M
    profits.append(revenue)

# 利益が負の店舗を閉店させる
closed = 0
for p in profits:
    if p < 0:
        closed += 1

print(closed)

'''
この問題は、各店舗が閉店するかどうかを判断することが問題の主要な部分です。
各店舗で得られる利益は、売り上げの合計にコストを差し引いたものになります。各店舗での利益が負の場合、その店舗は閉店する必要があります。
解決策のアプローチは、各店舗で得られる利益を計算し、負の利益を持つ店舗をカウントすることです。
利益は、売り上げの合計にコストを差し引いたものです。店舗の費用は、建設費用と人件費の合計であり、この金額を開店費用と呼びます。
売り上げの合計は、各店舗で販売されるラーメンの杯数に利益を乗算したものの合計です。
アルゴリズムのステップは以下のようになります。

入力値を読み取ります。
各店舗で得られる利益を計算します。
利益が負の店舗をカウントします。
結果を出力します。
'''
# C118　ダイヤル数
# utf-8
D, N, L = map(int, input().split())
keys = [int(input()) for _ in range(N)]

current = 0  # 現在のダイヤルの位置
count = 0  # 合計目盛り数
for i in range(N):
    # 目的のダイヤル番号まで、どちらの方向に回した方が目盛り数が少ないか計算する
    dist_cw = (keys[i] - current + D) % D
    dist_ccw = (current - keys[i] + D) % D
    count += min(dist_cw, dist_ccw)  # 目盛り数を加算
    current = keys[i]  # 現在のダイヤルの位置を更新
    if count > L:  # 合計目盛り数がLを超えたら壊れるのでNoを出力して終了
        print("No")
        exit()

# 解錠できたらYesを出力
print("Yes")
'''
この問題は、与えられたダイヤル番号を順に合わせていき、ダイヤルを0から回転させることで、
合計の目盛数が L 以下になるように解錠することができるかどうかを判定する問題です。
与えられたダイヤル番号を順に合わせていくことをシミュレートするために、変数 total で現在の目盛数を表します。
total には、ダイヤルを0から回転させた回数も加算されます。total が L 以下である限り、
ダイヤル番号を順に合わせていくことができます。一方、total が L を超えてしまう場合、鍵が壊れてしまうため、
解錠することはできません。
全てのダイヤル番号を順に調べ終わった後、total が L 以下であれば解錠することができ、
total が L を超えていれば解錠することができないため、適切に Yes または No を出力すればよいです。
'''

# C119　お菓子かいたずらか
# utf-8
N, M, K = map(int, input().split())
houses = set(range(1, N+1))
trick_houses = set(int(input()) for _ in range(M))
satisfy_count = 0
unsatisfy_count = 0
for house in houses:
    if house in trick_houses:
        unsatisfy_count += 1
        if unsatisfy_count == K:
            break
    else:
        satisfy_count += 1
        unsatisfy_count = 0
print(satisfy_count)
'''
まず、入力から町の家の数 N、男の子の数 M、K 軒の家で連続して驚かされると泣いて帰る Alice の条件を読み込みます。
そして、range(1, n+1)で全ての家の集合を作り、男の子たちが隠れている家の集合を作ります。
その後、for文で、全ての家について以下の処理を行います。
その家が男の子たちが隠れている家である場合、Alice は驚かされたので、unsatisfy_count を1増やします。
その家が男の子たちが隠れていない家である場合、Alice は驚かされていないので、satisfy_count を1増やします。
unsatisfy_count が K に等しくなった場合、Alice は驚かされた家が K 軒以上であるため泣いて帰ってしまうため、for文を抜けます。
最後に、Alice が貰えるお菓子の個数である satisfy_count を出力します。
'''
# C120　花のリース
# utf-8
N = int(input())  # リースを構成する花の数
S1 = input().strip()  # 1つ目のリースの状態
S2 = input().strip()  # 2つ目のリースの状態

# 1つ目のリースを1つずつ回転させながら、2つ目のリースと比較する
for i in range(N):
    if S1 == S2:
        print("Yes")
        break
    S1 = S1[1:] + S1[0]  # リースを1つ回転させる
else:
    print("No")
'''
この問題は、2つのリースが同じ種類であるかどうかを判定する問題です。リースは複数の種類の花からなり、花が手前を向くように並べられています。
2つのリースが同じ種類であるとは、共に表にした状態で、回転させることで同じ並びにすることができることを言います。
この問題を解くために、まずは1つ目のリースを固定して、回転させながら2つ目のリースと比較します。
リースを回転させる際には、文字列のスライスを用いて先頭の文字を末尾に移動させます。この操作により、リースの配置が回転することになります。
1つ目のリースを固定して比較を行う理由は、2つのリースが同じ種類であるかどうかを判定するために、リースのどこから回転させても同じリースになる場合があるからです。
このような場合、1つ目のリースを固定して、2つ目のリースと比較していくことで、同じ種類であることを判定することができます。
比較が終了した時点で2つのリースが同じ種類であることが分かっていない場合は、「No」と出力します。
'''
--------------------------------------------- C121　※欠番 ◆
# C121　レストランの人気メニュー　
# utf-8
n, limit = map(int, input().split())

menu = []  # メニューの情報を格納するリスト
for i in range(n):
    ranking, calories = map(int, input().split())
    menu.append((ranking, calories))

calorie_total = 0  # 食べたメニューのカロリー合計
top10_count = 0  # トップ 10 のメニューを何品食べたかをカウントする変数

for m in menu:
    if calorie_total + m[1] > limit:
        break  # カロリーの上限を超えたらループを終了する
    if m[0] <= 10:
        top10_count += 1  # トップ 10 のメニューを食べたらカウントする
    calorie_total += m[1]

if top10_count == 10:
    print("Yes")
else:
    print(top10_count)
'''
この問題は、与えられたメニューリストを順番に食べた時に、カロリーの上限を超える前にトップ10のメニューを全て食べることができるかどうかを判定する問題です。
まず、入力された N とカロリーの上限を取得しています。
次に、N 行分のメニューの情報をリストに格納しています。
リストの要素は、タプルで人気順位とカロリーがペアになっています。
その後、ループを使用して順番にメニューを注文していきます。
注文する前に、現在のカロリー合計が上限を超えているかどうかをチェックしています。
もし超えていた場合は、ループを終了します。
注文したメニューがトップ 10 に入っていた場合は、トップ 10 のメニューを食べた数をカウントします。
最後に、トップ 10 のメニューをすべて食べきれていた場合は "Yes" を、そうでない場合は食べたトップ 10 のメニューの数を出力します。
アルゴリズムは以下の通りです。
トップ10のメニューを昇順に並べ替える。
カロリーの合計を0に初期化する。
メニューリストを順番に処理し、以下を繰り返す。
カロリーの合計にメニューのカロリーを加える。
カロリーの合計が上限を超えたら、処理を終了する。
処理したメニューがトップ10に含まれていたら、そのメニューをトップ10リストから削除する。
トップ10リストが空になったら、処理を終了する。
トップ10リストが空になった場合は"Yes"を出力し、そうでない場合は食べたトップ10のメニューの数を出力する。
'''

# C122　プレゼントのセール
# utf-8
N, X, Y = map(int, input().split())
prices = []
for i in range(N):
    price = int(input())
    prices.append(price)

prices.sort()

total_price = sum(prices)
for i in range(Y):
    if X + i > N:
        break
    discount_items = prices[i:X + i]
    total_price -= min(discount_items)

print(total_price)
'''
入力された商品価格のリストを昇順にソートします。
セール対象となる購入数 X 個までの商品を全て購入し、価格をtotal_priceに加算します。
Y 品のうち、最も安い商品を1つ選んで無料にします。total_priceからその商品の価格を引きます。
total_priceを出力します。
このアプローチは、まず最初に商品価格のリストを昇順にソートすることで、最も安い商品から順に購入していくことを保証します。その後、セール対象となる購入数 X 個までの商品を全て購入することで、最低限の割引を適用します。そして、Y 品のうち最も安い商品を1つ選んで無料にすることで、最大限の割引を適用します。
このアプローチにより、どのようなテストケースにも対応できるようになっています。
'''
# C123　節分ロボット
# utf-8
n = int(input())

people = []
ans = [(0, 0) for i in range(n)]
for i in range(n):
    people.append((int(input()), 0))

m = int(input())

for command in range(m):
    a, b, c = map(int, list(input().split(" ")))

    for j in range(a - 1, b):
        year, mame = people[j]
        mame += c
        if mame >= year:
            people[j] = (year, year)
        else:
            people[j] = (year, mame)

for year, mame in people:
    print(mame)
'''
まず、people というリストを用意して、その中に各参加者が持つ年齢と豆の数をタプルとして格納します。
ここでは、全員が最初は豆を持っていないため、すべての人の豆の数を 0 に設定しています。
ans というリストは、最終的に各参加者が持つ豆の数を格納するために使われる予定でしたが、実際には使用されませんでした。
このため、ans は不要であり、削除してもプログラムの動作には影響がありません。
次に、命令の数 m を入力し、それだけ繰り返し処理を行います。1回の処理では、ある範囲の参加者に対して豆の数を加算する命令が与えられます。
命令は a b c の形式で与えられ、a 以上 b 以下の参加者すべての豆の数に c を加算することを意味します。
具体的には、与えられた a から b の範囲に対して、people リストの対応する要素の豆の数に c を加算します。
そして、もし加算後の豆の数がその参加者の年齢以上になってしまう場合には、豆の数を年齢と同じ値に固定します。
最後に、people リストの各要素について、その参加者が持つ豆の数を出力します。
ここで、タプルを year と mame に分割して、mame の値を出力しています。
'''

# C124　インターンへの応募
# utf-8
n = int(input())
companies = [[] for _ in range(n)]  # 各企業の日程リスト

# 各企業の日程を取得
for i in range(n):
    c_i = int(input())
    for j in range(c_i):
        s_j, p_j = map(int, input().split())
        companies[i].append((s_j, s_j + p_j))  # (開始日, 終了日)のタプルを格納

# 企業1がすべての期間を確保する場合
company1_periods = companies[0]
used_periods = company1_periods.copy()  # すでに使用された期間
count = 1  # 企業1は初期段階で確保している

# 他の企業が確保できる期間を調べる
for i in range(1, n):
    free_periods = []
    for period in companies[i]:
        if all(period[1] <= used_period[0] or used_period[1] <= period[0] for used_period in used_periods):
            free_periods.append(period)
    if not free_periods:
        continue
    count += 1
    # 企業1の期間を参照して重複しない期間を確保する
    for period in free_periods:
        for company1_period in company1_periods:
            if period[1] <= company1_period[0] or company1_period[1] <= period[0]:
                used_periods.append(period)
                break
print(count)
'''
この問題は、企業のインターン期間が重複しないようにスケジュールを組む問題です。
まず、各企業の日程を (開始日, 終了日) のタプルとしてリストに格納します。次に、企業1から順に、その日程が他の企業の日程と被っていないかどうかを確認します。
被っていない場合、その企業の日程を確保し、カウントします。被っている場合は、他の企業の日程をキャンセルする必要があります。このとき、すでにキャンセルした企業を再度カウントしないように注意しなければなりません。
最終的に、カウントした企業数が答えとなります。
この問題の時間計算量は O(N^2) となります。企業数が多くなると処理に時間がかかるため、より高速なアルゴリズムを考える必要があるかもしれません。
'''

# C125　カードの積
# utf-8
import itertools

N = int(input())
nums = list(map(int, input().split()))

max_product = float('-inf')  # 最大値を保持する変数を初期化

# 全探索で2つの数字を選び、+1または-1を行う
for comb in itertools.combinations(nums, 2):
    new_nums = nums.copy()  # 元の数字列をコピー
    new_nums.remove(comb[0])
    new_nums.remove(comb[1])

    # 2つの数字それぞれに+1または-1を行う
    plus = [comb[0] + 1, comb[1] - 1]
    minus = [comb[0] - 1, comb[1] + 1]
    for new_comb in [plus, minus]:
        nums_product = 1
        for num in new_comb + new_nums:
            nums_product *= num
        if nums_product > max_product:
            max_product = nums_product

print(max_product)
'''
この問題は全探索によって解くことができます。以下、アルゴリズムの概要を説明します。
step1　N個の整数を配列に入力する。
step2　最大値を保存する変数を初期化する。
step3　2つの数を選び、1つに+1、もう1つに-1を掛ける。この操作をN(N-1)/2通り行う。
step4　step3で得られた2つの数と、元のN-2個の数を掛け算し、その積の最大値を求める。この操作をN!通り行う。
step5　step4で求めた最大値が、現在の最大値より大きければ、最大値を更新する。
step6　全ての組み合わせに対して上記の処理を行い、最終的な最大値を出力する。
このアルゴリズムの時間計算量はO(N^2 * N!)になります。Nが10以下という小さな制約であるため、この計算量でも間に合います。
'''

# C126　宿泊費と交通費
# utf-8
import sys
input = sys.stdin.readline

A, B, N = map(int, input().split())
days = [list(map(int, input().split())) for _ in range(N)]

sum = 0
for i in range(1, N):
    day = days[i][0] - days[i - 1][1]
    sum = sum + B * day if A * 2 > B * day > 0 else sum + A * 2

print(sum + A * 2)
'''
まず、入力値を取得します。1行目のAとB、およびNをそれぞれ整数型で受け取り、2行目以降のdaysを二次元リストで受け取ります。
ここから、最小費用を計算する処理を行います。まず、最初の移動費用（家から最初のインターン先までの往復分）をsumに加算します。
次に、二番目以降のインターン先について、前のインターン終了日と現在のインターン開始日の間の日数をdayとして求めます。
その後、移動費用がA * 2よりも小さく、かつdayが正数である場合には、交通手段を新幹線からホテル泊まりに切り替えます。そうでない場合には、引き続き新幹線を利用します。
最後に、最後のインターン終了日から自宅に帰るまでの移動費用を加算して、最終的な費用を出力します。
'''

# C127　割引キャンペーン
# utf-8
N, M = map(int, input().split())
names = set()
for i in range(M):
    name = input().strip()
    names.add(name)
    if M - i <= N:
        if name in names:
            names.remove(name)
print(len(names))

# C128　連分数
# utf-8
from fractions import Fraction

n = int(input())
a = [int(input()) for i in range(n)]
x = Fraction(a[-1])
for i in range(n-2, -1, -1):
    x = a[i] + 1 / x
print(x.numerator, x.denominator)
'''
連分数は、分数を有限個の整数と、最後に無限に続く部分分数の和として表現する方法です。この問題では、与えられた数列を連分数に変換し、既約分数にまで簡約化する必要があります。
最初に与えられた数列に対して、以下のように連分数を計算することができます。
まず、数列の最後の要素を分母に設定し、その前の要素を分子に設定します。
それから、数列の前から2つめの要素から開始して、次の要素が分母に、前の連分数を分子に設定します。 
この手順を、数列の最初の要素まで続けます。これにより、与えられた数列の値を表す連分数が得られます。
次に、この連分数を既約分数に簡約化する必要があります。 これを行うには、連分数の最後から2つめの項から、連分数を繰り返し分数に変換し、その分数の分子と分母の最大公約数を求めます。 
最後に、最大公約数で分子と分母を割ることによって、既約分数を得ることができます。
Pythonのfractionsモジュールのgcd関数を使用して、分子と分母の最大公約数を計算することができます。
最後に、求めた既約分数の分子と分母を出力することができます。まず、入力を受け取り、最初に与えられた分数 x を Fraction オブジェクトとして初期化します。
ここで a[-1] はリスト a の最後の要素であり、これが与えられた連分数の最後の項に相当します。
その後、リスト a の後ろから順に連分数の途中の項を計算していきます。このとき、前の項の逆数を足すことで次の項を求めることができます。
つまり、i 番目の項 a[i] が与えられたとき、次の項を x = a[i] + 1 / x という式で求めています。
最後に、求めた x の分子と分母をそれぞれ numerator と denominator 属性から取り出し、出力します。
Fraction オブジェクトは、Pythonの組み込みモジュール fractions に含まれるクラスで、分数を扱うためのクラスです。
自動的に最大公約数で割り、分母を1以上の正の整数、分子を整数として表現します。
'''

# C129　工場の検品
# utf-8
import sys

def main():
    input_lines = sys.stdin.readlines()
    NM = input_lines[0].split()
    N = int(NM[0])
    M = int(NM[1])
    sample = list(map(int, input_lines[1:M+1]))
    come = list(map(int, input_lines[M+1:]))
    sample.sort()
    come.sort()
    if sample == come:
        print("Yes")
    else:
        print("No")

if __name__ == '__main__':
    main()
'''
このコードは、寿司を回転寿司に並べているかどうかを判定する問題を解くための Python スクリプトです。
まず、sys.stdinを使って標準入力から複数行の文字列を読み取り、split()を使って空白で区切ってリストに格納します。
次に、int()とmap()を使って文字列を整数に変換して、変数 N と M に代入します。
変数 sample と come には、それぞれ input_lines リストの中で、M 行目から最後までの寿司の種類の番号を整数のリストとして格納します。
sort()メソッドを使ってsampleとcomeを昇順にソートし、==演算子を使ってsampleとcomeが等しいかどうかを比較します。
等しい場合は "Yes" を、そうでない場合は "No" を表示します。
最後に、if __name__ == '__main__': で、このスクリプトが直接実行された場合に main() 関数を呼び出して処理を開始します。
'''

# C130 繰り返し学習
# utf-8
def find_unsolved_problems(N, problem_status):
    solved_problems = []  # 解かれた問題の番号を格納するリスト

    for problem_num in range(N):
        first_round = problem_status[problem_num][0]  # 1周目の正誤状況を取得
        second_round = problem_status[problem_num][1]  # 2周目の正誤状況を取得

        if first_round == 'n' or second_round == 'n':  # どちらかが不正解の場合
            solved_problems.append(problem_num + 1)  # 解かなければならない問題としてリストに追加

    return solved_problems

# 入力の受け取り
N = int(input())  # 問題数を受け取る
problem_status = []

# 各問題の正誤状況を受け取る
for _ in range(N):
    status = input().split()  # 1周目と2周目の正誤状況をスペース区切りで受け取る
    problem_status.append(status)

# 3周目で解かなければならない問題の番号を求める
unsolved = find_unsolved_problems(N, problem_status)

# 結果を出力
M = len(unsolved)  # 解かなければならない問題の数
print(M)  # 解かなければならない問題の数を出力
for problem_num in unsolved:
    print(problem_num)  # 解かなければならない問題の番号を順に出力
'''
returnまでの部分は関数 find_unsolved_problems を定義しています。この関数は、問題数と問題の正誤状況を受け取り、3周目で解かなければならない問題の番号のリストを返します。問題数を表す N と正誤状況のリスト problem_status を引数として受け取ります。solved_problems は解かれた問題の番号を格納するための空のリストです。
次に、入力の受け取り部分です。最初に問題数 N を整数として受け取ります。その後、N 行の入力が行われます。各行では、問題ごとの正誤状況をスペース区切りで受け取り、problem_status リストに追加しています。
最後に、find_unsolved_problems 関数を呼び出し、解かなければならない問題の番号を取得します。その後、取得した問題数を変数 M に格納し、解かなければならない問題の数を出力します。さらに、解かなければならない問題の番号を順に出力します。
'''
--------------------------------------------- C131　※欠番 ◆
# C131　ユニークな部屋番号
# utf-8
# 入力の取得
A, B = map(int, input().split())

# バリデーションチェック
if not (1 <= A <= B <= 100000):
    exit("入力が無効です。条件 1 ≦ A ≦ B ≦ 100000 を満たしているか確認してください。")

# 条件に合致する部屋番号の数をカウントする変数
count = 0

# 180°回転後に同じ番号になる数字のセット
same_numbers = {'0', '1', '8', '6', '9'}

# AからBまでの範囲でループ
for num in range(A, B + 1):
    # 部屋番号を文字列に変換
    room_number = str(num)

    # 部屋番号が180°回転後に同じ番号になるかをチェック
    rotated_number = ""
    for digit in room_number:
        if digit not in same_numbers:
            break
        if digit == '6':
            rotated_number = '9' + rotated_number
        elif digit == '9':
            rotated_number = '6' + rotated_number
        else:
            rotated_number = digit + rotated_number

    if room_number == rotated_number:
        count += 1

# 結果の出力
print(count)
'''
最初に、入力から部屋番号の範囲AとBを受け取ります。AとBは半角スペースで区切られた文字列として入力されます。
バリデーションチェックを行います。条件「1 ≦ A ≦ B ≦ 100,000」を満たしているか確認します。もし条件を満たしていない場合は、エラーメッセージを表示してプログラムを終了します。
変数countを初期化し、条件を満たす部屋番号の数をカウントします。
180°回転しても同じ番号になる数字のセットsame_numbersを定義します。このセットには、'0'、'1'、'8'、'6'、'9'が含まれます。
AからBまでの範囲でループを行います。
部屋番号を文字列に変換します。
部屋番号が180°回転後に同じ番号になるかをチェックします。まず、回転後の番号を表す空の文字列rotated_numberを初期化します。
部屋番号の各桁を順に取り出し、回転後の番号を構築していきます。もし取り出した桁がsame_numbersに含まれていない場合、ループを中断します。
取り出した桁が'6'の場合は、回転後は'9'になります。取り出した桁が'9'の場合は、回転後は'6'になります。それ以外の場合は、取り出した桁を回転後の番号の先頭に追加します。
部屋番号と回転後の番号が一致する場合、条件を満たす部屋番号としてカウントします。
ループが終了したら、条件を満たす部屋番号の個数が変数countに格納されます。
結果の個数を出力します。
'''

# C132　掃除ロボット
# utf-8
def can_clean_rooms():
    # 部屋の数を取得
    N = int(input())

    # ロボットがある部屋を掃除したとき次に何部屋右隣の部屋を掃除するかを取得
    M = int(input())

    # ロボットが1部屋おきに清掃する場合は必ず全ての部屋を清掃できるため、yesを返す
    if M == 1:
        return "yes"

    # ロボットが部屋を清掃する順序を決定する
    current_room = 0  # 現在の部屋のインデックス
    cleaned_rooms = 0  # 清掃された部屋の数
    while True:
        # 現在の部屋を清掃
        cleaned_rooms += 1

        # 清掃が完了したら次の部屋に移動
        next_room = (current_room + M) % N

        # 全ての部屋が清掃された場合、yesを返す
        if cleaned_rooms == N:
            return "yes"

        # ロボットが同じ部屋に戻った場合、noを返す
        if next_room == 0:
            return "no"

        # 次の部屋に移動
        current_room = next_room

# プログラムの実行
print(can_clean_rooms())
'''
ユーザーから部屋の数 N を入力します。
ユーザーからロボットがある部屋を掃除したときに次に何部屋右隣の部屋を掃除するかを表す整数 M を入力します。
ロボットが1部屋おきに清掃する場合 (M == 1) は必ず全ての部屋を清掃できるので、"yes"を返します。
ロボットが部屋を清掃する順序を決定するため、現在の部屋のインデックス current_room を0で初期化します。
清掃された部屋の数をカウントする変数 cleaned_rooms を0で初期化します。
無限ループを開始します。
現在の部屋を清掃し、cleaned_rooms を1増やします。
清掃が完了したら、次に掃除する部屋を計算します。現在の部屋のインデックスに M を加え、部屋の数 N で割った余りが次の部屋のインデックスになります。これにより、右端の部屋の1つ隣の部屋を左端の部屋として扱います。
全ての部屋が清掃された場合 (cleaned_rooms == N) は、"yes"を返します。
ロボットが同じ部屋に戻った場合 (next_room == 0) は、"no"を返します。
次の部屋に移動し、ループを継続します。
この修正後のプログラムは、与えられた部屋の数とロボットの清掃順序に基づいて、全ての部屋を清掃できるかどうかを判定します。最終的には、"yes"または"no"を出力します。
'''

# C133　雷危険地域
# utf-8
def calculate_danger_region(H, W, grid):
    # 3x3のエリアの平均値を計算する関数
    def get_average(r, c):
        total = 0
        for i in range(3):
            for j in range(3):
                total += grid[r + i][c + j]
        return total // 9

    danger_regions = []
    for i in range(0, H, 3):
        row = []
        for j in range(0, W, 3):
            # 3x3のエリアごとに平均値を計算してリストに追加
            row.append(get_average(i, j))
        danger_regions.append(row)

    return danger_regions

# 入力を受け取る
H, W = map(int, input().split())

# 制約を満たさない場合はエラーを出力して終了
if H % 3 != 0 or W % 3 != 0 or H < 3 or W < 3 or H > 999 or W > 999:
    print("Error: Invalid input.")
    exit()

grid = []
for _ in range(H):
    # 各行をリストにしてgridに追加
    row = list(map(int, input().split()))
    grid.append(row)

# 危険度を計算
output = calculate_danger_region(H, W, grid)

# 出力を整形して表示
for row in output:
    # 各エリアの平均値をスペース区切りで出力
    print(*row)
'''
このプログラムは、与えられた地域のマス目に雷が落ちた回数を記録し、その地域を9マスごとに分割して各エリアの危険度を計算します。以下に、主な機能と処理の流れを説明します。

calculate_danger_region 関数:
3x3のエリアの平均値を計算するための関数です。
エリア内の全マスの値を合計し、その平均値を求めて整数で返します。

入力を受け取る:
まず、標準入力から地域の縦と横のマスの数を受け取ります (変数 H, W)。
その後、H行分の地域の各マスに雷が落ちた回数を受け取り、二次元リスト grid に格納します。

制約のチェック:
入力された H と W が制約を満たしているか確認します。
H と W は共に3で割り切れる必要があり、3より小さくてはいけません。
同時に、999より大きくてもいけません。制約を満たさない場合はエラーメッセージを表示して終了します。

grid に格納された雷の回数を元に、各3x3エリアの危険度を計算します:
3x3のエリアを1つずつ検討し、calculate_danger_region関数を使ってそのエリアの平均値を計算します。
計算結果をリスト danger_regions に追加します。

出力を整形して表示:
計算された各エリアの危険度を整形して出力します。
各行ごとにスペース区切りで表示されます。
'''

# C134　セルの名前
# utf-8
def calculate_cell_name(n):
    num_letters = ord('Z') - ord('A') + 1  # アルファベットの総数を計算
    name = []  # マスの名前を格納するリスト

    while n > 0:
        n -= 1  # マスの名前が1から始まるため、1減算する
        remainder = n % num_letters  # 現在の桁における余りを計算
        name.append(chr(ord('A') + remainder))  # 余りをアルファベットに変換して名前に追加
        n //= num_letters  # 桁を1つ下げるために商を更新

    return ''.join(reversed(name))  # 逆順になっている名前を正しい順序に並び替えて返す

# 入力を受け取る
N = int(input())

# マスの名前を計算して出力
cell_name = calculate_cell_name(N)
print(cell_name)
'''
与えられた整数 N に対して、指定された規則に基づいて表計算ソフト上のマスの名前を計算し、出力するものです。
calculate_cell_name 関数：
1.1. 最初に、アルファベットの総数を num_letters として計算します。これによってアルファベットの範囲が計算されます。例えば、'A' から 'Z' までのアルファベットが合計で 26 文字なので、num_letters は 26 になります。
1.2. 空のリスト name を用意します。ここにマスの名前の各文字を追加していきます。
1.3. マスの名前が 1 から始まるため、入力された N から 1 を減算します。
1.4. 現在の桁における余りを計算します。これによってアルファベットの順序を求めます。例えば、N が 27 の場合、余りは 0 となり、'A' が計算されます。
1.5. 余りをアルファベットに変換し、name リストに追加します。この処理によって、現在の桁に対応するアルファベットが名前に追加されます。
1.6. 桁を次に進めるために、N を num_letters で割ります。これによって次の桁の計算に移ります。
1.7. 上記のステップを N が 0 より大きい限り繰り返します。
1.8. name リストに逆順でアルファベットが格納されているため、最後にこれを正しい順序に並び替えて文字列に変換し、その結果を返します。

メイン部分：
2.1. 入力として整数 N を受け取ります。
2.2. calculate_cell_name 関数に N を渡して、マスの名前を計算します。
2.3. 計算されたマスの名前を出力します。
'''

# C135　商品の割引
# utf-8
# 割引の条件と割引率を入力
M, D = map(int, input().split())

# 商品の価格と個数を入力
P, N = map(int, input().split())

# 同時購入数が割引条件を満たすかチェック
if N >= M:
    discounted_items = N // M  # 割引が適用される商品の個数
    undiscounted_items = N % M  # 割引が適用されない商品の個数
    discounted_price = (P * M * discounted_items * (100 - D) // 100) + (P * undiscounted_items)  # 割引後の価格を計算
else:
    discounted_price = P * N  # 割引が適用されない場合

print(discounted_price)
'''
このプログラムは、与えられた条件に基づいて割引後の商品の合計金額を計算し、小数点以下を切り捨てて整数で出力するためのものです。
最初に、2つの行から入力を受け取ります。最初の行では、割引の条件と割引率が整数としてスペースで区切られています。具体的には、M（同時購入の数の条件）とD（割引率）を受け取ります。2番目の行では、商品の価格Pと個数Nを受け取ります。
プログラムは、同時購入の数が割引条件を満たすかどうかをチェックします。つまり、NがM以上かどうかを確認します。
同時購入数が割引条件を満たす場合、割引が適用されます。割引後の価格を計算するために、以下のステップを実行します。

discounted_items: 割引が適用される商品の個数を計算します。これはNをMで割った整数部分です。
undiscounted_items: 割引が適用されない商品の個数を計算します。これはNをMで割った余りです。
discounted_price: 割引が適用される商品と適用されない商品のそれぞれについて、割引後の価格を計算し、合計します。割引後の価格は、P（商品の価格） × M（割引条件を満たす商品の個数） × discounted_items × (100 - D) // 100 です。そして、割引が適用されない商品の価格は、P × undiscounted_items です。
同時購入数が割引条件を満たさない場合、割引は適用されず、通常の価格で計算されます。合計金額はP × Nです。

最終的な割引後の合計金額が計算され、小数点以下は切り捨てられて整数として出力されます。
'''

# C136　ダイエットの連続記録
# utf-8
# ダイエットが続いた最大日数とダイエットを怠った最大日数を計算する関数
def max_diet_and_non_diet_days(N, weights):
    # 最大ダイエット日数と最大非ダイエット日数を0で初期化
    max_diet_days = [0] * N
    max_non_diet_days = [0] * N

    for i in range(1, N):
        # もし体重が前日よりも減少していた場合
        if weights[i] < weights[i - 1]:
            # 最大ダイエット日数を更新
            max_diet_days[i] = 1 + max_diet_days[i - 1]
        # もし体重が前日よりも増加していた場合
        if weights[i] > weights[i - 1]:
            # 最大非ダイエット日数を更新
            max_non_diet_days[i] = 1 + max_non_diet_days[i - 1]

    # 最大の連続ダイエット日数と最大の連続非ダイエット日数を返す
    return max(max_diet_days), max(max_non_diet_days)

# 1行目から体重の総数 N を読み取る
N = int(input())

# 2行目以降の体重記録をリストとして読み取る
weights = []
for _ in range(N):
    weight = int(input())
    weights.append(weight)

# 最大の連続ダイエット日数と最大の連続非ダイエット日数を計算
max_diet, max_non_diet = max_diet_and_non_diet_days(N, weights)

# 結果を出力
print(f"{max_diet} {max_non_diet}")
'''
Aさんの体重記録から過去に最大何日間連続でダイエットが続いたかと、最大何日間連続でダイエットを怠ったかを計算するためのプログラムです。コードは以下のステップで動作します。
max_diet_and_non_diet_days という関数が定義されています。この関数は、引数として総体重の日数 N と、日々の体重を示すリスト weights を受け取ります。この関数は最大の連続ダイエット日数と最大の連続非ダイエット日数を計算し、それらの値を返します。
max_diet_and_non_diet_days 関数内では、2つのリスト max_diet_days と max_non_diet_days がゼロで初期化されます。これらのリストは、各日における最大の連続ダイエット日数と最大の連続非ダイエット日数を記録するために使用されます。
for ループが始まり、各日の体重変動を確認します。日々の体重変動は前日との比較に基づいています。
もし体重が前日よりも減少していた場合、その日はダイエット日と見なし、max_diet_days リストを更新します。連続ダイエット日数が1増加します。
もし体重が前日よりも増加していた場合、その日は非ダイエット日と見なし、max_non_diet_days リストを更新します。連続非ダイエット日数が1増加します。
ループ内で、各日における最大の連続ダイエット日数と最大の連続非ダイエット日数を計算・更新します。
max_diet_and_non_diet_days 関数は計算結果を返し、最大の連続ダイエット日数と最大の連続非ダイエット日数が得られます。
本体の部分では、まず1行目から総体重の日数 N を受け取り、2行目以降では N 日分の体重記録をリスト weights として受け取ります。
max_diet_and_non_diet_days 関数を呼び出して、最大の連続ダイエット日数と最大の連続非ダイエット日数を計算します。
最終的に、計算結果を指定された形式に従って出力し、最大の連続ダイエット日数と最大の連続非ダイエット日数が表示されます。
'''

# C137　取締役選任
# utf-8
# 株主の数を受け取る
N = int(input())

# 株主ごとの得票数を格納する辞書を初期化
votes_by_candidate_1 = {}
votes_by_candidate_2 = {}

# 投票結果を集計
for i in range(N):
    candidate, shares = input().split()
    shares = int(shares)

    # 方法1：株主1人につき1票
    if candidate in votes_by_candidate_1:
        votes_by_candidate_1[candidate] += 1
    else:
        votes_by_candidate_1[candidate] = 1

    # 方法2：株主1人につき持株数分の票
    if candidate in votes_by_candidate_2:
        votes_by_candidate_2[candidate] += shares
    else:
        votes_by_candidate_2[candidate] = shares

# 方法1での最多得票数を得た者の名前を取得
max_votes_1 = max(votes_by_candidate_1.values())
director_method_1 = [candidate for candidate, votes in votes_by_candidate_1.items() if votes == max_votes_1]

# 方法2での最多得票数を得た者の名前を取得
max_votes_2 = max(votes_by_candidate_2.values())
director_method_2 = [candidate for candidate, votes in votes_by_candidate_2.items() if votes == max_votes_2]

# 結果を出力
print("\n".join(director_method_1))
print("\n".join(director_method_2))
'''
このプログラムは、与えられた株主の投票情報を使用して、2つの異なる方法で選任された取締役の名前を見つけます。
最初に、株主の数を表す整数Nを標準入力から受け取ります。この数は1から1,000までの範囲内であることが保証されています。
次に、N行の入力が続きます。各行には、株主の名前（C_i）とその株主が持つ株式数（S_i）がスペースで区切られています。これらの情報を取得し、株主ごとの得票数を計算します。
得票数を集計するために、2つの辞書（votes_by_candidate_1とvotes_by_candidate_2）を初期化します。これらの辞書は、それぞれ方法1と方法2での得票数を格納します。
各株主の情報を処理し、得票数を計算します。方法1では1票ずつ、方法2では持株数分の票を追加します。
方法1と方法2それぞれで、最多得票を得た候補者を見つけます。最多得票数はmax()関数を使用して求め、最多得票を得た候補者はリストに追加します。条件により、最多得票を得る候補者が複数出ることはありません。
最終的に、方法1で選任された取締役の名前（director_method_1）と方法2で選任された取締役の名前（director_method_2）をそれぞれ出力します。
出力は指定されたフォーマットに従い、最終行には改行が含まれます。
このプログラムは、与えられた制約条件に対応し、与えられた投票情報から取締役を選出する方法1と方法2の両方を正確に処理します。
'''

# C138　反復横跳び大会
# utf-8
# 生徒の数 N を読み込む
N = int(input())

# 生徒の記録を読み込む
records = []
for i in range(N):
    record = int(input())
    records.append(record)

# 各生徒の順位を計算する
ranks = []
for i in range(N):
    # 各生徒の記録が他の生徒の記録よりも大きい場合、順位をインクリメント
    rank = sum(record > records[i] for record in records) + 1
    ranks.append(rank)

# 順位を出力
for rank in ranks:
    print(rank)
'''
このプログラムは、PAIZA小学校の反復横跳び大会での生徒の記録を処理し、各生徒の順位を計算して出力します。
最初に、生徒の数Nを整数として読み込みます。これは入力の1行目で提供されます。
次に、N個の生徒の反復横跳びの記録を読み込み、それぞれの記録を整数としてリストrecordsに格納します。これは2行目からN+1行目までの入力値に対応します。
各生徒の順位を計算するため、空のリストranksを作成します。このリストは、各生徒の順位を保持するために使用されます。
forループを使用して、各生徒の記録に対して順位を計算します。具体的には、各生徒の記録を取り出し、その記録が他の生徒の記録よりも大きい場合、その生徒の順位をインクリメントします。この操作はリスト内包表記を使用して行われ、sum()関数が記録の比較を行います。最終的に、各生徒の順位が計算され、ranksリストに追加されます。
各生徒の順位が計算されたら、forループを使用して順位を出力します。これにより、各生徒の順位が1行ずつ整数として表示されます。
'''

# C139　誤発注
# utf-8
# Nの値を取得
N = int(input())

# 届いた製品のリストを初期化
received_products = set()

# N回のループで届いた製品を集計
for i in range(N):
    x = int(input())
    received_products.add(x)

# 1からNまでの製品をチェックし、届いていないものを数える
missing_products = 0
for i in range(1, N + 1):
    if i not in received_products:
        missing_products += 1

# 結果を出力
print(missing_products)
'''
最初に、必要な製品の数Nを整数として受け取ります。
次に、届いた製品の製品番号を保存するためのセットを初期化します。
forループを使用して、N回の繰り返しで届いた製品の製品番号を入力として受け取り、received_productsセットに追加します。
必要な製品の範囲（1からNまで）を調べ、received_productsセットに含まれていない製品を見つけてカウントします。これにより、届いていない製品の数を計算します。
最後に、届いていない製品の数（missing_products）を出力します。
このコードは、必要な製品のリストと届いた製品のリストを比較し、届いていない製品の数を数えて出力する簡単なプログラムです。
'''

# C140　コンタクトの販売
# utf-8
def main():
    # コンタクトの度数の種類の数を取得
    N = int(input())
    
    # 各度数のコンタクトの在庫を辞書に保存
    powers = {}
    for i in range(1, N+1):
        powers[i] = int(input())

    # 並んでいるお客さんの数を取得
    M = int(input())
    
    # コンタクトを販売したお客さんのカウント
    count = 0
    for i in range(M):
        # お客さんが必要とする右目と左目の度数を取得
        right, left = map(int, input().split())

        # 右目と左目が同じ場合
        if right == left:
            # 在庫が2つ未満ならスキップ
            if powers[right] < 2:
                continue
            powers[right] -= 2
            count += 1
            continue

        # 右目と左目が異なる場合
        if powers[right] > 0 and powers[left] > 0:
            powers[right] -= 1
            powers[left] -= 1
            count += 1
            continue

    # 販売したお客さんの数を出力
    print(count)

if __name__ == "__main__":
    main()
'''
このプログラムは、与えられたコンタクトの在庫とお客さんの要求に基づいて、できるだけ多くのお客さんにコンタクトを販売するためのものです。
ユーザーからの入力として、コンタクトの度数の種類の数 (N) を整数として受け取ります。各度数のコンタクトの在庫をユーザーからの入力として受け取り、辞書 powers に度数をキーとして在庫数を保存します。
並んでいるお客さんの数 (M) をユーザーからの入力として受け取ります。コンタクトを販売したお客さんの数をカウントする変数を初期化します。
並んでいるお客さんの数 (M) だけ繰り返しを行います。お客さんが必要とする右目と左目の度数をユーザーからの入力として受け取ります。
お客さんが必要とする右目と左目が同じ場合、在庫が2つ未満ならスキップし、在庫から2つ消費してコンタクトを販売し、count を増やします。
お客さんが必要とする右目と左目が異なり、両方の度数の在庫が1以上あれば、それぞれの在庫から1つずつ消費してコンタクトを販売し、count を増やします。
プログラムの最後で、販売したお客さんの数 (count) を出力します。プログラムが直接実行された場合に main 関数を呼び出します。これにより、他のスクリプトからこのスクリプトがインポートされたときには main 関数が呼び出されないようになります。
'''
--------------------------------------------- C141　※欠番 ◆
# C141　クラス委員選挙
# utf-8
from collections import Counter

def find_class_representative():
    # クラスの人数を取得
    N = int(input().strip())

    # 生徒の投票結果を取得
    votes = [input().strip() for _ in range(N)]

    # 投票数をカウント
    vote_counts = Counter(votes)

    # 最も得票数が多い生徒を取得
    class_representative = max(vote_counts, key=vote_counts.get)

    # 結果を出力
    print(class_representative)

# プログラムを実行
find_class_representative()
'''
このプログラムは、クラス委員を決めるための選挙で最も得票数の多い生徒を見つけるためのものです。Counterクラスを使うために必要なライブラリをインポートしています。Counterクラスは、リストや文字列などの要素の出現回数を数えるのに便利なクラスです。
find_class_representativeという関数を定義しています。この関数は、クラス委員を見つけるための主要な処理を含みます。
まず、クラスの人数 N を受け取ります。次に、forループを使用して各生徒の投票結果をリスト votes に格納します。input().strip()は、入力から余分な空白や改行を取り除くために使用されています。
Counterを使用して、各生徒が得た得票数を数えます。votes リストから得票数を抽出し、辞書の形で保持します。max関数を使用して、vote_counts 辞書の中で最も得票数が多いキー（生徒の名前）を見つけます。key引数には、比較の基準となる関数を指定しています。この場合、vote_counts.get を用いて各生徒の得票数を比較しています。
最終的に、最も得票数が多い生徒の名前を出力します。関数 find_class_representative を呼び出してプログラムを実行します。
'''

# C142　レストランのメニュー
# utf-8
# 入力を受け取る
S = input().strip()  # あなたの食べたい料理名
N = int(input().strip())  # 与えられるメニューの単語数
menu = input().strip().split()  # メニューの単語リスト

# メニューの単語を順番にチェックし、Sと一致するものがあれば"Yes"を出力
found = False  # 一致する料理が見つかったかどうかのフラグ
for word in menu:
    if S == word:  # 完全一致する料理名が見つかった場合
        found = True
        break

if found:
    print("Yes")
else:
    print("No")
'''
あなたが食べたい料理の名前と、料理店のメニューに載っている料理名を比較して、一致する料理名があるかどうかを判断します。
まず、最初の部分では、以下のような情報を受け取ります。
あなたが食べたい料理名を表す文字列 S
料理店のメニューの単語数を表す整数 N
メニュー名を表す単語の文字列が半角スペース区切りで与えられます。
次に、プログラムは与えられたメニューの単語を順番にチェックし、あなたが食べたい料理名と完全一致する料理名があるかどうかを調べます。一致する料理名が見つかった場合、"Yes"を出力して処理を終了します。
一致する料理名が見つからなかった場合、"No"を出力します。
'''

# C143　ファイル名の統一
# utf-8
# ファイル名文字列を入力として受け取る
file_name = input()

# 新しいファイル名を初期化
new_file_name = ""

# ファイル名文字列を1文字ずつ処理する
for i in range(len(file_name)):
    # 現在の文字がハイフンかつ直前の文字もハイフンでない場合、新しいファイル名に追加
    if file_name[i] == '-' and (i == 0 or file_name[i - 1] != '-'):
        new_file_name += '-'
    # 現在の文字がハイフンでない場合、新しいファイル名に追加
    elif file_name[i] != '-':
        new_file_name += file_name[i]

# 新しいファイル名を出力
print(new_file_name)
'''
このプログラムは、与えられたファイル名文字列を処理して、長さ2以上のハイフンをすべて長さ1のハイフンに変更します。
ファイル名文字列を取得します。処理された新しいファイル名を格納するための変数を初期化します。
ファイル名文字列の各文字を処理するために、文字列の長さだけループします。
現在の文字がハイフンであり、直前の文字がハイフンでない場合、新しいファイル名にハイフンを追加します。これにより、連続するハイフンが1つに置き換えられます。
現在の文字がハイフンでない場合、その文字を新しいファイル名に追加します。処理された新しいファイル名を出力します。
これにより、与えられたファイル名文字列内の長さ2以上の連続するハイフンが1つのハイフンに置き換えられます。
'''

# C144　じゃんけんの結果
# utf-8
# 入力を受け取る
N = int(input())

# アリスさんの勝利回数を初期化
alice_wins = 0

# N 回のじゃんけんの結果を処理する
for _ in range(N):
    # アリスさんとボブさんの手を受け取る
    alice_hand, bob_hand = input().split()
    
    # 勝敗を判定する
    if (alice_hand == 'G' and bob_hand == 'C') or \
       (alice_hand == 'C' and bob_hand == 'P') or \
       (alice_hand == 'P' and bob_hand == 'G'):
        # アリスさんが勝った場合、勝利回数をインクリメントする
        alice_wins += 1

# アリスさんの勝利回数を出力
print(alice_wins)
'''
最初に、入力からじゃんけんの回数 N を受け取ります。
アリスさんの勝利回数をカウントするための変数 alice_wins を初期化します。
for ループを使って、N 回のじゃんけんの結果を処理します。
各ループでは、アリスさんとボブさんの出した手を受け取ります。
アリスさんの手を alice_hand、ボブさんの手を bob_hand とします。
勝敗の判定を行います。

アリスさんが勝つ条件は、以下のいずれかです：
アリスさんの手がグー (G) で、ボブさんの手がチョキ (C) の場合
アリスさんの手がチョキ (C) で、ボブさんの手がパー (P) の場合
アリスさんの手がパー (P) で、ボブさんの手がグー (G) の場合
上記の条件が満たされた場合、アリスさんが勝利し、alice_wins をインクリメントします。
ループが終了した後、アリスさんの勝利回数 alice_wins を出力します。

このプログラムは、じゃんけんのルールをコード化し、アリスさんがボブさんに勝った回数を正確にカウントしています。
'''

# C145　公平な得点計算
# utf-8
def calculate_score(N, scores):
    # 最高点と最低点を除いた合計を計算
    total = sum(scores) - max(scores) - min(scores)
    # 得点を計算して小数第一位まで表示
    return float(int(total / (N - 2) * 10)) / 10

# 入力の読み込み
N = int(input())
scores = list(map(int, input().split()))

# 得点を計算して出力
result = calculate_score(N, scores)
print("%.1f" % result)
'''
与えられた審査員の人数と各審査員の得点に基づいて、競技の得点を計算するものです。
まず、calculate_score関数では、与えられた審査員の人数 N と各審査員の得点が格納されたリスト scores を受け取ります。この関数では、まず与えられた得点リストから最高点と最低点を除いた合計を計算します。これにより、審査員の主観を取り除いた合計点が得られます。
次に、合計点を最高点と最低点を除いた人数で割り、その結果を小数第一位までの精度で得点として返します。
次に、main関数では、標準入力から審査員の人数 N を受け取ります。次に、各審査員の得点がスペース区切りで与えられるので、それらをリストとして受け取ります。その後、calculate_score関数を呼び出して得点を計算し、小数第一位までの精度で出力します。
'''

# C146　怪盗からのメッセージ
# utf-8
def decrypt_message(message):
    decrypted_message = ""
    i = 0
    while i < len(message):
        char = message[i]
        if char.isdigit():
            # 連続する数字を処理する
            num = ""
            while i < len(message) and message[i].isdigit():
                num += message[i]
                i += 1
            # 数字を1加算して解読されたメッセージに追加
            decrypted_message += str((int(num) + 1))
        elif char.isalpha():
            # 英字の場合、1文字後ろにずらす
            if char == 'Z':
                decrypted_message += 'A'
            else:
                decrypted_message += chr(ord(char) + 1)
            i += 1
        else:
            # 英字でも数字でもない場合、そのまま追加
            decrypted_message += char
            i += 1
    return decrypted_message

# 入力を受け取る
encrypted_message = input()

# メッセージの解読
decrypted_message = decrypt_message(encrypted_message)

# 解読されたメッセージを出力
print(decrypted_message)
'''
与えられた暗号化されたメッセージを解読し、解読されたメッセージを出力するものです。
まず、decrypt_message 関数が定義されています。この関数は、暗号化されたメッセージを引数として受け取り、解読されたメッセージを返します。解読されたメッセージは decrypted_message という変数に格納されます。
次に、メインの処理が始まります。まず、入力を受け取るために input 関数が使われます。この入力は暗号化されたメッセージです。
その後、解読されたメッセージを出力するために decrypt_message 関数が呼び出されます。解読されたメッセージは decrypted_message 変数に格納され、それが print 関数を使って出力されます。
decrypt_message 関数では、与えられたメッセージを文字ごとに処理します。各文字が英字大文字か数字であるかをチェックし、それに応じて処理を行います。
英字大文字の場合、その文字をアルファベットの次の文字に置き換えます。ただし、Z の場合は A に戻ります。
数字の場合、連続する数字をまとめて処理し、それぞれの数字に1を加算します。ただし、10で割った余りを取ることで、Zの次はAに戻るようにします。
最後に、それ以外の文字（空白など）の場合はそのまま解読されたメッセージに追加します。
解読されたメッセージが完成したら、それを返します。
'''

# C147　
# C148　
# C149
# C150
