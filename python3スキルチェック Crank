※欠番が存在する理由につきましては、出題自体を公開終了した問題が欠番となっております。

--------------------------------------------- C001　※欠番 ◆
# C001 ◆
# C002 ◆
# C003 ◆
# C004 ◆
# C005　アドレス調査
# utf-8
def is_valid_ipv4(ip_string):
    # 入力されたIPアドレスを"."で分割し、各部分が10進数の範囲内にあるかをチェック
    parts = ip_string.split(".")
    if len(parts) != 4:  # IPアドレスが4つの部分で構成されているかをチェック
        return False

    for part in parts:
        if not part.isdigit():  # 数字以外の文字が含まれていないかをチェック
            return False

        num = int(part)
        if num < 0 or num > 255:  # 0から255の範囲内にあるかをチェック
            return False

    return True

# IPアドレスの数を取得
M = int(input().rstrip())

# M行の入力を受け取り、それぞれのIPアドレスの書式を判定して結果を出力
for _ in range(M):
    ip_string = input().rstrip()  # 入力文字列を取得し、末尾の改行を削除
    valid = is_valid_ipv4(ip_string)
    print(valid)  # 書式が合っているかどうかを出力
    
# C006 ハイスコアランキング
# utf-8
def calculate_score(C, X):
    """
    スコアを計算する関数
    :param C: アイテム種別ごとの得点を格納したリスト
    :param X: ユーザーのアイテム持ち数を格納したリスト
    :return: スコア
    """
    score = sum([C[i] * X[i] for i in range(len(C))])
    return round(score)

def top_k_scores(C, X, M, K):
    """
    トップKのスコアを計算する関数
    :param C: アイテム種別ごとの得点を格納したリスト
    :param X: ユーザーのアイテム持ち数を格納したリスト
    :param M: ユーザーの数
    :param K: トップKのスコアを取得する数
    :return: トップKのスコアを格納したリスト
    """
    scores = []
    for i in range(M):
        score = calculate_score(C, X[i])
        scores.append(score)
    top_k_scores = sorted(scores, reverse=True)[:K]
    return top_k_scores

# 入力を受け取る
params = input().split() # 一行目のパラメータをスペースで分割してリストに格納
N = int(params[0])
M = int(params[1])
K = int(params[2])

C = list(map(float, input().split())) # 二行目のパラメータをスペースで分割してリストに格納し、float型に変換
X = [] # 三行目以降のパラメータを二次元リストに格納
for _ in range(M):
    x = list(map(int, input().split())) # 三行目以降のパラメータをスペースで分割してリストに格納し、int型に変換
    X.append(x)

# トップKのスコアを計算
top_k_scores = top_k_scores(C, X, M, K)

# 結果を改行で出力
for i in range(K):
    print(top_k_scores[i])
    
# C007 ◆
# C008 ◆
# C009 ◆
# C010 安息の地を求めて
# utf-8
s = input().strip().split(" ")
n1 = list(map(int, s))  # int変換

cnt = int(input())

for i in range(cnt):
    s = input().strip().split(" ")
    n3 = list(map(int, s))  # int変換

    if ((n3[0] - n1[0]) ** 2) + ((n3[1] - n1[1]) ** 2) >= (n1[2] ** 2):
        print("silent")
    else:
        print("noisy")
        
--------------------------------------------- C011　※欠番 ◆
# C011 ◆
# C012 ◆
# C013　嫌いな数字
# utf-8
# 嫌いな数字を入力
n = int(input())

# 範囲外の場合はエラーを出力して終了
if n < 0 or n > 9:
    print("嫌いな数字は0から9の範囲で入力してください。")
    exit()

# 病室の総数を入力
m = int(input())

# 範囲外の場合はエラーを出力して終了
if m < 1 or m > 100:
    print("病室の総数は1から100の範囲で入力してください。")
    exit()

# 希望する病室の部屋番号を格納するリスト
desired_rooms = []

# 各病室の部屋番号を入力し、希望する病室をリストに追加
for i in range(m):
    room_number = int(input())

    # 範囲外の場合はエラーを出力して終了
    if room_number < 1 or room_number > 1000:
        print("部屋番号は1から1000の範囲で入力してください。")
        exit()

    if str(n) not in str(room_number): # 部屋番号に嫌いな数字が含まれていない場合
        desired_rooms.append(room_number)

# 希望する病室があるかどうかを判定し、出力
if len(desired_rooms) > 0:
    for room in desired_rooms:
        print(room)
else:
    print("none")
        
# C014　ボールが入る箱
# utf-8
# 入力からボールの半径と箱の情報を取得
n, r = map(int, input().split())
boxes = []
for i in range(n):
    h, w, d = map(int, input().split())
    boxes.append((h, w, d))

# ボールを収納することができる箱の番号を格納するリストを初期化
result = []

# 各箱について、ボールを収納できるかを判定
for i in range(n):
    h, w, d = boxes[i]
    # 箱の高さ、幅、奥行きのうち最も短いものを取得
    shortest_side = min(h, w, d)
    # ボールの直径が最も短い箱の辺の長さ以下であれば、ボールを収納できる
    if shortest_side >= 2 * r:
        result.append(i + 1)  # 箱の番号をリストに追加

# 結果を昇順に出力
for num in result:
    print(num)
    
# C015 ポイントカードの計算
# utf-8
# coding: utf-8
import math

cnt = int(input())

sum = 0
for i in range(cnt):
    s = input().strip().split(" ")
    a = str(s[0])
    n = int(s[1])

    if "3" in a:
        sum += math.floor(n / 100 * 3)
    elif "5" in a:
        sum += math.floor(n / 100 * 5)
    else:
        sum += math.floor(n / 100)

print(sum)

# C016 Leet文字列
# utf-8
def to_leet_string(input_string):
    leet_rules = {
        'A': '4',
        'E': '3',
        'G': '6',
        'I': '1',
        'O': '0',
        'S': '5',
        'Z': '2'
    }

    leet_string = ''
    for char in input_string:
        if char.upper() in leet_rules:
            leet_string += leet_rules[char.upper()]
        else:
            leet_string += char

    return leet_string

input_string = input().rstrip() # 入力文字列を取得し、末尾の改行を削除
leet_string = to_leet_string(input_string)
print(leet_string, end='\n') # Leet文字列を出力し、最後に改行を追加

# C017　ハイアンドロー・カードゲーム
def compare_cards(parent_card, child_card):
    """
    親カードと子カードの強弱関係を比較する関数

    Args:
        parent_card (tuple): 親カードの情報。(1つ目の番号, 2つ目の番号)
        child_card (tuple): 子カードの情報。 (1つ目の番号, 2つ目の番号)

    Returns:
        str: 強弱関係の結果を表す文字列。'High'、'Low'のいずれか。
    """
    parent_num1, parent_num2 = parent_card
    child_num1, child_num2 = child_card

    if parent_num1 > child_num1:
        return 'High'
    elif parent_num1 < child_num1:
        return 'Low'
    else:
        if parent_num2 < child_num2:
            return 'High'
        else:
            return 'Low'

# 親カードの情報を入力
parent_card = tuple(map(int, input().split()))

# 子カードの数を入力
n = int(input())

# 子カードの情報を入力し、強弱関係を判定して出力
for i in range(n):
    child_card = tuple(map(int, input().split()))
    result = compare_cards(parent_card, child_card)
    print(result)

# C018 何人前作れる?
# レシピに書かれている食材の数を取得
n = int(input())

# レシピの食材と必要量を辞書に格納
recipe = {}
for i in range(n):
    a, b = input().split()
    recipe[a] = int(b)

# あなたが所持している食材の数を取得
m = int(input())

# 所持している食材と数量を辞書に格納
ingredients = {}
for i in range(m):
    c, d = input().split()
    ingredients[c] = int(d)

# 最大で何人前作れるかを計算
max_servings = float('inf')  # 初期値を無限大に設定

# レシピの食材と必要量をループし、所持している食材と比較
for ingredient, amount in recipe.items():
    if ingredient in ingredients:
        max_servings = min(max_servings, ingredients[ingredient] // amount)
    else:
        max_servings = 0
        break

# 最大で何人前作れるかを出力
print(max_servings)

# C019 完全数とほぼ完全数
# utf-8
def is_perfect_or_almost_perfect_number(n):
    """
    入力された整数が完全数かほぼ完全数かそのいずれでもないかを判定する関数

    Args:
        n (int): 判定する整数

    Returns:
        str: 完全数、ほぼ完全数、そのいずれでもないことを示す文字列
    """
    # 約数の和を計算
    s = 0
    for i in range(1, n):
        if n % i == 0:
            s += i

    # 完全数の判定
    if n == s:
        return "perfect"

    # ほぼ完全数の判定
    if abs(n - s) == 1:
        return "nearly"

    # その他の場合
    return "neither"


# 判定したい整数の個数を入力
q = int(input())

# 入力範囲を満たすかチェック
if q < 1 or q > 50:
    print("Error: 1 ≦ Q ≦ 50 の範囲で入力してください。")
    exit(1)

# 各整数について判定を行い結果を出力
for i in range(q):
    n = int(input())

    # 入力範囲を満たすかチェック
    if n < 2 or n > 1000:
        print("Error: 2 ≦ N_i ≦ 1000 の範囲で入力してください。")
        exit(1)

    result = is_perfect_or_almost_perfect_number(n)
    print(result)
        
# C020　残り物の量
# utf-8
def calculate_leftover_amount(m, p, q):
    """
    生鮮食品の売れ残り量を計算する関数

    Args:
        m (int): 生鮮食品の仕入れ量(kg)
        p (int): 生のまま売れた割合(%)
        q (int): お総菜に変換された売れ残りの割合(%)

    Returns:
        float: 最終的な売れ残り量(kg)
    """
    # 生鮮食品の売れ残り量を計算
    leftover_amount = m * (100 - p) / 100

    # お総菜に変換された売れ残り量を計算
    leftover_amount = leftover_amount * (100 - q) / 100

    return leftover_amount


# 生鮮食品の仕入れ量、生のまま売れた割合、お総菜に変換された売れ残りの割合を入力
m, p, q = map(int, input().split())

# 生鮮食品の売れ残り量を計算
leftover_amount = calculate_leftover_amount(m, p, q)

# 売れ残り量を小数値で出力
print("{:.4f}".format(leftover_amount))
--------------------------------------------- C021　※欠番 ◆
# C021　暴風域にいますか
# utf-8
import math

def is_in_typhoon(xc, yc, r1, r2, x, y):
    """
    台風の暴風域にあるかどうかを判定する関数

    Args:
        xc (int): 台風1の中心のx座標
        yc (int): 台風1の中心のy座標
        r1 (int): 台風1の半径
        r2 (int): 台風2の半径
        x (int): 判定する人のx座標
        y (int): 判定する人のy座標

    Returns:
        bool: 台風の暴風域にある場合True、そうでない場合False
    """
    distance_squared = (x - xc) ** 2 + (y - yc) ** 2
    if r1 ** 2 <= distance_squared <= r2 ** 2:
        return True
    else:
        return False

# 台風情報の入力
xc, yc, r1, r2 = map(int, input().split())
# 人の数の入力
n = int(input())

# 各人の座標の入力と判定
for i in range(n):
    x, y = map(int, input().split())
    if is_in_typhoon(xc, yc, r1, r2, x, y):
        print("yes")
    else:
        print("no")
    
# C022 ローソク足
# utf-8
# 日数 n を入力
n = int(input())

# 株価データを入力し、始値、終値、高値、安値を計算
start_prices = []
end_prices = []
high_prices = []
low_prices = []

for i in range(n):
    s, e, h, l = map(int, input().split())
    start_prices.append(s)
    end_prices.append(e)
    high_prices.append(h)
    low_prices.append(l)

# n日間の始値を計算
start_price = start_prices[0]

# n日間の終値を計算
end_price = end_prices[-1]

# n日間の高値を計算
high_price = max(high_prices)

# n日間の安値を計算
low_price = min(low_prices)

# 結果を出力
print(start_price, end_price, high_price, low_price, end='')

# C023 クジの当選番号
# utf-8
import sys
a = [int(s) for s in sys.stdin.readline().split()]
N=int(input())
b = [[int(s) for s in line.split()] for line in sys.stdin]
for j in range(N):
    c=0
    for i in range(len(b[0])):
        if a[i] in b[j]:
            c += 1
    print(c)
    
# C024　ミニ・コンピュータ
# coding: utf-8
n = int(input())
num1 = 0
num2 = 0

cul = []

for i in range(0, n):
    cul.append(input().split(" "))

    #SET
    if("SET" in cul[i]):
        if(cul[i][1] == "1"):
            num1 = int(cul[i][2])
        else:
            num2 = int(cul[i][2])
    #ADD
    elif("ADD" in cul[i]):
        num2 = num1 + int(cul[i][1])
    #SUB
    else:
        num2 = num1 - int(cul[i][1])

print(num1, num2)

# C025　ファックスの用紙回収
# utf-8
def simulate_computer(instructions):
    """
    コンピュータをシミュレートする関数

    Args:
        instructions (list): コンピュータに与える命令のリスト

    Returns:
        tuple: 変数1と変数2の最終的な値のタプル
    """
    var1 = 0  # 変数1の初期値
    var2 = 0  # 変数2の初期値

    for instruction in instructions:
        operation = instruction[0]
        value = instruction[1]

        if operation == "SET":
            var_idx = int(instruction[2]) - 1  # 変数のインデックス
            if var_idx == 0:
                var1 = value
            elif var_idx == 1:
                var2 = value
        elif operation == "ADD":
            var2 += value
        elif operation == "SUB":
            var2 -= value

    return var1, var2

# 命令の数を入力
n = int(input("命令の個数を入力してください: "))

instructions = []
# 命令のリストを入力
for i in range(n):
    while True:
        instr = input(f"命令{i+1}を入力してください（例: SET 1 10、ADD 5、SUB 3）: ").split()
        if len(instr) != 3 or instr[0] not in ["SET", "ADD", "SUB"] or not instr[1].isdigit() or not instr[2].isdigit():
            print("命令のフォーマットが不正です。再度入力してください。")
        else:
            break
    instructions.append([instr[0], int(instr[1]), int(instr[2])])

# コンピュータをシミュレートし、変数1と変数2の最終的な値を取得
result = simulate_computer(instructions)

# 変数1と変数2の最終的な値を半角スペース区切りで1行に出力し、最後に改行を追加
print(*result, sep=" ", end="\n")

# C026　ウサギと人参
# utf-8
# 入力を受け取る
N, S, p = map(int, input().split())  # 人参のデータの数、目安となる糖分、許容誤差

max_mass = -1  # 最大質量を初期化
max_index = -1  # 最大質量の人参の番号を初期化

# N個の人参データを入力として受け取る
for i in range(1, N + 1):
    data = list(map(int, input().split()))  # 質量と糖分をスペース区切りで入力
    mass = data[0]  # 人参の質量
    sugar = data[1]  # 人参の糖分

    # 糖分が許容範囲内でかつ質量が最大の場合、最大質量とその人参の番号を更新
    if S - p <= sugar <= S + p and mass > max_mass:
        max_mass = mass
        max_index = i

if max_index != -1:
    print(max_index)  # 最大質量の人参の番号を出力
else:
    print("not found")  # 見つからなかった場合は "not found" を出力

# C027　◆
# C028　単語テストの採点
# utf-8
N = int(input())
words = [input().split() for x in range(N)] #出力[q_1,a_1][q_2,a_2]....
score = 0

for word in words:
    if len(word[0]) == len(word[1]):
        miss = 0 #missは毎回０になる必要がある
        for i in range(len(word[0])):#文字の長さだけ繰り返される(if文で文字列の数が違うものは省いているので差異を気にする必要はない)
            if (word[0])[i] != (word[1])[i]:#リストにしている単語を1文字ずつ(i)比べる
                miss += 1
        
        if miss < 1:
            score += 2
            
        elif miss < 2:
            score += 1
            
print(score)

# C029　旅行の計画
# utf-8
# 連休の日数を表す整数 M と 旅行の日数を表す整数 N を入力から取得
M, N = map(int, input().split())

# 連休の日付と降水確率を格納するリスト
dates = []
rainfall_probs = []

# 連休の日付と降水確率を入力から取得
for _ in range(M):
    d, r = map(int, input().split())
    dates.append(d)
    rainfall_probs.append(r)

# N日間の降水確率の平均が最も低くなる日程の最初の日付と最後の日付を初期化
min_avg_rainfall_prob = float('inf')
start_date = -1
end_date = -1

# 連休の日付をスライドさせながらN日間の降水確率の平均を計算し、最も低い値を探索
for i in range(M - N + 1):
    avg_rainfall_prob = sum(rainfall_probs[i:i+N]) / N
    if avg_rainfall_prob < min_avg_rainfall_prob:
        min_avg_rainfall_prob = avg_rainfall_prob
        start_date = dates[i]
        end_date = dates[i + N - 1]

# 結果を出力
print(start_date, end_date)

# C030　白にするか黒にするか
# utf-8
# 画像のサイズを表す整数 H, W を入力から取得
H, W = map(int, input().split())

# 画像の各画素値を表す整数の二次元配列 img を入力から取得
img = []
for _ in range(H):
    row = list(map(int, input().split()))
    img.append(row)

# 二値画像に変換して結果を出力
for i in range(H):
    for j in range(W):
        # 画素値が 128 以上ならば 1 (白)、それ以下ならば 0 (黒) に変換
        if img[i][j] >= 128:
            img[i][j] = 1
        else:
            img[i][j] = 0
        print(img[i][j], end=" ")  # 変換結果をスペース区切りで出力
    print()  # 改行して次の行を出力

--------------------------------------------- C031　※欠番 ◆
# C031　時差を求めたい
# utf-8
# 都市ごとの時差を管理する辞書を作成
time_difference = {}

# 都市の総数を入力
N = int(input())

# 都市ごとの時差情報を入力
for i in range(N):
    city_info = input().split()
    city_name = city_info[0]
    time_difference[city_name] = int(city_info[1])

# ユーザの所在地の都市と投稿時刻を入力
user_city, user_time = input().split()

# ユーザの所在地の都市の時差を取得
user_time_difference = time_difference[user_city]

# ユーザの投稿時刻を時と分に分割
user_hour, user_minute = map(int, user_time.split(':'))

# 各都市ごとに投稿時刻を修正して出力
for city, diff in time_difference.items():
    # ユーザの所在地の都市の場合はそのまま出力
    if city == user_city:
        print(user_time)
    else:
        # 各都市の時差を考慮して投稿時刻を修正
        city_hour = (user_hour + diff - user_time_difference + 24) % 24
        city_minute = user_minute
        # 時と分を0埋め2桁の文字列に変換して出力
        print('{:02d}:{:02d}'.format(city_hour, city_minute))

# C032　お得な買い物
# utf-8
n=int(input())
a=[0]*4
for i in range(n):
    v,p=map(int, input().split())
    a[v]=a[v]+p
print(a[0]//100*5+a[1]//100*3+a[2]//100*2+a[3]//100*1)

# C033　◆
# C034　先生の宿題
def calculate_answer(problem):
    # 問題をスペースで分割して、各要素を取得
    elements = problem.split(" ")
    a = elements[0]
    op = elements[1]
    b = elements[2]
    c = elements[4]
    
    # a, b, c のうち空欄を特定し、答えを計算
    if a == "x":
        if op == "+":
            answer = int(c) - int(b)
        elif op == "-":
            answer = int(c) + int(b)
    elif b == "x":
        if op == "+":
            answer = int(c) - int(a)
        elif op == "-":
            answer = int(a) - int(c)
    elif c == "x":
        if op == "+":
            answer = int(a) + int(b)
        elif op == "-":
            answer = int(a) - int(b)
    
    # 答えが 0 から 9 の間に収まるように制限
    if answer < 0:
        answer = 0
    elif answer > 9:
        answer = 9
        
    return str(answer)
            
# 問題を入力として受け取る
problem = input()

# 答えを計算して出力
answer = calculate_answer(problem)
print(answer)

# C035　試験の合格判定
# utf-8
# 受験者の人数を入力
N = int(input())

# 2段階選抜を通過できる人数をカウントする変数を初期化
passed_count = 0

# 各受験者の情報を入力し、2段階選抜を通過できるかを判定
for i in range(N):
    # 受験者の情報を入力
    data = input().split()
    t_i = data[0]  # 文理の区分
    e_i = int(data[1])  # 英語の点数
    m_i = int(data[2])  # 数学の点数
    s_i = int(data[3])  # 理科の点数
    j_i = int(data[4])  # 国語の点数
    g_i = int(data[5])  # 地理歴史の点数
    
    # 各科目の合計得点を計算
    total_score = e_i + m_i + s_i + j_i + g_i
    
    # 理系か文系かを判定
    is_science_major = t_i == "s"
    is_literature_major = t_i == "l"
    
    # 2段階選抜の条件を満たすかを判定
    if total_score >= 350 and ((is_science_major and (m_i + s_i) >= 160) or (is_literature_major and (j_i + g_i) >= 160)):
        passed_count += 1

# 2段階選抜を通過できる人数を出力
print(passed_count)

# C036　犬ぞりトーナメント
# utf-8
f1 = [int(_) for _ in sorted(input().split())]
f2 = [int(_) for _ in sorted(input().split())]
t1 = [int(_) for _ in input().split()]
t2 = [int(_) for _ in input().split()]

s = [f1[0] if t1[f1[0]-1] < t1[f1[1]-1] else f1[1]]
s += [f2[0] if t1[f2[0]-1] < t1[f2[1]-1] else f2[1]]
s.sort()
print(s[0] if t2[0] < t2[1] else s[1])
print(s[1] if t2[0] < t2[1] else s[0])

# C037　アニメの日時
# utf-8
import re
# 入力を受け取る
t = input().rstrip()

# 正規表現を使って入力の日付時刻をパース
pattern = r'(\d{2})/(\d{2}) (\d{2}):(\d{2})'
match = re.match(pattern, t)

if match:
    # パースに成功した場合
    month = int(match.group(1))
    day = int(match.group(2))
    hour = int(match.group(3))
    minute = int(match.group(4))
    
    # 月と日が不正な値の場合には修正する
    while month > 12 or day > 31:
        if month > 12:
            month -= 12
        if day > 31:
            day -= 31
    
    # 時間が 24 以上の場合は日付を繰り上げる
    while hour >= 24:
        hour -= 24
        day += 1
        
    # パースした値を元のフォーマットで出力
    print("{:02d}/{:02d} {:02d}:{:02d}".format(month, day, hour, minute))
else:
    # パースに失敗した場合は入力の日付時刻をそのまま出力
    print(t)

# C038　お菓子の分配
# utf-8
n = input().strip().split(" ")
n = list(map(int, n))   # int変換

ans = [0, 1001, 1001]  # No, mod, q

for i in range(n[0]):
    a = int(input())
    m = n[1] % a
    q = n[1] // a

    if (m < ans[1])or (m == ans[1] and q < ans[2]):
        ans[0] = i + 1
        ans[1] = m
        ans[2] = q

print(ans[0])

# C039　古代の数式
# utf-8
line = input()
# print(line)
line_list = list(line)
# print(line_list)

cnt_k=0
cnt_l=0

for i in range(len(line)):
    # print(i)
    if line_list[i]=="<":
        cnt_k += 1
    # print(cnt_k)
    if line_list[i]=="/":
        cnt_l += 1
    
print(cnt_k*10 + cnt_l)

# C040　背比べ
# utf-8
n = int(input())
comps = [input().split() for x in range(n)]
l,r=0,1000
for comp in comps:
  if comp[0] == 'ge':
    l = max(l,float(comp[1]))
  else:
    r = min(r,float(comp[1]))
print(l,r)

--------------------------------------------- C041　※欠番 ◆
# C041　メダルランキングの作成
# utf-8
# 入力を受け取る
N = int(input())  # 国の総数
medals = []  # メダルの獲得数を格納するリスト

# メダルの獲得数を入力から取得し、リストに格納
for i in range(N):
    g, s, b = map(int, input().split())
    medals.append((g, s, b))

# メダルの獲得数を条件にそってソート
medals.sort(reverse=True)

# ソートされたメダルの獲得数を出力
for medal in medals:
    print(*medal)

# C042　リーグ表の作成
# utf-8
# 参加者数を入力から取得
N = int(input())

# 各試合の結果を入力から取得
results = {}
for i in range(1, N * (N - 1) // 2 + 1):
    f, s = map(int, input().split())
    results[i] = (f, s)

# 表の初期化
table = [['-' for _ in range(N)] for _ in range(N)]

# 各試合の結果を表に反映
for i, (f, s) in results.items():
    table[f - 1][s - 1] = 'W'
    table[s - 1][f - 1] = 'L'

# 表の出力
for row in table:
    print(' '.join(row))
    
# C043　使用回数の調査
# utf-8
import collections

n = int(input())
m = input().strip().split(" ")
m = list(map(int, m))   # int変換

c = collections.Counter(m)

mc = c.most_common()

mx = mc[0][1]
l = []

for x in mc:
    if x[1] < mx:
        break
    else:
        l.append(x[0])

l.sort()

print(" ".join([str(x) for x in l]))

# C044　手の組み合わせ
# utf-8
n = int(input())

h = []
for i in range(n):
    h.append(input())

h = sorted(set(h))

if len(h) == 2:
    if h[0] == 'paper':
        if h[1] == 'rock':
            print(h[0])
        else:
            print(h[1])
    else:
        print(h[0])

else:
    print("draw")
    
# C045　ページネーション
# utf-8
def paginate_search_results(n, s, p):
    start = (p - 1) * s + 1 # 開始番号
    end = min(n, p * s) # 終了番号
    if start > n:
        return "none" # 検索結果が存在しない場合は"none"を返す
    else:
        return list(range(start, end + 1)) # 開始番号から終了番号までのリストを返す

# 入力の取得
n, s, p = map(int, input().split())

# ページネーションの実行
result = paginate_search_results(n, s, p)

# 出力
if result == "none":
    print(result)
else:
    print(*result)
    
# C046　書籍購入費ランキング
# utf-8
member = int(input())
name = input()
names = name.split()

book = int(input())
buy = [input() for i in range(book)]

dic = {}

for members in range(member):
	dic[names[members]] = 0

for books in buy:
	temp = books.split()
	dic[temp[0]] += int(temp[1])
	
for k, v in sorted(dic.items(), key=lambda x: x[1], reverse=True):
	print(k)
    
# C047　◆
# C048　タダ飲みコーヒー
# utf-8
import math

row = input()

sp = row.split()

# print(sp)

price = int(sp[0])
discount = int(sp[1])

after_price = price
total = price
count = 0

while after_price > 0:
	# 切り捨て
	after_price = math.floor(after_price * (100 - discount)/100)
	total += after_price
	
print(total)

# C049　エレベーター
# utf-8
# 入力を受け取る
N = int(input())  # ログの行数
floors = []  # エレベーターが止まった階のリスト
for _ in range(N):
    floor = int(input())
    floors.append(floor)

# エレベーターが合計で何階分の距離を動いたか計算する
total_distance = 0  # 合計の距離
current_floor = 1  # 現在の階数は必ず1階とする
for floor in floors:
    distance = abs(floor - current_floor)  # 現在の階数から目的の階数までの距離
    total_distance += distance  # 合計の距離に加算
    current_floor = floor  # 現在の階数を更新

# 結果を出力
print(total_distance)

# C050　オークションの結果
# utf-8
S,a,b=map(int,input().split())
while True:
    if a>=S+10:
        S=S+10
    else:
        print("B",S)
        break
    if b>=S+1000:
        S=S+1000
    else:
        print("A",S)
        break
--------------------------------------------- C051　※欠番 ◆
# C051　カード並べ
# utf-8
numlist=list(map(int,input().split()))#a, b, c, d はそれぞれ 4 枚のカード
newlist=sorted(numlist)#昇順に並び替え #例： 2, 3, 8 , 9
num1=str(newlist[3])+str(newlist[1])
num2=str(newlist[2])+str(newlist[0])
print(int(num1)+int(num2))

# C052　ゲームの画面
# utf-8
w = input().strip().split(" ")
w = list(map(int, w))   # int変換

n = input().strip().split(" ")
n = list(map(int, n))   # int変換

ful = w[0] * w[1]
used = (w[0] - abs(n[0])) * (w[1] - abs(n[1]))

print(ful - used)

# C053　カードの合計
# utf-8
party = int(input())

cards = input()
cards_split = cards.split()
ten = "x10" in cards_split

bonus = 1

if ten is True:
    cards_split.remove("x10")
    bonus = 10

cards_split_i = [int(s) for s in cards_split]

zero = "0" in cards_split

if zero is True:
    max_num = max(cards_split_i)
    cards_split_i.remove(max_num)

res = sum(cards_split_i) * bonus

print(res)

# C054　スピード違反の取り締まり
# utf-8
n = input().strip().split(" ")
n = list(map(int, n))   # int変換

t = []
p = []
while True:
    try:
        a = input().strip().split(" ")
        a = list(map(int, a))   # int変換
        t.append(a[0])
        p.append(a[1])

    except EOFError:
        break

ans = "NO"

for i in range(n[0]):
    if i == 0:
        continue

    if (p[i] - p[i-1]) / (t[i] - t[i-1]) > n[1]:
        ans = "YES"
        break

print(ans)

# C055　ログのフィルター
# utf-8
import re

N = int(input())
# print(N)
string = input()
# print(string)
flag = 0
for i in range(N):
    abc = input()
    
    if string in abc:
        print(abc)
        flag = 1
        
if flag == 0:
    print('None')
    
# C056　テストの採点
# utf-8
from sys import stdin

n, m = map(int, stdin.readline().rstrip().split())
test_results = [list(map(int, stdin.readline().rstrip().split())) for i in range(n)]
# pass_students_id = [i + 1 for i, result in enumerate(test_results) if (result[0] - result[1] * 5) >= m]
pass_students_id = []
for i, result in enumerate(test_results):
  r1 = result[0] - result[1] * 5
  r = r1 if r1 >= 0 else 0
  if r >= m:
    pass_students_id.append(i+1)
for i in pass_students_id:
  print(i)

# C057　シャボン玉飛ばし
# utf-8
# 入力を受け取る
T, x, y = map(int, input().split())
wind = []
for _ in range(T):
    a, b = map(int, input().split())
    wind.append((a, b))

# シャボン玉の位置を更新しながら最大の x 座標を求める
max_x = x
for i in range(T):
    a, b = wind[i]
    # シャボン玉の位置を更新
    x += a
    y += b
    # y 座標が 0 以下になったらシャボン玉が割れるので、最大の x 座標を出力して終了
    if y <= 0:
        print(max_x)
        exit()
    # x 座標の最大値を更新
    max_x = max(max_x, x)

# T 時間経過後までシャボン玉が割れずに生き残った場合、最終的な x 座標を出力
print(max_x)

# C058　模様そろえ
# utf-8
# 入力を受け取る
input_line = input().strip().split()
N = int(input_line[0])  # 箱の側面の数
t = input_line[1]  # そろえる向きを表す文字列
s = input_line[2]  # 最初の箱の向きを表す文字列

# 最小回転数を計算
rotation = (s + s).find(t)  # sを2つ繋げて、tが最初に出現するインデックスを求める

# 最小回転数がN以上の場合は、回転数を修正する
if rotation >= N:
    rotation = N - rotation

# 結果を出力
print(rotation)

# C059　パリティチェック
# utf-8
# 入力データの取得
N = int(input())  # 2進数の数
binary_list = []  # 2進数のリスト
for i in range(N):
    binary = input().strip()
    binary_list.append(binary)

# 排他的論理和(XOR)を計算して結果を出力する関数
def calculate_xor(binary_list):
    result = ""
    for i in range(4):  # 4桁の2進数なので4回繰り返す
        count = 0
        for j in range(N):
            if binary_list[j][i] == '1':
                count += 1
        if count % 2 == 1:
            result += '1'
        else:
            result += '0'
    return result

# 排他的論理和(XOR)を計算して結果を出力
result = calculate_xor(binary_list)
print(result)

# C060　辞書の作成
# utf-8
def get_words_on_page(N, K, P, words):
    # 辞書順に単語を並び替える
    words.sort()

    # P ページ目に載る単語のインデックスを計算
    start_idx = (P - 1) * K
    end_idx = min(start_idx + K, N)

    # P ページ目に載る単語のリストを取得
    words_on_page = words[start_idx:end_idx]

    return words_on_page

# 入力の受け取り
N, K, P = map(int, input().split())
words = input().strip().split()

# 入力のバリデーション
if not (3 <= N <= 1000) or not (1 <= K <= N) or not (1 <= P <= N):
    print("入力値が条件を満たしていません。")
    exit(1)

if len(words) != N or len(set(words)) != N:
    print("入力される単語が条件を満たしていません。")
    exit(1)

for word in words:
    if not (0 <= len(word) <= 10):
        print("入力される単語の長さが条件を満たしていません。")
        exit(1)

# P ページ目に載る単語のリストを取得
words_on_page = get_words_on_page(N, K, P, words)

# 結果を改行区切りで出力
print("\n".join(words_on_page))

'''
# 別解
N, K, P = map(int,input().split())
s = input().split()
s.sort()
j = []
for i in range(0, N, K):
    j.append(s[i:i+K])
for k in j[P-1]:
    print(k)

'''
--------------------------------------------- C061　※欠番 ◆
# C061　繰り上がりのない足し算
# utf-8
A, B = map(str,input().split())
s = ""
if max(len(A), len(B)) == 3:
    s += str((int(A) // 100 + int(B) // 100) % 10)
if max(len(A), len(B)) >= 2:
    s += str((int(A) // 10 + int(B) // 10) % 10)
s += str((int(A) + int(B)) % 10)
print(s)

# 別解
def add_with_kids_method(num1, num2):
    len_diff = abs(len(num1) - len(num2))

    if len(num1) > len(num2):
        num2 = '0' * len_diff + num2
    else:
        num1 = '0' * len_diff + num1

    result = ''
    for i in range(len(num1)-1, -1, -1):
        digit1 = int(num1[i])
        digit2 = int(num2[i])
        sum_digits = digit1 + digit2
        result = str(sum_digits % 10) + result

    return result


# 入力を受け取る
input_str = input().rstrip()  # 入力を1行受け取り、末尾の改行を削除
num1, num2 = input_str.split()  # スペース区切りで入力を分割
result = add_with_kids_method(num1, num2)  # 繰り上がりを無視して足し算を実行
print(result)  # 結果を出力

# C062　回転寿司のメロン
# utf-8
t = int(input())  # 皿の数を取得

a = 0  # 食べたメロンの数をカウントする変数
b = 10  # 滞在時間のカウントダウン用の変数

for i in range(t):
    n = input()  # ネタを取得
    b += 1  # 滞在時間をカウントダウン
    if n == 'melon' and b > 10:  # ネタがメロンであり、滞在時間が10を超えた場合にメロンを食べる
        a += 1  # メロンの数をカウント
        b = 0  # 滞在時間をリセット

print(a)  # 結果を出力

# C063　ガーデニング
# utf-8
N = int(input())

flowers = [[int(i) for i in input().split()] for j in range(N)]
bloom_days = []
max_count = 0
max_date = 10000

for i, j in flowers:
    bloom_day = i + j
    bloom_days.append(bloom_day)

for day in bloom_days:
    count = bloom_days.count(day)
    if count > max_count or (count == max_count and day < max_date):
        max_count = count
        max_date = day

print(max_date)
'''
x リストを使用せずに、bloom_days リストに直接花が咲く日数を追加しました。
2 重の for ループを使用する代わりに、count() メソッドを使用して同じ日数の花の個数を数えました。
最大の花の個数と日数を更新する際に、max_count と max_date の比較を行い、必要に応じて更新しました。
'''

# C064　paizaでお食事
# utf-8
M, N = map(int, input().split())

c = [int(input()) for i in range(M)]
a = [list(map(int, input().split())) for i in range(N)]

for i in range(N):
    total_calories = sum([c[j-1]*a[i][j-1]//100 for j in range(1, M+1)])
    print(total_calories)

# C065　数字あてゲーム

# C066　金魚すくい
# C067　数字の調査
# C068　秘密の手紙
# C069　お祭りの日付
# C070　簡易カードゲーム
--------------------------------------------- C071　※欠番 ◆
# C071　直角三角形
# C072　モンスターの進化
# C073　うさぎとかめ
# C074　文章サイズ変更
# C075　ポイント払い
# C076　給与の計算
# C077　レポートの評価
# C078　株の売買
# C079　カードを集める
# C080　ボタンを押すゲーム
--------------------------------------------- C081　※欠番 ◆
# C081　靴下の整理
# C082　テストの赤点
# C083　売上の発表
# C084　枠で囲む
# C085　壊れかけのキーボード
# C086　ハンドルネームの生成
# C087　数字の規則
# C088　RPGでお買い物
# C089　ストラックアウト
# C090　黒電話
--------------------------------------------- C091　※欠番 ◆
# C091　みかんの仕分け
# C092　工場のベルトコンベア
# C093　下桁ルール
# C094　国民の税金
# C095　合言葉
# C095　バスの時間(番号ダブり)
# C096　夏休み
# C097　プレゼント応募企画の実施
# C098　多重パス回し
# C099　折り紙の貼り合わせ
# C100　選曲の方法
--------------------------------------------- C101　※欠番 ◆
# C101　ラッキーデイ
# C102　行きたいライブのスケジュール
# C103　ロボット芸人
# C104　虫食い算
# C105　カードのスコア
# C106　メダル授与式
# C107　ランクの計算
# C108　観光の計画
# C109　IDを登録順に並べよう
# C110　就職活動
--------------------------------------------- C111　※欠番 ◆
# C111　ハッシュ関数
# C112　時差ボケ
# C113　一人でスゴロク
# C114　しりとりの判定
# C115　渋滞の距離
# C116　あたり棒の検査
# C117　大量出店
# C118　ダイヤル数
# C119　お菓子かいたずらか
# C120　花のリース
--------------------------------------------- C121　※欠番 ◆
# C121　レストランの人気メニュー
# C122　プレゼントのセール
# C123　節分ロボット
# C124　インターンへの応募
# C125　カードの積
# C126　宿泊費と交通費
# C127　割引キャンペーン
# C128　連分数
# C129
# C130
--------------------------------------------- C131　※欠番 ◆
# C131　
# C132　
# C133　
# C134　
# C135　
# C136　
# C137　
# C138　
# C139
# C140
--------------------------------------------- C141　※欠番 ◆
# C141　
# C142　
# C143　
# C144　
# C145　
# C146　
# C147　
# C148　
# C149
# C150
