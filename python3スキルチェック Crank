※欠番が存在する理由につきましては、出題自体を公開終了した問題が欠番となっております。

--------------------------------------------- C001　※欠番 ◆
# C001 ◆
# C002 ◆
# C003 ◆
# C004 ◆
# C005　アドレス調査
utf-8
def is_valid_ipv4(ip_string):
    # 入力されたIPアドレスを"."で分割し、各部分が10進数の範囲内にあるかをチェック
    parts = ip_string.split(".")
    if len(parts) != 4:  # IPアドレスが4つの部分で構成されているかをチェック
        return False

    for part in parts:
        if not part.isdigit():  # 数字以外の文字が含まれていないかをチェック
            return False

        num = int(part)
        if num < 0 or num > 255:  # 0から255の範囲内にあるかをチェック
            return False

    return True

# IPアドレスの数を取得
M = int(input().rstrip())

# M行の入力を受け取り、それぞれのIPアドレスの書式を判定して結果を出力
for _ in range(M):
    ip_string = input().rstrip()  # 入力文字列を取得し、末尾の改行を削除
    valid = is_valid_ipv4(ip_string)
    print(valid)  # 書式が合っているかどうかを出力
    
# C006 ハイスコアランキング
# utf-8
def calculate_score(C, X):
    """
    スコアを計算する関数
    :param C: アイテム種別ごとの得点を格納したリスト
    :param X: ユーザーのアイテム持ち数を格納したリスト
    :return: スコア
    """
    score = sum([C[i] * X[i] for i in range(len(C))])
    return round(score)

def top_k_scores(C, X, M, K):
    """
    トップKのスコアを計算する関数
    :param C: アイテム種別ごとの得点を格納したリスト
    :param X: ユーザーのアイテム持ち数を格納したリスト
    :param M: ユーザーの数
    :param K: トップKのスコアを取得する数
    :return: トップKのスコアを格納したリスト
    """
    scores = []
    for i in range(M):
        score = calculate_score(C, X[i])
        scores.append(score)
    top_k_scores = sorted(scores, reverse=True)[:K]
    return top_k_scores

# 入力を受け取る
params = input().split() # 一行目のパラメータをスペースで分割してリストに格納
N = int(params[0])
M = int(params[1])
K = int(params[2])

C = list(map(float, input().split())) # 二行目のパラメータをスペースで分割してリストに格納し、float型に変換
X = [] # 三行目以降のパラメータを二次元リストに格納
for _ in range(M):
    x = list(map(int, input().split())) # 三行目以降のパラメータをスペースで分割してリストに格納し、int型に変換
    X.append(x)

# トップKのスコアを計算
top_k_scores = top_k_scores(C, X, M, K)

# 結果を改行で出力
for i in range(K):
    print(top_k_scores[i])
    
# C007 ◆
# C008 ◆
# C009 ◆
# C010 安息の地を求めて
# utf-8
s = input().strip().split(" ")
n1 = list(map(int, s))  # int変換

cnt = int(input())

for i in range(cnt):
    s = input().strip().split(" ")
    n3 = list(map(int, s))  # int変換

    if ((n3[0] - n1[0]) ** 2) + ((n3[1] - n1[1]) ** 2) >= (n1[2] ** 2):
        print("silent")
    else:
        print("noisy")
        
--------------------------------------------- C011　※欠番 ◆
# C011 ◆
# C012 ◆
# C013　嫌いな数字
# utf-8
# 嫌いな数字を入力
n = int(input())

# 範囲外の場合はエラーを出力して終了
if n < 0 or n > 9:
    print("嫌いな数字は0から9の範囲で入力してください。")
    exit()

# 病室の総数を入力
m = int(input())

# 範囲外の場合はエラーを出力して終了
if m < 1 or m > 100:
    print("病室の総数は1から100の範囲で入力してください。")
    exit()

# 希望する病室の部屋番号を格納するリスト
desired_rooms = []

# 各病室の部屋番号を入力し、希望する病室をリストに追加
for i in range(m):
    room_number = int(input())

    # 範囲外の場合はエラーを出力して終了
    if room_number < 1 or room_number > 1000:
        print("部屋番号は1から1000の範囲で入力してください。")
        exit()

    if str(n) not in str(room_number): # 部屋番号に嫌いな数字が含まれていない場合
        desired_rooms.append(room_number)

# 希望する病室があるかどうかを判定し、出力
if len(desired_rooms) > 0:
    for room in desired_rooms:
        print(room)
else:
    print("none")
        
# C014
# utf-8
# 入力からボールの半径と箱の情報を取得
n, r = map(int, input().split())
boxes = []
for i in range(n):
    h, w, d = map(int, input().split())
    boxes.append((h, w, d))

# ボールを収納することができる箱の番号を格納するリストを初期化
result = []

# 各箱について、ボールを収納できるかを判定
for i in range(n):
    h, w, d = boxes[i]
    # 箱の高さ、幅、奥行きのうち最も短いものを取得
    shortest_side = min(h, w, d)
    # ボールの直径が最も短い箱の辺の長さ以下であれば、ボールを収納できる
    if shortest_side >= 2 * r:
        result.append(i + 1)  # 箱の番号をリストに追加

# 結果を昇順に出力
for num in result:
    print(num)
    
# C015 ポイントカードの計算
# utf-8
# coding: utf-8
import math

cnt = int(input())

sum = 0
for i in range(cnt):
    s = input().strip().split(" ")
    a = str(s[0])
    n = int(s[1])

    if "3" in a:
        sum += math.floor(n / 100 * 3)
    elif "5" in a:
        sum += math.floor(n / 100 * 5)
    else:
        sum += math.floor(n / 100)

print(sum)

# C016 Leet文字列
# utf-8
def to_leet_string(input_string):
    leet_rules = {
        'A': '4',
        'E': '3',
        'G': '6',
        'I': '1',
        'O': '0',
        'S': '5',
        'Z': '2'
    }

    leet_string = ''
    for char in input_string:
        if char.upper() in leet_rules:
            leet_string += leet_rules[char.upper()]
        else:
            leet_string += char

    return leet_string

input_string = input().rstrip() # 入力文字列を取得し、末尾の改行を削除
leet_string = to_leet_string(input_string)
print(leet_string, end='\n') # Leet文字列を出力し、最後に改行を追加

# C017　ハイアンドロー・カードゲーム
def compare_cards(parent_card, child_card):
    """
    親カードと子カードの強弱関係を比較する関数

    Args:
        parent_card (tuple): 親カードの情報。(1つ目の番号, 2つ目の番号)
        child_card (tuple): 子カードの情報。 (1つ目の番号, 2つ目の番号)

    Returns:
        str: 強弱関係の結果を表す文字列。'High'、'Low'のいずれか。
    """
    parent_num1, parent_num2 = parent_card
    child_num1, child_num2 = child_card

    if parent_num1 > child_num1:
        return 'High'
    elif parent_num1 < child_num1:
        return 'Low'
    else:
        if parent_num2 < child_num2:
            return 'High'
        else:
            return 'Low'

# 親カードの情報を入力
parent_card = tuple(map(int, input().split()))

# 子カードの数を入力
n = int(input())

# 子カードの情報を入力し、強弱関係を判定して出力
for i in range(n):
    child_card = tuple(map(int, input().split()))
    result = compare_cards(parent_card, child_card)
    print(result)

# C018 何人前作れる?
# レシピに書かれている食材の数を取得
n = int(input())

# レシピの食材と必要量を辞書に格納
recipe = {}
for i in range(n):
    a, b = input().split()
    recipe[a] = int(b)

# あなたが所持している食材の数を取得
m = int(input())

# 所持している食材と数量を辞書に格納
ingredients = {}
for i in range(m):
    c, d = input().split()
    ingredients[c] = int(d)

# 最大で何人前作れるかを計算
max_servings = float('inf')  # 初期値を無限大に設定

# レシピの食材と必要量をループし、所持している食材と比較
for ingredient, amount in recipe.items():
    if ingredient in ingredients:
        max_servings = min(max_servings, ingredients[ingredient] // amount)
    else:
        max_servings = 0
        break

# 最大で何人前作れるかを出力
print(max_servings)

# C019 完全数とほぼ完全数
# utf-8
def is_perfect_or_almost_perfect_number(n):
    """
    入力された整数が完全数かほぼ完全数かそのいずれでもないかを判定する関数

    Args:
        n (int): 判定する整数

    Returns:
        str: 完全数、ほぼ完全数、そのいずれでもないことを示す文字列
    """
    # 約数の和を計算
    s = 0
    for i in range(1, n):
        if n % i == 0:
            s += i

    # 完全数の判定
    if n == s:
        return "perfect"

    # ほぼ完全数の判定
    if abs(n - s) == 1:
        return "nearly"

    # その他の場合
    return "neither"


# 判定したい整数の個数を入力
q = int(input())

# 入力範囲を満たすかチェック
if q < 1 or q > 50:
    print("Error: 1 ≦ Q ≦ 50 の範囲で入力してください。")
    exit(1)

# 各整数について判定を行い結果を出力
for i in range(q):
    n = int(input())

    # 入力範囲を満たすかチェック
    if n < 2 or n > 1000:
        print("Error: 2 ≦ N_i ≦ 1000 の範囲で入力してください。")
        exit(1)

    result = is_perfect_or_almost_perfect_number(n)
    print(result)
        
# C020　残り物の量
# utf-8
def calculate_leftover_amount(m, p, q):
    """
    生鮮食品の売れ残り量を計算する関数

    Args:
        m (int): 生鮮食品の仕入れ量(kg)
        p (int): 生のまま売れた割合(%)
        q (int): お総菜に変換された売れ残りの割合(%)

    Returns:
        float: 最終的な売れ残り量(kg)
    """
    # 生鮮食品の売れ残り量を計算
    leftover_amount = m * (100 - p) / 100

    # お総菜に変換された売れ残り量を計算
    leftover_amount = leftover_amount * (100 - q) / 100

    return leftover_amount


# 生鮮食品の仕入れ量、生のまま売れた割合、お総菜に変換された売れ残りの割合を入力
m, p, q = map(int, input().split())

# 生鮮食品の売れ残り量を計算
leftover_amount = calculate_leftover_amount(m, p, q)

# 売れ残り量を小数値で出力
print("{:.4f}".format(leftover_amount))

# C021　暴風域にいますか
# utf-8
import math

def is_in_typhoon(xc, yc, r1, r2, x, y):
    """
    台風の暴風域にあるかどうかを判定する関数

    Args:
        xc (int): 台風1の中心のx座標
        yc (int): 台風1の中心のy座標
        r1 (int): 台風1の半径
        r2 (int): 台風2の半径
        x (int): 判定する人のx座標
        y (int): 判定する人のy座標

    Returns:
        bool: 台風の暴風域にある場合True、そうでない場合False
    """
    distance_squared = (x - xc) ** 2 + (y - yc) ** 2
    if r1 ** 2 <= distance_squared <= r2 ** 2:
        return True
    else:
        return False

# 台風情報の入力
xc, yc, r1, r2 = map(int, input().split())
# 人の数の入力
n = int(input())

# 各人の座標の入力と判定
for i in range(n):
    x, y = map(int, input().split())
    if is_in_typhoon(xc, yc, r1, r2, x, y):
        print("yes")
    else:
        print("no")
    
# C022 ローソク足
# utf-8
# 日数 n を入力
n = int(input())

# 株価データを入力し、始値、終値、高値、安値を計算
start_prices = []
end_prices = []
high_prices = []
low_prices = []

for i in range(n):
    s, e, h, l = map(int, input().split())
    start_prices.append(s)
    end_prices.append(e)
    high_prices.append(h)
    low_prices.append(l)

# n日間の始値を計算
start_price = start_prices[0]

# n日間の終値を計算
end_price = end_prices[-1]

# n日間の高値を計算
high_price = max(high_prices)

# n日間の安値を計算
low_price = min(low_prices)

# 結果を出力
print(start_price, end_price, high_price, low_price, end='')

# C023 クジの当選番号
# utf-8
import sys
a = [int(s) for s in sys.stdin.readline().split()]
N=int(input())
b = [[int(s) for s in line.split()] for line in sys.stdin]
for j in range(N):
    c=0
    for i in range(len(b[0])):
        if a[i] in b[j]:
            c += 1
    print(c)
    
# C024
# coding: utf-8
n = int(input())
num1 = 0
num2 = 0

cul = []

for i in range(0, n):
    cul.append(input().split(" "))

    #SET
    if("SET" in cul[i]):
        if(cul[i][1] == "1"):
            num1 = int(cul[i][2])
        else:
            num2 = int(cul[i][2])
    #ADD
    elif("ADD" in cul[i]):
        num2 = num1 + int(cul[i][1])
    #SUB
    else:
        num2 = num1 - int(cul[i][1])

print(num1, num2)

# C025　ファックスの用紙回収
# utf-8
def simulate_computer(instructions):
    """
    コンピュータをシミュレートする関数

    Args:
        instructions (list): コンピュータに与える命令のリスト

    Returns:
        tuple: 変数1と変数2の最終的な値のタプル
    """
    var1 = 0  # 変数1の初期値
    var2 = 0  # 変数2の初期値

    for instruction in instructions:
        operation = instruction[0]
        value = instruction[1]

        if operation == "SET":
            var_idx = int(instruction[2]) - 1  # 変数のインデックス
            if var_idx == 0:
                var1 = value
            elif var_idx == 1:
                var2 = value
        elif operation == "ADD":
            var2 += value
        elif operation == "SUB":
            var2 -= value

    return var1, var2

# 命令の数を入力
n = int(input("命令の個数を入力してください: "))

instructions = []
# 命令のリストを入力
for i in range(n):
    while True:
        instr = input(f"命令{i+1}を入力してください（例: SET 1 10、ADD 5、SUB 3）: ").split()
        if len(instr) != 3 or instr[0] not in ["SET", "ADD", "SUB"] or not instr[1].isdigit() or not instr[2].isdigit():
            print("命令のフォーマットが不正です。再度入力してください。")
        else:
            break
    instructions.append([instr[0], int(instr[1]), int(instr[2])])

# コンピュータをシミュレートし、変数1と変数2の最終的な値を取得
result = simulate_computer(instructions)

# 変数1と変数2の最終的な値を半角スペース区切りで1行に出力し、最後に改行を追加
print(*result, sep=" ", end="\n")

# C026　ウサギと人参
# utf-8
# 入力を受け取る
N, S, p = map(int, input().split())  # 人参のデータの数、目安となる糖分、許容誤差

max_mass = -1  # 最大質量を初期化
max_index = -1  # 最大質量の人参の番号を初期化

# N個の人参データを入力として受け取る
for i in range(1, N + 1):
    data = list(map(int, input().split()))  # 質量と糖分をスペース区切りで入力
    mass = data[0]  # 人参の質量
    sugar = data[1]  # 人参の糖分

    # 糖分が許容範囲内でかつ質量が最大の場合、最大質量とその人参の番号を更新
    if S - p <= sugar <= S + p and mass > max_mass:
        max_mass = mass
        max_index = i

if max_index != -1:
    print(max_index)  # 最大質量の人参の番号を出力
else:
    print("not found")  # 見つからなかった場合は "not found" を出力

# C027
# C028
# C029
# C030
# C031
# C032
# C033
# C034
# C035
# C036
# C037
# C038
# C039
# C040
# C041
# C042
# C043
# C044
# C045
# C046
# C047
# C048
# C049
# C050
# C051
# C052
# C053
# C054
# C055


# C128
