# ハノイの塔 A
# utf-8
import sys

def print_tower():
    for one in towers:
        if len(one) == 0:
            print("-")
            continue
        print(" ".join(map(str, one)))

def hanoi(n, frm, to, tmp, t):
    global count

    if n == 1:
        towers[to].append(towers[frm][-1])
        del towers[frm][-1]

        count += 1
        if count == t:
            print_tower()
            sys.exit(0)

    else:
        hanoi(n - 1, frm, tmp, to, t)
        hanoi(1, frm, to, tmp, t)
        hanoi(n - 1, tmp, to, frm, t)

n, t = map(int, input().split())
count = 0
towers = [[n - i for i in range(n)], [], []]
hanoi(n, 0, 2, 1, t)
'''
関数の中で自身を呼び出す再帰関数と呼ばれるものを用います。
n 個の円盤を A から C に移すときの操作を次のように考えます。
上から n-1 個の円盤を B に避ける。
n 個目の円盤を C に移す。
B に避けていた n-1 個の円盤を C に移す。
n = 1 のときは A から C に円盤を一つ移すだけです。

3 つの塔を 2 次元リスト、 towers にまとめています。
一つ一つの塔はリストになっています。
A, B, C のそれぞれがインデックス 0, 1, 2 に対応し、最も下の円盤がリストの 0 番目の要素になっていると考えます。このとき、初期状態は towers[0] に n, n-1, ..., 1 の n 個の整数が格納されている状態になります。
この塔の表現において、A から B へ 1 枚円盤を移す操作は、A の配列の末尾の要素を削除し、B の配列の末尾に追加する操作になります。
hanoi メソッドは方針の通り実装します。
hanoi メソッドのそれぞれの引数の意味を少し説明します。
n : 操作対象の円盤の総数
frm : どの塔の円盤を移動するかのインデックス
to : どこの塔に円盤を移動させたいかのインデックス
tmp : to の塔に円盤を動かすために一時的に円盤を退避させる塔のインデックス
t : 何回の操作で終了させるかの整数
'''

# 山折り谷折り A
# utf-8
'''
N 回折ったときの折り目は N-1 回折ったときの折り目から簡単に求めることができます。
1 回折ったときの折り目は "0"、2 回折ったときの折り目は "0" + "0" + "1" = "001"、3 回折ったときの折り目は "001" + "0" + "011" = "0010011" です。
N-1 回折ったときの折り目の文字列を S、S を逆順にし、0 と 1 を反転させた文字列を S' とすると、N 回折ったときの折り目の文字列は S + "0" + S' となります。

N 回折ったときの折り目の数 2N-1 個の要素を持つ配列を用意します。
方針の通りに 1 回折ったときの折り目から順に N 回折ったときの折り目までを順に求めます。
'''
N = int(input())

size = 2 ** N - 1
paper = [False] * size

count = 0
while True:
    for i in range(count):
        paper[count * 2 - i] = not paper[i]

    paper[count] = False
    count = count * 2 + 1

    N -= 1
    if N == 0:
        break

for i in range(0, size):
    print(1 if paper[i] else 0, end="")

print()

# 本の整理 A
# utf-8
'''
右側の最も小さな ID の本の位置を毎回探すと実行時間制限を越えてしまいます。
ID が 1 から N まで重複なしに使われているので、各 ID の本が本棚のどの位置にあるかを保持する配列を用いることで、最小 ID の本の位置を毎回探索する必要がなくなります。
'''
N = int(input())
shelf = [int(x)-1 for x in input().split()]

pos = [-1] * N
for i in range(N):
    pos[shelf[i]] = i

ans = 0
for i in range(N):
    if shelf[i] == i:
        continue

    ans += 1
    shelf[pos[i]] = shelf[i]
    pos[shelf[i]] = pos[i]

print(ans)
'''
リスト shelf に入力値を格納する際に、プログラム内で扱いやすいように 本のID を -1 しています。(ここで -1 することで、コード内で i+1 と表現する必要がなくなりますが、以下では分かりやすさの観点から、i+1 として説明します。)
リスト shelf は shelf[i] が「左端から i+1 番目の本の ID はなにか」の情報を保持しています。
リスト pos は pos[i] が「 ID が i+1 の本が現在左端から何番目にあるか」の情報を保持するように用意します。
本の移動のコードを少し説明します。
【 shelf[pos[i]] = shelf[i] 】
pos[i] : ID が i+1 の本の場所
shelf[i] : 左端から i+1 番目の本の ID
つまり、ID が i+1 の本が置かれていた場所に左端から i+1 番目の本を置く
【 pos[shelf[i]] = pos[i] 】
shelf[i] : 左端から i+1 番目の本の ID
pos[i] : ID が i+1 の本の場所
つまり、左端から i+1 番目にある本を、ID が i+1 の本が置かれている場所に移動する
この 2 行のコードから左端から i+1 番目の本が ID が i+1 の本があった場所に移されているのがわかります。
'''

# 雪だるま作り A
# 最小の運賃 A
# 文字列収集 S
# 十億連勝 S
