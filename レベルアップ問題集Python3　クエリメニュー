<ソートと検索(query)>
step1　指定の位置への要素の追加
# utf-8
N, K, Q = map(int, input().split())
A = [int(input()) for _ in range(N)]

A.insert(K, Q)

for a in A:
    print(a)
'''
配列を用意して A の各要素を受け取ったのち、要素を追加するメソッドを利用したり、新たに長さ N + 1 の配列 B を作成し、A の要素と次のように対応させることで問題を解くことができます。
B_i = A_i (1 ≦ i ≦ K)
B_i = Q (i = K + 1)
B_i = A_{i-1} (K + 2 ≦ i ≦ N + 1)

リストの insert メソッドを使って解いています。
'''

step2　指定要素の検索
# utf-8
N, K = map(int, input().split())
A = [int(input()) for _ in range(N)]

exist = False
for a in A:
    if a == K:
        exist = True
        break

print("YES" if exist else "NO")
'''
配列を用いてデータを受け取り、繰り返しを用いて、各要素について K かどうかを条件文で判定すれば良いです。
判定の結果に応じて "YES" または "NO" を出力しましょう。
for 文を使ってリストの各要素が K に一致するか判定しています。
'''

step3　指定要素の検索(query)
# utf-8
N, Q = map(int, input().split())
A = {int(input()) for _ in range(N)}

for _ in range(Q):
    k = int(input())
    if k in A:
        print("YES")
    else:
        print("NO")
'''
配列を用いてデータを受け取り、繰り返しを用いて、K_1 ... K_Q の各要素について A に存在するかどうかを条件文で判定することでも判定をおこなうことはできます。
しかし、そうした場合 K の要素 1 つを探すために A の要素を全て探索する必要があり、プログラム全体で Q × N 回ループを回す必要があります。
この問題の条件に注目すると 1 ≦ N , Q ≦ 100,000 とあるので、 Q × N は最大で 10,000,000,000 になり得ます。
これでは実行時間内に答えを出すことはできません。
この問題を解決するためには、計算量を意識してプログラムを書く必要があります。言語間で備わっているデータ構造が異なっているので一概にこれを使えば良いというのはないので、各言語ごとの実装例にて計算量改善の方法を参照してください。
この問題を解くためのデータ構造として、代表的なものとしては順序付き集合が挙げられます。
これは、値を常にソートされた状態で保持するデータ構造です。
順序付き集合に A の値を追加したのち、その中から K_i の値を検索することで、この問題を O(Q log N) で解くことができます。

set を使って解いています。
set はハッシュ法を用いて値を管理しているため、in 演算子による値の探索が平均 O(1) で実行できます。
'''

step4　先頭の要素の削除
# utf-8
N = int(input())
A = [int(input()) for _ in range(N)]

del A[0]

for a in A:
    print(a)
'''
配列を用意して A の各要素を受け取ったのち、要素を削除するメソッドを利用したり、新たに長さ N - 1 の配列 B を作成し、A の要素と次のように対応させることで問題を解くことができます。
B_i = A_{i+1} (1 ≦ i ≦ N - 1)
del 文を del list[削除したい要素のインデックス] のように使うことでリストのインデックスを指定して要素を削除することができます。
del 文を list オブジェクトに用いたときの計算量は O(N) です。
'''

step5　先頭の要素の削除(query)
# utf-8
from collections import deque

N, K = map(int, input().split())
A = deque([int(input()) for _ in range(N)])

f = 0
for _ in range(K):
    s = input()
    if s == "pop":
        A.popleft()
        continue
    for a in A:
        print(a)
'''
配列を用いてデータを受け取り、問題の指示に従って要素を削除・出力することでも判定をおこなうことはできます。
しかし、そうした場合 A の要素を削除する度に全ての要素を移動させる必要があり、プログラム全体で N × K 回ループを回す必要があります。
この問題の条件に注目すると 1 ≦ K ≦ N ≦ 100,000 とあるので、 N × K は最大で 10,000,000,000 になり得ます。
これでは実行時間内に答えを出すことはできません。
この問題を解決するためには、計算量を意識してプログラムを書く必要があります。言語間で備わっているデータ構造が異なっているので一概にこれを使えば良いというのはないので、各言語ごとの実装例にて計算量改善の方法を参照してください。
この問題を解くためのデータ構造として、代表的なものとしては両端キューが挙げられます。
これは、末尾への要素の追加と先頭要素の削除を高速(O(1))に行うことができます。
このデータ構造を使うことで、この問題の計算量は O(N+K) となります。

両端キューは collections モジュールの deque クラスとして用意されています。
この deque オブジェクトの popleft メソッドの計算量は O(1) です。
'''

step6　連想配列
# utf-8
N, K = map(int, input().split())
roster = {(x, y) for x, y in [input().split() for _ in range(N)]}

for _ in range(K):
    q = input()
    for num, ID in roster:
        if num == q:
            print(ID)
'''
全ての生徒の出席番号と ID をセットで保持し、出席番号が与えられたら、その出席番号と対応する ID を探して出力すれば良いです。
出席番号と ID をセットで保持するには、配列を 2 つ用意して、 1 人の出席番号と ID を同じ要素番号に入れるなどすれば良いです。
'''

step7　連想配列(query)
# utf-8
N, K = map(int, input().split())
roster = {x: y for x, y in [input().split() for _ in range(N)]}

for _ in range(K):
    s = input().split()
    if s[0] == "join":
        num, ID = s[1:]
        roster[num] = ID
    elif s[0] == "leave":
        num = s[1]
        del roster[num]
    else:
        num = s[1]
        print(roster[num])
'''
全ての生徒の出席番号と ID をセットで保持し、出席番号が与えられたら全ての出席番号の中から、その出席番号を探す方針のプログラムを組んだ場合、ループが最大で (100,000)^2 回回ってしまうため、実行時間制限に間に合いません。
また、生徒の追加や削除のごとに生徒に対応する要素番号が変化するため、情報の管理が大変になってしまいます。
これらの問題を解決するために連想配列というものを使うことにします。
連想配列とは、キーと呼ばれる値とそれに対応する値からなるデータ構造であり、N 個のキーとその値の組の中から、特定のキーに対応する値を取得する際にかかる時間が O(log N) でおこなうことができます。
また、連想配列ではキーと値の組の追加・削除も O(log N) でおこなうことができるため、今回の問題で与えられる全てのイベントの処理を O(log N) でおこなうことができるため、この問題を O(K log (N + K)) で解くことができるようになります。

辞書 (dict オブジェクト) を使って実装しています。
dict オブジェクトはキーと値の組をキーのハッシュ値で管理します。
>ハッシュ法を用いてキーと値の組を管理しているため、キーを用いた探索の計算量は平均 O(1) です。
dict オブジェクトの要素をキーを指定して削除する際は del 文を del dict[削除したい組のキー] のように使います。
削除の計算量は平均 O(1) です。
'''

step8　ソートと検索
final　ソートと検索(query)

<Vtuber>
step1　アイドルグループ
step2　歴史を作る時間
step3　銀行
step4　経理
final Vtuber

<平方分割>
step1　累積和
step2　区間和
step3　二次元累積和
step4　二次元区間和
step5　平方分割のパケット
final　平方分割

<点の幅>
step1　'I'の数
step2　ドーナツ
final　点の幅　
