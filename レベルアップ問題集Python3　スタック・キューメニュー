<スタック・キュー実装編(共通問題)>
step1 スタック・キュー実装編(共通問題) step1
# utf-8
N = int(input())

A = [0] * N  # キュー, スタック本体
for i in range(N):
    A[i] = int(input())
print(N)
for i in range(N):
    print(A[i])
'''
スタック・キューの実装において共通で使用する、要素の入力部分を作成します。
この問題では標準入力の受け取り、標準出力、ループができれば正解できます。
'''

final スタック・キュー実装編(共通問題) step2
# utf-8
Q = int(input())

A = []  # キュー, スタック本体
for i in range(Q):
    query = input().split()
    if query[0] == "1":
        # PUSH
        A.append(query[1])
    elif query[0] == "2":
        # STAY(何もしない)
        continue
print(len(A))
for i in range(len(A)):
    print(A[i])
'''
スタック・キューの実装において共通で使用する、クエリの処理部分を作成します。
入力で与えられた数値によって、おこなう処理を分岐させることができれば正解できます。
if 文などで分岐させることができれば、残りは前問と同じように正解できます。
'''

<スタック実装編>
step1 スタック実装編 step1
# utf-8
Q = int(input())

A = []  # スタック本体
for i in range(Q):
    query = input().split()
    if query[0] == "1":
        # PUSH
        A.append(query[1])
    elif query[0] == "2":
        A.pop()
    print(" ".join(A))
'''
スタックへ要素を追加・削除するプログラムを実装します。
スタックの中に入っている要素の個数を K, スタック本体の配列を A とします。前問より、スタックに要素 X を追加するときは、 A[K] に X を代入すればよいです。追加は簡単ですが、削除は少し工夫が必要です。
結論から述べると、 K を 1 つ減らせばよいです。これではスタック A の中に A [ K ] が残ってしまうのではないかと思いますが、それでよいのです。スタック本体の配列を A とする、とさきほど述べましたが、正確には A の 0 番目の値から K - 1 番目の値までをスタック本体と考えます。すると、各処理は以下のように考えられます。
追加 ... スタックの範囲外の要素 1 つ( A[K] )をスタックの範囲内にし、 A[K] に要素を追加する。
削除 ... スタックの範囲を 1 つ狭める。狭めたことによって範囲外に出た要素はスタックの要素として扱わない。
出力 ... スタックの範囲内( 0 番目から K - 1 番目まで )の値を出力する。
リストを半角区切りで出力することは " ".join(リスト) により可能です。
'''

final スタック実装編 step2
# utf-8
Q = int(input())

A = []  # キュー, スタック本体
for i in range(Q):
    query = input().split()
    if query[0] == "1":
        # PUSH
        A.append(query[1])
    elif query[0] == "2":
        print(A.pop())
    print(" ".join(A))
'''
スタックとしての基本的な機能を完成させます。前問との違いは大きく 2 点です。
1 つ目はスタックへ与えられるデータが文字になっています。今までは整数型でスタックの配列を用意していましたが、これを文字型に変えましょう。
2 つ目は POP をする際に、削除する予定の要素を出力します。ここで、スタックの中に入っている要素の個数を K, スタック本体の配列を A とします。
このとき、削除される要素は A[K - 1] であり、これを出力したのちに削除の処理として K を 1 つ減らします。
リストを半角区切りで出力することは " ".join(リスト) により可能です。また、リストの末尾を削除し、値を取得することは A.pop() により可能です。
'''

<キュー実装編>
step1 キュー実装編 step1
# utf-8
import queue

Q = int(input())

q = queue.Queue()  # キュー本体
for i in range(Q):
    query = input().split()
    if query[0] == "1":
        # PUSH
        q.put(query[1])
    elif query[0] == "2":
        # POP
        q.get()
    for j in range(q.qsize()):  # キューの要素分だけループを回す
        tmp = q.get()
        if j < q.qsize():
            print(tmp, end=" ")
        else:
            print(tmp, end="")
        q.put(tmp)
    print()
'''
キューへ要素を追加・削除するプログラムを実装します。
キューの末尾の次の要素のインデックスを R, キュー本体の配列を A とします。前問より、キューに要素 X を追加するときは、 A[R] に X を代入すればよいです。追加は簡単ですが、削除は少し工夫が必要です。
スタックの場合、 R を 1 つ減らせばよいのですが、キューの場合は変数 L を 1 つ増やせばよいです。ここで L は 今まで削除した要素数 を表します。キューを実装する際には、 A の L 番目の値から R - 1 番目の値までをキュー本体と考えます。すると、各処理は以下のように考えられます。
追加 ... キューの末尾の次の要素( A[R] )をキューの範囲内にし、 A[R] に要素を追加する。
削除 ... キューの先頭の要素( A[L] )をキューの範囲外にする。範囲を狭めたことによって範囲外に出た要素はキューの要素として扱わない。
出力 ... キューの範囲内( L 番目から R - 1 番目まで )の値を出力する。
Pythonでキューを作成するには、Queueモジュールをインポートしたのちに queue.Queue() と記述することにより可能です。末尾に追加する場合は「put」、先頭の取り出しには「get」を使用します。
'''

final キュー実装編 step2
# utf-8
import queue

Q = int(input())

q = queue.Queue()  # キュー本体
for i in range(Q):
    query = input().split()
    if query[0] == "1":
        # PUSH
        q.put(query[1])
    elif query[0] == "2":
        print(q.get())
    for j in range(q.qsize()):  # キューの要素分だけループを回す
        tmp = q.get()
        if j < q.qsize():
            print(tmp, end=" ")
        else:
            print(tmp, end="")
        q.put(tmp)
    print()
'''
キューとしての基本的な機能を完成させます。前問との違いは大きく 2 点です。
1 つ目はキューへ与えられるデータが文字になっています。今までは整数型でキューの配列を用意していましたが、これを文字型に変えましょう。これでさまざまなデータが与えられても簡単に変更ができるキューになります。
2 つ目は POP をする際に、削除する予定の要素を出力します。ここで、 今まで削除した要素数 + 1 を L, キュー本体の配列を A とします( 配列は 1 - indexed で説明します )。
このとき、削除される要素は A[L] であり、これを出力したのちに削除の処理として L を 1 つ増やします。
Pythonでキューを作成するには、Queueモジュールをインポートしたのちに queue.Queue() と記述することにより可能です。末尾に追加する場合は「put」、先頭の取り出しには「get」を使用します。
'''

<箱とボール>
step1 2つのキュー
# utf-8
import queue

Q = int(input())

q1 = queue.Queue()
q2 = queue.Queue()  # キュー本体
for i in range(Q):
    query = input().split()
    if query[0] == "1":
        if query[1] == "1":
            q1.put(query[2])
        else:
            q2.put(query[2])
    elif query[0] == "2":
        if query[1] == "1":
            print(q1.get())
        else:
            print(q2.get())
    else:
        print(q1.qsize(), q2.qsize())
'''
キューを 2 つ用意します。キューのプログラムをコピー&ペーストして同じようなコードを 2 つ記述してもよいですし、キュークラスなどを定義してもよいです。
Pythonでキューを作成するには、Queueモジュールをインポートしたのちに queue.Queue() と記述することにより可能です。末尾に追加する場合は「put」、先頭の取り出しには「get」を使用します。
キューの要素数を取得は q.qsize() により可能です。
'''

step2 最大の区間和
# utf-8
n, x = map(int, input().split())
a = list(map(int, input().split()))

left_num = a[0]  # 区間の和が最大になる左端の値
max_sum = 0  # 区間の和の最大

for i in range(x):
    max_sum += a[i]
tmp_sum = max_sum  # 区間の和

for i in range(n - x):
    tmp_sum -= a[i]
    tmp_sum += a[i + x]
    if tmp_sum > max_sum:
        left_num = a[i + 1]
        max_sum = tmp_sum

print(max_sum, left_num)
'''
まずは X 個の要素の和を効率よく計算する方法を考えます。区間 [l, l + X) の X 個の要素の和を S とすると、区間 [l + 1, l + 1 + X) の和は S - A[l] + A[l + X] となります。
また X 個の要素の和が最大値となる区間の左端の値は、さまざまな求め方が存在しますが、ここではキューを用います。ループを用いて毎回 A_i の値をキューに PUSH しておきます。このときキューの中に入っている要素数が X であれば、 A_i までの X 個の要素の先頭の値はキューの先頭の値と一致します。
キューを使わない方法もあります。 A の i 番目までの X 個の要素の先頭の値は、 A の i - X + 1 番目の値です。この値をランダムアクセスしてもよいです。
リストを用いた方法です。各区間で毎回和を計算するとタイムオーバーになってしまうので、tmp_sum により和を保存し、区間が1つシフトする際に、区間から外れる左端の値分を tmp_sum から差し引き、新しく区間に加わる右端の値を足す、という操作で各区間の和を計算します。また、max_sum に区間の最大値が保存され、tmp_sum が暫定の最大値を超えるたびに更新します。区間の和が最大になる左端の値は left_num に保存します。
'''

step3 逆ポーランド記法
# utf-8
n = int(input())
a = input().split()

st = []

for i in range(n):
    if a[i] == "+" or a[i] == "-":
        num1 = st.pop()
        num2 = st.pop()
        if a[i] == "+":
            st.append(num1 + num2)
        else:
            st.append(num2 - num1)
    else:
        st.append(int(a[i]))
print(st[-1])
'''
逆ポーランド記法は数値と数値の後に演算子が置かれるため、演算子があった場合その直前の 2 つの数値がその演算子に対応しています。
逆ポーランド記法の数式は以下のアルゴリズムで計算できます。
逆ポーランド記法の数式 A を入力

A から 1 文字ずつみて、これを c とする
もし c が 数値 の場合
スタックに c を追加

もし c が 演算子 の場合
スタックから 1 つの数値を取り出し、 N_1 とする
スタックから 1 つの数値を取り出し、 N_2 とする

    もし c が + の場合
      スタックに N_1 + N_2 を追加
    もし c が - の場合
      スタックに N_2 - N_1 を追加

最後にスタックに残った数値を出力
'''

step4 括弧列
# utf-8
n = int(input())
s = input()

st = []

for i in range(n):
    if len(st) > 0 and st[-1] == "(" and s[i] == ")":
        st.pop()
    else:
        st.append(s[i])
if len(st) == 0:
    print("Yes")
else:
    print("No")
'''
正しい括弧列かどうか判定する問題ですが、正しい括弧列の定義から以下のように問題を言い換えることができます。
> 「 ( ) の順に連続する括弧列を削除する」という操作をできるだけおこないます。最終的に括弧を全て削除することができますか？
たとえば括弧列 (()()) は以下のように操作をおこないます
2, 3 文字目は ( , ) の順に連続しているので、削除します。すると括弧列は ( ()) となります。
2, 3 文字目を削除します。すると括弧列は ( ) となります。
1, 2 文字目を削除します。すると括弧をすべて削除できます。
これを上手におこなうことができれば良いのですが、単純に実装するとタイムオーバーになってしまいます。( 一回の操作で最大 N/2 文字を移動する可能性があります。 ((((...()...)))) というテストケースがこれにあたります。 )
スタックを用いるとこれを O(N) のアルゴリズムとして実装できます。
S の先頭からひとつひとつの括弧を取り出し、これを A とおきます。操作 2,3,4 を繰り返します。
スタックに要素が何もなければ、スタックに A を追加します。
スタックの末尾( 最も最後に追加された要素 )が ( かつ A が ) の場合はこの 2 つが対応する括弧です。よってスタックから要素を一つ取り出します。
操作 2, 3 でスタックに対しての操作をしなかった場合は、スタックに A を追加します。
スタックに要素が残っている場合は No 空である場合は Yes を出力します。
少し難しいですが、スタックを使用しない他の方法もあります。変数 D を 0 で初期化しておいて、 S の先頭から順にみて ( の場合は D に 1 を足し、 ) の場合は D から 1 引きます。最終的に D が 0 かつ操作の途中で D が一度も負にならなければ Yes です。
これは以下の条件を両方とも満たすとき、 S は正しい括弧列であるため成り立ちます。
( 1 ≦ i ≦ N )を満たすすべての i について、 S の先頭から i 文字目までの部分文字列において ( の文字数は ) の文字数以上である
S の ( の文字数と ) の文字数は同数
スタックを用いた方法です。方針に記載されているアルゴリズム通りにPython で実装すると、上記のようになります。
'''

step5 エスカレーター
final 箱とボール
