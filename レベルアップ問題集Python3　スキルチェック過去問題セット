問題一覧(殿堂入り・掲載期間外含む)
Eメールアドレス D
N倍の文字列 D(殿堂入り)
宿泊の日程 D
水分補給 D
文字列の最後 D
検索履歴 C
単語のカウント C
宝くじ C
野球の審判 C
みかんの仕分け C
残り物の量 C(殿堂入り)
1を数えよ[ビット演算] C
文字列の抽出 C
イルミネーション C
数列の調査 C
日別訪問者数の最大平均区間 B
みんなでしりとり B
3Dプリンタ B
神経衰弱(オリジナル) B
名刺バインダー管理 B(殿堂入り)
値の計算 B
「地下アイドルの夢」B
部外者をはじけ B
決まり字 B
「PV調査」 B
ビームの反射 B
複数形への変換　B
ポスターの貼り付け作業 B
日別訪問者数の最大平均区間(large) A
お菓子の詰め合わせ A(殿堂入り)
ひとりすごろく A(殿堂入り)
落ちものシミュレーション A
ある数でつくられた数列 A
Kボナッチ数列 A
村人の友好関係 S(殿堂入り)


★★★ D ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Q. Eメールアドレス D
# utf-8
s = input()
t = input()

print(f"{s}@{t}")
'''
メールアドレスの @ よりも前の部分は「ローカル名」と呼ばれ、後ろの部分は「ドメイン名」と呼ばれます。
入力で与えられる S と T を @ で区切って出力してください。
'''

# Q. N倍の文字列　D(殿堂入り)
# utf-8
N = int(input())
print("*" * N)

# Q. 検索履歴 C
# utf-8
n = int(input())

re = []

for i in range(n):
    s = input()

    if s in re:
        re.pop(re.index(s))

    re.append(s)

for i in range(len(re)):
    print(re[-i - 1])
'''
連結リスト等のデータ構造を用いて、問題文にある通りに履歴を作ってもよいのですが、以下のようにすると簡単に解くことが出来ます。
検索ワードを W_N から W_1 まで逆順に見ていき、そのワードが既出でなければ出力する。
'''

# Q. 宿泊の日程 D
# utf-8
n = int(input())

m = int(input())

print(n - m)

# Q. 水分補給 D
# utf-8
n = int(input())

print((200 * n) // 15)
'''
答えは (200 × n) ÷ 15 です。
Pythonの場合、n は int(input()) で受け取ることができます。先に 200 ÷ 15 を計算してから n を掛ける方法では、誤差が生じて正しい計算結果にならない可能性があるので気を付けてください。
'''

# Q. 文字列の最後 D
# utf-8
S = input()

print(S[-1])
'''
標準入力で文字列を受け取り、最後の文字を出力します。
Pythonの場合は S = input() で入力を受け取ることができ、S[-1] もしくは、S[len(S) - 1] で最後の文字を取り出すことが出来ます。
'''
★★★ C ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Q. 単語のカウント C
step2 「単語のカウント」を解くために:part1
# utf-8
word_list = input().split()
	
for word in word_list:
	print(word)
'''
入力された単語を配列やリストに格納します。
配列やリストの名前に特に決まりはありませんが、単語(word)の一覧(lsit)であることを表現する意図を持ってword_listと名付けています。
繰り返し処理を用いて、その配列やリストの要素を順に出力します。
'''

step3 「単語のカウント」を解くために:part2
# utf-8
word_list = input().split()
if "red" in word_list:
    print("Yes")
else:
    print("No")
'''
入力された単語を配列やリストに格納します。
　　配列やリストの名前に特に決まりはありませんが、この解説では、単語(word)の一覧(lsit)であることを表現する意図を持ってword_listと名付けています。
演算子などを使って、配列やリストの中に red が含まれているか調べます。
結果に応じてYesかNoを出力します。

Python では in 演算子を使うことで、リストの中に特定の値が含まれているか否か調べることができます。
'''

step4 「単語のカウント」を解くために:part3
# utf-8
word_list = input().split()
order = []

for word in word_list:
    if word in order:
        print("already_been")
    else:
        order.append(word)
        print(word)
'''
orderという配列やリストを用意します。
　　入力された単語を入力された順番(order)で格納していくので、orderと名付けています。
条件分岐を用いて以下のような処理をします
　　もし、与えられた単語が既にorderに含まれていれば、その単語は既出なので、already_beenという文字列を出力します。
　　もし、与えられた単語がまだorderに含まれていなければ、その単語を出力します。
　　この時、次に同じ単語が入力された時に正しく分岐されるよう、入力された単語をorderに追加します。
'''

step5 「単語のカウント」を解くために:part4
# utf-8
word_list = input().split()
order = []

for word in word_list:
    if word not in order:
        order.append(word)
        print(word)
'''
orderという配列やリストを用意します。
　　入力された単語を入力された順番(order)で格納していくので、orderと名付けています。
もし、与えられた単語がまだorderに含まれていなければ、その単語をorderに追加し、出力します
　　（今回の問題では、与えられた単語が既にorderに含まれている場合にしなければならない処理は存在しません。）
'''

step6 「単語のカウント」を解くために:part5
# utf-8
word_list = input().split()
order = []
count = []
for word in word_list:
    if word in order:
        count.append(1)
    else:
        order.append(word)
        print(word)
        
for c in count:
    print(c)
'''
countという配列やリストを用意します。
　　最終的には単語の出現した回数を格納するのでcountと名付けていますが、この問題では1だけを格納します。
もし、与えられた単語が orderに含まれていれば、count に 1 を追加します。
もし、与えられた単語が order に含まれていなければ、その単語をorder に追加し、出力します
ループを用いて、count の要素をひとつずつ出力します。
'''

step7 「単語のカウント」を解くために:part6
# utf-8
word_list = input().split()
S = input()
print(word_list.index(S))
'''
文字列 S を標準入力から受け取ります。
word_listの中で S が登場するインデックス番号を出力します。
'''

step8 「単語のカウント」を解くために:part7
word_list = input().split()
order = []
count = []
for word in word_list:
    if word in order:
        count[order.index(word)] += 1
    else:
        count.append(1)
        order.append(word)
        print(word)
for c in count:
    print(c)
'''
入力から、既にorderに含まれている単語が与えられた場合、countの数を1増やします。そうすることで単語の出現回数を数えます。
「既にorderに含まれている単語が与えられた場合」と「orderに含まれていない単語が与えられた場合」で処理を分岐させます。
　　既にorderに含まれている単語が与えられた場合、countの数を1増やします。
　　このとき、countの中の何番目の数字がどの単語に対応しているかを分かるようにしておく必要があります。
　　そのため、orderの中の単語の順番と、countの中の数字の順番を対応させる必要があります。
　　例えば、入力例1のケースでは、orderの 0 番目に "red" が保存されているので、countの 0 番目に "red" の出現回数を保存します。
'''

単語のカウント（力試し編）& final 単語のカウント
# utf-8
li = input().split()

m = []
k = []

for i in li:
    if i in m:
        k[m.index(i)] += 1
    else:
        m.append(i)
        k.append(1)

for i in range(len(m)):
    print(m[i], k[i])
'''
英単語を出現した順番で保存しておく配列と、その出現回数を記録する配列を用意し、
英単語を順に見ていきながら処理していけばよいです。
'''

# Q. 宝くじ C
# utf-8
a = input()
n = int(input())

for i in range(n):
    b = input()

    if a == b:
        print("first")
    elif abs(int(a) - int(b)) == 1:
        print("adjacent")
    elif a[2:] == b[2:]:
        print("second")
    elif a[3:] == b[3:]:
        print("third")
    else:
        print("blank")

# Q. 野球の審判 C
step2 「野球の審判」を解くために:part1
# utf-8
N = int(input())
print(N)
'''
標準入力を用いて、入力を受け取ります。
　　このとき、整数型で受け取ると、この先の実装がスムーズに進みます。
受け取った値を変数に代入します。
　　変数の名前に特に決まりはありませんが、この入力について問題文中で N と表記されているので、実装例では変数名も N にして、合わせています。
　　他の名付け方としては「投球」や「投球数」を想起できる英語表現を採用するパターンもあります。
　　その場合、pitch や number_of_pitches などの候補が挙がるでしょう。
変数の値を標準出力します。
'''

step3 「野球の審判」を解くために:part2
# utf-8
N = int(input())
for i in range(N):
    print("strike or ball")
'''
標準入力を用いて、入力を受け取ります。
受け取った値を変数に代入します。【ここまでが前の問題でやった内容です】
N 回実行される繰り返し処理を書きます。
繰り返し処理の中で strike or ball という文字列を出力します。
'''

step4 「野球の審判」を解くために:part3
# utf-8
N = int(input())
for i in range(N):
    s = input()
    print(s)
'''
標準入力を用いて、入力を受け取ります。
受け取った値を変数に代入します。
N 回実行される繰り返し処理を書きます。【ここまでが前の問題でやった内容です】
　　4 ~ 6 の手順が N 回実行されるように書きます
入力を 1 行受け取ります。(strike か ball が入力されます)
受け取った値を変数に代入します。（実装例では変数名を s としています。）
変数の値を出力します。
'''

step5 「野球の審判」を解くために:part4
# utf-8
N = int(input())
for i in range(N):
    s = input()
    if s == "strike":
        print("strike!")
    else:
        print(s)
'''
標準入力を用いて、入力を受け取ります。
受け取った値を変数に代入します。
N 回実行される繰り返し処理を書きます。
　　4 ~ 6 の手順が N 回実行されるように書きます。
入力を 1 行受け取ります。(strike か ball が入力されます)
受け取った値を変数に代入します。【ここまでが前の問題でやった内容です】
5 の変数の値によって処理が変わる条件分岐を書きます。
　　もし、変数の値が "strike" ならば "strike!" を出力します
　　そうでないならば、変数の値をそのまま出力します
'''

step6 「野球の審判」を解くために:part5
# utf-8
N = int(input())
strike_count = 0
for i in range(N):
    s = input()
    if s == "strike":
        strike_count += 1
        print("strike!")
        print(strike_count)
    else:
        print(s)
'''
標準入力を用いて、入力を受け取ります。
受け取った値を変数に代入します。
N 回実行される繰り返し処理を書きます。
　　4 ~ 6 の手順が N 回実行されるように書きます。
入力を 1 行受け取ります。(strike か ball が入力される)
受け取った値を変数に代入します。
5 の変数の値によって処理が変わる条件分岐を書きます。【ここまでが前の問題でやった内容です】
　　もし、変数の値が strike ならば strike! を出力します
　　そうでないならば、変数の値をそのまま出力します
ループの処理が始まる前に、strikeの数を数えるための変数を用意し、0 を代入します
　　実装例では変数名を strike_count としています。
　　何も受け取っていない（１球も投げていない）段階では strike は 0 個なので、変数に 0 を代入します。
6 で作った条件分岐で 「strike だった場合に実行される処理」に以下の処理を加えます
　　・7 で作った変数の値に +1 する処理
　　　　プログラムのこの部分が実行されるということは、今回の投球結果が strike だったということなので、「strike の数を数える変数」の値に 1 を足します。
　　・7 で作った変数の値を出力する
　　　　このとき、先に足してから、そのあと出力されるよう、順番に留意して書いてください。
'''

step7 「野球の審判」を解くために:part6
# utf-8
N = int(input())
strike_count = 0
for i in range(N):
    s = input()
    if s == "strike":
        strike_count += 1
        if strike_count == 3:
            print("out!")
        else:
            print("strike!")
    else:
        print(s)
'''
標準入力を用いて、入力を受け取ります。
受け取った値を変数に代入します。
N 回実行される繰り返し処理を書きます。
　　4 ~ 6 の手順が N 回実行されるように書きます。
入力を 1 行受け取ります。(strike か ball が入力される)
受け取った値を変数に代入します。
5 の変数の値によって処理が変わる条件分岐を書きます。
　　もし、変数の値が strike ならば strike! を出力します
　　そうでないならば、変数の値をそのまま出力します
ループの処理が始まる前に、strikeの数を数えるための変数を用意し、0 を代入します
　　実装例では変数名を strike_count としています。
　　何も受け取っていない（１球も投げていない）段階では strike は 0 個なので、変数に 0 を代入します
6 で作った条件分岐で 「strike だった場合に実行される処理」に以下の処理を加えます。
　　・7 で作った変数に +1 する処理【ここまでが前の問題でやった内容です】
　　・もし、7 で作った変数の値が 3 であれば、out! と出力し、そうでないならば strike! と出力する条件分岐
　　　　条件分岐の中に条件分岐を書きます。
'''

step1 野球の審判（力試し編）& final 野球の審判
# utf-8
n = int(input())

ball = 0
strike = 0

for i in range(n):
    s = input()

    if s == "strike":
        strike += 1

        if strike == 3:
            print("out!")
        else:
            print("strike!")
    else:
        ball += 1

        if ball == 4:
            print("fourball!")
        else:
            print("ball!")

# Q. みかんの仕分け C(殿堂入り)
step2 「みかんの仕分け」を解くために:part1
# utf-8
N, M = map(int, input().split())
print(N, M)

for _ in range(M):
    w = int(input())
    print(w)
'''
標準入力を用いて、入力を受け取ります。
　　このとき、整数型で受け取ると、この先の実装がスムーズに進みます。
　　1 行目の入力は空白区切りで 2 つ与えられることに注意しましょう。
受け取った値をそれぞれ変数に代入します。
　　変数の名前に特に決まりはありませんが、この入力について問題文中で N M と表記されているので、実装例では変数名も N M にして、合わせています。
変数の値を空白区切りで標準出力します。
M 回実行される繰り返し処理を書きます。
　　5 ~ 7 の手順が M 回実行されるように書きます
標準入力を用いて、入力を受け取ります。
受け取った値を変数に代入します。（実装例では変数名を w としています）
変数の値を標準出力します。
'''

step3 「みかんの仕分け」を解くために:part2
# utf-8
N, M = map(int, input().split())

for _ in range(M):
    w = int(input())

    if w % N == 0:
        print("Yes")
    else:
        print("No")
'''
1 行目の入力を標準入力を用いて受け取り、受け取った値をそれぞれ変数に代入します。
M 回実行される繰り返し処理を書きます。
　　3 ~ 4 の手順が M 回実行されるように書きます
標準入力を用いて入力を受け取り、受け取った値を変数に代入します。
3 で受け取った変数の値によって処理が変わる条件分岐を書きます。
　　変数の値が N の倍数なら Yes を出力する。
　　　　変数の値を N で割った余りが 0 であればその値は N の倍数です。
　　そうでないなら No を出力する。
'''

step4 「みかんの仕分け」を解くために:part3
# utf-8
N, M = map(int, input().split())

k1, k2 = map(int, input().split())

for _ in range(M):
    w = int(input())

    if abs(k1 - w) < abs(k2 - w):
        print(k1)
    else:
        print(k2)
'''
1 行目の入力を標準入力を用いて受け取り、受け取った値をそれぞれ変数に代入します。
2 行目の入力を標準入力を用いて受け取り、受け取った値をそれぞれ変数に代入します。（実装例では変数名を k1, k2 としています）
M 回実行される繰り返し処理を書きます。
　　4 ~ 5 の手順が M 回実行されるように書きます
標準入力を用いて入力を受け取り、受け取った値を変数に代入します。（実装例では変数名を w としています）
4 で受け取った変数の値が 2 で受け取った変数のどちらに近いかを判定する条件分岐を書きます。
　　箱に書かれた数とみかんの重さの差の絶対値が小さいほど、みかんの重さはその箱の数に近いといえます。
　　・ k1 の方が k2 よりも w に近いなら、つまり k1 - w の絶対値が k2 - w の絶対値より小さいなら k1 の値 を出力します。
　　・ そうでないなら k2 の値 を出力します。
　　　　重さが一番近い箱が複数ある場合、数が大きい方の箱に仕分けられることに注意してください。条件より k_1 < k_2 なので、k1 - w の絶対値が k2 - w の絶対値が等しいなら k2 の値 を出力します。
'''

step5 「みかんの仕分け」を解くために:part4
# utf-8
N, M = map(int, input().split())

P = int(input())
K = list(map(int, input().split()))

for _ in range(M):
    w = int(input())
    ans = -100000  # 絶対に答えにならないもので初期化

    for i in range(P):
        if K[i] % N == 0:
            if abs(K[i] - w) <= abs(ans - w):
                ans = K[i]

    print(ans)
'''
1 行目の入力を標準入力を用いて受け取り、受け取った値をそれぞれ変数に代入します。
2 行目の入力を標準入力を用いて受け取り、受け取った値を変数に代入します。
3 行目の入力を標準入力を用いて受け取り、受け取った値を変数に代入します。
　　このとき配列に格納しておくと、この先の実装がスムーズに進みます。（実装例では配列名を K としています）
M 回実行される繰り返し処理を書きます。
　　5 ~ 10 の手順が M 回実行されるように書きます
標準入力を用いて入力を受け取り、受け取った値を変数に代入します。
これまでにみた箱に書かれた数字のうち、みかんの重さに最も近いものを格納する変数を用意します。（実装例では変数名を ans としています）
　　変数の初期値として絶対に答えにならない数値を入れておきます。（実装例では初期値を -10000 としています）
P 回実行される繰り返し処理を書きます。（実装例ではループ変数を i としています）
　　8 ~ 9 の手順が P 回実行されるように書きます
3 で受け取った配列 K の i 番目の値によって処理が変わる条件分岐を書きます。（配列 K の i 番目の値を k_i と表します）
　　・ k_i が N の倍数であるなら 9 の処理を続けます。
　　・ そうでないなら、なにもしません。
k_i が N の倍数であるなら、現在の解答候補よりみかんの重さに近い箱であるかを確認します。
　　・ k_i と w の差の絶対値が ans と w の差の絶対値以下であるなら、ans を k_i で更新します。
　　　　条件より配列 K の値は昇順であり、重さが一番近い箱が複数ある場合は数が大きい方の箱に仕分けられます。そのため、ans と w の差の絶対値"未満"ではなく"以下"とすることに注意してください。
　　・ そうでないなら、なにもしません。
ans の値を出力します。
6 では、より厳密には、変数の初期値として絶対に答えにならない かつ 実際の解答に影響を与えない数値を選ぶ必要があります。
例えば ans の初期値に -1 を選んだ場合は N = 5, w = 1, K = [ 5, 10, 15 ] の場合に、 9 の処理で ans が更新されることがなく初期値の -1 を誤って出力してしまいます。
このように初期値の設定ミスは一部のテストケースで不正解になる可能性があります。方針があっているのに不正解になってしまう場合は、変数の初期値を見直してみましょう。
'''

step6 「みかんの仕分け」を解くために:part5
# utf-8
N, M = map(int, input().split())

W = int(input())

for i in range(1, 1501):
    if i % N == 0:
        print(i, abs(i - W))
'''
1 行目の入力を標準入力を用いて受け取り、受け取った値をそれぞれ変数に代入します。
2 行目の入力を標準入力を用いて受け取り、受け取った値を変数に代入します。（実装例では変数名を w としています）
1500 回実行される処理を書きます。
　　ループ変数が 1 から 1500 まで 1 ずつ増加するようにし、4 の処理が 1500 回実行されるようにします。
ループ変数の値によって処理が変わる条件分岐を書きます。
　　・ ループ変数が N の倍数であるなら、「ループ変数」と「 w とループ変数の差の絶対値」を空白区切りで出力します。
　　・ そうでないならなにもしません
ここからは、元の問題「みかんの仕分け」について、どのくらい大きい数字が書かれた箱まで調べたらよいかを考えます。
まず、元の問題は「みかんの重さに一番近い数が書かれた箱」を探す問題でした。
そしてこの問題の出力を見てみると、どのテストケースでも箱に書かれた数が 1 ~ 1100くらい の範囲に「箱に書かれた数字と w の差の絶対値」が最小となる箱、つまり元の問題の答えとなる箱が存在していることがわかります。
よって、元の問題では 1100 までの箱を調べれば十分です。
このような考え方で十分ですが、以下により詳しい考え方を示します。詳しく知りたい方やあまりピンとこない方は参考にしてください。
みかんの重さを w とします。
この問題の出力をみると次のことがわかります
　　・ 箱に書かれた数字が w より小さいとき、箱に書かれた数字が大きくなるほど「箱に書かれた数字と w の差の絶対値」は小さくなる
　　・ 箱に書かれた数字が w 以上のとき、箱に書かれた数字が大きくなるほど「箱に書かれた数字と w の差の絶対値」は大きくなる
1 より、次のことがわかります。
　　みかんの重さより小さい数のなかで最大の N の倍数が書かれたの箱 か みかんの重さ以上の数の中で最小の N の倍数が書かれた箱 のどちらかが、「箱に書かれた数字と w の差の絶対値」が最も小さくなる。つまり、答えになる箱はこのどちらかである。
　　例えば N = 10, w = 22 のとき、みかんの重さより小さい数のなかで最大の N の倍数は 20、みかんの重さ以上の数の中で最小の N の倍数は 30 です。
2 より、答えになる可能性がある最大の数は「みかんの重さ以上の数の中で最小の N の倍数」であるとわかります。
調べる数の上限は答えになる可能性がある最大の数です。みかんの重さによって調べる数の上限を変えてもよいですが少し実装が複雑になるため、すべての入力に対して 1 つの上限を考えます。
　　「みかんの重さ以上の数の中で最小の N の倍数」が最大になるときはみかんの重さが最大になるときであるため、みかんの重さの最大値 w = 1000 のときについて考えればよいです。
　　このとき「みかんの重さ以上の数の中で最小の N の倍数」は 「 1000 以上の数で最小の N の倍数」と言い換えることができます。
　　ここで、1000 以上 1100 以下の数の中に N ( 1 ≦ N ≦ 100 ) の倍数は必ず 1 つ以上存在します。（ i 番目の N の倍数と i + 1 番目の N の倍数の差は N であり、条件より N ≦ 100 であるため）
4 より、調べる数の上限は 1100 で十分であることがわかります。
'''

step1 みかんの仕分け（力試し編）& final みかんの仕分け
# utf-8
N, M = [int(i) for i in input().split()]

for _ in range(M):
    x = int(input())
    ans = -100000

    for w in range(1, 1201):
        if w % N != 0:
            continue
        
        if abs(x - w) <= abs(x - ans):
            ans = w

    print(ans)
'''
みかんの重さが最大で 1000 程度なので、みかんを入れる箱の候補は 1 ~ 1200 の箱です。
( N が最大 100 より、1100 の箱とかも候補になるので、余分に調べることにする )
各みかんごとにどの箱に入れるのが良いかを計算することができます。
みかん 1 つにつき、最大 1000 回程度の計算が行われるので、M(≦10) 個のみかんそれぞれに計算を行っても 10000 回程度の計算しか行われないため、制限時間に余裕をもって間に合います。
重さが x のみかんを入れる箱の求め方を考えます。
箱の候補は 1 ~ 1200 なので、変数 : w が 1~1200 の範囲で for 文を回します。
みかんを入れる箱には N の倍数が書かれているので、w が N の倍数かどうかを判定する必要があります。
w が N の倍数かどうかは、以下のように判定することができます。
w % N == 0 : (w を N で割ったあまりが 0 かどうか)
候補の箱の中で、箱に書かれた数が x に最も近い箱(複数ある場合は大きい方)を探す必要があります。
以下の変数を定義して for 文を回すと良いでしょう。
ans := これまでにみた候補の箱に書かれた番号のうち、x に最も近いもの
'''
# Q. 残り物の量　C(殿堂入り)
# utf-8
def calculate_leftover_amount(m, p, q):
    """
    生鮮食品の売れ残り量を計算する関数

    Args:
        m (int): 生鮮食品の仕入れ量(kg)
        p (int): 生のまま売れた割合(%)
        q (int): お総菜に変換された売れ残りの割合(%)

    Returns:
        float: 最終的な売れ残り量(kg)
    """
    # 生鮮食品の売れ残り量を計算
    leftover_amount = m * (100 - p) / 100

    # お総菜に変換された売れ残り量を計算
    leftover_amount = leftover_amount * (100 - q) / 100

    return leftover_amount


# 生鮮食品の仕入れ量、生のまま売れた割合、お総菜に変換された売れ残りの割合を入力
m, p, q = map(int, input().split())

# 生鮮食品の売れ残り量を計算
leftover_amount = calculate_leftover_amount(m, p, q)

# 売れ残り量を小数値で出力
print("{:.4f}".format(leftover_amount))

# Q. 1を数えよ[ビット演算] C
step1 & final  1を数えよ
# utf-8
N = int(input())
ans = 0
bitMask = 1
while bitMask <= N:
    if bitMask & N != 0:
        ans += 1
    bitMask *= 2

print(ans)
'''
N を 2 進数にしたとき最下位の桁が 1 かどうか判定するには、2 進数で最下位の桁のみ 1 である数値との論理積を取ればよいのでした。 これをすべてのビットに対して行えばよいです。 例えば、N の下から 2 ビット目が 1 か判定するには、2 進数で下から 2 桁目のみ 1 である数値 00000010、つまり 10 進数の 2 と論理積を取ればよいです。 このような、ビット単位の論理演算で特定のビットだけを取り出したりするために用いられるビットパターンのことをビットマスクと呼びます。
標準入力を用いて入力を受け取り、変数に代入します。(実装例では変数名 N)
1 の個数を管理する変数を用意し、初期値を 0 にします。(実装例では変数名 ans)
論理積を取る相手(ビットマスク)を用意し、初期値を 1 とします。(実装例では変数名 bitMask)
bitMask の値が N 以下である限り実行される繰り返し処理を書きます。
　　5 ~ 6 の手順が繰り返されるようにします。
N と bitMask の論理積が 0 でないなら、ans に 1 加算します。
bitMask に 2 をかけます。(bitMask のビットが立っている桁を左に 1 ずらします。)
ans の値を出力します。
'''

step2 「1を数えよ」を解くために part1
# utf-8
N = int(input())

print(N)
'''
標準入力を用いて入力を受け取り、変数に代入します。
　　このとき整数型で受け取ります。
　　変数の名前に特に決まりはありませんが、この入力について問題文中で N と表記されているので、実装例では変数名を N にして、合わせています。
変数の値を標準出力します。
'''

step3 「1を数えよ」を解くために part2
# utf-8
S = input()

ans = 0
for i in range(len(S)):
    if S[i] == "1":
        ans += 1
print(ans)
'''
標準入力を用いて入力を受け取り、変数に代入します。
　　解説・実装例では文字列型で受け取ることにします。(実装例では変数名 S)
1 の個数を管理する変数を用意し、初期値を 0 にします。(実装例では変数名 ans)
S の長さと同じ回数実行される繰り返し処理を書きます。
　　4 の手順が繰り返されるようにします。
　　解説・実装例ではループ変数を i とし、0 ~ S の長さ-1 まで変化させます。
S[i] が 1 なら ans に 1 加算します。(S[i] は 文字列 S の i+1 番目の文字を表します。)
ans の値を出力します。
'''

step4 「1を数えよ」を解くために part3
# utf-8
N = int(input())

binaryNumber = list()
while N // 2 > 0:
    binaryNumber.append(N % 2)
    N //= 2
binaryNumber.append(N)
reversed(binaryNumber)  # 逆順にする

ans = 0
for i in range(len(binaryNumber)):
    if binaryNumber[i] == 1:
        ans += 1
print(ans)
'''
標準入力を用いて入力を受け取り、変数に代入します。(実装例では変数名 N)
問題文にしたがって N を 2 進数に変換していきます。変換後の 2 進数を管理する配列を用意します。(実装例では変数名 binaryNumber)
N を商が 0 になるまで 2 で割り続けます。N を 2 で割った商が 0 より大きい限り繰り返される while 文を書きます。
　　4 ~ 5 の手順が繰り返されるようにします。
N を 2 で割った余りを binaryNumber に追加します。
N を 2 で割ります。切り捨て除算になるように注意してください。
N をbinaryNumber に追加します。
binaryNumber を逆順にします。ここまでの操作で binaryNumber は N を 2 進数に変換したものになりました。
　　この問題に解答する上では逆順にする操作はなくてもかまいません。
1 の個数を管理する変数を用意し、初期値を 0 にします。(実装例では変数名 ans)
binaryNumber の要素数と同じ回数実行される繰り返し処理を書きます。
　　10 の手順が繰り返されるようにします。
　　解説・実装例ではループ変数を i とします。
binaryNumber[i] が 1 なら ans に 1 加算します。
ans の値を出力します。
'''

step5 「1を数えよ」を解くために part4
# utf-8
N = int(input())

if N & 1 == 1:
    print("Yes")
else:
    print("No")
'''
N を 2 進数にしたとき最下位の桁が 1 かどうか判定するには、2 進数で最下位の桁のみ 1 である数値との論理積を取ればよいです。 つまり、N と 1 の論理積を取ればよいです。 N と 1 の論理積が 1 なら N を 2 進数にしたとき最下位の桁が 1 、そうでないなら 0 です。
標準入力を用いて入力を受け取り、変数に代入します。(実装例では変数名 N)
N と 1 の論理積によって処理が変わる条件分岐を書きます。
　　論理積が 1 なら Yes を出力します。
　　そうでないなら No を出力します。
'''

# Q. 文字列の抽出 C
step2 文字列の抽出 : part1
# utf-8
def solve():
    S1 = input()
    S2 = list(S1)
    print(S1)
    print("".join(S2))
if __name__ == "__main__":
    solve()
'''
文字列の受け取り方には、いくつかの方法がありますが代表的な方法は以下の 2 つです。
1 つめは、単純に文字列型で受け取る方法、 2 つ目は、配列に 1 つずつ文字を格納する方法です。
文字列型で受け取れば、 1 つの固まりとして扱うことができますが、Pythonなど一部の言語では、文字を変更することが困難な場合があるなどどちらにもメリット、デメリットがあります。
そのため、どちらも使用できるようになっておきましょう。
実装例では、どちらも使用し、文字列型として受け取ったものを S1 、配列として受け取ったものを S2 としています。
'''

step3 文字列の抽出 : part2
# utf-8
def solve():
    tag_a, tag_b = input().split()
    search_str = input()
    m = len(tag_a)
    a_index,b_index = map(int,input().split())
    if a_index+m == b_index:
        print('<blank>')
    else:
        print(search_str[a_index+m-1:b_index-1])
if __name__ == "__main__":
    solve()
'''
文字列のどの部分を出力すべきか考えてみましょう。
単純に開始タグと終了タグの開始点を切り抜いてしまうと、開始タグを含めて出力してしまいます。
開始タグを含まずに出力するには、タグの文字数分切り抜く開始位置をずらす必要があります。
図を書いて考えて見ると分かりやすいです。
また、切り抜く部分が 0 文字の場合、 blank と出力する必要があることに注意しましょう。
'''

step4 文字列の抽出 : part3
# utf-8
def solve():
    tag_a, tag_b = input().split()
    search_str = input()
    n,m = len(search_str),len(tag_a)
    a_index = search_str.find(tag_a)+1
    b_index = search_str.find(tag_b)+1
    print(a_index,b_index)
if __name__ == "__main__":
    solve()
'''
part2 のコードに加え、それぞれのタグの開始位置を求めればこの問題に正答できます。
これは、for 文や文字列検索を行う組み込み関数で行うことができます。
実装例では、Python3 では組み込み関数、C++ ではfor 文で実装しています。
なお、解説では、タグを探す文字列を search_str 、開始タグと終了タグをtag_aとtag_bという変数名の文字列とします。
for文の場合
開始位置の候補となる 1 文字目から N-M+1 文字目について、タグの条件を満たしているかチェックします。
　　具体的には、for 文で変数 i を (i=0~N-M) として、2 ~ 3 の手順が繰り返します。
変数jを使ってi文字目から i+M-1 文字目までの search_str が tag_aとtag_b に全て一致しているかを確認します。
　　具体的には、変数 j を (j=0~m-1) として、search_str[i+j] と tag_a[j] が全ての j で一致しているか、search_str[i+j] と tag_b[j] が全ての j で一致しているかを for 文で確認してみましょう。
tag_a と完全に一致していれば開始タグ、tag_b であれば終了タグです。 i+1 の値が開始位置なので、保持しましょう。
組み込み関数を利用する場合
組み込み関数で行う場合、タグを引数にとることで簡単に行うことができます。
例えば、Python3 では find 関数が該当します。
'''

step5 文字列の抽出 : part4
# utf-8
def solve():
    tag_a, tag_b = input().split()
    search_str = input()
    n,m = len(search_str),len(tag_a)
    a_index,b_index  = [],[]
    for i in range(n-m+1):
        check_a = True
        check_b = True
        for j in range(m):
            if search_str[i+j] != tag_a[j]:
                check_a = False
            if search_str[i+j] != tag_b[j]:
                check_b = False
        if check_a:
            a_index.append(i+1)
        if check_b:
            b_index.append(i+1)
    for i in range(len(a_index)):
        print(a_index[i],b_index[i])
if __name__ == "__main__":
    solve()
'''
part3 のコードを変更して、開始位置を全て保持するようにしましょう。for 文と文字列検索を行う組み込み関数場合では以下のようにして実装しましょう。
for 文の場合
組み込み関数で行う場合、保持に使用するオブジェクトを数値型から、空の配列などに変更して開始位置を全て追加していけばよいです。
そうすればあとは、位置をそれぞれ出力すればよいです。
組み込み関数を利用する場合
文字列検索を行う関数の多くは、複数の部分文字列が含まれる場合、一番左側の部分文字列の位置のみが返されることに注意しましょう。
その場合、以下のように while 文で行いましょう。
以下の文字検索を行う関数を find 関数とします。
while 文で変数 j を j=0 として、n-m を超えるまで、以下の操作を繰り返します　
find 関数で、検索を行う開始位置を j として、開始タグと終了タグの位置 (s_i,g_i) をそれぞれ取得して保持します。
　　この際、タグが見つからなかった場合、break して処理を打ち切りましょう。
j を終了タグの終了位置、つまり、g_i+m に更新します。
'''

step1 文字列の抽出（力試し編）& final 文字列の抽出
# utf-8
def solve():
    tag_a, tag_b = input().split()
    search_str = input()
    p = 0
    s = 0
    while True:
        s = search_str[p::].find(tag_a)
        p += s + len(tag_a)
        e = search_str[p::].find(tag_b) + p
        if s == -1:
            break
        elif p == e:
            print('<blank>')
        elif p < e:
            print(search_str[p:e:])
        p = e
if __name__ == "__main__":
    solve()

# utf-8
def solve():
    tag_a, tag_b = input().split()
    search_str = input()
    n,m = len(search_str),len(tag_a)
    a_index,b_index  = [],[]
    for i in range(n-m+1):
        check_a = True
        check_b = True
        for j in range(m):
            if search_str[i+j] != tag_a[j]:
                check_a = False
            if search_str[i+j] != tag_b[j]:
                check_b = False
        if check_a:
            a_index.append(i+1)
        if check_b:
            b_index.append(i+1)
    for i in range(len(a_index)):
        if a_index[i]+m == b_index[i]:
            print('<blank>')
        else:
            print(search_str[a_index[i]+m-1:b_index[i]-1])
if __name__ == "__main__":
    solve()
'''
part4 で求めたタグの位置を利用しましょう。
タグの位置から、part2 のようにして切り抜く場所を求め、出力すればよいです。
part2 同様、切り抜く部分が 0 文字の場合、blank と出力する必要があることに注意しましょう。
'''

# Q. イルミネーション C
# utf-8
N, M = map(int,input().split())

LED = [0] * N #明るさを管理する配列

for i in range(M):
    a, b = map(int,input().split())
    LED[a - 1] = b
    #すべてのランプが点灯→全てのランプの明るさが正ならば、総和を出力し繰り返し処理を止める
    if min(LED) > 0:
        print(sum(LED))
        break
'''
LEDの明るさを管理する配列を用意します。それぞれの信号で明るさを変更し、そのたびに全てのLEDが点灯しているかを調べ、点灯していたら総和を出力し、繰り返し処理を止めます。
全てのLEDが点灯しているかは配列の最小値が正であるかで判定できます。Pythonの場合繰り返し処理を止めるのは、break文で行えます。
'''

# Q. 数列の調査 C
# utf-8
N = int(input())

A = list(map(int,input().split()))

ans_arith = "Yes"

#隣接 2 項間の差分を求め、すべて等しければ Yes、そうでなければ No → 1 ≦ i ≦ N - 2 を満たす i で A_{i + 2} - A{i + 1} = A_{i + 1} - A_i が成り立てば Yes、そうでなければ No 
for i in range(N - 2):
    if A[i + 2] - A[i + 1] != A[i + 1] - A[i]:
        ans_arith = "No"

print(ans_arith)

ans_geo = "Yes"

#等比数列と同じように求める。誤差に注意し、A_{i + 2} × A_i = A_{i + 1} × A_{i + 1} で判定
for i in range(N - 2):
    if A[i + 2] * A[i] != A[i + 1] ** 2:
        ans_geo = "No"

print(ans_geo)
'''
等差数列は全ての差が等しい数列、等比数列は全ての比が等しい数列です。
よって、隣接 2 項間の差、比がすべて等しいかを判定することで答えを求めることが出来ます。これは、A_{i + 2} - A_{i + 1} = A{i + 1} - A_i、A_{i + 2} / A_{i + 1} = A_{i + 1} / A_i が全てのの i (1 ≦ i ≦ N - 2) で成り立つかを判定すればよいです。
比を計算するとき、このままでは誤差の影響で正しく判定できない可能性があるので、A_{i + 2} × A_i = A_{i + 1} × A_{i + 1} とし、整数の範囲で判定する必要があります。
'''

★★★ B ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Q. 日別訪問者数の最大平均区間 B
# utf-8
n, k = map(int, input().split())
data = list(map(int, input().split()))

ave = [None] * (n - k + 1)
ave[0] = sum(data[:k])

for i in range(1, n - k + 1):
    ave[i] = ave[i - 1] - data[i - 1] + data[i - 1 + k]

m = max(ave)

print(ave.count(m), ave.index(m) + 1)
'''
訪問者数の累積和を取り、連続する k 日の合計訪問者数の最大値 max_visitor を求めます。
そして、連続する k 日の期間のうち、その合計訪問者数が max_visitor に等しい期間の数を数えます。
このとき同時にそのような期間のうち最も速い開始日を記録しておきます。
なお、この問題の制約は非常に小さいため、連続する k 日の期間の合計訪問者数を累積和を用いずに愚直に計算しても、実行時間制限に十分な余裕を持って間に合います。
'''

# Q. みんなでしりとり B
# utf-8
n, k, m = map(int, input().split())
ikiteru = [1] * n
data = set()
jun = 0
data2 = set()
flag = False
old_s = " "

for i in range(k):
    data.add(input())

for i in range(m):
    while True:
        if ikiteru[jun % n] == 1:
            break
        jun += 1

    new_s = input()

    if new_s in data2:
        ikiteru[jun % n] = 0
        flag = False
        continue

    if new_s[0] != old_s[-1] and flag:
        ikiteru[jun % n] = 0
        flag = False
        continue

    if not (new_s in data):
        ikiteru[jun % n] = 0
        flag = False
        continue

    if new_s[-1] == "z":
        ikiteru[jun % n] = 0
        flag = False
        continue

    data2.add(new_s)
    flag = True
    old_s = new_s
    jun += 1

print(ikiteru.count(1))

for i in range(n):
    if ikiteru[i] == 1:
        print(i + 1)
'''
ルールが多く、チェックするのが大変ですが、配列や集合などの各種データ構造を効果的に用いることにより問題を解くことが出来ます。
単語リストは集合の形で、しりとりから脱落せずに残っているプレイヤーは配列か集合の形で持つようにすると比較的楽に実装できるでしょう。
'''

# Q. 3Dプリンタ B(殿堂入り)
# utf-8
X, Y, Z = map(int, input().split())
grid = [[0] * Y for _ in range(Z)]

for z in range(Z):
    for x in range(X):
        s = input().strip()
        for y in range(Y):
            if s[y] == '#':
                grid[z][y] = 1

    bar = input()

for z in range(Z - 1, -1, -1):
    for y in range(Y):
        if grid[z][y] == 1:
            print("#", end="")
        else:
            print(".", end="")
    print()
'''
与えられた図形を x 軸と水平方向から見た時のシルエットを出力する問題です。
x 軸と水平方向から見たシルエットとは、y-z 二次元平面に影を落とした影そのものです。
影をおとす y-z 平面に対応するグリッド : G を用意します。
点 (px , py , pz) にセルが存在するならば、G[ py ][ pz ] にメモする
以上の操作を行うことで、y-z に落ちる影が G にメモされます。
G にメモされた影を、出力する順番に注意して出力してください。
'''

# Q. 神経衰弱(オリジナル) B
step2 「神経衰弱」を解くために:part1
# utf-8
# 1 行の入力を文字列として受け取り、半角スペースで区切ったものを整数に変換する
H, W, N = map(int, input().split())

# 半角スペース区切りで出力する
print("{H} {W} {N}".format(H=H, W=W, N=N))
'''
半角スペース区切りで 1 行の入力を受け取り、受け取ったデータを半角スペース区切りで出力します。
'''

step3 「神経衰弱」を解くために:part2
# utf-8
# 1 行の入力を文字列として受け取り、半角スペースで区切ったものを整数に変換する
H, W, N = map(int, input().split())

# 1 行の入力を文字列として受け取り、半角スペースで区切ったものを整数の配列に変換する
# この操作を H 回繰り返す
cards = [list(map(int, input().split())) for _ in range(H)]

# H 行の配列を 1 つずつ取り出して処理する
for line in cards:
  # join 関数を使うために整数の配列を文字列の配列に変換
  line = map(str, line)
  # join 関数で line 配列の要素を半角スペース区切りで連結した文字列に変換
  print(' '.join(line))
'''
半角スペース区切りで 1 行の入力を受け取ります。
1 行目で受け取った H と W のデータを使って H 行のトランプのカードのデータを受け取ります、そのまま出力します。
'''

step4 「神経衰弱」を解くために:part3
# utf-8
# 1 行の入力を文字列として受け取り、半角スペースで区切ったものを整数に変換する
H, W, N = map(int, input().split())

# 1 行の入力を文字列として受け取り、半角スペースで区切ったものを整数の配列に変換する
# この操作を H 回繰り返す
cards = [list(map(int, input().split())) for _ in range(H)]

# 記録の長さ L を受け取る
L = int(input())
# 捲られたトランプの記録を受け取る
# L 行に渡って整数を半角スペース区切りで受け取る
logs = [map(int, input().split()) for _ in range(L)]

for a_i, b_i, A_i, B_i in logs:
  # a_i 行 b_i 列 のトランプに書かれた数字
  # a_i の範囲は 1 ~ H, cards 配列の範囲は 0 ~ H-1 なのでずらす
  card_number_1 = cards[a_i - 1][b_i - 1]
  # A_i 行 B_i 列 のトランプに書かれた数字
  card_number_2 = cards[A_i - 1][B_i - 1]

  # 書かれた数字が同じなら YES
  if card_number_1 == card_number_2:
    print("YES")
  else: # 異なるなら NO
    print("NO")
'''
記録の長さを表す整数 L を受け取ります。
続く L 行に渡って、捲ったカードの記録を受け取ります。
これらの記録は捲ったカードの位置を表しているので、並べられたカードのデータから、対応する位置のカードに書かれている数字を読み出します。
それぞれの記録について、捲った 2 枚のカードの数字が同じなら YES を異なるなら NO を出力します。
'''

step5 「神経衰弱」を解くために:part4
# utf-8
# 1 行の入力を文字列として受け取り、半角スペースで区切ったものを整数に変換する
H, W, N = map(int, input().split())

# 1 行の入力を文字列として受け取り、半角スペースで区切ったものを整数の配列に変換する
# この操作を H 回繰り返す
cards = [list(map(int, input().split())) for _ in range(H)]

# 手番のプレイヤーの番号 P を受け取る
P = int(input())
# 捲られたトランプの記録を受け取る
a, b, A, B = map(int, input().split())

# a 行 b 列 のトランプに書かれた数字
card_number_1 = cards[a - 1][b - 1]
# A 行 B 列 のトランプに書かれた数字
card_number_2 = cards[A - 1][B - 1]
# 次のプレイヤーの番号を保持
next_player = P
# 書かれた数字が同じなら YES
if card_number_1 == card_number_2:
  print("YES")
else: # 異なるなら NO
  print("NO")
  # 手番が次のプレイヤーに移る
  # 現在のプレイヤーが N 番のときは 1 番に
  if N == P:
    next_player = 1
  else:
    next_player = P + 1
print(next_player)
'''
並べられたトランプのデータを受け取るところまでは前回と同じです。
手番のプレイヤーの番号 P と捲られたトランプの位置 (a, b) と (A, B) を受け取ります。
(a, b) のトランプと (A, B) のトランプに書かれた数字を比べたとき、それぞれ以下のように処理します。
書かれた数字が同じとき
YES を出力します。
次の手番のプレイヤーは変化しません。
書かれた数字が異なるとき
NO を出力します。
次の手番のプレイヤーは番号がひとつ大きいプレイヤーに変わります。ただし、今の手番のプレイヤーが N 番の場合、次の手番のプレイヤーは 1 番に変わります。
最後に、捲ったトランプの数字が同じかどうかにかかわらず、次の手番のプレイヤーの番号を出力します。
'''

step6 「神経衰弱」を解くために:part5
# utf-8
# 1 行の入力を文字列として受け取り、半角スペースで区切ったものを整数に変換する
H, W, N = map(int, input().split())

# 並べられたカードの情報を保持する 2 次元リストを宣言
cards = [list(map(int, input().split())) for _ in range(H)]

# 記録の長さ L を受け取る
L = int(input())
# 捲られたトランプの記録を受け取る
# L 行に渡って整数を半角スペース区切りで受け取る
logs = [map(int, input().split()) for _ in range(L)]

# それぞれのプレイヤーが取り除いたカードの枚数を保持する配列を宣言
acquired_cards = [0 for _ in range(N)]
# 今の手番のプレイヤー番号を保持する変数 P を宣言
P = 1

for a_i, b_i, A_i, B_i in logs:
  # a_i 行 b_i 列 のトランプに書かれた数字
  # a_i の範囲は 1 ~ H, cards 配列の範囲は 0 ~ H-1 なのでずらす
  card_number_1 = cards[a_i - 1][b_i - 1]
  # A_i 行 B_i 列 のトランプに書かれた数字
  card_number_2 = cards[A_i - 1][B_i - 1]

  # 書かれた数字が同じなら YES
  if card_number_1 == card_number_2:
    # 書かれた数字が同じなら
    # 現在のプレイヤーがカードを 2 枚取り除く
    acquired_cards[P - 1] += 2
  else:
    # 異なるなら手番が変わる
    # 次のプレイヤーは次の番号のプレイヤー
    # N 番のときは 1 番
    if P == N:
      P = 1
    else:
      P = P + 1

# 結果を出力
for ans in acquired_cards:
  print(ans)
'''
それぞれのプレイヤーが取り除いたカードの枚数を保持する配列を宣言と今の手番のプレイヤー番号を保持する変数を宣言します。
それぞれの記録について、捲った 2 枚のカードの数字が
同じなら
現在の手番のプレイヤーがカードを 2 枚取り除く
異なるなら
手番が次の番号のプレイヤーに移る。ただし、N 番のプレイヤーが手番のとき、次のプレイヤーは 1 番
すべての記録について上記を繰り返し、1 番のプレイヤーから順に取り除いたカードの枚数を出力します
'''

step1 神経衰弱（力試し編）& final 神経衰弱(オリジナル)
# utf-8
h, w, n = map(int, input().split())

cards = [None] * h
player = [0] * n
jun = 0

for i in range(h):
    cards[i] = list(map(int, input().split()))

l = int(input())

for i in range(l):
    b, a, B, A = map(int, input().split())
    num1 = cards[b - 1][a - 1]
    num2 = cards[B - 1][A - 1]

    if num1 == num2:
        player[jun % n] += 2
        cards[b - 1][a - 1] = 0
        cards[B - 1][A - 1] = 0
    else:
        jun += 1

for i in player:
    print(i)
'''
トランプの配置を二次元配列で受け取り、問題文の通りに実装をすればよいです。
'''

# Q. 名刺バインダー管理　B(殿堂入り)
# utf-8
n, m = map(int, input().split())
print((m-1)//n*n+2*n-(m-1)%n if (m-1) % (2*n) < n else (m-1)//n*n-(m-1)%n)

# 値の計算 B
step2 「値の計算」を解くために：part1
# utf-8
N = int(input())
print(N)

for _ in range(N):
    s, w = input().split()
    w = int(w)
    print(s, w)

M = int(input())
print(M)

T = input().split()
print(" ".join(T))
'''
標準入力を用いて、入力を受け取ります。
　　このとき整数型で受け取ります。
受け取った値を変数に代入します。
　　変数の名前に特に決まりはありませんが、この入力について問題文中で N と表記されているので、実装例では変数名も N にして、合わせています。
変数の値を標準出力します。
N 回実行される繰り返し処理を書きます。
　　5 ~ 7 の手順が N 回実行されるように書きます
標準入力を用いて、入力を受け取ります。
受け取った値を変数に代入します。（実装例では変数名を s w としています）
　　このとき s は文字列型、w は整数型として受け取ります。
変数の値を空白区切りで標準出力します。
標準入力を用いて、入力を受け取ります。
受け取った値を変数に代入します。（実装例では変数名を M としています）
　　このとき整数型として受け取ります。
変数の値を標準出力します。
標準入力を用いて、空白区切りの入力を受け取ります。
　　このとき文字列として受け取り、配列に格納します。
受け取った配列を空白区切りで出力します。
行の末尾に余計な空白が入らないように注意してください。

Python の場合、input() は入力をすべて文字列として受け取ります。 文字列以外の型で受け取る場合は、文字列として受け取った後に型変換を行います。 
例えば、1 行に文字列と整数が含まれるときは、まずすべて文字列として受け取り、その後整数は整数に変換します。(実装例の 5, 6 行目)
'''

step3 「値の計算」を解くために：part2
# utf-8
N = int(input())

D = dict()
for _ in range(N):
    s, w = input().split()
    D[s] = int(w)

key = list(D.keys())
key.sort()

for k in key:
    print(D[k])
'''
1 標準入力を用いて、入力を受け取ります。
2 連想配列 (Python の辞書) を用意します。
　　実装例では変数名を D としています。
3N 回実行される繰り返し処理を書きます。
　　4 ~ 5 の手順が N 回実行されるように書きます
4標準入力を用いて、入力を受け取ります。
5抵抗名をキー、抵抗値をバリューとして受け取った値を連想配列に格納します。
　　このとき、抵抗値を整数型にしておくと part3 以降をスムーズに進められます。
6連想配列のキーを取り出し配列などに格納します。
7取り出したキーをアルファベット順にソートします。
8N 回実行される繰り返し処理を書きます。
　　9 の手順が N 回実行されるように書きます。解説ではループ変数を i とします。
9 7でソートしたアルファベット順で i 番目のキーのバリューを出力します。

Python の場合、連想配列には dict を使用します。 
宣言は 変数名 = dict()、要素の追加は 変数名[key] = value 、要素のアクセスは 変数名[key] です。 キーの取り出しは 変数名.keys()です。
'''

step4 「値の計算」を解くために：part3
# utf-8
N = int(input())

D = dict()
for _ in range(N):
    s, w = input().split()
    D[s] = int(w)

M = int(input())
T = input().split()
ans = 0
for i in range(M):
    ans += D[T[i]]

print(ans)
'''
標準入力を用いて、入力を受け取ります。
連想配列 (Python の辞書) を用意します。
N 回実行される繰り返し処理を書きます。
　　4 ~ 5 の手順が N 回実行されるように書きます。
標準入力を用いて、入力を受け取ります。
抵抗名をキー、抵抗値をバリューとして受け取った値を連想配列に格納します。
標準入力を用いて、入力を受け取ります。(実装例では変数名 M)
標準入力を用いて、空白区切りで入力を受け取ります。(実装例では変数名 T)
解答となる回路全体の抵抗値を管理する変数を用意します。 (実装例では変数名 ans)
M 回実行される繰り返し処理を書きます。
　　10 の手順が M 回実行されるように書きます。
　　解説ではループ変数を i とします。
8 の変数に抵抗名 T_i の抵抗値を加算します。
　　抵抗値の計算は直列の場合 A + B であるので、今回の問題では加算するだけでよいです。
'''

step5 「値の計算」を解くために：part4
# utf-8
N = int(input())

D = dict()
for _ in range(N):
    s, w = input().split()
    D[s] = int(w)

M = int(input())
T = input()
ans = 0
tmp = 0
for j in range(len(T)):
    tmp += 1 / D[T[j]]
ans += 1 / tmp

print(int(ans))
'''
標準入力を用いて、入力を受け取ります。
連想配列 (Python の辞書) を用意します。
N 回実行される繰り返し処理を書きます。
　　4 ~ 5 の手順が N 回実行されるように書きます。
標準入力を用いて、入力を受け取ります。
抵抗名をキー、抵抗値をバリューとして受け取った値を連想配列に格納します。
標準入力を用いて、入力を受け取ります。(実装例では変数名 M)
標準入力を用いて、入力を受け取ります。(実装例では変数名 T)
解答となる回路全体の抵抗値を管理する変数を用意します。 (実装例では変数名 ans)
並列の場合の抵抗値は 1 / (1 / A + 1 / B) で計算されます。そのため、まず分母の (1 / A + 1 / B) を計算し、最後に 1 / (1 / A + 1 / B) を計算することにします。分母を管理する変数を用意します。(実装例では変数名 tmp)
文字列 T の長さと同じ回数実行される繰り返し処理を書きます。
　　11 の手順が繰り返し実行されるように書きます。
　　解説ではループ変数を j とします。
9 の変数に 1 / (抵抗名 T_j の抵抗値) を加算します。
　　計算過程では小数点以下を考慮する必要があることに注意してください。
9 の変数を利用して 1 / (1 / A + 1 / B) を計算します。8 の変数に 1 / (9 の変数) を加算します。
8 の変数の値の小数点以下を切り捨てた値を出力します。
　　小数点以下切り捨てには各言語に用意された関数やライブラリを使用して下さい。
静的型付け言語の場合、方針 8, 9 で用意する変数を小数を扱うことができる型で定義する必要があることに注意してください。
Python では小数点以下の切り捨てに int 関数を使うことができます。
'''

step6 「値の計算」を解くために：part5
# utf-8
N = int(input())

D = dict()
for _ in range(N):
    s, w = input().split()
    D[s] = int(w)

M = int(input())
T = input().split()
ans = 0
for i in range(M):
    if len(T[i]) == 1:
        ans += D[T[i]]
    else:
        tmp = 0
        for j in range(len(T[i])):
            tmp += 1 / D[T[i][j]]
        ans += 1 / tmp

print(int(ans))
'''
標準入力を用いて、入力を受け取ります。
連想配列 (Python の辞書) を用意します。
N 回実行される繰り返し処理を書きます。
　　4 ~ 5 の手順が N 回実行されるように書きます。
標準入力を用いて、入力を受け取ります。
抵抗名をキー、抵抗値をバリューとして受け取った値を連想配列に格納します。
標準入力を用いて、入力を受け取ります。(実装例では変数名 M)
標準入力を用いて、入力を受け取ります。(実装例では変数名 T)
解答となる回路全体の抵抗値を管理する変数を用意します。 (実装例では変数名 ans)
M 回実行される繰り返し処理を書きます。
　　10 の手順が繰り返し実行されるように書きます。解説ではループ変数を i とします。
7 で受け取った配列の i 番目の文字列の長さによって処理が変わる条件分岐を書きます。(7 で受け取った配列の i 番目の文字列 を T_i と表します)
　　・T_i の長さが 1 であるなら直列でつながれているので、8 の変数に抵抗名 T_i の抵抗値を加算します。
　　・そうでないなら抵抗は並列でつながれています。そのため、part 4 と同じように抵抗値を計算します。具体的には以下の 1 ~ 3 の処理を行います。
　　
分母の (1 / A + 1 / B) を管理する変数を用意します。
以下の手順が T_i の長さと同じ回数実行される繰り返し処理を書きます。(解説ではループ変数を j とします)
分母を管理する変数に 1 / (抵抗名 T_{i,j} の抵抗値) を加算する。
8 の変数に 1 / (分母を管理する変数) を加算します。
8 の変数の値の小数点以下を切り捨てた値を出力します。
'''

step1・final 値の計算（力試し編）& final 値の計算
# utf-8
N = int(input())

D = dict()
for _ in range(N):
    s, w = input().split()
    D[s] = int(w)

M = int(input())
T = input().split()
ans = 0
for i in range(M):
    if len(T[i]) == 1:
        ans += D[T[i]]
    else:
        tmp = 0
        for j in range(len(T[i])):
            tmp += 1 / D[T[i][j]]
        ans += 1 / tmp

print(int(ans))
'''
標準入力を用いて、入力を受け取ります。
連想配列 (Python の辞書) を用意します。
N 回実行される繰り返し処理を書きます。
　　4 ~ 5 の手順が N 回実行されるように書きます。
標準入力を用いて、入力を受け取ります。
抵抗名をキー、抵抗値をバリューとして受け取った値を連想配列に格納します。
標準入力を用いて、入力を受け取ります。(実装例では変数名 M)
標準入力を用いて、入力を受け取ります。(実装例では変数名 T)
解答となる回路全体の抵抗値を管理する変数を用意します。 (実装例では変数名 ans)
M 回実行される繰り返し処理を書きます。
　　10 の手順が繰り返し実行されるように書きます。解説ではループ変数を i とします。
7 で受け取った配列の i 番目の文字列 T_i の長さによって処理が変わる条件分岐を書きます。
　　・T_i の長さが 1 であるなら直列でつながれているので、8 の変数に抵抗名 T_i の抵抗値を加算します。
　　・そうでないなら抵抗は並列でつながれています。そのため、part 4 と同じように並列につながれている抵抗の抵抗値を計算します。具体的には以下の 1 ~ 3 の処理を行います。
　　
分母の (1 / A + 1 / B) を管理する変数を用意します。
以下の手順が T_i の長さと同じ回数実行される繰り返し処理を書きます。(解説ではループ変数を j とします)
分母を管理する変数に 1 / (抵抗名 T_{i,j} の抵抗値) を加算する。
8 の変数に 1 / (分母を管理する変数) を加算します。
8 の変数の小数点以下を切り捨てた値を出力します。
'''

# Q.「地下アイドルの夢」 B
step2 「地下アイドルの夢」を解くために：part1
def solve():
    n,m = map(int,input().split())
    if n == 0 or m == 0:
        exit()
    E = [list(map(int,input().split())) for _ in range(m)]
    for i in range(m):
        print(*E[i])
if __name__ == "__main__":
    solve()
'''
n,m のどちらかが 0 である場合、何も出力しないということに注意しましょう。
1 行ずつ受け取る方法
1 行目の入力を受け取り、空白で区切って、それぞれを変数に代入します。このとき、変数名は N と M とします。
次に空の二次元配列を用意し、変数名を E とします。
2 行目から、m+1 行目までは、for 文で配列として受け取り、E に格納していきます。
最後に、for 文で i=0~N-1 として、E[i] を空白区切りで出力すればよいです。

Pythonでは、二次元配列の受け取りは、リスト内包表記を使えば1行で簡潔に記述することができます。
リスト内包表記は、非常に便利で多用されるのでぜひ覚えておきましょう。
なお、配列を空白区切りで出力する場合、配列の左に*をつけることで可能です。
'''

step3 「地下アイドルの夢」を解くために：part2
# utf-8
def solve():
    n,m = map(int,input().split())
    if n == 0:
      print(0)
      exit()
    E = list(map(int,input().split()))
    sum_e = sum(E)
    print(max(sum_e,0))
if __name__ == "__main__":
    solve()
'''
会員それぞれの損益の総和がライブの損益になるので、これを求めましょう。以下 sum_e とします。
なお、sum_e は、for 文や関数で求めることができます。
実装例では、Python3 は関数、C++ では for 文を用いています。
ライブの損益が正であれば開催したほうがよく、負であれば開催しない方がよいです。負の場合は損益 0 という処理にします。
損益の判定は、if 文でもいいですが、多くの言語で実装されている、引数の内最大のものを返す max 関数を用いて、max(sum_e,0) のようにすれば簡潔に記述出来ます。
'''

step4 「地下アイドルの夢」を解くために：part3
# utf-8
def solve():
    n,m = map(int,input().split())
    E = [int(input()) for _ in range(m)]
    ans = 0
    for e in E:
        ans += max(0,e)
    print(ans)
if __name__ == "__main__":
    solve()
'''
ライブ j を開催すればよいかは、e[j] が正であるかで決定されます。
したがって、まず、変数 ans を 0 で初期化し以下のような操作を for 文で繰り返します。なお、変数 ans は、来年の利益を計算するために使用します。
j = 0~m-1 として、e[j] が正であれば、ans に e[j] を加算します。
このような操作で、最大利益を求めることが可能です。
'''

step1・final
# utf-8
def solve():
    N,M = map(int,input().split())
    if N == 0:
        print(0)
        exit()
    ans = 0
    for i in range(M):
        e = list(map(int,input().split()))
        se = sum(e)
        if se > 0:
            ans += se
    print(ans)
if __name__ == "__main__":
    solve()
'''
あるライブイベントを開くか開かないかは、他のライブイベントに一切影響しません。
したがって、単純にそれぞれ個別にライブイベントを開くべきかつまり利益が生じるかを判定すればよいです。
ライブiを開催したときの損益は、ライブiでの全ての会員の損益の総和であるため簡単に計算できます。

part2 と同様に、ライブイベントごとの損益を求め、正であれば part3 のように、変数 ans を加算していけばよいです。
N や M が 0 の場合に注意しましょう。
'''

# 部外者をはじけ B
step2 「部外者をはじけ」を解くために：part1
# utf-8
N = int(input())
print(N)

coordinate = list()
for _ in range(N):
    x, y = map(float, input().split())
    print(x, y)
    coordinate.append((x, y))
'''
標準入力を用いて入力を受け取り、受け取った値を変数に代入します。
このとき、整数型で受け取ります。
変数名に特に決まりはありませんが、この入力について問題文中で N と表記されているので、実装例では変数名も N にして、合わせています。
受け取った変数の値を出力します。
各人物の座標を格納する配列を用意します。(実装例では変数名 coordinate)
N 回実行される繰り返し処理を書きます。
標準入力を用いて入力を受け取り、受け取った値を変数に代入します。
このとき、小数型で受け取ります。
受け取った変数の値を空白区切りで出力します。
用意した配列に 5. で受け取った変数の組を格納します。
'''

step3 「部外者をはじけ」を解くために：part2
# utf-8
# (x1,y1) と (x2,y2) を通る直線が ax + by + c = 0 のとき、a,b,c の値を返す関数
def calaLine(x1, y1, x2, y2):
    return (y2 - y1, -(x2 - x1), (x2 - x1) * y1 - (y2 - y1) * x1)


N = int(input())
x1, y1 = map(float, input().split())
x2, y2 = map(float, input().split())

a, b, c = calaLine(x1, y1, x2, y2)
print(a, b, c)
'''
引数として 2 点の座標 (x_1, y_1), (x_2, y_2) を取り、 その 2 点を通る直線の方程式が ax + by + c = 0 であるとき、この式の a, b, c の値を返す関数を書きます。(実装例では関数名 calcLine) 問題文より、a, b, c の値はそれぞれ以下のように求めることができます。 ・ a := y2 - y1 ・ b := -1 * (x2 - x1) ・ c := (x2 - x1) * y1 - (y2-y1) * x1 問題文に書かれている計算方法で導出できる直線の方程式は ax - by + c = 0 の形であるため、ax + by + c = 0 の形にするには (x2 - x1) に -1 をかける必要があることに注意してください。 直線の方程式の計算を必ずしも関数にする必要はありませんが、可読性や保守性の観点から関数にすることを推奨します。 上記の関数を宣言した上で、具体的な解法を以下に示します。
標準入力を用いて入力を受け取り、受け取った値を変数に代入します。(実装例では変数名 N)
標準入力を用いて入力を受け取り、受け取った値を変数に代入します。(実装例では変数名 x1, y1)
標準入力を用いて入力を受け取り、受け取った値を変数に代入します。(実装例では変数名 x2, y2)
あらかじめ用意した直線を求める関数を呼び出し、方程式の a, b, c の値を求めます。
引数に x1, y1, x2, y2 を渡します。
a, b, c の値を空白区切りで出力します。
a, b, c の値は小数で出力します。
真値との誤差が 0.001 未満である場合にのみ正答とみなされることに注意してください。
'''

step4 「部外者をはじけ」を解くために：part3
# utf-8
# (x1,y1) と (x2,y2) を通る直線が ax + by + c = 0 のとき、a,b,c の値を返す関数
def calcLine(x1, y1, x2, y2):
    return (y2 - y1, -(x2 - x1), (x2 - x1) * y1 - (y2 - y1) * x1)


N = int(input())
coordinate = list()
for _ in range(N):
    x, y = map(float, input().split())
    coordinate.append((x, y))

for i in range(N - 1):
    xi, yi = coordinate[i]
    for j in range(i + 1, N):
        xj, yj = coordinate[j]
        # i 番目の人と j 番目の人を結ぶ直線の方程式を求める
        a, b, c = calcLine(xi, yi, xj, yj)
        print(a, b, c)
'''
標準入力を用いて入力を受け取り、受け取った値を変数に代入します。(実装例では変数名 N)
各人物の座標を格納する配列を用意します。(実装例では変数名 coordinate)
N 回実行される繰り返し処理を書きます。手順が繰り返されるようにします。
標準入力を用いて入力を受け取り、受け取った値を変数に代入します。
用意した配列に 4. で受け取った変数の組を格納します。
N-1 回実行される繰り返し処理を書きます。ループ変数を i := 1, 2, ...., N-1 とします。
N-i-1 回実行される繰り返し処理を書きます。手順が繰り返されるようにします。
本解説ではループ変数を j := i+1, i+2, ...., N とします。
i 番目の人と j 番目の人を結ぶ直線の方程式を求めます。あらかじめ用意した直線を求める関数を呼び出し、方程式の a, b, c の値を求めます。
引数に i 番目の人物の座標と j 番目の人の座標を渡します。a, b, c の値を空白区切りで出力します。

<別解>
Python で組み合わせを全列挙する場合は itertools.combinations() を使うことができます。 この関数は引数に選択する要素数を渡すことで、リストなどから任意の要素数の組み合わせを全列挙することができます。
from itertools import combinations
# (x1,y1) と (x2,y2) を通る直線が ax + by + c = 0 のとき、a,b,c を返す関数
def calcLine(x1,y1,x2,y2):
    return (y2-y1,-(x2-x1),(x2-x1)*y1-(y2-y1)*x1)

N = int(input())
coordinate = list()
for _ in range(N):
    x,y = map(float,input().split())
    coordinate.append((x,y))

for (x1,y1), (x2,y2) in combinations(coordinate,2):
    a,b,c = calcLine(x1,y1,x2,y2)
    print(a,b,c)
'''

step5 「部外者をはじけ」を解くために：part4
# utf-8
import math

# (x1,y1) と (x2,y2) を通る直線が ax + by + c = 0 のとき、a,b,c の値を返す関数
def calcLine(x1, y1, x2, y2):
    return (y2 - y1, -(x2 - x1), (x2 - x1) * y1 - (y2 - y1) * x1)


# 直線 ax + by + c = 0 と点 (x, y) の距離を返す関数
def calcDistance(a, b, c, x, y):
    return abs(a * x + b * y + c) / math.sqrt(a ** 2 + b ** 2)


N = int(input())
x1, y1 = map(float, input().split())
x2, y2 = map(float, input().split())
x3, y3 = map(float, input().split())

a, b, c = calcLine(x1, y1, x2, y2)
distance = calcDistance(a, b, c, x3, y3)
print(distance)
'''
引数として直線の方程式の a, b, c の値と 点の座標 (x,y) をとり、直線と点の距離を返す関数を書きます。(実装例では関数名 calcDistance) 問題文より、直線と点の距離は以下のように求めることができます。 ・ |a * x + b * y + c| / (a^2 + b^2)^(1/2) 上記の関数を宣言した上で、具体的な解法を以下に示します。
標準入力を用いて入力を受け取り、受け取った値を変数に代入します。(実装例では変数名 N)
標準入力を用いて入力を受け取り、受け取った値を変数に代入します。(実装例では変数名 x1, y1)
標準入力を用いて入力を受け取り、受け取った値を変数に代入します。(実装例では変数名 x2, y2)
標準入力を用いて入力を受け取り、受け取った値を変数に代入します。(実装例では変数名 x3, y3)
あらかじめ用意した直線を求める関数を呼び出し、(x1,y1) と (x2,y2) を通る直線の方程式の a, b, c の値を求めます。
引数に x1, y1, x2, y2 を渡します。求めた直線と 点 (x3,y3) との距離を求めます。
あらかじめ用意した直線と点の距離を求める関数を呼び出します。引数に求めた a, b. c と x3, y3 を渡します。
求めた値を出力します。 Python で数値 x 平方根を計算するときは math.sqrt(x) を使うことができます。 その他に、x**0.5 や pow(x,0.5) と書いても平方根を計算できます。
'''

step6 「部外者をはじけ」を解くために：part5
# utf-8
import math

# (x1,y1) と (x2,y2) を通る直線が ax + by + c = 0 のとき、a,b,c の値を返す関数
def calcLine(x1, y1, x2, y2):
    return (y2 - y1, -(x2 - x1), (x2 - x1) * y1 - (y2 - y1) * x1)


# 直線 ax + by + c = 0 に対して (x, y) が部外者なら True を返す関数
def isOutsider(a, b, c, x, y):
    return abs(a * x + b * y + c) / math.sqrt(a ** 2 + b ** 2) >= 2


N = int(input())
coordinate = list()
for _ in range(N):
    x, y = map(float, input().split())
    coordinate.append((x, y))

# (x_1, y_1) と (x_2, y_2) を結ぶ直線を求める
a, b, c = calcLine(
    coordinate[0][0], coordinate[0][1], coordinate[1][0], coordinate[1][1]
)

ans = 0
for i in range(N):
    # i 番目の人が部外者かどうか調べる
    xi, yi = coordinate[i]
    if isOutsider(a, b, c, xi, yi):
        ans += 1

print(ans)
'''
引数として直線の方程式の a, b, c の値と 点の座標 (x,y) をとり、直線に対して点が部外者であるかを返す関数を書きます。(実装例では関数名 isOutsider) 問題文より、直線と点の距離は以下のように求めることができます。 ・ |a * x + b * y + c| / (a^2 + b^2)^(1/2) この距離が 2 以上であれば true を返す関数を実装すればよいです。 上記の関数を宣言した上で、具体的な解法を以下に示します。
標準入力を用いて入力を受け取り、受け取った値を変数に代入します。(実装例では変数名 N)
各人物の座標を格納する配列を用意します。(実装例では変数名 coordinate)
N 回実行される繰り返し処理を書きます。手順が繰り返されるようにします。
標準入力を用いて入力を受け取り、受け取った値を変数に代入します。
用意した配列に受け取った変数の組を格納します。
あらかじめ用意した直線を求める関数を呼び出し、(x1,y1) と (x2,y2) を通る直線の方程式の a, b, c の値を求めます。
引数に x1, y1, x2, y2 を渡します。
部外者の数を管理する変数を用意します。初期値を 0 とします。(実装例では変数名 ans)
N 回実行される繰り返し処理を書きます。手順が繰り返されるようにします。
本解説ではループ変数を i := 1, 2, ...., N とします。
i 番目の人が求めた直線に対して部外者であるかを調べます。あらかじめ用意した部外者かどうかを返す関数を呼び出します。
引数にで求めた a, b, c と i 番目の人の座標 (x_i, y_i) を渡します。
i 番目の人が部外者なら変数に 1 加算します。変数の値を出力します。
'''

step1・final 「部外者をはじけ」
# utf-8
import math

# (x1,y1) と (x2,y2) を通る直線が ax + by + c = 0 のとき、a,b,c の値を返す関数
def calcLine(x1, y1, x2, y2):
    return (y2 - y1, -(x2 - x1), (x2 - x1) * y1 - (y2 - y1) * x1)

# 直線 ax + by + c = 0 に対して点 (x, y) が部外者なら True を返す関数
def isOutsider(a, b, c, x, y):
    return abs(a * x + b * y + c) / math.sqrt(a ** 2 + b ** 2) >= 2

N = int(input())
coordinate = list()
for _ in range(N):
    x, y = map(float, input().split())
    coordinate.append((x, y))

# 部外者の数の最小値
ans = N
# 部外者の数が最小になる直線 Ax + By + C = 0
A, B, C = -1.0, -1.0, -1.0

for i in range(N - 1):
    xi, yi = coordinate[i]
    for j in range(i + 1, N):
        xj, yj = coordinate[j]

        # (xi,yi) と (xj,yj) を通る直線の部外者を調べる
        a, b, c = calcLine(xi, yi, xj, yj)
        count = 0
        for k in range(N):
            xk, yk = coordinate[k]
            if isOutsider(a, b, c, xk, yk):
                count += 1

        # 部外者の数がいままで調べた中で最小になるなら
        if ans > count:
            ans = count
            A, B, C = a, b, c

if ans == 0:  # 部外者が存在しないなら
    print("none")
else:
    # 直線 Ax + By + C = 0 が正しい直線
    # 正しい直線を引いたときの部外者を出力する
    for i in range(N):
        xi, yi = coordinate[i]
        if isOutsider(A, B, C, xi, yi):
            print(i + 1)
'''
このコードは、指定された二次元平面上の点群から最適な直線を求め、直線から2m以上離れている「部外者」を検出します。
calcLine関数
与えられた二点 
(𝑥1,𝑦1)(𝑥1,y1) と(𝑥2,𝑦2)(x2,y2) を通る直線の方程式　𝑎𝑥+𝑏𝑦+𝑐=0 の係数 𝑎、𝑏、𝑐を計算します。
具体的には、次の計算を行います：
𝑎 = 𝑦2−𝑦1,𝑏 = −(𝑥2−𝑥1),𝑐=(𝑥2−𝑥1)⋅𝑦1−(𝑦2−𝑦1)⋅𝑥1​
 
isOutsider関数
点 (𝑥,𝑦)が直線 ax+by+c=0 から2メートル以上離れているかどうかを判定します。
距離が2メートル以上であれば、部外者と見なして True を返します。距離は次の式で計算されます：
𝑑 = ∣a⋅x+b⋅y+c∣/(√(a^2+b^2))
​ 
主要ループ
全ての二点の組み合わせに対して、直線の係数を計算し、各直線ごとに部外者の数をカウントします。
部外者数が最小の直線の係数 𝐴 𝐵 𝐶 を保持します。

出力処理
部外者数がゼロの場合、「none」を出力します。
部外者がいる場合は、正しい直線に基づいて部外者の番号（1から始まるインデックス）を昇順で出力します。

直線の方程式を求める関数と直線と点の距離から部外者を判定する関数を書きます。 引数として 2 点の座標 (x_1, y_1), (x_2, y_2) を取り、 その 2 点を通る直線の方程式が ax + by + c = 0 であるとき、この式の a, b, c の値を返す関数を書きます。(実装例では関数名 calcLine) 問題文より、a, b, c の値はそれぞれ以下のように求めることができます。 ・ a := y2 - y1 ・ b := -1 * (x2 - x1) ・ c := (x2 - x1) * y1 - (y2-y1) * x1 問題文に書かれている計算方法で導出できる直線の方程式は ax - by + c = 0 の形であるため、ax + by + c = 0 の形にするには (x2 - x1) に -1 をかける必要があることに注意してください。 引数として直線の方程式の a, b, c の値と 点の座標 (x,y) をとり、直線に対して点が部外者であるかを bool 値で返す関数を書きます。(実装例では関数名 isOutsider) 問題文より、直線と点の距離は以下のように求めることができます。 ・ |a * x + b * y + c| / (a^2 + b^2)^(1/2) この距離が 2 以上であれば true を返す関数を実装すればよいです。 上記の関数を実装した上で、具体的な解法を以下に示します。
標準入力を用いて入力を受け取り、受け取った値を変数に代入します。(実装例では変数名 N)
各人物の座標を格納する配列を用意します。(実装例では変数名 coordinate)
N 回実行される繰り返し処理を書きます。
　　4 ~ 5 の手順が繰り返されるようにします。
標準入力を用いて入力を受け取り、受け取った値を変数に代入します。
2. で用意した配列に 4. で受け取った変数の組を格納します。
いままで調べた中の部外者の最小値を管理する変数を用意します。初期値は解答としてありえない大きな数に設定します。(実装例では変数名 ans)
いままで調べた中で部外者の数が最小になる直線が Ax + By + C = 0 であるとき、この A, B, C の値を記録する変数を用意します。初期値は適当な値にしておきます。(実装例では変数名 A, B, C)
　　初期値は必ず後から書き換えられ、初期値が何であろうと処理結果に影響しないため適当な値でよいです。
N-1 回実行される繰り返し処理を書きます。
　　9 ~ 14 の手順が繰り返されるようにします。
　　本解説ではループ変数を i := 1, 2, ...., N-1 とします。
N-i-1 回実行される繰り返し処理を書きます。
　　10 ~ 14 の手順が繰り返されるようにします。
　　本解説ではループ変数を j := i+1, i+2, ...., N とします。
i 番目の人と j 番目の人を結ぶ直線の方程式を求めます。あらかじめ用意した直線を求める関数を呼び出し、方程式の a, b, c の値を求めます。
　　引数に i 番目の人物の座標と j 番目の人の座標を渡します。
i 番目の人と j 番目の人を結ぶ直線に対する部外者の数を調べます。このときの部外者の数を管理する変数を用意します。(実装例では変数名 count)
N 回実行される繰り返し処理を書きます。
　　13 ~ 14 の手順が繰り返されるようにします。
　　本解説ではループ変数を k := 1, 2, ...., N とします。
あらかじめ用意した部外者かどうかを判定する関数を呼び出します。k 番目の人が部外者であるなら count に 1 加算します。
　　引数に 10. で求めた a, b, c と k 番目の人の座標を渡します。
i 番目の人と j 番目の人を結ぶ直線に対する部外者の数がいままで調べた中で最小になるなら、ans に count を、7. の変数に 10. で求めた値を代入します。
7. の変数によって処理が変わる条件分岐を書きます。
　　・7. の変数の値が 0 なら部外者の数が存在しないため none を出力します。
　　・そうでないなら、部外者として検出された人物の番号を昇順に出力します。このとき、正しい直線は 7. の変数を用いて Ax + By + C = 0 と表されます。N 回実行される繰り返し処理を書き、正しい直線に対する部外者であるかを 1 人ずつ調べればよいです。
以上の方針により、時間計算量 O(N^3) でこの問題を解くことができました。 上記の解説では暫定的な正しい直線 Ax + By + C = 0 を更新していき、最後に正しい直線に対する部外者を求めました。 別解として、暫定的な正しい直線自体は管理せずに、暫定的な正しい直線に対する部外者の番号を配列として管理し、更新していくことでもこの問題を解くことができます。 ただし、配列のコピーは多くの場合時間計算量 O(要素数) であるため、上記の方針の解法より少し時間計算量が悪化することに注意してください。
'''

# Q. 決まり字 B
step2 「決まり字」を解くために : part1
# utf-8
n, m = map(int, input().split())

S = list()
for _ in range(n):
    s = input()
    S.append(s)

print(S[m - 1])
'''
標準入力を用いて入力を受け取ります。(実装例では変数名 n, m)
和歌を格納する配列を用意します。(実装例では変数名 S)
n 回実行される繰り返し処理を書きます。
　　4.~ 5. の手順が繰り返されるようにします。
標準入力を用いて入力を受け取ります。
受け取った入力を 2. の配列に格納します。
配列 S の m 番目の要素を出力します。
　　実装では 0-index であることに注意してください。
'''

step3 「決まり字」を解くために : part2
# utf-8
n = int(input())
S = list()
for _ in range(n):
    s = input()
    S.append(s)

for j in range(min(len(S[0]), len(S[1]))):
    if S[0][j] != S[1][j]:
        print("No")
    else:
        print("Yes")
'''
標準入力を用いて入力を受け取ります。(実装例では変数名 n)
和歌を格納する配列を用意し、n 行の入力を受け取り順に配列に格納します。(実装例では変数名 S)
min(|s_1|, |s_2|) 回実行される繰り返し処理を書きます。
　　4. の手順が繰り返されるようにします。
　　解説ではループ変数を j=1, 2, ..., min(|s_1|, |s_2|) とします。
以下の条件分岐を書きます。
　　・s_1 と s_2 の j 文字目が同じなら Yes を出力します。
　　・そうでないなら No を出力します。
'''

step4 「決まり字」を解くために : part3
# utf-8
n = int(input())
S = list()
for _ in range(n):
    s = input()
    S.append(s)

lcp_length = 0
for j in range(min(len(S[0]), len(S[1]))):
    if S[0][j] != S[1][j]:
        lcp_length = j
        break

print(lcp_length)
'''
標準入力を用いて入力を受け取ります。(実装例では変数名 n)
和歌を格納する配列を用意し、n 行の入力を受け取り順に配列に格納します。(実装例では変数名 S)
2 つの和歌の最長共通接頭辞の長さを求めます。最長共通接頭辞の長さを格納する変数を用意します。(実装例では変数名 lcp_length)
min(|s_1|, |s_2|) 回実行される繰り返し処理を書きます。
　　5. の手順が繰り返されるようにします。
　　解説ではループ変数を j=0, 1, ..., min(|s_1|, |s_2|)-1 とします。
s_1 の j+1 文字目と s_2 の j+1 文字目が一致しないなら、最長共通接頭辞は s_1,s_2 の 1 文字目 ~ j 文字目です。lcp_length = j と更新し、ループを終了します。
lcp_length の値を出力します。
'''

step5 「決まり字」を解くために : part4
# utf-8
n, m = map(int, input().split())
S = list()
for _ in range(n):
    s = input()
    S.append(s)

lcp_length = 0
for j in range(min(len(S[0]), len(S[1]))):
    if S[0][j] != S[1][j]:
        lcp_length = j
        break

print(S[m - 1][: lcp_length + 1])
'''
最長共通接頭辞と決まり字の関係を考えてみます。 例えば、和歌 1 を akinotanokarihonoionotomaoarami 、和歌 2 を akikazenitanabikukumonotaemayori とし、和歌 1 の決まり字を知りたいとします。 このとき、和歌 1 と和歌 2 の最長共通接頭辞は aki、和歌 1 の決まり字は akin です。 このことから、和歌 1 の決まり字は「最長共通接頭辞 + 次の 1 文字」 だとわかります。 つまり、和歌 1 の決まり字は「和歌 1 の 1 文字目 ~ (最長共通接頭辞の長さ) +1 文字目」 です。 決まり字を知りたい和歌を和歌 m としたとき、和歌 m の決まり字が「(和歌 m とその他の和歌との最長共通接頭辞) + 次の 1 文字」となることはすべての場合で成り立ちます。
標準入力を用いて入力を受け取ります。(実装例では変数名 n, m)
和歌を格納する配列を用意し、n 行の入力を受け取り順に配列に格納します。(実装例では変数名 S)
2 つの和歌の最長共通接頭辞の長さを求めます。最長共通接頭辞の長さを格納する変数を用意します。(実装例では変数名 lcp_length)
min(|s_1|, |s_2|) 回実行される繰り返し処理を書きます。
　　5. の手順が繰り返されるようにします。
　　解説では、ループ変数を j=0, 1, ..., min(|s_1|, |s_2|)-1 とします。
和歌 1 と和歌 2 の j+1 文字目が一致しないなら、lcp_length = j と更新し、ループを終了します。
和歌 m の 1 文字目 ~ lcp_length+1 文字目を出力します。
'''

step1・final 決まり字
# utf-8
# 全探索する解法
n, m = map(int, input().split())
S = list()
for _ in range(n):
    s = input()
    S.append(s)

s_m = S[m - 1]
lcp_length = 0
for i in range(n):
    if i == m - 1:
        continue
    s_i = S[i]
    # s_i と s_m の最長共通接頭辞を求める
    for j in range(min(len(s_i), len(s_m))):
        if s_m[j] != s_i[j]:
            lcp_length = max(lcp_length, j)
            break

print(s_m[: lcp_length + 1])
'''
この解説では、i 番目の和歌を s_i、決まり字を知りたい和歌を s_m と表します。 また、|s_i| は文字列 s_i の長さを表します。 一般に、文字列 S と文字列 T の共通する接頭辞のうち、文字列 S と文字列 T の 最長共通接頭辞 (LCP) と呼びます。 決まり字を知りたい和歌 s_m と その他の和歌 s_1, s_2 ..., s_{m-1}, s_{m+1}, .. , s_n との最長共通接頭辞の長さの最大値を LEN としたとき、s_m の 1 文字目 ~ LEN+1 文字目 が和歌 m の決まり字となります。 例えば、n=2 とし、 s_1 = akinotanokarihonoionotomaoarami 、s_2 = akikazenitanabikukumonotaemayori とします。 このとき、最長共通接頭辞は akiであり、和歌 1 の決まり字は akin です。 したがって、この問題の本質は、決まり字を知りたい和歌 s_m と その他の和歌 s_1, s_2 ..., s_{m-1}, s_{m+1}, .. , s_n の最長共通接頭辞の長さの最大値を求めることになります。
全探索する解法
与えられる和歌を全探索し最長共通接頭辞の長さを求める方法です。 時間計算量は O(N × |s_m|) です。
標準入力を用いて入力を受け取ります。(実装例では変数名 n, m)
和歌を格納する配列を用意し、n 行の入力を受け取り順に配列に格納します。(実装例では変数名 S)
s_m との最長共通接頭辞のうち最長のものの長さを管理する変数を用意します。(実装例では変数名 lcp_length)
　　初期値は 0 以下の適当な整数にしておきます。最長共通接頭辞の長さは 0 以上であり、長さの最大値を管理する変数なので 0 より大きい数値を初期値としてはいけません。
n 回実行される繰り返し処理を書きます。
　　5. ~ 7. の手順が繰り返されるようにします。
　　解説ではループ変数を i=1, 2, ... , n とします。
i と m が等しいならループをスキップ (continue) します。
s_i と s_m の最長共通接頭辞の長さを求めます。min(|s_i|, |s_m|) 回実行される繰り返し処理を書きます。
　　7. の手順が繰り返されるようにします。
　　解説ではループ変数を j=1, 2, ... , min(|s_i|, |s_m|) とします。
s_i の j 文字目と s_m の j 文字目が一致しないなら、最長共通接頭辞の長さは j-1 です。lcp_length = max(lcp_length, j-1) と更新し、ループを終了します。
s_m の 1 文字目 ~ lcp_length+1 文字目を出力します。
辞書順に並べる解法
この問題で求めたいものは、決まり字を知りたい和歌 s_m と その他の和歌 s_1, s_2 ..., s_{m-1}, s_{m+1}, .. , s_n の最長共通接頭辞の長さの最大値です。 最長共通接頭辞の定義から、最長共通接頭辞の長さは 2 つの文字列が辞書順で近いほど大きくなることが分かります。 よって、和歌を辞書順にソートし s_m と辞書順で隣接する文字列との最長共通接頭辞のみを考えても、最長共通接頭辞の長さの最大値を求めることができます。 時間計算量は和歌の辞書順ソートがボトルネックとなりますが、文字列の辞書順ソートの計算量解析は難しいためここでは省略します。
ただし、制約 1 ≦ n ≦ 100 と 1 ≦ |s_i| ≦ 100 より、今回の問題ではソートが実行時間制限に間に合うことを容易に予想できます。(時間計算量が O(n^2) であるソートアルゴリズムを使った場合でも、最悪時間計算量は O(n^2 × max(|s_i|)) です。)
標準入力を用いて入力を受け取ります。(実装例では変数名 n, m)
和歌を格納する配列を用意し、n 行の入力を受け取り順に配列に格納します。(実装例では変数名 S)
s_m との最長共通接頭辞のうち最長のものの長さを管理する変数を用意します。(実装例では変数名 lcp_length)
辞書順にソートすると和歌の並び順が変わるため、決まり字を知りたい和歌 s_m を変数に格納しておきます。(実装例では変数名 s_m)
和歌を辞書順にソートします。
決まり字を知りたい和歌が辞書順で何番目かを調べ、変数に格納します。(実装例では変数名 s_m_idx)
決まり字を知りたい和歌と辞書順で 1 つ後の和歌との最長共通接頭辞の長さを求めます。決まり字を知りたい和歌の辞書順で 1 つ後の和歌を s_r と表します。min(|s_m|, |s_r|) 回実行される繰り返し処理を書き、最長共通接頭辞の長さを求め lcp_length を更新します。詳しくは「全探索する解法」の手順 6. ~ 7. や実装例を参考にしてください。
決まり字を知りたい和歌と辞書順で 1 つ前の和歌との最長共通接頭辞の長さを求めます。手順 7. と同じように処理します。
s_m の 1 文字目 ~ lcp_length+1 文字目を出力します。
文字列アルゴリズムを利用する解法
有名な文字列アルゴリズムを使うことでこの問題を簡単に解くことができます。 以下に有名アルゴリズムを使った 2 つの解法を簡単に紹介します。 詳しい実装方法は実装例をご確認ください。 有名な文字列アルゴリズムを使った解法の 1 つは、 Trie 木を使った解法です。 Trie 木とは共通接頭辞をうまく管理することで文字列の検索などを高速に行えるデータ構造のことです。 Trie 木について、詳しくはレベルアップ問題集の「トライ木メニュー」を参照してください。 Trie 木を使った解法の時間計算量は、Trie 木の構築に O(Σ |s_i|) (1 ≦ i ≦ n) 、決まり字の探索に O(|s_m|) です。 
Trie 木を使った解法の利点は、決まり字を求める和歌が複数ある場合も高速に決まり字を求めることができる点です。 今回の問題ではこの利点はいかされませんが、より上のランクを目指す場合は知っておくとよいでしょう。 2 つ目は Z-Algorithm を使った解法です。 Z-Algorithm は文字列の共通接頭辞の長さを線形時間で求めることができるアルゴリズムです。 Z-Algorithm について、詳しくはレベルアップ問題集の「Zアルゴリズムメニュー」を参照してください。 Z-Algorithm でこの問題を解く場合、時間計算量は O(Σ |s_i|) (1 ≦ i ≦ n) です。 
文字列の接頭辞といえば Z-Algorithm が有名なので、より上のランクを目指す場合は知っておくとよいでしょう。
実装例
どの実装例においても 0-index で書かれていることに注意してください。

辞書順に並べる解法です。
# 辞書順に並べる解法
n, m = map(int, input().split())
S = list()
for _ in range(n):
    s = input()
    S.append(s)

lcp_length = 0
s_m = S[m - 1]
S.sort()
s_m_idx = S.index(s_m)
# 辞書順で 1 つ後のものとの最長共通接頭辞の長さを求める
if s_m_idx + 1 < n:
    S_r = S[s_m_idx + 1]
    for j in range(min(len(s_m), len(S_r))):
        if s_m[j] != S_r[j]:
            lcp_length = max(lcp_length, j)
            break
# 辞書順で 1 つ前のものとの最長共通接頭辞の長さを求める
if s_m_idx - 1 >= 0:
    S_l = S[s_m_idx - 1]
    for j in range(min(len(s_m), len(S_l))):
        if s_m[j] != S_l[j]:
            lcp_length = max(lcp_length, j)
            break

print(s_m[: lcp_length + 1])

Trie 木を使った解法です。
# Trie 木を使った解法
n, m = map(int, input().split())
S = list()
for _ in range(n):
    s = input()
    S.append(s)

# Trie 木のノード
class Node:
    def __init__(self):
        self.child = [None] * 26  # 子ノード
        self.word_cnt = 0  # 根からここまでを接頭辞として持つ単語の数

root = Node()
for s_i in S:
    now = root # 現在のノード
    for j in range(len(s_i)):
        v = ord(s_i[j]) - ord("a")
        if now.child[v] == None:  # 子ノードがまだ存在しないなら
            now.child[v] = Node()
        now = now.child[v]  # 子ノードに移動
        now.word_cnt += 1

s_m = S[m - 1]
now = root
for j in range(len(s_m)):
    v = ord(s_m[j]) - ord("a")
    now = now.child[v]
    # 根からここまでを接頭辞として持つ単語が 1 つなら、ここまでが決まり字
    if now.word_cnt == 1:
        print(s_m[: j + 1])
        break

Z-Algorithm を使った解法です。
# Z-Algorithm を使った解法
n, m = map(int, input().split())
S = list()
for _ in range(n):
    s = input()
    S.append(s)

# Z[i] := S[0:|S|] と S[i:|S|] の最長共通接頭辞の長さ
def z_algo(S: str) -> list[int]:
    Z = [0] * len(S)
    Z[0] = len(S)
    i, j = 1, 0
    while i < len(S):
        while i + j < len(S) and S[j] == S[i + j]:
            j += 1
        Z[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while k < j and k + Z[k] < j:
            Z[i + k] = Z[k]
            k += 1
        i += k
        j -= k

    return Z

# Z-Algorithm に使う文字列
z_string = S[m - 1]  # 決まり字を求めたい文字列を先頭にする
for i in range(n):
    if i == m - 1:
        continue
    # ダミー文字 "$" を挟んで結合する
    z_string += "$" + S[i]
# Z 配列を求める
Z = z_algo(z_string)

lcp_length = 0
now = len(S[m - 1]) + 1
for i in range(n):
    if i == m - 1:
        continue
    # Z[now] = s_m と s_i の最長共通接頭辞の長さ
    lcp_length = max(lcp_length, Z[now])
    now += len(S[i]) + 1

print(S[m - 1][: lcp_length + 1])
'''

# Q.「PV調査」 B
step2 「PV調査」を解くために:part1
# utf-8
def solve():
    n = int(input())
    a = list(map(int,input().split()))
    print(*a)
if __name__ == "__main__":
    solve()
'''
整数 n の受け取りは簡単かもしれませんが、a_i の受け取りが難しいかもしれません。
n 個の整数 a_i を受け取る場合、言語によっては1行全て受け取って、配列にすることが出来ます。
そのようなことが出来ない場合は、以下の方法があります。
空の配列 a を用意します。
for 文で n 回以下の操作を繰り返します。
整数を受け取って配列 a に追加していきます。
最後に、配列 a を出力します。言語によっては、関数によって簡単に行うことが出来ますが、それがない場合は for 文で行いましょう。
Python3 では、input 関数によって、1 行読み取ることが出来ます。
この場合受け取った文字は、文字列として扱われます。
したがって、2 行目のように整数型に変換するには、int 関数を使う必要があります。
また、複数の整数を配列で受け取るには、3行目のような方法が主流です。
この方法は、多くの問題で必要になるため、必ず覚えましょう。
何をしているか簡単に説明すると以下のようになります。なお、ここでは入力を 1 2 4 とします。
まず、受け取った文字列を split 関数によって空白ごとに区切ります。これによって 1,2,4 に分かれます
ここでは、まだ 1,2,4 は全て文字列として扱われています。
これらを map 関数に int 関数を作用させることによって、それぞれに int 関数を使い整数にしています。
最後に list 関数を使い配列に変更しています。
また、配列の空白区切りの出力は、配列の左に*をつけることで簡単に行えます。
'''

step3 「PV調査」を解くために:part2
# utf-8
def solve():
    n,k = map(int,input().split())
    a = list(map(int,input().split()))
    b = []
    for i in range(n-1):
        b.append(a[i]+a[i+1])
    print(*b)
if __name__ == "__main__":
    solve()
'''
受け取った配列を利用して足し算するだけで求めることが出来ます。
配列を a とすると多くの言語で a の i 番目の配列は、a[i-1] と表します。
'''

step4 「PV調査」を解くために:part3
# utf-8
def solve():
    n,k = map(int,input().split())
    a = list(map(int,input().split()))
    b = []
    count = 0
    for i in range(k):
        count += a[i]
    b.append(count)
    for i in range(n-k):
        b.append(b[-1]+a[i+k]-a[i])
    print(*b)
if __name__ == "__main__":
    solve()
'''
前回と同じように受け取った配列を利用して足し算するだけで求めようとすると、b_i の計算は、k 回の足し算を行う必要があり、b_n まで求めるには、n×k 回の計算を行う必要があるため、実行時間に間に合いません。
なので、もっと効率よく求める必要があります。
解法が思いつかない場合一度小さいケースで実験を行うのが大切です。
例えば k=4 の時を考えましょう。
このとき、b_1= a_1 + a_2 + a_3 + a_4 であり、b_2 = a_2 + a_3 + a_4 + a_5 となります。
ここで、b_1 と b_2 には、共通部分は多いことがわかります。
なので、b_i を求めるとき、b_(i-1) を利用して計算を簡略化することを考えます。
今回の場合 b_2 = b_1 + a_5 - a_1 と計算することが出来ます。
一般化すると、b_i = b_(i-1) + a_(i+k-1) - a_(i-1) であることがわかります。
これを利用すれば、b_i の計算を k 回の足し算から3回の足し算に削減することが出来ます。
この事実を利用して高速に b_i を求めることで、実行時間に間に合わせることができます。
'''

step5 「PV調査」を解くために:part4
# utf-8
def solve():
    n,k = map(int,input().split())
    b = list(map(int,input().split()))
    maxb = max(b)
    for i,bi in enumerate(b):
        if bi == maxb:
            print(i+1)
            break          
if __name__ == "__main__":
    solve()
'''
配列の最大値を求めるのは、組み込み関数や for 文などで簡単に行えると思いますが、最大値の内最初にある位置を求めるのが難しいかもしれません。
言語によっては、配列に特定の値があるか検索し、あるのならば最初にある位置を返す関数があり、それを使って簡単に正答できます。
それがない場合、以下のように for 文を使って計算しましょう。
b_1 から for 文で順に探索していき、b_i が最大値と一致したら i を出力して処理を打ち切る。
今回はfor文での解法を紹介しましたが、Python3では、配列に特定の値があるか検索し、あるのならば最初にある位置を返す関数として、index関数が存在します。 したがって、答えは、b.index(max(b))+1と求めることもできます。
'''

step1・final 「PV調査」
# utf-8
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    b = []
    count = 0
    for i in range(k):
        count += a[i]
    b.append(count)
    for i in range(n - k):
        b.append(b[-1] + a[i + k] - a[i])
    maxb = max(b)
    maxb_count = b.count(maxb)
    for i, bi in enumerate(b):
        if bi == maxb:
            print(maxb_count, i + 1)
            break


if __name__ == "__main__":
    solve()
'''
part3とpart4のコードを組み合わせることで、b（連続する k 日間の合計訪問者数のリスト）を求め、その中で最大の値を持つ最初の日を見つけることができます。
そのため、後はキャンペーンを行った期間の候補数を求めればこの問題に正答出来ます。
これは、 b のリスト内で最大値が何回登場するかをカウントすればよいです。
これは組み込み関数を使って簡単に行え、例えば Python3 では count 関数が該当します。
'''

# Q. ビームの反射 B
step2 「ビームの反射」を解くために:part1
# utf-8
H,W = map(int,input().split())
S = []

def change(x):
    if x == '_':
        return 0
    elif x == '/':
        return 1
    elif x == '\\':
        return 2
      
for h in range(H):
    s = []
    X = list(input())
    for x in X:
        s.append(change(x))
    S.append(s)

for i in range(H):
    print(*S[i])
'''
この問題は、for 文や if 文のみで簡単に実装することが出来ますが注意点があります。 それは、/ (バックスラッシュ)の取り扱いです。 バックスラッシュは、Python や C++ 等多くの言語でエスケープ文字として特別な意味を持っています。 エスケープ文字は、その直後の文字と組み合わせて「特別な指示」を表現します。 例えば\nは改行を表します。 そのため、バックスラッシュを 1 個だけ書くと、プログラムは「次の文字をエスケープする指示」と解釈します。 もしエスケープ対象の文字が無い場合や無効な場合、エラーが発生してしまいます。 なので、バックスラッシュそのものを比較や出力に使いたい場合、バックスラッシュを 2 個 (\\) 書く必要があります。 これにより、プログラムは「これはエスケープ文字ではなく、1 個のバックスラッシュ」と認識します。 このことに注意して以下のような処理を実装することでこの問題に正答できます。
1 行目の入力を受け取ります。(実装例では変数名 H, W)
H×W の二次元配列を用意します。(実装例では変数名 S)
文字を数値に変換する関数を用意します。
H 回実行される繰り返し処理を書きます。
　　5. ~ 7. の手順が繰り返されるようにします。
ループ変数を h = 0, 1, ..., H-1 とします。
h 行目の入力を受け取ります。(実装例では変数名 X)
X の各文字に対して、3. の変換関数を適用し、数値に変換します。
変換結果を一時的な配列に格納し、S の h 行目に追加します。
すべての行を変換し終えたら、S の各行をスペース区切りで出力します。
'''

step3 「ビームの反射」を解くために:part2
# utf-8
def reflect(dx,dy,s):
    if s == '_':
        return dx,dy
    elif s == '/':
        return -dy,-dx
    elif s == '\\':
        return dy,dx
    
N = int(input())

dx,dy = 1,0

for i in range(N):
    wall = input()
    dx,dy = reflect(dx,dy,wall)
    print(dx,dy)
'''
反射したときの向きがどうなるか考えてみましょう。
例えば右方向から、/の壁にぶつかった場合、上方向に向かいます。
これは座標で考えると、(1, 0)が(0, -1)に反射によって変更されたということです。
この進行方向と反射壁の関係を整理すると次のようになります。
(dx, dy)は、/の壁で(-dy, -dx)に、\の壁で(dy,dx)に変換される。
図をかいてみると理解しやすいです。
また、整理が苦手な場合、進行方向と反射壁の組み合わせは4×2の 8 通りと少ないので愚直に if 文などを書くことによって実装してもよいでしょう。
これらを利用して向きを求めていきましょう。
向きの変換は関数として実装すると可読性が高まります。
'''

step4 「ビームの反射」を解くために:part3
# utf-8
def change(X,D):
    if X == 'R':
        return (1, 0)
    elif X == 'L':
        return (-1, 0)
    elif X == 'U':
        return (0, -1)
    elif X == 'D':
        return (0, 1)
    else:
        return D

H,W = map(int,input().split())
S = [list(input()) for _ in range(H)]

ans = 0

w,h,D = 0,0,(1,0)
ans = 0
while 0 <= h <= H-1 and 0 <= w <= W-1:
    D = change(S[h][w],D)
    w += D[0]
    h += D[1]
    ans += 1
print(ans)
'''
このパートでは、箱区画の移動を適切に行えるかが問われています。
区画に与えられた移動方向を適切に取得し、上書きするというのを関数で実装してみましょう。
移動先が箱の範囲外であれば移動を終了し、区画の通過回数を出力するという点に注意しましょう。
詳しい実装は以下のようになります。
H と W を入力として受け取ります。
グリッドの状態を2次元配列 Sに格納します。
現在の移動方向を記録するため、初期値として (1, 0) (右方向) を設定します。
現在の位置を記録する変数 w (幅方向) と h (高さ方向) を設定し、初期位置 (0, 0) とします。
範囲外に出るまで移動処理を繰り返すループを開始します。そのためループの継続条件は以下のようになります。
高さ方向の位置 h が 0 以上 H-1 以下
幅方向の位置 w が 0 以上 W-1 以下
現在の位置の文字 S[h][w] を取得し、移動方向を変更する関数 change を呼び出します。
R が与えられた場合、右方向 (1, 0) に変更
L が与えられた場合、左方向 (-1, 0) に変更
U が与えられた場合、上方向 (0, -1) に変更
D が与えられた場合、下方向 (0, 1) に変更
S が与えられた場合、現在の方向を維持
移動方向に基づいて w および h を更新します。
移動回数をカウントする変数 ans をインクリメントします。
ループが終了したら、ans を出力します。
'''

step1・final 「ビームの反射」
# utf-8
def solve():
    H,W = map(int,input().split())
    ans = 0
    S = [list(input()) for _ in range(H)]
    def reflect(x,y,d):
        dx,dy = d
        if S[y][x] == '_':
            return x+dx,y+dy,d
        elif S[y][x] == '/':
            return x-dy,y-dx,(-dy,-dx)
        else:
            return x+dy,y+dx,(dy,dx)
    w,h,D = 0,0,(1,0)
    ans = 0
    while 0 <= h <= H-1 and 0 <= w <= W-1:
        w,h,D = reflect(w,h,D)
        ans += 1
    print(ans)
if __name__ == "__main__":
    solve()
'''
part2 のようにして移動先を求め、part3 のようにして、区画内を移動していけばよいです。
範囲外アクセスでエラーが起きないよう、part3 同様範囲外に出たら移動を打ち切るのを忘れないようにしましょう。
'''

# Q. 複数形への変換 B
step2 複数形への変換を解くために:part2
# utf-8
n = int(input())
for _ in range(n):
    a_i = input()
    ans = a_i + "s"
    print(ans)
'''
1 行目の入力を受け取ります。(実装例では変数名 n)
n 回実行される繰り返し処理を書きます。
　　3. ~ 5. の手順が繰り返されるようにします。
入力を受け取ります。(実装例では変数名 a_i)
解答となる文字列を格納する変数を用意し、a_i の末尾に "s" をつけたものを代入します。
ans を出力します。
'''

step3 複数形への変換を解くために:part3
# utf-8
n = int(input())
for _ in range(n):
    a_i = input()
    ans = ""

    # 末尾が s, sh, ch, o, x のいずれかであるなら、英単語の末尾に es を付ける
    for suffix in ["s", "sh", "ch", "o", "x"]:
        if a_i[len(a_i) - len(suffix) :] == suffix:
            ans = a_i + "es"
            break

    # 上の条件に当てはまらないなら英単語の末尾に s を付ける
    if ans == "":
        ans = a_i + "s"

    print(ans)
'''
問題文に書かれた条件を if 文で 1 つずつ記述してもよいですが、元の問題では 8 通り以上の条件分岐を書くことになり少し大変です。 また、同じ処理を何度も書くより 1 つのコードに集約した方が、保守性や可読性等の観点から望ましいです。 そのため、if 文と for 文を組み合わせて解く方法を紹介します。
1 行目の入力を受け取ります。(実装例では変数名 n)
n 回実行される繰り返し処理を書きます。
　　3. ~ 7. の手順が繰り返されるようにします。
入力を受け取ります。(実装例では変数名 a_i)
解答となる文字列を格納する変数を用意します。初期値は空文字列にしておきます。
a_i の末尾が s, sh, ch, o, x のいずれかであるかを調べます。for 文を書き、a_i の末尾が s, sh, ch, o, x であるかを順に調べていきます。末尾が s, sh, ch, o, x のいずれかである場合、ans = a_i + "es" と更新します。
5. の手順の後、ans が初期値のまま（空文字列）なら a_i は末尾が s, sh, ch, o, x のいずれかであるという条件に当てはまらないことになります。ans = a_i + "s" と更新します。
ans を出力します。
文字列の末尾の文字を取り出すには、Python ならスライス、C++ なら substr() 関数を使うと実装できます。 文字列の扱いについて詳しく学習したい場合は、レベルアップ問題集の文字列処理メニューを参照してください。 "s", "sh", "ch", "o", "x" を格納した配列をあらかじめ用意しておくと、for 文を使うことで末尾の文字が条件を満たすかを順に調べることができます。

スライスを使って末尾の文字を調べています。 S[i:j] と書くと、文字列 S の i 文字目から j-1 文字目を取り出すことができます。（0-index なので最左の文字は 0 文字目です） i=0 や j=|S| のときは i,j を省略することができます。 例えば、S[i:] は i 文字目から |S|-1 文字目までを取り出します。
'''

step4 複数形への変換を解くために:part4
# utf-8
n = int(input())
for _ in range(n):
    a_i = input()
    ans = ""

    # 末尾が f, fe のいずれかであるなら、英単語の末尾の f, fe を除き末尾に ves を付ける
    for suffix in ["f", "fe"]:
        if a_i[len(a_i) - len(suffix) :] == suffix:
            ans = a_i[0 : len(a_i) - len(suffix)] + "ves"
            break

    # 上の条件に当てはまらないなら英単語の末尾に s を付ける
    if ans == "":
        ans = a_i + "s"

    print(ans)
'''
1 行目の入力を受け取ります。(実装例では変数名 n)
n 回実行される繰り返し処理を書きます。
　　3. ~ 7. の手順が繰り返されるようにします。
入力を受け取ります。(実装例では変数名 a_i)
解答となる文字列を格納する変数を用意します。初期値は空文字列にしておきます。
a_i の末尾が f, fe のいずれかであるかを調べます。for 文を書き、a_i の末尾が f, fe であるかを順に調べていきます。末尾が f, fe のいずれかである場合、ans = a_i の末尾から f, fe を除いたもの + "ves" と更新します。
5. の手順の後、ans が初期値のまま（空文字列）なら a_i は末尾が f, fe のいずれかであるという条件に当てはまらないことになります。ans = a_i + "s" と更新します。
ans を出力します。
'''

step5 複数形への変換を解くために:part5
# utf-8
n = int(input())
for _ in range(n):
    a_i = input()
    ans = ""

    # 末尾の1文字が y で末尾から2文字目が a, i, u, e, o のいずれでもないなら、英単語の末尾の y を除き末尾に ies を付ける
    if a_i[-1] == "y" and not a_i[-2] in ["a", "i", "u", "e", "o"]:
        ans = a_i[:-1] + "ies"

    # 上の条件に当てはまらないなら英単語の末尾に s を付ける
    if ans == "":
        ans = a_i + "s"

    print(ans)
'''
1 行目の入力を受け取ります。(実装例では変数名 n)
n 回実行される繰り返し処理を書きます。
　　3. ~ 7. の手順が繰り返されるようにします。
入力を受け取ります。(実装例では変数名 a_i)
解答となる文字列を格納する変数を用意します。初期値は空文字列にしておきます。
a_i の末尾の1文字が y かつ末尾から2文字目が a, i, u, e, o のいずれでもないなら、ans = a_i の末尾から y を除いたもの + "ies" と更新します。
5. の手順の後、ans が初期値のまま（空文字列）なら、 a_i は末尾の1文字が y で末尾から2文字目が a, i, u, e, o のいずれでもないという条件に当てはまらないことになります。ans = a_i + "s" と更新します。
ans を出力します。
"a", "i", "u", "e", "o" を格納した配列や set をあらかじめ用意しておくことで、末尾から2文字目が条件を満たすかどうかを簡単に判定することができます。
'''

step1・final 複数形への変換
# utf-8
n = int(input())
for _ in range(n):
    a_i = input()
    ans = ""

    # 末尾が s, sh, ch, o, x のいずれかであるなら、英単語の末尾に es を付ける
    for suffix in ["s", "sh", "ch", "o", "x"]:
        if a_i[len(a_i) - len(suffix) :] == suffix:
            ans = a_i + "es"
            break

    # 末尾が f, fe のいずれかであるなら、英単語の末尾の f, fe を除き末尾に ves を付ける
    for suffix in ["f", "fe"]:
        if a_i[len(a_i) - len(suffix) :] == suffix:
            ans = a_i[0 : len(a_i) - len(suffix)] + "ves"
            break

    # 末尾の1文字が y で末尾から2文字目が a, i, u, e, o のいずれでもないなら、英単語の末尾の y を除き末尾に ies を付ける
    if a_i[-1] == "y" and not a_i[-2] in ["a", "i", "u", "e", "o"]:
        ans = a_i[:-1] + "ies"

    # 上のいずれの条件にも当てはまらないなら英単語の末尾に s を付ける
    if ans == "":
        ans = a_i + "s"

    print(ans)
'''
この問題は if 文と for 文の基礎的な問題です。 問題文に書かれた条件をすべて if 文で 1 つずつ記述してもよいですが、8 通り以上の条件分岐を書くことになり少し大変です。 また、同じ処理を何度も書くより 1 つのコードに集約した方が、保守性や可読性等の観点から望ましいです。 そのため、if 文と for 文を組み合わせて解く方法を紹介します。
1 行目の入力を受け取ります。(実装例では変数名 n)
n 回実行される繰り返し処理を書きます。
　　3. ~ 9. の手順が繰り返されるようにします。
入力を受け取ります。(実装例では変数名 a_i)
解答となる文字列を格納する変数を用意します。初期値は空文字列にしておきます。(実装例では変数名 ans)
a_i の末尾が s, sh, ch, o, x のいずれかであるかを調べます。for 文を書き、a_i の末尾が s, sh, ch, o, x であるかを順に調べていきます。末尾が s, sh, ch, o, x のいずれかである場合、ans = a_i + "es" と更新します。
a_i の末尾が f, fe のいずれかであるかを調べます。for 文を書き、a_i の末尾が f, fe であるかを順に調べていきます。末尾が f, fe のいずれかである場合、ans = a_i の末尾から f, fe を除いたもの + "ves" と更新します。
a_i の末尾の1文字が y かつ末尾から2文字目が a, i, u, e, o のいずれでもないなら、ans = a_i の末尾から y を除いたもの + "ies" と更新します。
5. ~ 7. の手順の後、ans が初期値のままなら a_i はいずれの条件にも当てはまらないことになります。ans = a_i + "s" と更新します。
ans を出力します。
文字列の末尾の文字を取り出すには、Python ならスライス、C++ なら substr() 関数を使うと実装できます。 
'''

# Q. ポスターの貼り付け作業 B
# utf-8
N = int(input())

A = int(input())

S = input()

B = int(input())

if S == "CW":
    step = 1
else:
    step = -1

ans = [A]

#計算しやすいようにインデックスを 1 引いて計算する。

poster_done = set() #ポスターを貼った木の集合

poster_done.add(A - 1)

now = A - 1

for i in range(N - 1):
    cnt = B
    #ポスターが張っていない木を B 本数える。
    while cnt > 0:
        now = (now + step) % N
        if now not in poster_done:
            cnt -= 1
    ans.append(now + 1)
    poster_done.add(now)

print(*ans)
'''
問題文にある通り、時計回りもしくは反時計回りにポスターを貼っていない木を B 本数え、B 本目にポスターを貼っていきます。
ここで計算しやすいように、それぞれの木のインデックスを 1 引いて 0-indexed にします。
このとき、木 i にいるとき、時計回りで次の木は、木 (i + 1) mod N、反時計回りで次の木は木 (i - 1) mod N となります。
ポスターを貼った木の集合を用いて、木にポスターを貼ったかの判定を行うことが出来ます。
したがって、以上を組み合わせて、ポスターを貼っていない木を B 本数え、B 本目にポスターを貼る作業を N - 1 回繰り返すことで答えを計算することが出来ます。
'''
★★★ A ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Q. 日別訪問者数の最大平均区間(large) A
# utf-8
n, k = map(int, input().split())
data = list(map(int, input().split()))

ave = [None] * (n - k + 1)
ave[0] = sum(data[:k])

for i in range(1, n - k + 1):
    ave[i] = ave[i - 1] - data[i - 1] + data[i - 1 + k]

m = max(ave)

print(ave.count(m), ave.index(m) + 1)
'''
訪問者数の累積和を取り、連続する k 日の合計訪問者数の最大値 max_visitor を求めます。
そして、連続する k 日の期間のうち、その合計訪問者数が max_visitor に等しい期間の数を数えます。
このとき同時にそのような期間のうち最も速い開始日を記録しておきます。
'''

# Q. お菓子の詰め合わせ　A(殿堂入り)
# utf-8
def combinations(iterable, r):
    # combinations()関数は、与えられたiterableからr個の要素を持つすべての組み合わせを生成するジェネレータです。
    pool = tuple(iterable)  # 入力のiterableをタプルに変換してpoolに格納
    n = len(pool)  # poolの長さを取得
    if r > n:  # rがnより大きければ、組み合わせは存在しないので終了
        return
    indices = list(range(r))  # 組み合わせを表すインデックスのリストを作成
    yield tuple(pool[i] for i in indices)  # 最初の組み合わせを生成して返す
    while True:
        for i in reversed(range(r)):  # 右端から左に向かってインデックスを調整
            if indices[i] != i + n - r:
                break
        else:
            return
        indices[i] += 1  # インデックスを調整
        for j in range(i + 1, r):  # 調整後のインデックスを更新
            indices[j] = indices[j - 1] + 1
        yield tuple(pool[i] for i in indices)  # 新しい組み合わせを生成して返す

# 入力の受け取り
N, money = map(int, input().split())  # N: お菓子の種類数, money: 指定制限金額
All = []  # お菓子の値段リスト
for n in range(N):
    All.append(int(input()))  # 各お菓子の値段をリストに追加

All.sort()  # お菓子の値段リストを昇順にソート

# なるべく多くの種類を購入するための計算
temp = 0  # 合計金額の一時変数
count = 0  # 購入するお菓子の種類数
for i in All:
    temp += i  # お菓子の値段を加算
    if temp > money:  # 合計が指定制限金額を超えたらループを終了
        break
    count += 1  # 購入する種類数をインクリメント

temp = []  # 指定制限金額を超えない購入パターンの釣銭リスト
# 全ての組み合わせを生成して、釣銭を計算
for i in combinations(All, count):
    s = sum(i)  # 組み合わせの合計値を計算
    if s <= money:  # 指定制限金額を超えない場合
        temp.append(money - s)  # 釣銭をリストに追加

print(min(temp))  # 最小の釣銭を出力
'''
combinations関数の定義:
combinations(iterable, r)は、与えられたiterable（例:リスト）からr個の要素を持つすべての組み合わせを生成します。
最初に入力をタプルに変換し、その長さを取得します。
組み合わせを生成するためのインデックスリストを初期化し、最初の組み合わせを生成します。
以降、右端からインデックスを調整しながら新しい組み合わせを生成します。
入力の受け取り:
1行目からお菓子の種類数Nと指定制限金額moneyを受け取ります。
続くN行から各お菓子の値段をリストAllに追加します。
お菓子の値段リストのソート:
お菓子の値段リストを昇順にソートします。これにより、安いお菓子から順に選ぶことができます。
種類数最大化のための計算:
合計金額tempと購入するお菓子の種類数countを初期化します。
お菓子の値段リストを順に見ていき、合計が指定制限金額を超えない範囲で種類数を増やしていきます。
指定制限金額内での購入パターンと釣銭の計算:
combinations関数を使って、購入するお菓子の組み合わせを生成します。
各組み合わせの合計金額が指定制限金額を超えない場合、釣銭を計算してリストtempに追加します。
結果の出力:
釣銭リストtempから最小の釣銭を選んで出力します。
'''

# Q. ひとりすごろく　A(殿堂入り)
step2 「ひとりすごろく」を解くために : part1
# utf-8
T, B, U, D, L, R = map(int, input().split())

# opposite[i] := サイコロの上の面の数字が i であるときその裏にある数字
opposite = [-1] * 7
opposite[T] = B
opposite[B] = T
opposite[U] = D
opposite[D] = U
opposite[L] = R
opposite[R] = L

Q = int(input())

print(opposite[Q])
'''
このような問題では、まずは単純な計算などの簡潔な処理でうまく実装できないか考えることをおすすめします。 今回の問題では 1 行目の入力を配列として受け取り、インデックスの mod 2 でサイコロの裏表の関係になっていることを利用して実装することができます。 簡潔な処理で実装する方針が思いつかない時は、愚直な実装や手打ちなど、少々面倒ですが簡単に思いつく方法を考えてみましょう。 今回の問題ではサイコロの面は高々 6 つしかないので、それぞれの面の裏の面を 1 つずつ手打ちでコードを書いてもさほど時間がかかりません。
裏の面を埋め込む方針
サイコロの各面の裏の面を記録する配列を用意し手打ちで値を設定する方針を説明します。
標準入力を用いて 1 行目の入力を受け取ります。(実装例では変数名 T, B, U, D, L, R)
サイコロの各面の裏の面を記録する配列を用意します (実装例では変数名 opposite)。opposite[i] := サイコロの上の面の数字が i であるときその裏にある数字 とします。
標準入力を用いて 2 行目の入力を受け取ります。(実装例では変数名 Q)
opposite[Q] を出力します。
簡潔な処理で実装する方針
入力は T, B, U, D, L, R の順で与えられます。 この入力を順に配列に格納することを考えると、[ T, B, U, D, L, R ] となります。 ここで、インデックスは 0-index とします。 すると、インデックスで 0 と 1、2 と 3、4 と 5 がそれぞれサイコロの表と裏の関係になっていることがわかります。 これを利用することで、裏の面を埋め込まずに簡単な処理で解くことができます。
標準入力を用いて 1 行目の入力を受け取ります。ここで、入力を配列に格納します。(実装例では変数名 num)
標準入力を用いて 2 行目の入力を受け取ります。(実装例では変数名 Q)
配列 num における Q のインデックスを求めます。(実装例では変数名 idx)
以下の条件分岐を書きます。
　　・idx を 2 で割った余りが 0 なら num[idx+1] の値を出力します。
　　・そうでないなら num[idx-1] の値を出力します。
'''

step3 「ひとりすごろく」を解くために : part2
# utf-8
T, B, U, D, L, R = map(int, input().split())

# opposite[i] := サイコロの上の面の数字が i であるときその裏にある数字
opposite = [-1] * 7
opposite[T] = B
opposite[B] = T
opposite[U] = D
opposite[D] = U
opposite[L] = R
opposite[R] = L

for i in range(1, 7):
    # i が書かれた面を上にするには何回転させるか考える
    if i == T:  # そのままでいいなら
        print(0)
    elif i == opposite[T]:  # 裏面にあるなら
        print(2)
    else:
        print(1)
'''
問題文の画像をもとに、T の面が上のサイコロを考えてみましょう。 T の面を上にするには回転させる必要がないことは明らかなので、それ以外の場合を考えます。 U の面を上にするには手前に 1 回転させればよいです。 B の面を上にするには手前に 2 回転させればよいです。 では、D の面を上にするにはどうすればよいでしょうか？ 手前に 3 回転させる、または奥に 1 回転させればよいです。 問題では回転回数は最小で何回かを聞かれているので、D の面を上にするには奥に 1 回転させればよいことになります。 このように考えていくと、B の面を上にするには 2 回転、それ以外の面を上にするには 1 回転させればよいことになります。 ここで、B の面とは T の面に対する裏の面、つまりサイコロの上の面に対する裏の面です。 サイコロの上の面に対する裏の面を上にするには 2 回転、それ以外の面を上にするには 1 回転させる必要があることは、元の問題を解くうえで重要な考察です。
標準入力を用いて 1 行目の入力を受け取ります。(実装例では変数名 T, B, U, D, L, R)
サイコロの各面の裏の面を記録する配列を用意します (実装例では変数名 opposite)。opposite[i] := 整数 i の書かれた面の裏の面の数字 となるように値を設定します。
6 回実行される繰り返し処理を書きます。
　　4. の手順が繰り返されるようにします。
　　ループ変数を i = 1, 2, ... , 6 とします。
ループ変数 i の値の面を上にするには何回転させる必要があるかを考えます。以下の条件分岐を書きます。
　　・i が T と等しいなら回転する必要はありません。よって 0 を出力します。
　　・i が opposite[T] と等しいなら、つまり裏面にあるなら 2 回転する必要があります。よって 2 を出力します。
　　・そうでないなら 1 回の回転で上にすることができます。よって 1 を出力します。
'''

step1 & final 「ひとりすごろく」
# utf-8
T, B, U, D, L, R = map(int, input().split())

N = int(input())
P = list()
for i in range(N):
    pi = int(input())
    P.append(pi)

# opposite[i] := サイコロの上の面の数字が i であるときその裏面の数字
opposite = [-1] * 7
opposite[T] = B
opposite[B] = T
opposite[U] = D
opposite[D] = U
opposite[L] = R
opposite[R] = L

ans = 0  # 回転操作回数の合計
prev = P[0]  # 現在のサイコロの上の面の数字
for i in range(1, N):
    if P[i] == prev:
        pass
    elif P[i] == opposite[prev]:  # 裏にあるなら
        ans += 2
    else:
        ans += 1

    prev = P[i]

print(ans)
'''
スタートから i 番目のマスをマス i と表現します。 スタートの状態、つまりサイコロが T の面を上、U の面をゴール側にして置かれている状態を考えます。 このサイコロを T, B, U, D, L, R の面を上にするには最小で何回回転させればよいでしょうか。 T の面を上にするには回転させる必要はないため、それ以外の面を考えます。 問題文の図などを参考にすると、B の面を上にするには 2 回転、U, D, L, R の面を上にするには 1 回転させる必要があります。 言い換えれば、上の面に対する裏の面を上にするには 2 回転、それ以外の面を上にするには 1 回転させる必要があります。 では、ゴール側に向いている面が変わると、必要な回転回数は変わるでしょうか？ サイコロは「奥」「手前」「右」「左」のいずれかの方向に回転させることができます。 そのため、裏面以外のどの面も 1 回転で上の面にすることができます。 よって、どの面がゴール側に向いているかに関わらず、サイコロの上の面によってのみ必要な回転回数が決まることがわかります。 したがって、どの面をゴール側にするかについて考える必要はありません。 また、どの面をゴール側にするかについて考える必要はないことから、すべての i (1 ≦ i ≦ N-1) について、マス i からマス i+1 に移動するとき最小の回転回数でサイコロを操作することが最適だとわかります。 以上の考察をまとめると、以下の二点が重要なポイントになります。 ・現在のサイコロの上の面がわかれば、次のマスに移動する際に必要な回転回数がわかる ・常に最小の回転回数で操作すればよい このポイントをふまえ、具体的な方針を以下に示します。
1. 標準入力を用いて 1 行目の入力を受け取ります。(実装例では変数名 T, B, U, D, L, R)
2. 標準入力を用いて 2 行目の入力を受け取ります。(実装例では変数名 N)
3. マスに書かれた数字を格納する配列を用意します (実装例では変数名 P)。
4. N 回実行される繰り返し処理を書きます。標準入力を用いて入力を受け取り、3 の配列に順番に格納します。
5. サイコロの各面の裏の面を記録する配列を用意します (実装例では変数名 opposite)。opposite[i] := サイコロの上の面の数字が i であるときその裏にある数字 とします。
　　実装では 0-index と 1-index を混同しないように注意してください。
6. 最終的な解答となる回転操作回数の合計を管理する変数を用意します。(実装例では変数名 ans)
7. 現在のサイコロの上の面の数字を管理する変数を用意します (実装例では変数名 now)。初期値は最初のサイコロの上の面である T に対応する数字にします。
8. N-1 回実行される繰り返し処理を書きます。
　　9. ~ 10. の手順が N-1 回繰り返されるようにします。
　　解説ではループ変数を i = 2, 3, ... , N とします。
9.以下の条件分岐を書きます。
　　・マス i に書かれた数字が現在のサイコロの上の面の数字と同じなら、サイコロを回転させる必要がないのでなにもしません。
　　・マス i に書かれた数字が現在のサイコロの上の面の裏にあるなら、サイコロをある方向に 2 回転させる必要があります。6. の変数に 2 加算します。
　　・上記 2 つの条件のいずれにも当てはまらない場合は、ある方向に 1 回転させればよいです。6. の変数に 1 加算します。
10. 7. の変数にマス i に書かれた数字を代入します。
11. 6. の変数の値を出力します。
'''

# Q. 落ちものシミュレーション A
step2 「落ちものシミュレーション」を解くために : part1 
# utf-8
H, W, N = map(int, input().split())
# フィールドの状態を表す二次元配列
field = [["."] * W for _ in range(H)]

h1, w1, x1 = map(int, input().split())
# ブロックを置く
for i in range(H - h1, H):
    for j in range(x1, w1 + x1):
        field[i][j] = "#"

# 解答を出力
for i in range(H):
    print("".join(field[i]))
'''
フィールドの上から i 行目、左から j 列目の地点を地点 (i-1,j-1) と表します。 例えば、フィールドの左上端は地点 (0,0)、右上端は地点 (0,W-1) です。
標準入力を用いて入力を受け取ります。(実装例では変数名 H, W, N)
フィールドの状態を表す H×W の二次元配列を用意します。初期値はブロックが置かれていないことを表す . にしておきます。(実装例では変数名 field)
標準入力を用いて入力を受け取ります。(実装例では変数名 h1, w1, x1)
ブロックを置いていきます。h1 回実行される繰り返し処理を書きます。
　　5. ~ 6. の手順が繰り返されるようにします。
　　ループ変数を i = H-h1, H-h1+1, ..., H-1 とします。
w1 回実行される繰り返し処理を書きます。
　　6. の手順が繰り返されるようにします。
　　ループ変数を j = x1, x1+1, ..., x1+w1-1 とします。
field[i][j] = "#" と更新します。
解答を出力します。field の要素を問題文の出力形式に従って出力してください。
'''

step3  「落ちものシミュレーション」を解くために : part2
# utf-8
H, W, N = map(int, input().split())
# フィールドの状態を表す二次元配列
field = [["."] * W for _ in range(H)]

for _ in range(N):
    h, w, x = map(int, input().split())
    # ブロックの下側の辺が上から何行目に置かれるかを表す変数
    bottom = -1
    # ブロックを置く場所を探す
    for i in range(H):
        if field[i][x] == "#":
            bottom = i - 1
            break

    # ブロックを置く
    # フィールドの底辺に接触するなら
    if bottom == -1:
        field[H - 1][x] = "#"
    else:  # 他の長方形に接触するなら
        field[bottom][x] = "#"

# 解答を出力
for i in range(H):
    print("".join(field[i]))
'''
フィールドの上から i 行目、左から j 列目の地点を地点 (i-1,j-1) と表します。 例えば、フィールドの左上端は地点 (0,0)、右上端は地点 (0,W-1) です。
標準入力を用いて入力を受け取ります。(実装例では変数名 H, W, N)
フィールドの状態を表す H×W の二次元配列を用意します。初期値はブロックが置かれていないことを表す . にしておきます。(実装例では変数名 field)
N 回実行される繰り返し処理を書きます。
　　4. ~ 8. の手順が繰り返されるようにします。
標準入力を用いて入力を受け取ります。(実装例では変数名 h, w, x)
長方形のブロックがどこに置かれるかを考えていきます。ブロックの下側の辺が上から何行目に置かれるかを表す変数を用意します。初期値は適当な値にしておきます。(実装例では変数名 bottom)
ブロックを置く場所を探します。H 回実行される繰り返し処理を書きます。
　　7. の手順が繰り返されるようにします。
　　ループ変数を i = 0, 1, ..., H-1 とします。
field[i][x]=="#" なら、ブロックはこの上に固定されることになります。bottom = i-1 と更新し、ループを終了します。
ブロックを置いていきます。以下の条件分岐を書きます。
　　・bottom の値が初期値のままなら、ブロックはフィールドの底辺に接触します。field[H-1][x] = "#" と更新します。
　　・そうでないなら、他のブロックに接触します。field[bottom][x] = "#" と更新します。
解答を出力します。field の要素を問題文の出力形式に従って出力してください。
上記の方針では、ブロックが他のブロックに接触する場合とフィールドの底辺に接触する場合を分けて書きました。 別解として、フィールドの底辺にあらかじめブロックが置かれていたことにすると、場合分けが必要なくなり実装が楽になります。 
このように、例外的な処理を避けられるように前処理をすると実装が楽になることはよくあります。 詳しくは実装例をご確認ください。
'''

step4  「落ちものシミュレーション」を解くために : part3 
# utf-8
H, W, N = map(int, input().split())
field = [["."] * W for _ in range(H)]

for _ in range(N):
    h, w, x = map(int, input().split())
    # ブロックの下側の辺が上から何行目に置かれるかを表す変数
    bottom = -1
    # ブロックを置く場所を探す
    for i in range(H):
        for j in range(x, x + w):
            if field[i][j] == "#":
                bottom = i - 1
                break
        if bottom != -1:
            break

    # ブロックを置く
    # フィールドの底辺に接触するなら
    if bottom == -1:
        for i in range(H - h, H):
            for j in range(x, x + w):
                field[i][j] = "#"
    # 他の長方形に接触するなら
    else:
        # 四点 (bottom-h+1, x), (bottom-h+1, x+w-1), (bottom, x), (bottom, x+w-1) を頂点とする長方形領域にブロックを置く
        for i in range(bottom - h + 1, bottom + 1):
            for j in range(x, x + w):
                field[i][j] = "#"

# 解答を出力
for i in range(H):
    print("".join(field[i]))
'''
フィールドの上から i 行目、左から j 列目の地点を地点 (i-1,j-1) と表します。 例えば、フィールドの左上端は地点 (0,0)、右上端は地点 (0,W-1) です。
標準入力を用いて入力を受け取ります。(実装例では変数名 H, W, N)
フィールドの状態を表す H×W の二次元配列を用意します。初期値はブロックが置かれていないことを表す . にしておきます。(実装例では変数名 field)
N 回実行される繰り返し処理を書きます。
　　4. ~ 9. の手順が繰り返されるようにします。
標準入力を用いて入力を受け取ります。(実装例では変数名 h, w, x)
長方形のブロックがどこに置かれるかを考えていきます。ブロックの下側の辺が上から何行目に置かれるかを表す変数を用意します。初期値は適当な値にしておきます。(実装例では変数名 bottom)
H 回実行される繰り返し処理を書きます。
　　7. ~ 8. の手順が繰り返されるようにします。
　　ループ変数を i = 0, 1, ..., H-1 とします。
w 回実行される繰り返し処理を書きます。
　　8. の手順が繰り返されるようにします。
　　ループ変数を j = x, x+1, ..., x+w-1 とします。
field[i][j]=="#" なら、長方形ブロックはこの上に固定されることになります。bottom = i-1 と更新し、二重ループを終了します。
bottom が初期値のままなら、この長方形はフィールドの底辺と接することになります。そうでないなら、この長方形は他の長方形と接します。以下の条件分岐を書きます。詳しい実装方法は、実装例やこれまでの part の解説をご覧ください。
　　・bottom が初期値のままなら、四点 (H-h, x), (H-h, x+w-1), (H-1, x), (H-1, x+w-1) を頂点とする長方形領域にブロックを置きます。
　　・そうでないなら、四点 (bottom-h+1, x), (bottom-h+1, x+w-1), (bottom, x), (bottom, x+w-1) を頂点とする長方形領域にブロックを置いきます。
解答を出力します。field の要素を問題文の出力形式に従って出力してください。
'''

step1・final 落ちものシミュレーション・
# utf-8
H, W, N = map(int, input().split())
field = [["."] * W for _ in range(H)]

for _ in range(N):
    h, w, x = map(int, input().split())
    # ブロックの下側の辺が上から何行目に置かれるかを表す変数
    bottom = -1
    # ブロックを置く場所を探す
    for i in range(H):
        for j in range(x, x + w):
            if field[i][j] == "#":
                bottom = i - 1
                break
        if bottom != -1:
            break

    # ブロックを置く
    # フィールドの底辺に接触するなら
    if bottom == -1:
        for i in range(H - h, H):
            for j in range(x, x + w):
                field[i][j] = "#"
    # 他の長方形に接触するなら
    else:
        # 四点 (bottom-h+1, x), (bottom-h+1, x+w-1), (bottom, x), (bottom, x+w-1) を頂点とする長方形領域にブロックを置く
        for i in range(bottom - h + 1, bottom + 1):
            for j in range(x, x + w):
                field[i][j] = "#"

# 解答を出力
for i in range(H):
    print("".join(field[i]))
'''
フィールドの上から i 行目、左から j 列目の地点を地点 (i-1,j-1) と表します。 例えば、フィールドの左上端は地点 (0,0)、右上端は地点 (0,W-1) です。
標準入力を用いて入力を受け取ります。(実装例では変数名 H, W, N)
フィールドの状態を表す H×W の二次元配列を用意します。初期値はブロックが置かれていないことを表す . にしておきます。(実装例では変数名 field)
N 回実行される繰り返し処理を書きます。
　　4. ~ 9. の手順が繰り返されるようにします。
標準入力を用いて入力を受け取ります。(実装例では変数名 h, w, x)
長方形のブロックがどこに置かれるかを考えていきます。ブロックの下側の辺が上から何行目に置かれるかを表す変数を用意します。初期値は適当な値にしておきます。(実装例では変数名 bottom)
H 回実行される繰り返し処理を書きます。
　　7. ~ 8. の手順が繰り返されるようにします。
　　ループ変数を i = 0, 1, ..., H-1 とします。
w 回実行される繰り返し処理を書きます。
　　8. の手順が繰り返されるようにします。
　　ループ変数を j = x, x+1, ..., x+w-1 とします。
field[i][j]=="#" なら、長方形ブロックはこの上に固定されることになります。bottom = i-1 と更新し、二重ループを終了します。
bottom が初期値のままなら、この長方形はフィールドの底辺と接することになります。そうでないなら、この長方形は他の長方形と接します。以下の条件分岐を書きます。詳しい実装方法は、実装例やこれまでの part の解説をご覧ください。
　　・bottom が初期値のままなら、四点 (H-h, x), (H-h, x+w-1), (H-1, x), (H-1, x+w-1) を頂点とする長方形領域にブロックを置きます。
　　・そうでないなら、四点 (bottom-h+1, x), (bottom-h+1, x+w-1), (bottom, x), (bottom, x+w-1) を頂点とする長方形領域にブロックを置いきます。
解答を出力します。field の要素を問題文の出力形式に従って出力してください。
ブロックがフィールドの底辺に接触するか、他の長方形に接触するかの条件分岐をなくすことで、簡潔に実装する方針です。 このように、例外的な処理を避けられるように前処理をすると実装が楽になることはよくあります。
標準入力を用いて入力を受け取ります。(実装例では変数名 H, W, N)
フィールドの状態を表す H×W の二次元配列を用意します。初期値はブロックが置かれていないことを表す . にしておきます。(実装例では変数名 field)
実装を簡単にするために、フィールドの底辺はブロックが置かれていることにします。field の末尾に、ブロックが置かれていることを表す # を W 個格納した一次元配列を追加します。
　　これにより、手順 6. の bottom の値が初期値のままになることはなくなります。
N 回実行される繰り返し処理を書きます。
　　5. ~ 12. の手順が繰り返されるようにします。
標準入力を用いて入力を受け取ります。(実装例では変数名 h, w, x)
長方形のブロックがどこに置かれるかを考えていきます。ブロックの下側の辺が上から何行目に置かれるかを表す変数を用意します。(実装例では変数名 bottom)
H+1 回実行される繰り返し処理を書きます。
　　8. ~ 9. の手順が繰り返されるようにします。
　　ループ変数を i=0, 1, ..., H とします。
w 回実行される繰り返し処理を書きます。
　　9. の手順が繰り返されるようにします。
　　ループ変数を j=x, x+1, ..., x+w-1 とします。
field[i][j]=="#" なら、長方形ブロックはこの上に固定されることになります。bottom = i-1 と更新し、二重ループを終了します。
四点 (bottom-h+1, x), (bottom-h+1, x+w-1), (bottom, x), (bottom, x+w-1) を頂点とする長方形領域にブロックを置いていきます。h 回実行される繰り返し処理を書きます。
　　ループ変数を i=bottom-h+1, bottom-h, bottom-h+1, ..., bottom とします。
w 回実行される繰り返し処理を書きます。
　　ループ変数を j=x, x+1, ..., x+w-1 とします。
field[i][j] = "#" と更新します。
解答を出力します。field の要素を問題文の出力形式に従って出力してください。
'''

# Q. ある数でつくられた数列 A
step2 「ある数でつくられた数列」を解くために：part1
# utf-8
# 入力を受け取る
P1, P2, P3, k = map(int, input().split())

# 入力された値をそのまま出力
print(P1, P2, P3, k) 
'''
標準入力を用いて入力を受け取り、受け取った値を変数に代入します。
それぞれの値を順に出力します。
'''

step3 「ある数でつくられた数列」を解くために：part2
# utf-8
# 入力を受け取る
A1, A2, A3 = map(int, input().split())

# 3つの整数を掛け合わせる
result = A1 * A2 * A3

# 結果を出力
print(result) 
'''
標準入力を用いて入力を受け取り、受け取った値を変数に代入します。
オーバーフローに注意しながらそれぞれの整数を掛け合わせます。
掛け合わせた結果を出力します。
'''

step4 「ある数でつくられた数列」を解くために：part3
# utf-8
# 入力を受け取る
A1, A2, A3 = map(int, input().split())
N = int(input())

# 重複を除いた結果を格納するセット
unique_results = set()

# N個の整数を受け取り、掛け算結果をセットに追加
for _ in range(N):
    b = int(input())
    # 3つの整数との掛け算結果をセットに追加
    unique_results.add(b * A1)
    unique_results.add(b * A2)
    unique_results.add(b * A3)

# 結果の種類数を出力
print(len(unique_results))
'''
標準入力を用いて入力を受け取り、受け取った値を変数に代入します。
掛け合わせてできる整数を数えるためにsetを用意します
N 回のループの中で変数を受け取り、A_1, A_2, A_3 との積をsetに追加します
最後に集合のサイズを出力します。
'''

step5 「ある数でつくられた数列」を解くために：part4
# utf-8
import heapq

# 入力を受け取る
P1, P2, P3, k = map(int, input().split())

# 優先度付きキュー（最小ヒープ）を初期化
heap = [1]
# 生成済みの数を管理するセット
seen = {1}

# k番目の数を見つけるまで繰り返す
for _ in range(k):
    # 最小の数を取り出す
    current = heapq.heappop(heap)
    
    # 3つの素数を掛け合わせた結果をキューに追加
    for p in [P1, P2, P3]:
        next_num = current * p
        if next_num not in seen:
            seen.add(next_num)
            heapq.heappush(heap, next_num)

# k番目の数を出力
print(current)
'''
3つの素数P_1, P_2, P_3を受け取ります。
優先度付きキュー（最小ヒープ）を使用して、小さい順に数を生成していきます。
各数を生成する際に、その数に3つの素数を掛け合わせた結果をキューに追加します。
重複を避けるために、生成済みの数をsetで管理します。
k番目の数が見つかるまで、上記の操作を繰り返します。
'''

step6 「ある数でつくられた数列」を解くために：part5
# utf-8
import heapq

# 入力を受け取る
A1, A2, A3 = map(int, input().split())
N = int(input())

# 優先度付きキュー（最小ヒープ）を初期化
heap = []

# N個の整数を受け取り、処理を行う
for _ in range(N):
    b = int(input())
    
    # b_iにA_1, A_2, A_3を掛けた値をキューに追加
    for a in [A1, A2, A3]:
        heapq.heappush(heap, b * a)
    
    # 最小の値を取り出して出力
    min_val = heapq.heappop(heap)
    print(min_val)
'''
3つの整数A_1, A_2, A_3を受け取ります。
整数Nを受け取ります。
優先度付きキュー（最小ヒープ）を初期化します。
N回のループで各b_iを受け取り、以下の処理を行います：
b_iにA_1, A_2, A_3を掛けた値をキューに追加します。
キューから最小の値を取り出して出力します。
取り出した値をキューから削除します。
'''

step1 & final ある数でつくられた数列
# utf-8
from heapq import heapify,heappush,heappop
if __name__ == '__main__':
    *P,k = map(int,input().split())
    X = [1]
    check = {1}
    heapify(X)
    for _ in range(k-1):
        x = heappop(X)
        for p in P:
            xp = x*p
            if not xp in check:
                heappush(X,xp)
                check.add(xp)
    print(X[0])
'''
k番目がp1,p2,p3をそれぞれ何回掛け合わせたものか直接求めるのは難しそうです。
では、i-1番目までの結果から、i番目を求めそれをk番目まで繰り返すという方針を考えてみましょう。
考えてみると1以外は、p1,p2,p3いずれかの倍数であることがわかります。
そして、pで割れた場合割った値も数列に必ず含まれています。
つまり、i番目のものは 1 から i-1 までのものを p1, p2, p3 倍したもので最も小さい数ということになります。
これを利用して、1から順に、 p1, p2, p3 倍したものを優先度付きキューに入れていけばk番目の数を求めることが出来ます。
この際、同じ数値をキューに入れないように注意しましょう。
例えば、6は、2を3倍したときと3を2倍したときで、2回入ってしまう可能性があります。
'''

# Q. Kボナッチ数列  A
# utf-8
MOD = 10000

K = int(input())

N = int(input())

KB = [0] * 200001 #KB[i] は K ボナッチ数列の i 項目である

for i in range(1, K + 1):
    KB[i] = 1

KB[K + 1] = K % MOD 

for i in range(K + 2, N + 1):
    KB[i] = (2 * KB[i - 1] - KB[i - K - 1]) % MOD

print(KB[N]) 
'''
それぞれの項を求める際に前 K 項の和を求めていると最大で 100000 × 100000 = 10 ^ 10 の繰り返し処理が発生してしまい、間に合いません。
そこで、差分に注目します。KB_i を K ボナッチ数列の i 項目とします。i > K のとき、定義より以下の定義式で求められます。
KB_i = KB_{i - K} + KB_{i - K + 1} + ... + KB_{i - 2} + KB_{i - 1}
同様に、
KB_{i + 1} = KB_{i - K + 1} + KB_{i - K + 2} + ... + KB_{i - 1} + KB_i
となります。 2 番目の式から 1 番目の式を引くと、KB_{i + 1} - KB_i = KB_i - KB_{i - K} となります。整理すると KB_{i + 1} = 2 × KB_i - KB_{i - K} という漸化式が得られます。
この式は 2 つの項から計算が出来るため高速に計算することが出来ます。 KB_{K + 1} = K と計算できるため、K + 2 項目から以上の漸化式で計算することにより N 項目を求めることが高速に求めることが可能です。
'''
★★★ S ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Q. 村人の友好関係　S(殿堂入り)
# utf-8
class UnionFind:
	def __init__(self, size):
		self.par = [-1 for _ in range(size)]
	
	def find(self, x):
		if self.par[x] < 0:
			return x
		else:
			self.par[x] = self.find(self.par[x])
			return self.par[x]
	
	def union(self, x, y):
		x = self.find(x)
		y = self.find(y)
		
		if x == y: return False
		if self.par[x] <= self.par[y]:
			self.par[x] += self.par[y]
			self.par[y] = x
		else:
			self.par[y] += self.par[x]
			self.par[x] = y
		
		return True
		

if __name__ == "__main__":
	N, M, Q = map(int, input().split())
	
	all_edges = []
	for _ in range(M):
		a, b, f = map(int, input().split())
		a = a - 1
		b = b - 1
		
		all_edges.append((f, a, b))
	
	all_edges = sorted(all_edges, reverse = True)
	
	uf = UnionFind(N)
	mst_edges = list()
	for f, a, b in all_edges:
		if not uf.union(a, b): continue
		mst_edges.append((a, b, f))
	
	is_member = [ False for _ in range(N)]
	for _ in range(Q):
		op, member = input().split()
		member = int(member) - 1
		
		if op == "+":
			is_member[member] = True
		else:
			is_member[member] = False
		
		answer = 0
		for a, b, f in mst_edges:
			if is_member[a] == is_member[b]: continue
			answer = max(answer, f)
		
		print(answer)
'''
このプログラムは、指定された村人間の友好度データに基づいて同好会の人気度を管理するものです。以下は、このプログラムの動作の詳細な説明です。

プログラムは以下の手順で動作します：

入力データを読み込む。
村人間の友好関係を管理する。
村人の入退会に基づいて同好会の人気度を計算する。
詳細な説明
1. UnionFind クラスの定義
UnionFindクラスは、効率的な集合管理（同じ集合に属するかどうかの判定と、集合の併合）を行うためのデータ構造です。

__init__(self, size):
サイズ size の配列 par を初期化し、全ての要素を -1 に設定します。par[i] が負の場合、その絶対値はその集合のサイズを示し、i がその集合のルートであることを示します。
find(self, x):
要素 x のルートを見つけます。パス圧縮を用いて、探索経路上の全てのノードが直接ルートを指すように更新します。
union(self, x, y):
要素 x と y が属する集合を併合します。ルートのサイズを比較し、小さい方のルートを大きい方に接続します。

最初に、村人の数 N、友好関係の数 M、ログの数 Q を読み込みます。次に、友好関係をリスト all_edges に格納します。各関係はタプル (f, a, b) として格納され、友好度 f、村人 a と b を表します。入力のインデックスは 0 から始まるように調整されます。
友好関係は友好度の降順でソートされます。これにより、最大の友好度を簡単に取得できるようにします。

UnionFind データ構造を用いて、最小全域木 (MST) を構築します。全ての友好関係を降順で処理し、異なる集合に属する村人間の友好関係を MST に追加します。
is_member 配列を使って、各村人が同好会に所属しているかどうかを管理します。

次に、各ログエントリについて処理を行います。各操作に対して、同好会の人気度を計算します。mst_edges を調べ、同好会に属する村人とそうでない村人間の友好度の最大値を計算します。
'''
