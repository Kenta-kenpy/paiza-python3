<構造体の更新>
step1　構造体の作成
# utf-8
N = int(input())

for _ in range(N):
    n, o, b, s = input().split()

    print("User{")
    print("nickname : " + n)
    print("old : " + o)
    print("birth : " + b)
    print("state : " + s)
    print("}")
'''
生徒の情報を受け取って、各言語の文字列の出力を用いて、指定された形式で出力を行ってください。
今回の問題のように、「ある人や物に関する情報をまとめて管理したい」という考え方が構造体を使う上で大切な考え方です。

n 行にわたる入力を for 文を用いて受け取ります。
for 文の変数 _ ですが、これは「この変数は明示的に使わない」ということを意味する変数名です。
しかし、慣習的な書き方であるので、「必ずこう書かなくてはならない」ということではありません。
n, o, b, s = input().split() は input().split() で入力値を半角スペースで区切ってリストを生成して、アンパックで左辺の変数にそれぞれ代入しています。
【 アンパックについて 】
右辺に置かれたタプルやリストなどのオブジェクトの要素の数だけ左辺に変数を置くと、オブジェクトの要素順に左辺の変数に代入される
'''

step2　構造体の検索
# utf-8
class Student:
    def __init__(self, name, old, birth, state):
        self.name = name
        self.old = old
        self.birth = birth
        self.state = state


n = int(input())

roster = [None] * n
for i in range(n):
    name, old, birth, state = input().split()
    roster[i] = Student(name, old, birth, state)

k = input()
for student in roster:
    if student.old == k:
        print(student.name)
        break
'''
問題文の指示通り生徒のデータを構造体でまとめて管理しましょう。構造体に関する文法は言語によって異なるので、自分の使っている言語の構造体に関する文法を参考にしましょう。
1 人の生徒に関する情報をまとめた構造体 student をクラス全員分作成し、管理する必要があるため、構造体の配列を用いてクラス全員のデータを管理しましょう。
作成した構造体は変数ではなく型として扱われます。イメージとしては整数型・文字列型...といったものと同じです。
全ての生徒の情報を受け取ったのち、各生徒の年齢が K と一致するかどうかを調べ、一致した場合名前を出力すれば良いです。

「クラス」を用いることで、生徒の情報を管理します。
【 流れ・考え方 】
[None] * n では、要素数が n であるリストを生成しています。
入力値は input().split() でリストを生成して、左辺の変数に代入しています (アンパックについては前問の解説で説明しました)。
リスト roster の要素が Student のインスタンスになるように代入します。
k と各インスタンスの old が一致するか判定して、一致したインスタンスの name を出力します。
【 クラスの基本的事項 】
ここでは、Python3 でクラスをどのように使うかを説明します。
【 クラス定義 】
クラスは class クラス名: として定義します。
「クラスの中身」 はインデントを 1 つ下げて書きます。
Python3 では、「クラスの中身」のことを「属性」と言います。
属性には以下の 2 種類があります。
プロパティ
クラス内で定義される変数のこと
使い方は変数と大きく変わらない。
メソッド
クラス内で定義される関数のこと
定義の構文は関数と大きく変わらない
【 コンストラクタ 】
コンストラクタはメソッドの 1 種です。
コンストラクタの主な役割は、クラスのプロパティを用意することです。
コンストラクタのメソッド名は __init__ と決まっています。
クラスを実際に使うときに、「インスタンス化」 (次の節で説明) という作業を行うのですが、その際に呼び出されるメソッドです。
【 インスタンス 】
インスタンスとは、「実体」のような意味を持ちます。
実際にクラスを使うときに「インスタンス化」という作業を行い、インスタンスを生成します。
【 インスタンス化 】
インスタンス化はクラスを実際に使うときに行う作業のことです。
インスタンス化は インスタンス名 = クラス(引数) のように行います。
【 インスタンスの利用 】
インスタンスは、生成時に指定した インスタンス名 を使って取り扱います。
クラスで定義されている属性を利用する際、主にインスタンスから利用します。
【 属性へのアクセス 】
インスタンス名.属性名 のようにしてアクセスします。
プロパティ
インスタンス名.プロパティ名 のように書くことで、プロパティ名に対応する値を取得することができます。
メソッド
インスタンス名.メソッド名 のように書くことで、メソッド名に対応するメソッドを利用することができます。
【 self について 】
コンストラクタなどに出てくる self とは何か、について説明します。
self は簡単に言えば、「どのインスタンスの属性か」を特定するために使われるものです。
【 もう少し詳しい説明 】
クラスからはいくつものインスタンスを生成することができますが、すべてのインスタンスにおいて同名の属性が定義できます。
この状況下で単純に name としたときに、どのインスタンスの name かが分かりません。
そこで、インスタンス名.name とアクセスして「どのインスタンスの name か」という問題を解決します。
同様にクラス内でも self.name とすることで、問題を解決しています。
'''

step3　構造体の整列
final　構造体の更新

<静的メンバ>
step1　クラスの作成
step2　コンストラクタ
step3　クラスのメンバの更新
step4　クラスの継承
step5　デフォルト引数
final　静的メンバ

<ロボットの暴走>
step1　出口のない迷路
step2　RPG
step3　格闘ゲーム
step4  スーパースーパースーパーカー
final　ロボットの暴走
