<3項間漸化式>
step1　2項間漸化式1
# utf-8
x, d, k = map(int, input().split())

a = [x] * (k + 1)

for i in range(2, k + 1):
    a[i] = a[i - 1] + d

print(a[k])
'''
数列の各項の値を保存する1次元配列を用意し、for 文等のループを利用して a_2 から順に漸化式に従って計算していけばよいです。
'''

step2　2項間漸化式2
# utf-8
x, d = map(int, input().split())

a = [x] * (1000 + 1)

for i in range(2, 1000 + 1):
    a[i] = a[i - 1] + d

q = int(input())

for i in range(q):
    k = int(input())
    print(a[k])
'''
k_i を入力として受け取る度に a_{k_i} の値をいちいち求める必要はありません。あらかじめ a_1 から a_1000 までの値を求めておき、各 k_i に対して求めておいた a_{k_i} をそのまま出力すればよいです。
よって、まずは数列の各項の値を保存する1次元配列を用意し、for 文等のループを利用して a_2 から a_1000 まで順に漸化式に従って計算します。
そして、k_i を入力として受け取り a_{k_i} を出力することを Q 回繰り返せばよいです。
'''

step3　特殊な2項間漸化式1
# utf-8
x, d1, d2, k = map(int, input().split())

a = [x] * (k + 1)

for i in range(2, k + 1):
    if i % 2 == 0:
        a[i] = a[i - 1] + d2
    else:
        a[i] = a[i - 1] + d1

print(a[k])
'''
数列の各項の値を保存する1次元配列を用意し、for 文等のループを利用して a_2 から順に漸化式に従って計算していけばよいです。
添字の偶奇によって漸化式の形が変わっているので、a_i を計算する際に添字の偶奇による場合分けを行いましょう。
'''

step4　特殊な2項間漸化式2
# utf-8
x, d1, d2 = map(int, input().split())

a = [x] * (1000 + 1)

for i in range(2, 1000 + 1):
    if i % 2 == 0:
        a[i] = a[i - 1] + d2
    else:
        a[i] = a[i - 1] + d1

q = int(input())

for i in range(q):
    k = int(input())
    print(a[k])
'''
まず最初に、数列の各項の値を保存する1次元配列を用意し、for 文等のループを利用して a_2 から順に a_1000 まで漸化式に従って計算します。
添字の偶奇によって漸化式の形が変わっているので、a_i を計算する際に添字の偶奇による場合分けを行いましょう。
最後に、k_i を入力として受け取り数列の k_i 項目の値を出力することを Q 回繰り返せばよいです。
'''

step5　3項間漸化式1
# utf-8
a = [1] * (40 + 1)

for i in range(3, 40 + 1):
    a[i] = a[i - 1] + a[i - 2]

k = int(input())
print(a[k])
'''
数列の各項の値を保存する1次元配列を用意し、for 文等のループを利用して a_3 から順に漸化式に従って計算していけばよいです。
'''

final　3項間漸化式2
a = [1] * (40 + 1)

for i in range(3, 40 + 1):
    a[i] = a[i - 1] + a[i - 2]

q = int(input())

for i in range(q):
    k = int(input())
    print(a[k])
'''
数列の各項の値を保存する1次元配列を用意し、for 文等のループを利用して a_3 から順に a_40 まで漸化式に従って計算します。
そして、k_i を入力として受け取り数列の k_i 項目の値を出力することを Q 回繰り返せばよいです。
'''

<階段の上り方>
step1　階段の上り方1
# utf-8
n = int(input())

dp = [1] * (n + 1)

for i in range(2, n + 1):
    dp[i] = dp[i - 1] + dp[i - 2]

print(dp[n])
'''
階段の上り方の通り数を保存する1次元配列 dp を用意し、for 文等のループを利用して dp[1] から dp[n] までを、
考察によって導かれた漸化式 dp[i] = dp[i-1] + dp[i-2] に従って順に計算していけばよいです。
'''

step2　階段の上り方2
# utf-8
n, a, b = map(int, input().split())

dp = [0] * (n + 1)
dp[0] = 1

for i in range(1, n + 1):
    if i >= a:
        dp[i] += dp[i - a]
    if i >= b:
        dp[i] += dp[i - b]

print(dp[n])
'''
dp[n] を、n 段の階段を上る方法の数だとすると、dp[0] ~ dp[n-1] と dp[n] の関係は、dp[n] = dp[n-a] + dp[n-b] で表すことができます。
よって、階段の上り方の通り数を保存する1次元配列 dp を用意し、for 文等のループを利用して dp[1] から dp[n] までを、この漸化式に従って計算していけばよいです。
i が a より小さい場合、i-a 段目は存在せず、i-a 段目から a 段上って i 段目へ移動することはあり得ないことに注意して dp[i] を計算しましょう (b についても同様) 。
'''

final  階段の上り方3
# utf-8
n, a, b, c = map(int, input().split())

dp = [0] * (n + 1)
dp[0] = 1

for i in range(1, n + 1):
    if i >= a:
        dp[i] += dp[i - a]
    if i >= b:
        dp[i] += dp[i - b]
    if i >= c:
        dp[i] += dp[i - c]

print(dp[n])
'''
dp[n] を、n 段の階段を上る方法の数だとすると、dp[0] ~ dp[n-1] と dp[n] の関係は、dp[n] = dp[n-a] + dp[n-b] + dp[n-c] で表すことができます。
よって、階段の上り方の通り数を保存する1次元配列 dp を用意し、for 文等のループを利用して dp[1] から dp[n] までを、この漸化式に従って順に計算していけばよいです。
i が a より小さい場合、i-a 段目は存在せず、i-a 段目から a 段上って i 段目へ移動することはあり得ないことに注意して dp[i] を計算しましょう (b, c についても同様) 。
'''

<最安値>
step1　最安値を達成するには1
step2　最安値を達成するには2
step3　最安値を達成するには3
final　最安値を達成するには4

<連続列>
step1　最長増加連続部分列
final　最長減少連続部分列

<最長減少部分列>
step1　最長部分増加列
final　最長減少部分列
