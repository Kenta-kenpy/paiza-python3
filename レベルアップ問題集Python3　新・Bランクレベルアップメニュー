<マップの扱い1　マップの書き換え・1マス>
# utf-8
def main():
    import sys
    input = sys.stdin.read
    
    data = input().splitlines()

    # H, W
    H, W = map(int, data[0].split())

    # 盤面
    board = [list(data[i + 1]) for i in range(H)]

    # 書き換える座標
    y, x = map(int, data[H + 1].split())

    # 書き換え
    if board[y][x] == '.':
        board[y][x] = '#'
    else:
        board[y][x] = '.'

    # 出力
    for row in board:
        print("".join(row))

if __name__ == "__main__":
    main()
'''
入力の読み込み:
標準入力から全ての行を取得します。
最初の行から盤面サイズ H,W を取得。
続く H 行から盤面をリストとして格納。
最終行で変更する座標 y,x を取得。
文字の反転:
指定された座標の文字をチェック。
"." なら "#" に、"#" なら "." に置き換えます。
結果の出力:
各行を連結して出力。
'''

<マップの扱い2　マップの書き換え・縦横>
# utf-8
def main():
    import sys
    input = sys.stdin.read
    
    data = input().splitlines()

    # H, W
    H, W = map(int, data[0].split())

    # 盤面
    board = [list(data[i + 1]) for i in range(H)]

    # 書き換える座標
    y, x = map(int, data[H + 1].split())

    # 隣接する座標を含む座標リスト
    directions = [(0, 0), (-1, 0), (1, 0), (0, -1), (0, 1)]

    for dy, dx in directions:
        ny, nx = y + dy, x + dx
        if 0 <= ny < H and 0 <= nx < W:
            # 書き換え
            if board[ny][nx] == '.':
                board[ny][nx] = '#'
            else:
                board[ny][nx] = '.'

    # 出力
    for row in board:
        print("".join(row))

if __name__ == "__main__":
    main()
'''
指定された座標とその上下左右のマスを反転するロジックを追加しました。
上下左右の判定: 現在のマスを含めて、最大5マスを対象とするように修正しました。
範囲チェック: 配列外参照を防ぐため、座標が有効な場合のみ反転を行います。
'''

<マップの扱い3　マップの判定・縦横斜め>
# utf-8
# 入力の受け取り
import sys
input = sys.stdin.read

data = input().splitlines()

# H: 行数, W: 列数
H, W = map(int, data[0].split())

# マップの初期状態を取得
map_grid = [list(data[i + 1]) for i in range(H)]

# y, x: 書き換え開始座標
y, x = map(int, data[H + 1].split())

# 文字を書き換える関数を定義
def toggle_char(c):
    return '#' if c == '.' else '.'

# 書き換え対象の座標を集めるためのセット（重複を防ぐためセットを使用）
target_coords = set()

# 縦・横の座標を追加
for i in range(H):
    target_coords.add((i, x))  # 縦方向
for j in range(W):
    target_coords.add((y, j))  # 横方向

# 斜め方向の座標を追加
directions = [(-1, -1), (-1, 1), (1, -1), (1, 1)]  # 斜めの4方向
for dy, dx in directions:
    ny, nx = y, x
    while 0 <= ny < H and 0 <= nx < W:
        target_coords.add((ny, nx))
        ny += dy
        nx += dx

# 対象座標を走査して文字を書き換える
for ty, tx in target_coords:
    map_grid[ty][tx] = toggle_char(map_grid[ty][tx])

# 結果を出力
for row in map_grid:
    print(''.join(row))
'''
マップを二次元配列で管理しましょう。
今回の座標系において、(y,x)と同じ縦列のマスは 0 ≦ i < W であるような i を用いて (i,x) の通り表されます。同様にして、横列のマスは 0 ≦ i < H であるような i を用いて (i,x), 斜めの列のマスは 0 ≦ i < min(h,w) であるような i を用いて (y±i,x±i) (ただし、0 ≦ y±i < H かつ 0 ≦ x±i < W を満たすもの) と表すことができます。
このことと for 文などの繰り返しを用いて、縦横斜めの全ての列について問題文の通りの処理をおこないましょう。
入力の受け取り:
マップの行数(H)と列数(W)、各行の文字列、書き換え対象の座標(y, x)を入力から取得します。
文字の書き換え関数:
toggle_char関数を使って、文字が.の場合は#に、#の場合は.に切り替えます。
書き換え対象座標の計算:
縦方向のすべてのマス、横方向のすべてのマスを計算します。
斜め方向(4方向)について、範囲内の座標を計算し、すべての対象座標を集合target_coordsに追加します。
座標の書き換え:
計算した対象座標に従って、マスの文字を切り替えます。
結果の出力:
書き換えた後のマップを1行ずつ出力します。
'''

<マップの扱い4　マップのナンバリング>
# utf-8
def generate_map(H, W, D):
    # マップ全体を0で初期化
    count = 1
    map_grid = [[0] * W for _ in range(H)]

    if D == 1:  # 斜め右下方向
        # 最初のセルを1で初期化
        map_grid[0][0] = count
        count += 1
        # 上半分（左上から斜め右下）
        for i in range(1, H):
            for j in range(min(i, W - 1) + 1):
                map_grid[i - j][j] = count
                count += 1
        # 下半分（右上から斜め右下）
        for i in range(1, W):
            for j in range(min(H, W - i)):
                map_grid[H - 1 - j][i + j] = count
                count += 1

    elif D == 2:  # 水平方向
        # 左から右に行ごとにナンバリング
        for i in range(H):
            for j in range(W):
                map_grid[i][j] = count
                count += 1

    elif D == 3:  # 垂直方向
        # 上から下に列ごとにナンバリング
        for j in range(W):
            for i in range(H):
                map_grid[i][j] = count
                count += 1

    elif D == 4:  # 斜め右上方向
        # 最初のセルを1で初期化
        map_grid[0][0] = count
        count += 1
        # 上半分（左下から斜め右上）
        for i in range(1, W):
            for j in range(min(i, H - 1) + 1):
                map_grid[j][i - j] = count
                count += 1
        # 下半分（右下から斜め右上）
        for i in range(1, H):
            for j in range(min(H - i, W)):
                map_grid[i + j][W - 1 - j] = count
                count += 1

    return map_grid

# 入力処理
import sys
input = sys.stdin.read
H, W, D = map(int, input().strip().split())

# マップ生成
result_map = generate_map(H, W, D)

# 結果出力
for row in result_map:
    print(" ".join(map(str, row)))
'''
このプログラムは、与えられた行数 𝐻 列数 𝑊、ナンバリングの向き 𝐷 に基づいて、マップ全体に番号を振る機能を実装しています。以下に、プログラムの流れを説明します。
入力の受け取り: 標準入力から、マップの行数 (𝐻)、列数 (𝑊)、ナンバリングの向き (𝐷) を読み取ります。

マップの生成:
指定された向きに応じて異なるロジックを使用し、マップの各セルに番号を割り当てます。
各向きの詳細は以下の通りです:
D=1: 斜め右下方向に番号を振る。
D=2: 水平方向（左から右、上から下に行ごと）に番号を振る。
D=3: 垂直方向（上から下、左から右に列ごと）に番号を振る。
D=4: 斜め右上方向に番号を振る。

結果の出力:
生成されたマップを1行ずつ出力します。
各セルの値は半角スペースで区切られます。
'''

<シミュレーション1　反復横跳び>
# utf-8
def calculate_extra_distance(n, x, k):
    # 反復横跳びで余分に移動した距離を計算する関数
    # K % 4 の余りによって場合分けを行う
    # K % 4 が 3 の場合は、追加の距離 X を加算する必要がある
    if k % 4 == 3:
        return 2 * x * ((k - 4 * n) // 4) + x  # 追加距離 X を加算
    else:
        return 2 * x * ((k - 4 * n) // 4)  # 通常の計算

# 標準入力から値を取得
import sys
input_data = sys.stdin.read().strip()  # 入力データを取得し、末尾の改行を除去
n, x, k = map(int, input_data.split())  # 入力を N, X, K に分割して整数として取得

# 余分な移動距離を計算
result = calculate_extra_distance(n, x, k)

# 結果を出力
print(result)  # 計算結果を標準出力に表示
'''
関数: calculate_extra_distance
この関数は、友達が反復横跳びで本来より余分に移動した距離を計算します。

引数:
n：いたずらされる直前に 4×N 回線を跨いだことを表す値。
x：いたずらで左の線を元の位置から遠ざけた距離（cm）。
k：友達が実際に線を跨いだ回数。

計算の流れ:
K%4 の余りによって場合分けを行います。

K%4=0,1,2 の場合:
通常の移動距離計算式 2 * x * ((k - 4 * n) // 4) を使用。
これは、左の線を跨ぐ回数が整数回である場合に余分な移動距離を正確に求めます。

K%4=3 の場合:
通常の計算に加えて、左の線をもう一度跨ぐ際の距離 
x を加算。
計算式は 2 * x * ((k - 4 * n) // 4) + x になります。

入力処理
import sys:
標準入力を利用してデータを取得するために sys モジュールをインポートします。

input_data = sys.stdin.read().strip():
標準入力から値を取得します（複数行入力を想定）。
strip() を使うことで末尾の改行文字を除去。

n, x, k = map(int, input_data.split()):
入力データをスペース区切りで分割し、それぞれ int 型に変換。
これにより、変数 n, x, k に対応する値が格納されます。

余分な移動距離の計算
result = calculate_extra_distance(n, x, k):
関数 calculate_extra_distance を呼び出し、計算結果を変数 result に格納。

結果の出力
print(result):
計算結果（友達が余分に移動した距離）を標準出力に表示。
'''

<シミュレーション2　perfect shuffle>
# utf-8
import sys

def perfect_shuffle(deck):
    """デッキをパーフェクトシャッフルする関数"""
    half1 = deck[:26]  # 上半分
    half2 = deck[26:]  # 下半分
    shuffled_deck = []
    
    # 交互にカードを配置
    for i in range(26):
        shuffled_deck.append(half1[i])  # 上半分のカード
        shuffled_deck.append(half2[i])  # 下半分のカード
    
    return shuffled_deck

def main():
    """メイン処理関数"""
    # 標準入力からKを取得
    K = int(sys.stdin.read().strip())
    
    # 初期デッキの作成（S, H, D, C の順に1から13）
    suits = ['S', 'H', 'D', 'C']
    deck = [f"{suit}_{num}" for suit in suits for num in range(1, 14)]
    
    # K回シャッフル
    for _ in range(K):
        deck = perfect_shuffle(deck)
    
    # 結果を出力
    print("\n".join(deck))

if __name__ == "__main__":
    main()
'''
perfect_shuffle(deck) 関数
この関数は、渡されたデッキ (deck) を 1回のパーフェクトシャッフル で並べ替える役割を担います。

処理の流れ
デッキを2つの半分に分割

half1 = deck[:26] → 上半分（先頭26枚）
half2 = deck[26:] → 下半分（後ろ26枚）
交互にカードを配置

shuffled_deck.append(half1[i]) で 上半分のカードを追加
shuffled_deck.append(half2[i]) で 下半分のカードを追加
これを i=0 から i=25 までループして繰り返し、新しいシャッフル後のデッキを作成
シャッフル後のデッキを返す

main() 関数
この関数はプログラムのメイン処理を行います。

処理の流れ
標準入力からKを取得

K = int(sys.stdin.read().strip()) でKを取得し、整数型に変換
初期デッキの作成

suits = ['S', 'H', 'D', 'C'] で4種類のマークを定義
リスト内包表記を使い、 'S_1', 'S_2', ..., 'C_13' のように 順番通りのデッキ を作成
K回のシャッフル

for _ in range(K): のループで、 K 回 perfect_shuffle(deck) を実行
そのたびにデッキが更新される
結果の出力

print("\n".join(deck)) で、デッキのカードを 1枚ずつ改行して出力

if __name__ == "__main__":
これは、スクリプトが 直接実行されたときに main() を呼び出す ための構文です。
（他のスクリプトからインポートされたときは実行されません）
'''

<シミュレーション3　燃費>
<シミュレーション4　位置情報システム>
<条件判定1　郵便料金>
<条件判定2　視力検査>
<条件判定3　過剰コンプライアンス>
<全探索1　高い寿司を食いたい!>
<全探索2　コップの水>
<全探索3　+1,-1,'1'+,+'1'>
<全探索4　ストラックアウト>
<文字列1　疑似数字>
<文字列2　super long int>
<文字列3　p4!2@>
<配列1　平面で計算>
<配列2　立体で計算>
<計算1　マンハッタン距離>
<計算2　疑似乱数>
