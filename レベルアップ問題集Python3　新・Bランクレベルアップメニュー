<マップの扱い1　マップの書き換え・1マス>
# utf-8
def main():
    import sys
    input = sys.stdin.read
    
    data = input().splitlines()

    # H, W
    H, W = map(int, data[0].split())

    # 盤面
    board = [list(data[i + 1]) for i in range(H)]

    # 書き換える座標
    y, x = map(int, data[H + 1].split())

    # 書き換え
    if board[y][x] == '.':
        board[y][x] = '#'
    else:
        board[y][x] = '.'

    # 出力
    for row in board:
        print("".join(row))

if __name__ == "__main__":
    main()
'''
入力の読み込み:
標準入力から全ての行を取得します。
最初の行から盤面サイズ H,W を取得。
続く H 行から盤面をリストとして格納。
最終行で変更する座標 y,x を取得。
文字の反転:
指定された座標の文字をチェック。
"." なら "#" に、"#" なら "." に置き換えます。
結果の出力:
各行を連結して出力。
'''

<マップの扱い2　マップの書き換え・縦横>
# utf-8
def main():
    import sys
    input = sys.stdin.read
    
    data = input().splitlines()

    # H, W
    H, W = map(int, data[0].split())

    # 盤面
    board = [list(data[i + 1]) for i in range(H)]

    # 書き換える座標
    y, x = map(int, data[H + 1].split())

    # 隣接する座標を含む座標リスト
    directions = [(0, 0), (-1, 0), (1, 0), (0, -1), (0, 1)]

    for dy, dx in directions:
        ny, nx = y + dy, x + dx
        if 0 <= ny < H and 0 <= nx < W:
            # 書き換え
            if board[ny][nx] == '.':
                board[ny][nx] = '#'
            else:
                board[ny][nx] = '.'

    # 出力
    for row in board:
        print("".join(row))

if __name__ == "__main__":
    main()
'''
指定された座標とその上下左右のマスを反転するロジックを追加しました。
上下左右の判定: 現在のマスを含めて、最大5マスを対象とするように修正しました。
範囲チェック: 配列外参照を防ぐため、座標が有効な場合のみ反転を行います。
'''

<マップの扱い3　マップの判定・縦横斜め>
# utf-8
# 入力の受け取り
import sys
input = sys.stdin.read

data = input().splitlines()

# H: 行数, W: 列数
H, W = map(int, data[0].split())

# マップの初期状態を取得
map_grid = [list(data[i + 1]) for i in range(H)]

# y, x: 書き換え開始座標
y, x = map(int, data[H + 1].split())

# 文字を書き換える関数を定義
def toggle_char(c):
    return '#' if c == '.' else '.'

# 書き換え対象の座標を集めるためのセット（重複を防ぐためセットを使用）
target_coords = set()

# 縦・横の座標を追加
for i in range(H):
    target_coords.add((i, x))  # 縦方向
for j in range(W):
    target_coords.add((y, j))  # 横方向

# 斜め方向の座標を追加
directions = [(-1, -1), (-1, 1), (1, -1), (1, 1)]  # 斜めの4方向
for dy, dx in directions:
    ny, nx = y, x
    while 0 <= ny < H and 0 <= nx < W:
        target_coords.add((ny, nx))
        ny += dy
        nx += dx

# 対象座標を走査して文字を書き換える
for ty, tx in target_coords:
    map_grid[ty][tx] = toggle_char(map_grid[ty][tx])

# 結果を出力
for row in map_grid:
    print(''.join(row))
'''
マップを二次元配列で管理しましょう。
今回の座標系において、(y,x)と同じ縦列のマスは 0 ≦ i < W であるような i を用いて (i,x) の通り表されます。同様にして、横列のマスは 0 ≦ i < H であるような i を用いて (i,x), 斜めの列のマスは 0 ≦ i < min(h,w) であるような i を用いて (y±i,x±i) (ただし、0 ≦ y±i < H かつ 0 ≦ x±i < W を満たすもの) と表すことができます。
このことと for 文などの繰り返しを用いて、縦横斜めの全ての列について問題文の通りの処理をおこないましょう。
入力の受け取り:
マップの行数(H)と列数(W)、各行の文字列、書き換え対象の座標(y, x)を入力から取得します。
文字の書き換え関数:
toggle_char関数を使って、文字が.の場合は#に、#の場合は.に切り替えます。
書き換え対象座標の計算:
縦方向のすべてのマス、横方向のすべてのマスを計算します。
斜め方向(4方向)について、範囲内の座標を計算し、すべての対象座標を集合target_coordsに追加します。
座標の書き換え:
計算した対象座標に従って、マスの文字を切り替えます。
結果の出力:
書き換えた後のマップを1行ずつ出力します。
'''

<マップの扱い4　マップのナンバリング>
# utf-8
def generate_map(H, W, D):
    # マップ全体を0で初期化
    count = 1
    map_grid = [[0] * W for _ in range(H)]

    if D == 1:  # 斜め右下方向
        # 最初のセルを1で初期化
        map_grid[0][0] = count
        count += 1
        # 上半分（左上から斜め右下）
        for i in range(1, H):
            for j in range(min(i, W - 1) + 1):
                map_grid[i - j][j] = count
                count += 1
        # 下半分（右上から斜め右下）
        for i in range(1, W):
            for j in range(min(H, W - i)):
                map_grid[H - 1 - j][i + j] = count
                count += 1

    elif D == 2:  # 水平方向
        # 左から右に行ごとにナンバリング
        for i in range(H):
            for j in range(W):
                map_grid[i][j] = count
                count += 1

    elif D == 3:  # 垂直方向
        # 上から下に列ごとにナンバリング
        for j in range(W):
            for i in range(H):
                map_grid[i][j] = count
                count += 1

    elif D == 4:  # 斜め右上方向
        # 最初のセルを1で初期化
        map_grid[0][0] = count
        count += 1
        # 上半分（左下から斜め右上）
        for i in range(1, W):
            for j in range(min(i, H - 1) + 1):
                map_grid[j][i - j] = count
                count += 1
        # 下半分（右下から斜め右上）
        for i in range(1, H):
            for j in range(min(H - i, W)):
                map_grid[i + j][W - 1 - j] = count
                count += 1

    return map_grid

# 入力処理
import sys
input = sys.stdin.read
H, W, D = map(int, input().strip().split())

# マップ生成
result_map = generate_map(H, W, D)

# 結果出力
for row in result_map:
    print(" ".join(map(str, row)))
'''
このプログラムは、与えられた行数 𝐻 列数 𝑊、ナンバリングの向き 𝐷 に基づいて、マップ全体に番号を振る機能を実装しています。以下に、プログラムの流れを説明します。
入力の受け取り: 標準入力から、マップの行数 (𝐻)、列数 (𝑊)、ナンバリングの向き (𝐷) を読み取ります。

マップの生成:
指定された向きに応じて異なるロジックを使用し、マップの各セルに番号を割り当てます。
各向きの詳細は以下の通りです:
D=1: 斜め右下方向に番号を振る。
D=2: 水平方向（左から右、上から下に行ごと）に番号を振る。
D=3: 垂直方向（上から下、左から右に列ごと）に番号を振る。
D=4: 斜め右上方向に番号を振る。

結果の出力:
生成されたマップを1行ずつ出力します。
各セルの値は半角スペースで区切られます。
'''

<シミュレーション1　反復横跳び>
<シミュレーション2　perfect shuffle>
<シミュレーション3　燃費>
<シミュレーション4　位置情報システム>
<条件判定1　郵便料金>
<条件判定2　視力検査>
<条件判定3　過剰コンプライアンス>
<全探索1　高い寿司を食いたい!>
<全探索2　コップの水>
<全探索3　+1,-1,'1'+,+'1'>
<全探索4　ストラックアウト>
<文字列1　疑似数字>
<文字列2　super long int>
<文字列3　p4!2@>
<配列1　平面で計算>
<配列2　立体で計算>
<計算1　マンハッタン距離>
<計算2　疑似乱数>
