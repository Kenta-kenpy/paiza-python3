<拡張ユークリッドの互除法>
step1 ユークリッドの互除法
# utf-8
def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)


a, b = map(int, input().split())
print(gcd(a, b))
'''
問題文中のユークリッドの互除法の手順通りの処理を行うプログラムを作成しましょう。
手順の 2 にある「A , B のうち小さいほうで大きいほうを割る」という操作では、条件分岐で A , B のうち大きいほうを調べる必要があるように思えますが、「A , B の大きいほうで小さいほうをわり、大きいほうをその余りで置き換える」操作をした時、大きいほうの値と小さいほうの値がそのまま入れ替わるだけなので、A , B の大小の判定は行わなくても大丈夫です。
この操作は最初のループ処理でのみ起こりうるので全体の計算量に影響を及ぼしません。

<別解>
import math
a, b = map(int, input().split())
print(math.gcd(a, b))
# Python3 の標準ライブラリである math には、与えられた 2 つの整数の最大公約数を計算する gcd() 関数が存在します。
'''

step2 3つ以上の整数の最大公約数
# utf-8
def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)


N = int(input())
gcd_all = int(input())

for i in range(N - 1):
    a = int(input())
    gcd_all = gcd(gcd_all, a)

print(gcd_all)
'''
問題文にある通り、3 つ以上の整数 a,b,c,d,e,... の最大公約数はgcd(...gcd(gcd(gcd(gcd(a,b),c),d),e)...)といった具合に求めることができます。
そのため、初めの整数を受け取ったのち、次の処理を残りの入力について行えば良いです。
「ループ処理を用いて変数を 1 つ受け取り、その時点での gcd の値と受け取った変数の gcd を求める。」
2 変数の gcd を求める処理は関数化しておくと再利用しやすくなります。
'''

step3 最小公倍数
step4 ax + by = c
final 拡張ユークリッドの互除法

<意地悪すごろく>
step1 分数
final 意地悪すごろく

<RSA暗号の基本原理>
step1 合同式
step2 modの演算
step3 modの逆元
step4 高速な累乗の計算
final RSA暗号の基本原理

<RSA暗号の作成(文字列)>
step1 RSA暗号の解読(1文字)
step2 RSA暗号の解読(文字列)
final RSA暗号の作成(1文字)
